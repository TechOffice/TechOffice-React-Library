webpackHotUpdate(0,{455:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react/index.js\nvar react = __webpack_require__(0);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-dom/index.js\nvar react_dom = __webpack_require__(19);\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/lodash-es/_freeGlobal.js\nvar _freeGlobal = __webpack_require__(160);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/lodash-es/_root.js\n\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == \'object\' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = _freeGlobal["a" /* default */] || freeSelf || Function(\'return this\')();\n\n/* harmony default export */ var _root = (root);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/lodash-es/_Symbol.js\n\n\n/** Built-in value references. */\nvar _Symbol_Symbol = _root.Symbol;\n\n/* harmony default export */ var _Symbol = (_Symbol_Symbol);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/lodash-es/_getRawTag.js\n\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar _getRawTag_hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = _getRawTag_hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/* harmony default export */ var _getRawTag = (getRawTag);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/lodash-es/_objectToString.js\n/** Used for built-in method references. */\nvar _objectToString_objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar _objectToString_nativeObjectToString = _objectToString_objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return _objectToString_nativeObjectToString.call(value);\n}\n\n/* harmony default export */ var _objectToString = (objectToString);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/lodash-es/_baseGetTag.js\n\n\n\n\n/** `Object#toString` result references. */\nvar nullTag = \'[object Null]\',\n    undefinedTag = \'[object Undefined]\';\n\n/** Built-in value references. */\nvar _baseGetTag_symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (_baseGetTag_symToStringTag && _baseGetTag_symToStringTag in Object(value))\n    ? _getRawTag(value)\n    : _objectToString(value);\n}\n\n/* harmony default export */ var _baseGetTag = (baseGetTag);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/lodash-es/_overArg.js\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/* harmony default export */ var _overArg = (overArg);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/lodash-es/_getPrototype.js\n\n\n/** Built-in value references. */\nvar getPrototype = _overArg(Object.getPrototypeOf, Object);\n\n/* harmony default export */ var _getPrototype = (getPrototype);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/lodash-es/isObjectLike.js\n/**\n * Checks if `value` is object-like. A value is object-like if it\'s not `null`\n * and has a `typeof` result of "object".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == \'object\';\n}\n\n/* harmony default export */ var lodash_es_isObjectLike = (isObjectLike);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/lodash-es/isPlainObject.js\n\n\n\n\n/** `Object#toString` result references. */\nvar objectTag = \'[object Object]\';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    isPlainObject_objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar isPlainObject_hasOwnProperty = isPlainObject_objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ \'x\': 0, \'y\': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!lodash_es_isObjectLike(value) || _baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = _getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = isPlainObject_hasOwnProperty.call(proto, \'constructor\') && proto.constructor;\n  return typeof Ctor == \'function\' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\n/* harmony default export */ var lodash_es_isPlainObject = (isPlainObject);\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/symbol-observable/es/index.js\nvar es = __webpack_require__(60);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux/es/createStore.js\n\n\n\n/**\n * These are private action types reserved by Redux.\n * For any unknown actions, you must return the current state.\n * If the current state is undefined, you must return the initial state.\n * Do not reference these action types directly in your code.\n */\nvar ActionTypes = {\n  INIT: \'@@redux/INIT\'\n\n  /**\n   * Creates a Redux store that holds the state tree.\n   * The only way to change the data in the store is to call `dispatch()` on it.\n   *\n   * There should only be a single store in your app. To specify how different\n   * parts of the state tree respond to actions, you may combine several reducers\n   * into a single reducer function by using `combineReducers`.\n   *\n   * @param {Function} reducer A function that returns the next state tree, given\n   * the current state tree and the action to handle.\n   *\n   * @param {any} [preloadedState] The initial state. You may optionally specify it\n   * to hydrate the state from the server in universal apps, or to restore a\n   * previously serialized user session.\n   * If you use `combineReducers` to produce the root reducer function, this must be\n   * an object with the same shape as `combineReducers` keys.\n   *\n   * @param {Function} [enhancer] The store enhancer. You may optionally specify it\n   * to enhance the store with third-party capabilities such as middleware,\n   * time travel, persistence, etc. The only store enhancer that ships with Redux\n   * is `applyMiddleware()`.\n   *\n   * @returns {Store} A Redux store that lets you read the state, dispatch actions\n   * and subscribe to changes.\n   */\n};function createStore_createStore(reducer, preloadedState, enhancer) {\n  var _ref2;\n\n  if (typeof preloadedState === \'function\' && typeof enhancer === \'undefined\') {\n    enhancer = preloadedState;\n    preloadedState = undefined;\n  }\n\n  if (typeof enhancer !== \'undefined\') {\n    if (typeof enhancer !== \'function\') {\n      throw new Error(\'Expected the enhancer to be a function.\');\n    }\n\n    return enhancer(createStore_createStore)(reducer, preloadedState);\n  }\n\n  if (typeof reducer !== \'function\') {\n    throw new Error(\'Expected the reducer to be a function.\');\n  }\n\n  var currentReducer = reducer;\n  var currentState = preloadedState;\n  var currentListeners = [];\n  var nextListeners = currentListeners;\n  var isDispatching = false;\n\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice();\n    }\n  }\n\n  /**\n   * Reads the state tree managed by the store.\n   *\n   * @returns {any} The current state tree of your application.\n   */\n  function getState() {\n    return currentState;\n  }\n\n  /**\n   * Adds a change listener. It will be called any time an action is dispatched,\n   * and some part of the state tree may potentially have changed. You may then\n   * call `getState()` to read the current state tree inside the callback.\n   *\n   * You may call `dispatch()` from a change listener, with the following\n   * caveats:\n   *\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\n   * will not have any effect on the `dispatch()` that is currently in progress.\n   * However, the next `dispatch()` call, whether nested or not, will use a more\n   * recent snapshot of the subscription list.\n   *\n   * 2. The listener should not expect to see all state changes, as the state\n   * might have been updated multiple times during a nested `dispatch()` before\n   * the listener is called. It is, however, guaranteed that all subscribers\n   * registered before the `dispatch()` started will be called with the latest\n   * state by the time it exits.\n   *\n   * @param {Function} listener A callback to be invoked on every dispatch.\n   * @returns {Function} A function to remove this change listener.\n   */\n  function subscribe(listener) {\n    if (typeof listener !== \'function\') {\n      throw new Error(\'Expected listener to be a function.\');\n    }\n\n    var isSubscribed = true;\n\n    ensureCanMutateNextListeners();\n    nextListeners.push(listener);\n\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return;\n      }\n\n      isSubscribed = false;\n\n      ensureCanMutateNextListeners();\n      var index = nextListeners.indexOf(listener);\n      nextListeners.splice(index, 1);\n    };\n  }\n\n  /**\n   * Dispatches an action. It is the only way to trigger a state change.\n   *\n   * The `reducer` function, used to create the store, will be called with the\n   * current state tree and the given `action`. Its return value will\n   * be considered the **next** state of the tree, and the change listeners\n   * will be notified.\n   *\n   * The base implementation only supports plain object actions. If you want to\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\n   * wrap your store creating function into the corresponding middleware. For\n   * example, see the documentation for the `redux-thunk` package. Even the\n   * middleware will eventually dispatch plain object actions using this method.\n   *\n   * @param {Object} action A plain object representing “what changed”. It is\n   * a good idea to keep actions serializable so you can record and replay user\n   * sessions, or use the time travelling `redux-devtools`. An action must have\n   * a `type` property which may not be `undefined`. It is a good idea to use\n   * string constants for action types.\n   *\n   * @returns {Object} For convenience, the same action object you dispatched.\n   *\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n   * return something else (for example, a Promise you can await).\n   */\n  function dispatch(action) {\n    if (!lodash_es_isPlainObject(action)) {\n      throw new Error(\'Actions must be plain objects. \' + \'Use custom middleware for async actions.\');\n    }\n\n    if (typeof action.type === \'undefined\') {\n      throw new Error(\'Actions may not have an undefined "type" property. \' + \'Have you misspelled a constant?\');\n    }\n\n    if (isDispatching) {\n      throw new Error(\'Reducers may not dispatch actions.\');\n    }\n\n    try {\n      isDispatching = true;\n      currentState = currentReducer(currentState, action);\n    } finally {\n      isDispatching = false;\n    }\n\n    var listeners = currentListeners = nextListeners;\n    for (var i = 0; i < listeners.length; i++) {\n      var listener = listeners[i];\n      listener();\n    }\n\n    return action;\n  }\n\n  /**\n   * Replaces the reducer currently used by the store to calculate the state.\n   *\n   * You might need this if your app implements code splitting and you want to\n   * load some of the reducers dynamically. You might also need this if you\n   * implement a hot reloading mechanism for Redux.\n   *\n   * @param {Function} nextReducer The reducer for the store to use instead.\n   * @returns {void}\n   */\n  function replaceReducer(nextReducer) {\n    if (typeof nextReducer !== \'function\') {\n      throw new Error(\'Expected the nextReducer to be a function.\');\n    }\n\n    currentReducer = nextReducer;\n    dispatch({ type: ActionTypes.INIT });\n  }\n\n  /**\n   * Interoperability point for observable/reactive libraries.\n   * @returns {observable} A minimal observable of state changes.\n   * For more information, see the observable proposal:\n   * https://github.com/tc39/proposal-observable\n   */\n  function observable() {\n    var _ref;\n\n    var outerSubscribe = subscribe;\n    return _ref = {\n      /**\n       * The minimal observable subscription method.\n       * @param {Object} observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns {subscription} An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */\n      subscribe: function subscribe(observer) {\n        if (typeof observer !== \'object\') {\n          throw new TypeError(\'Expected the observer to be an object.\');\n        }\n\n        function observeState() {\n          if (observer.next) {\n            observer.next(getState());\n          }\n        }\n\n        observeState();\n        var unsubscribe = outerSubscribe(observeState);\n        return { unsubscribe: unsubscribe };\n      }\n    }, _ref[es["default"]] = function () {\n      return this;\n    }, _ref;\n  }\n\n  // When a store is created, an "INIT" action is dispatched so that every\n  // reducer returns their initial state. This effectively populates\n  // the initial state tree.\n  dispatch({ type: ActionTypes.INIT });\n\n  return _ref2 = {\n    dispatch: dispatch,\n    subscribe: subscribe,\n    getState: getState,\n    replaceReducer: replaceReducer\n  }, _ref2[es["default"]] = observable, _ref2;\n}\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux/es/utils/warning.js\n/**\n * Prints a warning in the console if it exists.\n *\n * @param {String} message The warning message.\n * @returns {void}\n */\nfunction warning_warning(message) {\n  /* eslint-disable no-console */\n  if (typeof console !== \'undefined\' && typeof console.error === \'function\') {\n    console.error(message);\n  }\n  /* eslint-enable no-console */\n  try {\n    // This error was thrown as a convenience so that if you enable\n    // "break on all exceptions" in your console,\n    // it would pause the execution at this line.\n    throw new Error(message);\n    /* eslint-disable no-empty */\n  } catch (e) {}\n  /* eslint-enable no-empty */\n}\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux/es/combineReducers.js\n\n\n\n\nfunction getUndefinedStateErrorMessage(key, action) {\n  var actionType = action && action.type;\n  var actionName = actionType && \'"\' + actionType.toString() + \'"\' || \'an action\';\n\n  return \'Given action \' + actionName + \', reducer "\' + key + \'" returned undefined. \' + \'To ignore an action, you must explicitly return the previous state. \' + \'If you want this reducer to hold no value, you can return null instead of undefined.\';\n}\n\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\n  var reducerKeys = Object.keys(reducers);\n  var argumentName = action && action.type === ActionTypes.INIT ? \'preloadedState argument passed to createStore\' : \'previous state received by the reducer\';\n\n  if (reducerKeys.length === 0) {\n    return \'Store does not have a valid reducer. Make sure the argument passed \' + \'to combineReducers is an object whose values are reducers.\';\n  }\n\n  if (!lodash_es_isPlainObject(inputState)) {\n    return \'The \' + argumentName + \' has unexpected type of "\' + {}.toString.call(inputState).match(/\\s([a-z|A-Z]+)/)[1] + \'". Expected argument to be an object with the following \' + (\'keys: "\' + reducerKeys.join(\'", "\') + \'"\');\n  }\n\n  var unexpectedKeys = Object.keys(inputState).filter(function (key) {\n    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];\n  });\n\n  unexpectedKeys.forEach(function (key) {\n    unexpectedKeyCache[key] = true;\n  });\n\n  if (unexpectedKeys.length > 0) {\n    return \'Unexpected \' + (unexpectedKeys.length > 1 ? \'keys\' : \'key\') + \' \' + (\'"\' + unexpectedKeys.join(\'", "\') + \'" found in \' + argumentName + \'. \') + \'Expected to find one of the known reducer keys instead: \' + (\'"\' + reducerKeys.join(\'", "\') + \'". Unexpected keys will be ignored.\');\n  }\n}\n\nfunction assertReducerShape(reducers) {\n  Object.keys(reducers).forEach(function (key) {\n    var reducer = reducers[key];\n    var initialState = reducer(undefined, { type: ActionTypes.INIT });\n\n    if (typeof initialState === \'undefined\') {\n      throw new Error(\'Reducer "\' + key + \'" returned undefined during initialization. \' + \'If the state passed to the reducer is undefined, you must \' + \'explicitly return the initial state. The initial state may \' + \'not be undefined. If you don\\\'t want to set a value for this reducer, \' + \'you can use null instead of undefined.\');\n    }\n\n    var type = \'@@redux/PROBE_UNKNOWN_ACTION_\' + Math.random().toString(36).substring(7).split(\'\').join(\'.\');\n    if (typeof reducer(undefined, { type: type }) === \'undefined\') {\n      throw new Error(\'Reducer "\' + key + \'" returned undefined when probed with a random type. \' + (\'Don\\\'t try to handle \' + ActionTypes.INIT + \' or other actions in "redux/*" \') + \'namespace. They are considered private. Instead, you must return the \' + \'current state for any unknown actions, unless it is undefined, \' + \'in which case you must return the initial state, regardless of the \' + \'action type. The initial state may not be undefined, but can be null.\');\n    }\n  });\n}\n\n/**\n * Turns an object whose values are different reducer functions, into a single\n * reducer function. It will call every child reducer, and gather their results\n * into a single state object, whose keys correspond to the keys of the passed\n * reducer functions.\n *\n * @param {Object} reducers An object whose values correspond to different\n * reducer functions that need to be combined into one. One handy way to obtain\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\n * undefined for any action. Instead, they should return their initial state\n * if the state passed to them was undefined, and the current state for any\n * unrecognized action.\n *\n * @returns {Function} A reducer function that invokes every reducer inside the\n * passed object, and builds a state object with the same shape.\n */\nfunction combineReducers(reducers) {\n  var reducerKeys = Object.keys(reducers);\n  var finalReducers = {};\n  for (var i = 0; i < reducerKeys.length; i++) {\n    var key = reducerKeys[i];\n\n    if (false) {}\n\n    if (typeof reducers[key] === \'function\') {\n      finalReducers[key] = reducers[key];\n    }\n  }\n  var finalReducerKeys = Object.keys(finalReducers);\n\n  var unexpectedKeyCache = void 0;\n  if (false) {}\n\n  var shapeAssertionError = void 0;\n  try {\n    assertReducerShape(finalReducers);\n  } catch (e) {\n    shapeAssertionError = e;\n  }\n\n  return function combination() {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var action = arguments[1];\n\n    if (shapeAssertionError) {\n      throw shapeAssertionError;\n    }\n\n    if (false) { var warningMessage; }\n\n    var hasChanged = false;\n    var nextState = {};\n    for (var _i = 0; _i < finalReducerKeys.length; _i++) {\n      var _key = finalReducerKeys[_i];\n      var reducer = finalReducers[_key];\n      var previousStateForKey = state[_key];\n      var nextStateForKey = reducer(previousStateForKey, action);\n      if (typeof nextStateForKey === \'undefined\') {\n        var errorMessage = getUndefinedStateErrorMessage(_key, action);\n        throw new Error(errorMessage);\n      }\n      nextState[_key] = nextStateForKey;\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n    }\n    return hasChanged ? nextState : state;\n  };\n}\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux/es/bindActionCreators.js\nfunction bindActionCreator(actionCreator, dispatch) {\n  return function () {\n    return dispatch(actionCreator.apply(undefined, arguments));\n  };\n}\n\n/**\n * Turns an object whose values are action creators, into an object with the\n * same keys, but with every function wrapped into a `dispatch` call so they\n * may be invoked directly. This is just a convenience method, as you can call\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\n *\n * For convenience, you can also pass a single function as the first argument,\n * and get a function in return.\n *\n * @param {Function|Object} actionCreators An object whose values are action\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\n * syntax. You may also pass a single function.\n *\n * @param {Function} dispatch The `dispatch` function available on your Redux\n * store.\n *\n * @returns {Function|Object} The object mimicking the original object, but with\n * every action creator wrapped into the `dispatch` call. If you passed a\n * function as `actionCreators`, the return value will also be a single\n * function.\n */\nfunction bindActionCreators(actionCreators, dispatch) {\n  if (typeof actionCreators === \'function\') {\n    return bindActionCreator(actionCreators, dispatch);\n  }\n\n  if (typeof actionCreators !== \'object\' || actionCreators === null) {\n    throw new Error(\'bindActionCreators expected an object or a function, instead received \' + (actionCreators === null ? \'null\' : typeof actionCreators) + \'. \' + \'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?\');\n  }\n\n  var keys = Object.keys(actionCreators);\n  var boundActionCreators = {};\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var actionCreator = actionCreators[key];\n    if (typeof actionCreator === \'function\') {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\n    }\n  }\n  return boundActionCreators;\n}\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux/es/compose.js\n/**\n * Composes single-argument functions from right to left. The rightmost\n * function can take multiple arguments as it provides the signature for\n * the resulting composite function.\n *\n * @param {...Function} funcs The functions to compose.\n * @returns {Function} A function obtained by composing the argument functions\n * from right to left. For example, compose(f, g, h) is identical to doing\n * (...args) => f(g(h(...args))).\n */\n\nfunction compose() {\n  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n\n  if (funcs.length === 0) {\n    return function (arg) {\n      return arg;\n    };\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n\n  return funcs.reduce(function (a, b) {\n    return function () {\n      return a(b.apply(undefined, arguments));\n    };\n  });\n}\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux/es/applyMiddleware.js\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\n\n\n/**\n * Creates a store enhancer that applies middleware to the dispatch method\n * of the Redux store. This is handy for a variety of tasks, such as expressing\n * asynchronous actions in a concise manner, or logging every action payload.\n *\n * See `redux-thunk` package as an example of the Redux middleware.\n *\n * Because middleware is potentially asynchronous, this should be the first\n * store enhancer in the composition chain.\n *\n * Note that each middleware will be given the `dispatch` and `getState` functions\n * as named arguments.\n *\n * @param {...Function} middlewares The middleware chain to be applied.\n * @returns {Function} A store enhancer applying the middleware.\n */\nfunction applyMiddleware() {\n  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {\n    middlewares[_key] = arguments[_key];\n  }\n\n  return function (createStore) {\n    return function (reducer, preloadedState, enhancer) {\n      var store = createStore(reducer, preloadedState, enhancer);\n      var _dispatch = store.dispatch;\n      var chain = [];\n\n      var middlewareAPI = {\n        getState: store.getState,\n        dispatch: function dispatch(action) {\n          return _dispatch(action);\n        }\n      };\n      chain = middlewares.map(function (middleware) {\n        return middleware(middlewareAPI);\n      });\n      _dispatch = compose.apply(undefined, chain)(store.dispatch);\n\n      return _extends({}, store, {\n        dispatch: _dispatch\n      });\n    };\n  };\n}\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux/es/index.js\n\n\n\n\n\n\n\n/*\n* This is a dummy function to check if the function name has been altered by minification.\n* If the function has been minified and NODE_ENV !== \'production\', warn the user.\n*/\nfunction isCrushed() {}\n\nif (false) {}\n\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js\nvar objectWithoutPropertiesLoose = __webpack_require__(15);\nvar objectWithoutPropertiesLoose_default = /*#__PURE__*/__webpack_require__.n(objectWithoutPropertiesLoose);\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/lodash/isFunction.js\nvar isFunction = __webpack_require__(44);\nvar isFunction_default = /*#__PURE__*/__webpack_require__.n(isFunction);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/actionTypes.js\nvar prefix = \'@@redux-form/\';\nvar ARRAY_INSERT = prefix + "ARRAY_INSERT";\nvar ARRAY_MOVE = prefix + "ARRAY_MOVE";\nvar ARRAY_POP = prefix + "ARRAY_POP";\nvar ARRAY_PUSH = prefix + "ARRAY_PUSH";\nvar ARRAY_REMOVE = prefix + "ARRAY_REMOVE";\nvar ARRAY_REMOVE_ALL = prefix + "ARRAY_REMOVE_ALL";\nvar ARRAY_SHIFT = prefix + "ARRAY_SHIFT";\nvar ARRAY_SPLICE = prefix + "ARRAY_SPLICE";\nvar ARRAY_UNSHIFT = prefix + "ARRAY_UNSHIFT";\nvar ARRAY_SWAP = prefix + "ARRAY_SWAP";\nvar AUTOFILL = prefix + "AUTOFILL";\nvar BLUR = prefix + "BLUR";\nvar CHANGE = prefix + "CHANGE";\nvar CLEAR_FIELDS = prefix + "CLEAR_FIELDS";\nvar CLEAR_SUBMIT = prefix + "CLEAR_SUBMIT";\nvar CLEAR_SUBMIT_ERRORS = prefix + "CLEAR_SUBMIT_ERRORS";\nvar CLEAR_ASYNC_ERROR = prefix + "CLEAR_ASYNC_ERROR";\nvar DESTROY = prefix + "DESTROY";\nvar FOCUS = prefix + "FOCUS";\nvar INITIALIZE = prefix + "INITIALIZE";\nvar REGISTER_FIELD = prefix + "REGISTER_FIELD";\nvar RESET = prefix + "RESET";\nvar RESET_SECTION = prefix + "RESET_SECTION";\nvar SET_SUBMIT_FAILED = prefix + "SET_SUBMIT_FAILED";\nvar SET_SUBMIT_SUCCEEDED = prefix + "SET_SUBMIT_SUCCEEDED";\nvar START_ASYNC_VALIDATION = prefix + "START_ASYNC_VALIDATION";\nvar START_SUBMIT = prefix + "START_SUBMIT";\nvar STOP_ASYNC_VALIDATION = prefix + "STOP_ASYNC_VALIDATION";\nvar STOP_SUBMIT = prefix + "STOP_SUBMIT";\nvar SUBMIT = prefix + "SUBMIT";\nvar TOUCH = prefix + "TOUCH";\nvar UNREGISTER_FIELD = prefix + "UNREGISTER_FIELD";\nvar UNTOUCH = prefix + "UNTOUCH";\nvar UPDATE_SYNC_ERRORS = prefix + "UPDATE_SYNC_ERRORS";\nvar UPDATE_SYNC_WARNINGS = prefix + "UPDATE_SYNC_WARNINGS";\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/lodash/toPath.js\nvar toPath = __webpack_require__(24);\nvar toPath_default = /*#__PURE__*/__webpack_require__.n(toPath);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/deleteInWithCleanUp.js\n\n\nfunction createDeleteInWithCleanUp(structure) {\n  var shouldDeleteDefault = function shouldDeleteDefault(structure) {\n    return function (state, path) {\n      return structure.getIn(state, path) !== undefined;\n    };\n  };\n\n  var deepEqual = structure.deepEqual,\n      empty = structure.empty,\n      getIn = structure.getIn,\n      deleteIn = structure.deleteIn,\n      setIn = structure.setIn;\n  return function (shouldDelete) {\n    if (shouldDelete === void 0) {\n      shouldDelete = shouldDeleteDefault;\n    }\n\n    var deleteInWithCleanUp = function deleteInWithCleanUp(state, path) {\n      if (path[path.length - 1] === \']\') {\n        // array path\n        var pathTokens = toPath_default()(path);\n\n        pathTokens.pop();\n        var parent = getIn(state, pathTokens.join(\'.\'));\n        return parent ? setIn(state, path) : state;\n      }\n\n      var result = state;\n\n      if (shouldDelete(structure)(state, path)) {\n        result = deleteIn(state, path);\n      }\n\n      var dotIndex = path.lastIndexOf(\'.\');\n\n      if (dotIndex > 0) {\n        var parentPath = path.substring(0, dotIndex);\n\n        if (parentPath[parentPath.length - 1] !== \']\') {\n          var _parent = getIn(result, parentPath);\n\n          if (deepEqual(_parent, empty)) {\n            return deleteInWithCleanUp(result, parentPath);\n          }\n        }\n      }\n\n      return result;\n    };\n\n    return deleteInWithCleanUp;\n  };\n}\n\n/* harmony default export */ var es_deleteInWithCleanUp = (createDeleteInWithCleanUp);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/structure/plain/splice.js\nvar splice_splice = function splice(array, index, removeNum, value) {\n  array = array || [];\n\n  if (index < array.length) {\n    if (value === undefined && !removeNum) {\n      // inserting undefined\n      var _copy2 = [].concat(array);\n\n      _copy2.splice(index, 0, true); // temporary placeholder\n\n\n      _copy2[index] = undefined; // set to undefined\n\n      return _copy2;\n    }\n\n    if (value != null) {\n      var _copy3 = [].concat(array);\n\n      _copy3.splice(index, removeNum, value); // removing and adding\n\n\n      return _copy3;\n    }\n\n    var _copy = [].concat(array);\n\n    _copy.splice(index, removeNum); // removing\n\n\n    return _copy;\n  }\n\n  if (removeNum) {\n    // trying to remove non-existant item: return original array\n    return array;\n  } // trying to add outside of range: just set value\n\n\n  var copy = [].concat(array);\n  copy[index] = value;\n  return copy;\n};\n\n/* harmony default export */ var plain_splice = (splice_splice);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/structure/plain/getIn.js\n\n\nvar getIn_getIn = function getIn(state, field) {\n  if (!state) {\n    return state;\n  }\n\n  var path = toPath_default()(field);\n\n  var length = path.length;\n\n  if (!length) {\n    return undefined;\n  }\n\n  var result = state;\n\n  for (var i = 0; i < length && result; ++i) {\n    result = result[path[i]];\n  }\n\n  return result;\n};\n\n/* harmony default export */ var plain_getIn = (getIn_getIn);\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/@babel/runtime/helpers/extends.js\nvar helpers_extends = __webpack_require__(3);\nvar extends_default = /*#__PURE__*/__webpack_require__.n(helpers_extends);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/structure/plain/setIn.js\n\n\n\nvar setIn_setInWithPath = function setInWithPath(state, value, path, pathIndex) {\n  var _extends2;\n\n  if (pathIndex >= path.length) {\n    return value;\n  }\n\n  var first = path[pathIndex];\n  var firstState = state && (Array.isArray(state) ? state[Number(first)] : state[first]);\n  var next = setInWithPath(firstState, value, path, pathIndex + 1);\n\n  if (!state) {\n    if (isNaN(first)) {\n      var _ref;\n\n      return _ref = {}, _ref[first] = next, _ref;\n    }\n\n    var initialized = [];\n    initialized[parseInt(first, 10)] = next;\n    return initialized;\n  }\n\n  if (Array.isArray(state)) {\n    var copy = [].concat(state);\n    copy[parseInt(first, 10)] = next;\n    return copy;\n  }\n\n  return extends_default()({}, state, (_extends2 = {}, _extends2[first] = next, _extends2));\n};\n\nvar setIn_setIn = function setIn(state, field, value) {\n  return setIn_setInWithPath(state, value, toPath_default()(field), 0);\n};\n\n/* harmony default export */ var plain_setIn = (setIn_setIn);\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/lodash/isEqualWith.js\nvar isEqualWith = __webpack_require__(46);\nvar isEqualWith_default = /*#__PURE__*/__webpack_require__.n(isEqualWith);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/structure/plain/deepEqual.js\n\n\n\nvar deepEqual_customizer = function customizer(obj, other) {\n  if (obj === other) return true;\n\n  if (!obj && !other) {\n    var objIsEmpty = obj === null || obj === undefined || obj === \'\';\n    var otherIsEmpty = other === null || other === undefined || other === \'\';\n    return objIsEmpty === otherIsEmpty;\n  }\n\n  if (obj && other && obj._error !== other._error) return false;\n  if (obj && other && obj._warning !== other._warning) return false;\n  if (react_default.a.isValidElement(obj) || react_default.a.isValidElement(other)) return false;\n};\n\nvar deepEqual_deepEqual = function deepEqual(a, b) {\n  return isEqualWith_default()(a, b, deepEqual_customizer);\n};\n\n/* harmony default export */ var plain_deepEqual = (deepEqual_deepEqual);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/structure/plain/deleteIn.js\n\n\n\nfunction deleteInWithPath(state, first) {\n  if (state === undefined || state === null || first === undefined || first === null) {\n    return state;\n  }\n\n  for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    rest[_key - 2] = arguments[_key];\n  }\n\n  if (rest.length) {\n    if (Array.isArray(state)) {\n      if (isNaN(first)) {\n        throw new Error("Must access array elements with a number, not \\"" + String(first) + "\\".");\n      }\n\n      var firstIndex = Number(first);\n\n      if (firstIndex < state.length) {\n        var result = deleteInWithPath.apply(void 0, [state && state[firstIndex]].concat(rest));\n\n        if (result !== state[firstIndex]) {\n          var copy = [].concat(state);\n          copy[firstIndex] = result;\n          return copy;\n        }\n      }\n\n      return state;\n    }\n\n    if (first in state) {\n      var _extends2;\n\n      var _result = deleteInWithPath.apply(void 0, [state && state[first]].concat(rest));\n\n      return state[first] === _result ? state : extends_default()({}, state, (_extends2 = {}, _extends2[first] = _result, _extends2));\n    }\n\n    return state;\n  }\n\n  if (Array.isArray(state)) {\n    if (isNaN(first)) {\n      throw new Error("Cannot delete non-numerical index from an array. Given: \\"" + String(first));\n    }\n\n    var _firstIndex = Number(first);\n\n    if (_firstIndex < state.length) {\n      var _copy = [].concat(state);\n\n      _copy.splice(_firstIndex, 1);\n\n      return _copy;\n    }\n\n    return state;\n  }\n\n  if (first in state) {\n    var _copy2 = extends_default()({}, state);\n\n    delete _copy2[first];\n    return _copy2;\n  }\n\n  return state;\n}\n\nvar deleteIn_deleteIn = function deleteIn(state, field) {\n  return deleteInWithPath.apply(void 0, [state].concat(toPath_default()(field)));\n};\n\n/* harmony default export */ var plain_deleteIn = (deleteIn_deleteIn);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/structure/plain/keys.js\nfunction keys_keys(value) {\n  if (!value) {\n    return [];\n  }\n\n  if (Array.isArray(value)) {\n    return value.map(function (i) {\n      return i.name;\n    });\n  }\n\n  return Object.keys(value);\n}\n\n/* harmony default export */ var plain_keys = (keys_keys);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/structure/plain/index.js\n\n\n\n\n\n\nvar plain_structure = {\n  allowsArrayErrors: true,\n  empty: {},\n  emptyList: [],\n  getIn: plain_getIn,\n  setIn: plain_setIn,\n  deepEqual: plain_deepEqual,\n  deleteIn: plain_deleteIn,\n  forEach: function forEach(items, callback) {\n    return items.forEach(callback);\n  },\n  fromJS: function fromJS(value) {\n    return value;\n  },\n  keys: plain_keys,\n  size: function size(array) {\n    return array ? array.length : 0;\n  },\n  some: function some(items, callback) {\n    return items.some(callback);\n  },\n  splice: plain_splice,\n  equals: function equals(a, b) {\n    return b.every(function (val) {\n      return ~a.indexOf(val);\n    });\n  },\n  orderChanged: function orderChanged(a, b) {\n    return b.some(function (val, index) {\n      return val !== a[index];\n    });\n  },\n  toJS: function toJS(value) {\n    return value;\n  }\n};\n/* harmony default export */ var plain = (plain_structure);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/createReducer.js\n\n\n\n\n\n\nvar createReducer_shouldDelete = function shouldDelete(_ref) {\n  var getIn = _ref.getIn;\n  return function (state, path) {\n    var initialValuesPath = null;\n\n    if (/^values/.test(path)) {\n      initialValuesPath = path.replace(\'values\', \'initial\');\n    }\n\n    var initialValueComparison = initialValuesPath ? getIn(state, initialValuesPath) === undefined : true;\n    return getIn(state, path) !== undefined && initialValueComparison;\n  };\n};\n\nvar createReducer_isReduxFormAction = function isReduxFormAction(action) {\n  return action && action.type && action.type.length > prefix.length && action.type.substring(0, prefix.length) === prefix;\n};\n\nfunction createReducer(structure) {\n  var _behaviors;\n\n  var deepEqual = structure.deepEqual,\n      empty = structure.empty,\n      forEach = structure.forEach,\n      getIn = structure.getIn,\n      setIn = structure.setIn,\n      deleteIn = structure.deleteIn,\n      fromJS = structure.fromJS,\n      keys = structure.keys,\n      size = structure.size,\n      some = structure.some,\n      splice = structure.splice;\n  var deleteInWithCleanUp = es_deleteInWithCleanUp(structure)(createReducer_shouldDelete);\n  var plainDeleteInWithCleanUp = es_deleteInWithCleanUp(plain)(createReducer_shouldDelete);\n\n  var doSplice = function doSplice(state, key, field, index, removeNum, value, force) {\n    var existing = getIn(state, key + "." + field);\n    return existing || force ? setIn(state, key + "." + field, splice(existing, index, removeNum, value)) : state;\n  };\n\n  var doPlainSplice = function doPlainSplice(state, key, field, index, removeNum, value, force) {\n    var slice = getIn(state, key);\n    var existing = plain.getIn(slice, field);\n    return existing || force ? setIn(state, key, plain.setIn(slice, field, plain.splice(existing, index, removeNum, value))) : state;\n  };\n\n  var rootKeys = [\'values\', \'fields\', \'submitErrors\', \'asyncErrors\'];\n\n  var arraySplice = function arraySplice(state, field, index, removeNum, value) {\n    var result = state;\n    var nonValuesValue = value != null ? empty : undefined;\n    result = doSplice(result, \'values\', field, index, removeNum, value, true);\n    result = doSplice(result, \'fields\', field, index, removeNum, nonValuesValue);\n    result = doPlainSplice(result, \'syncErrors\', field, index, removeNum, undefined);\n    result = doPlainSplice(result, \'syncWarnings\', field, index, removeNum, undefined);\n    result = doSplice(result, \'submitErrors\', field, index, removeNum, undefined);\n    result = doSplice(result, \'asyncErrors\', field, index, removeNum, undefined);\n    return result;\n  };\n\n  var behaviors = (_behaviors = {}, _behaviors[ARRAY_INSERT] = function (state, _ref2) {\n    var _ref2$meta = _ref2.meta,\n        field = _ref2$meta.field,\n        index = _ref2$meta.index,\n        payload = _ref2.payload;\n    return arraySplice(state, field, index, 0, payload);\n  }, _behaviors[ARRAY_MOVE] = function (state, _ref3) {\n    var _ref3$meta = _ref3.meta,\n        field = _ref3$meta.field,\n        from = _ref3$meta.from,\n        to = _ref3$meta.to;\n    var array = getIn(state, "values." + field);\n    var length = array ? size(array) : 0;\n    var result = state;\n\n    if (length) {\n      rootKeys.forEach(function (key) {\n        var path = key + "." + field;\n\n        if (getIn(result, path)) {\n          var value = getIn(result, path + "[" + from + "]");\n          result = setIn(result, path, splice(getIn(result, path), from, 1)); // remove\n\n          result = setIn(result, path, splice(getIn(result, path), to, 0, value)); // insert\n        }\n      });\n    }\n\n    return result;\n  }, _behaviors[ARRAY_POP] = function (state, _ref4) {\n    var field = _ref4.meta.field;\n    var array = getIn(state, "values." + field);\n    var length = array ? size(array) : 0;\n    return length ? arraySplice(state, field, length - 1, 1) : state;\n  }, _behaviors[ARRAY_PUSH] = function (state, _ref5) {\n    var field = _ref5.meta.field,\n        payload = _ref5.payload;\n    var array = getIn(state, "values." + field);\n    var length = array ? size(array) : 0;\n    return arraySplice(state, field, length, 0, payload);\n  }, _behaviors[ARRAY_REMOVE] = function (state, _ref6) {\n    var _ref6$meta = _ref6.meta,\n        field = _ref6$meta.field,\n        index = _ref6$meta.index;\n    return arraySplice(state, field, index, 1);\n  }, _behaviors[ARRAY_REMOVE_ALL] = function (state, _ref7) {\n    var field = _ref7.meta.field;\n    var array = getIn(state, "values." + field);\n    var length = array ? size(array) : 0;\n    return length ? arraySplice(state, field, 0, length) : state;\n  }, _behaviors[ARRAY_SHIFT] = function (state, _ref8) {\n    var field = _ref8.meta.field;\n    return arraySplice(state, field, 0, 1);\n  }, _behaviors[ARRAY_SPLICE] = function (state, _ref9) {\n    var _ref9$meta = _ref9.meta,\n        field = _ref9$meta.field,\n        index = _ref9$meta.index,\n        removeNum = _ref9$meta.removeNum,\n        payload = _ref9.payload;\n    return arraySplice(state, field, index, removeNum, payload);\n  }, _behaviors[ARRAY_SWAP] = function (state, _ref10) {\n    var _ref10$meta = _ref10.meta,\n        field = _ref10$meta.field,\n        indexA = _ref10$meta.indexA,\n        indexB = _ref10$meta.indexB;\n    var result = state;\n    rootKeys.forEach(function (key) {\n      var valueA = getIn(result, key + "." + field + "[" + indexA + "]");\n      var valueB = getIn(result, key + "." + field + "[" + indexB + "]");\n\n      if (valueA !== undefined || valueB !== undefined) {\n        result = setIn(result, key + "." + field + "[" + indexA + "]", valueB);\n        result = setIn(result, key + "." + field + "[" + indexB + "]", valueA);\n      }\n    });\n    return result;\n  }, _behaviors[ARRAY_UNSHIFT] = function (state, _ref11) {\n    var field = _ref11.meta.field,\n        payload = _ref11.payload;\n    return arraySplice(state, field, 0, 0, payload);\n  }, _behaviors[AUTOFILL] = function (state, _ref12) {\n    var field = _ref12.meta.field,\n        payload = _ref12.payload;\n    var result = state;\n    result = deleteInWithCleanUp(result, "asyncErrors." + field);\n    result = deleteInWithCleanUp(result, "submitErrors." + field);\n    result = setIn(result, "fields." + field + ".autofilled", true);\n    result = setIn(result, "values." + field, payload);\n    return result;\n  }, _behaviors[BLUR] = function (state, _ref13) {\n    var _ref13$meta = _ref13.meta,\n        field = _ref13$meta.field,\n        touch = _ref13$meta.touch,\n        payload = _ref13.payload;\n    var result = state;\n    var initial = getIn(result, "initial." + field);\n\n    if (initial === undefined && payload === \'\') {\n      result = deleteInWithCleanUp(result, "values." + field);\n    } else if (payload !== undefined) {\n      result = setIn(result, "values." + field, payload);\n    }\n\n    if (field === getIn(result, \'active\')) {\n      result = deleteIn(result, \'active\');\n    }\n\n    result = deleteIn(result, "fields." + field + ".active");\n\n    if (touch) {\n      result = setIn(result, "fields." + field + ".touched", true);\n      result = setIn(result, \'anyTouched\', true);\n    }\n\n    return result;\n  }, _behaviors[CHANGE] = function (state, _ref14) {\n    var _ref14$meta = _ref14.meta,\n        field = _ref14$meta.field,\n        touch = _ref14$meta.touch,\n        persistentSubmitErrors = _ref14$meta.persistentSubmitErrors,\n        payload = _ref14.payload;\n    var result = state;\n    var initial = getIn(result, "initial." + field);\n\n    if (initial === undefined && payload === \'\') {\n      result = deleteInWithCleanUp(result, "values." + field);\n    } else if (isFunction_default()(payload)) {\n      var fieldCurrentValue = getIn(state, "values." + field);\n      result = setIn(result, "values." + field, payload(fieldCurrentValue, state.values));\n    } else if (payload !== undefined) {\n      result = setIn(result, "values." + field, payload);\n    }\n\n    result = deleteInWithCleanUp(result, "asyncErrors." + field);\n\n    if (!persistentSubmitErrors) {\n      result = deleteInWithCleanUp(result, "submitErrors." + field);\n    }\n\n    result = deleteInWithCleanUp(result, "fields." + field + ".autofilled");\n\n    if (touch) {\n      result = setIn(result, "fields." + field + ".touched", true);\n      result = setIn(result, \'anyTouched\', true);\n    }\n\n    return result;\n  }, _behaviors[CLEAR_SUBMIT] = function (state) {\n    return deleteIn(state, \'triggerSubmit\');\n  }, _behaviors[CLEAR_SUBMIT_ERRORS] = function (state) {\n    var result = state;\n    result = deleteInWithCleanUp(result, \'submitErrors\');\n    result = deleteIn(result, \'error\');\n    return result;\n  }, _behaviors[CLEAR_ASYNC_ERROR] = function (state, _ref15) {\n    var field = _ref15.meta.field;\n    return deleteIn(state, "asyncErrors." + field);\n  }, _behaviors[CLEAR_FIELDS] = function (state, _ref16) {\n    var _ref16$meta = _ref16.meta,\n        keepTouched = _ref16$meta.keepTouched,\n        persistentSubmitErrors = _ref16$meta.persistentSubmitErrors,\n        fields = _ref16$meta.fields;\n    var result = state;\n    fields.forEach(function (field) {\n      result = deleteInWithCleanUp(result, "values." + field);\n      result = deleteInWithCleanUp(result, "asyncErrors." + field);\n\n      if (!persistentSubmitErrors) {\n        result = deleteInWithCleanUp(result, "submitErrors." + field);\n      }\n\n      result = deleteInWithCleanUp(result, "fields." + field + ".autofilled");\n\n      if (!keepTouched) {\n        result = deleteIn(result, "fields." + field + ".touched");\n      }\n    });\n    var anyTouched = some(keys(getIn(result, \'registeredFields\')), function (key) {\n      return getIn(result, "fields." + key + ".touched");\n    });\n    result = anyTouched ? setIn(result, \'anyTouched\', true) : deleteIn(result, \'anyTouched\');\n    return result;\n  }, _behaviors[FOCUS] = function (state, _ref17) {\n    var field = _ref17.meta.field;\n    var result = state;\n    var previouslyActive = getIn(state, \'active\');\n    result = deleteIn(result, "fields." + previouslyActive + ".active");\n    result = setIn(result, "fields." + field + ".visited", true);\n    result = setIn(result, "fields." + field + ".active", true);\n    result = setIn(result, \'active\', field);\n    return result;\n  }, _behaviors[INITIALIZE] = function (state, _ref18) {\n    var payload = _ref18.payload,\n        _ref18$meta = _ref18.meta,\n        keepDirty = _ref18$meta.keepDirty,\n        keepSubmitSucceeded = _ref18$meta.keepSubmitSucceeded,\n        updateUnregisteredFields = _ref18$meta.updateUnregisteredFields,\n        keepValues = _ref18$meta.keepValues;\n    var mapData = fromJS(payload);\n    var result = empty; // clean all field state\n    // persist old warnings, they will get recalculated if the new form values are different from the old values\n\n    var warning = getIn(state, \'warning\');\n\n    if (warning) {\n      result = setIn(result, \'warning\', warning);\n    }\n\n    var syncWarnings = getIn(state, \'syncWarnings\');\n\n    if (syncWarnings) {\n      result = setIn(result, \'syncWarnings\', syncWarnings);\n    } // persist old errors, they will get recalculated if the new form values are different from the old values\n\n\n    var error = getIn(state, \'error\');\n\n    if (error) {\n      result = setIn(result, \'error\', error);\n    }\n\n    var syncErrors = getIn(state, \'syncErrors\');\n\n    if (syncErrors) {\n      result = setIn(result, \'syncErrors\', syncErrors);\n    }\n\n    var registeredFields = getIn(state, \'registeredFields\');\n\n    if (registeredFields) {\n      result = setIn(result, \'registeredFields\', registeredFields);\n    }\n\n    var previousValues = getIn(state, \'values\');\n    var previousInitialValues = getIn(state, \'initial\');\n    var newInitialValues = mapData;\n    var newValues = previousValues;\n\n    if (keepDirty && registeredFields) {\n      if (!deepEqual(newInitialValues, previousInitialValues)) {\n        //\n        // Keep the value of dirty fields while updating the value of\n        // pristine fields. This way, apps can reinitialize forms while\n        // avoiding stomping on user edits.\n        //\n        // Note 1: The initialize action replaces all initial values\n        // regardless of keepDirty.\n        //\n        // Note 2: When a field is dirty, keepDirty is enabled, and the field\n        // value is the same as the new initial value for the field, the\n        // initialize action causes the field to become pristine. That effect\n        // is what we want.\n        //\n        var overwritePristineValue = function overwritePristineValue(name) {\n          var previousInitialValue = getIn(previousInitialValues, name);\n          var previousValue = getIn(previousValues, name);\n\n          if (deepEqual(previousValue, previousInitialValue)) {\n            // Overwrite the old pristine value with the new pristine value\n            var newInitialValue = getIn(newInitialValues, name); // This check prevents any \'setIn\' call that would create useless\n            // nested objects, since the path to the new field value would\n            // evaluate to the same (especially for undefined values)\n\n            if (getIn(newValues, name) !== newInitialValue) {\n              newValues = setIn(newValues, name, newInitialValue);\n            }\n          }\n        };\n\n        if (!updateUnregisteredFields) {\n          forEach(keys(registeredFields), function (name) {\n            return overwritePristineValue(name);\n          });\n        }\n\n        forEach(keys(newInitialValues), function (name) {\n          var previousInitialValue = getIn(previousInitialValues, name);\n\n          if (typeof previousInitialValue === \'undefined\') {\n            // Add new values at the root level.\n            var newInitialValue = getIn(newInitialValues, name);\n            newValues = setIn(newValues, name, newInitialValue);\n          }\n\n          if (updateUnregisteredFields) {\n            overwritePristineValue(name);\n          }\n        });\n      }\n    } else {\n      newValues = newInitialValues;\n    }\n\n    if (keepValues) {\n      forEach(keys(previousValues), function (name) {\n        var previousValue = getIn(previousValues, name);\n        newValues = setIn(newValues, name, previousValue);\n      });\n      forEach(keys(previousInitialValues), function (name) {\n        var previousInitialValue = getIn(previousInitialValues, name);\n        newInitialValues = setIn(newInitialValues, name, previousInitialValue);\n      });\n    }\n\n    if (keepSubmitSucceeded && getIn(state, \'submitSucceeded\')) {\n      result = setIn(result, \'submitSucceeded\', true);\n    }\n\n    result = setIn(result, \'values\', newValues);\n    result = setIn(result, \'initial\', newInitialValues);\n    return result;\n  }, _behaviors[REGISTER_FIELD] = function (state, _ref19) {\n    var _ref19$payload = _ref19.payload,\n        name = _ref19$payload.name,\n        type = _ref19$payload.type;\n    var key = "registeredFields[\'" + name + "\']";\n    var field = getIn(state, key);\n\n    if (field) {\n      var count = getIn(field, \'count\') + 1;\n      field = setIn(field, \'count\', count);\n    } else {\n      field = fromJS({\n        name: name,\n        type: type,\n        count: 1\n      });\n    }\n\n    return setIn(state, key, field);\n  }, _behaviors[RESET] = function (state) {\n    var result = empty;\n    var registeredFields = getIn(state, \'registeredFields\');\n\n    if (registeredFields) {\n      result = setIn(result, \'registeredFields\', registeredFields);\n    }\n\n    var values = getIn(state, \'initial\');\n\n    if (values) {\n      result = setIn(result, \'values\', values);\n      result = setIn(result, \'initial\', values);\n    }\n\n    return result;\n  }, _behaviors[RESET_SECTION] = function (state, _ref20) {\n    var sections = _ref20.meta.sections;\n    var result = state;\n    sections.forEach(function (section) {\n      result = deleteInWithCleanUp(result, "asyncErrors." + section);\n      result = deleteInWithCleanUp(result, "submitErrors." + section);\n      result = deleteInWithCleanUp(result, "fields." + section);\n      var values = getIn(state, "initial." + section);\n      result = values ? setIn(result, "values." + section, values) : deleteInWithCleanUp(result, "values." + section);\n    });\n    var anyTouched = some(keys(getIn(result, \'registeredFields\')), function (key) {\n      return getIn(result, "fields." + key + ".touched");\n    });\n    result = anyTouched ? setIn(result, \'anyTouched\', true) : deleteIn(result, \'anyTouched\');\n    return result;\n  }, _behaviors[SUBMIT] = function (state) {\n    return setIn(state, \'triggerSubmit\', true);\n  }, _behaviors[START_ASYNC_VALIDATION] = function (state, _ref21) {\n    var field = _ref21.meta.field;\n    return setIn(state, \'asyncValidating\', field || true);\n  }, _behaviors[START_SUBMIT] = function (state) {\n    return setIn(state, \'submitting\', true);\n  }, _behaviors[STOP_ASYNC_VALIDATION] = function (state, _ref22) {\n    var payload = _ref22.payload;\n    var result = state;\n    result = deleteIn(result, \'asyncValidating\');\n\n    if (payload && Object.keys(payload).length) {\n      var _error = payload._error,\n          fieldErrors = objectWithoutPropertiesLoose_default()(payload, ["_error"]);\n\n      if (_error) {\n        result = setIn(result, \'error\', _error);\n      }\n\n      if (Object.keys(fieldErrors).length) {\n        result = setIn(result, \'asyncErrors\', fromJS(fieldErrors));\n      }\n    } else {\n      result = deleteIn(result, \'error\');\n      result = deleteIn(result, \'asyncErrors\');\n    }\n\n    return result;\n  }, _behaviors[STOP_SUBMIT] = function (state, _ref23) {\n    var payload = _ref23.payload;\n    var result = state;\n    result = deleteIn(result, \'submitting\');\n    result = deleteIn(result, \'submitFailed\');\n    result = deleteIn(result, \'submitSucceeded\');\n\n    if (payload && Object.keys(payload).length) {\n      var _error = payload._error,\n          fieldErrors = objectWithoutPropertiesLoose_default()(payload, ["_error"]);\n\n      if (_error) {\n        result = setIn(result, \'error\', _error);\n      } else {\n        result = deleteIn(result, \'error\');\n      }\n\n      if (Object.keys(fieldErrors).length) {\n        result = setIn(result, \'submitErrors\', fromJS(fieldErrors));\n      } else {\n        result = deleteIn(result, \'submitErrors\');\n      }\n\n      result = setIn(result, \'submitFailed\', true);\n    } else {\n      result = deleteIn(result, \'error\');\n      result = deleteIn(result, \'submitErrors\');\n    }\n\n    return result;\n  }, _behaviors[SET_SUBMIT_FAILED] = function (state, _ref24) {\n    var fields = _ref24.meta.fields;\n    var result = state;\n    result = setIn(result, \'submitFailed\', true);\n    result = deleteIn(result, \'submitSucceeded\');\n    result = deleteIn(result, \'submitting\');\n    fields.forEach(function (field) {\n      return result = setIn(result, "fields." + field + ".touched", true);\n    });\n\n    if (fields.length) {\n      result = setIn(result, \'anyTouched\', true);\n    }\n\n    return result;\n  }, _behaviors[SET_SUBMIT_SUCCEEDED] = function (state) {\n    var result = state;\n    result = deleteIn(result, \'submitFailed\');\n    result = setIn(result, \'submitSucceeded\', true);\n    return result;\n  }, _behaviors[TOUCH] = function (state, _ref25) {\n    var fields = _ref25.meta.fields;\n    var result = state;\n    fields.forEach(function (field) {\n      return result = setIn(result, "fields." + field + ".touched", true);\n    });\n    result = setIn(result, \'anyTouched\', true);\n    return result;\n  }, _behaviors[UNREGISTER_FIELD] = function (state, _ref26) {\n    var _ref26$payload = _ref26.payload,\n        name = _ref26$payload.name,\n        destroyOnUnmount = _ref26$payload.destroyOnUnmount;\n    var result = state;\n    var key = "registeredFields[\'" + name + "\']";\n    var field = getIn(result, key);\n\n    if (!field) {\n      return result;\n    }\n\n    var count = getIn(field, \'count\') - 1;\n\n    if (count <= 0 && destroyOnUnmount) {\n      // Note: Cannot use deleteWithCleanUp here because of the flat nature of registeredFields\n      result = deleteIn(result, key);\n\n      if (deepEqual(getIn(result, \'registeredFields\'), empty)) {\n        result = deleteIn(result, \'registeredFields\');\n      }\n\n      var syncErrors = getIn(result, \'syncErrors\');\n\n      if (syncErrors) {\n        syncErrors = plainDeleteInWithCleanUp(syncErrors, name);\n\n        if (plain.deepEqual(syncErrors, plain.empty)) {\n          result = deleteIn(result, \'syncErrors\');\n        } else {\n          result = setIn(result, \'syncErrors\', syncErrors);\n        }\n      }\n\n      var syncWarnings = getIn(result, \'syncWarnings\');\n\n      if (syncWarnings) {\n        syncWarnings = plainDeleteInWithCleanUp(syncWarnings, name);\n\n        if (plain.deepEqual(syncWarnings, plain.empty)) {\n          result = deleteIn(result, \'syncWarnings\');\n        } else {\n          result = setIn(result, \'syncWarnings\', syncWarnings);\n        }\n      }\n\n      result = deleteInWithCleanUp(result, "submitErrors." + name);\n      result = deleteInWithCleanUp(result, "asyncErrors." + name);\n    } else {\n      field = setIn(field, \'count\', count);\n      result = setIn(result, key, field);\n    }\n\n    return result;\n  }, _behaviors[UNTOUCH] = function (state, _ref27) {\n    var fields = _ref27.meta.fields;\n    var result = state;\n    fields.forEach(function (field) {\n      return result = deleteIn(result, "fields." + field + ".touched");\n    });\n    var anyTouched = some(keys(getIn(result, \'registeredFields\')), function (key) {\n      return getIn(result, "fields." + key + ".touched");\n    });\n    result = anyTouched ? setIn(result, \'anyTouched\', true) : deleteIn(result, \'anyTouched\');\n    return result;\n  }, _behaviors[UPDATE_SYNC_ERRORS] = function (state, _ref28) {\n    var _ref28$payload = _ref28.payload,\n        syncErrors = _ref28$payload.syncErrors,\n        error = _ref28$payload.error;\n    var result = state;\n\n    if (error) {\n      result = setIn(result, \'error\', error);\n      result = setIn(result, \'syncError\', true);\n    } else {\n      result = deleteIn(result, \'error\');\n      result = deleteIn(result, \'syncError\');\n    }\n\n    if (Object.keys(syncErrors).length) {\n      result = setIn(result, \'syncErrors\', syncErrors);\n    } else {\n      result = deleteIn(result, \'syncErrors\');\n    }\n\n    return result;\n  }, _behaviors[UPDATE_SYNC_WARNINGS] = function (state, _ref29) {\n    var _ref29$payload = _ref29.payload,\n        syncWarnings = _ref29$payload.syncWarnings,\n        warning = _ref29$payload.warning;\n    var result = state;\n\n    if (warning) {\n      result = setIn(result, \'warning\', warning);\n    } else {\n      result = deleteIn(result, \'warning\');\n    }\n\n    if (Object.keys(syncWarnings).length) {\n      result = setIn(result, \'syncWarnings\', syncWarnings);\n    } else {\n      result = deleteIn(result, \'syncWarnings\');\n    }\n\n    return result;\n  }, _behaviors);\n\n  var reducer = function reducer(state, action) {\n    if (state === void 0) {\n      state = empty;\n    }\n\n    var behavior = behaviors[action.type];\n    return behavior ? behavior(state, action) : state;\n  };\n\n  var byForm = function byForm(reducer) {\n    return function (state, action) {\n      if (state === void 0) {\n        state = empty;\n      }\n\n      if (action === void 0) {\n        action = {\n          type: \'NONE\'\n        };\n      }\n\n      var form = action && action.meta && action.meta.form;\n\n      if (!form || !createReducer_isReduxFormAction(action)) {\n        return state;\n      }\n\n      if (action.type === DESTROY && action.meta && action.meta.form) {\n        return action.meta.form.reduce(function (result, form) {\n          return deleteInWithCleanUp(result, form);\n        }, state);\n      }\n\n      var formState = getIn(state, form);\n      var result = reducer(formState, action);\n      return result === formState ? state : setIn(state, form, result);\n    };\n  };\n  /**\n   * Adds additional functionality to the reducer\n   */\n\n\n  function decorate(target) {\n    target.plugin = function (reducers, config) {\n      var _this = this;\n\n      if (config === void 0) {\n        config = {};\n      }\n\n      // use \'function\' keyword to enable \'this\'\n      return decorate(function (state, action) {\n        if (state === void 0) {\n          state = empty;\n        }\n\n        if (action === void 0) {\n          action = {\n            type: \'NONE\'\n          };\n        }\n\n        var callPlugin = function callPlugin(processed, key) {\n          var previousState = getIn(processed, key);\n          var nextState = reducers[key](previousState, action, getIn(state, key));\n          return nextState !== previousState ? setIn(processed, key, nextState) : processed;\n        };\n\n        var processed = _this(state, action); // run through redux-form reducer\n\n\n        var form = action && action.meta && action.meta.form;\n\n        if (form && !config.receiveAllFormActions) {\n          // this is an action aimed at forms, so only give it to the specified form\'s plugin\n          return reducers[form] ? callPlugin(processed, form) : processed;\n        } else {\n          // this is not a form-specific action, so send it to all the plugins\n          return Object.keys(reducers).reduce(callPlugin, processed);\n        }\n      });\n    };\n\n    return target;\n  }\n\n  return decorate(byForm(reducer));\n}\n\n/* harmony default export */ var es_createReducer = (createReducer);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/reducer.js\n\n\n/* harmony default export */ var es_reducer = (es_createReducer(plain));\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/@babel/runtime/helpers/createClass.js\nvar createClass = __webpack_require__(7);\nvar createClass_default = /*#__PURE__*/__webpack_require__.n(createClass);\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/@babel/runtime/helpers/inheritsLoose.js\nvar inheritsLoose = __webpack_require__(16);\nvar inheritsLoose_default = /*#__PURE__*/__webpack_require__.n(inheritsLoose);\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/lodash/merge.js\nvar merge = __webpack_require__(102);\nvar merge_default = /*#__PURE__*/__webpack_require__.n(merge);\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/lodash/mapValues.js\nvar mapValues = __webpack_require__(103);\nvar mapValues_default = /*#__PURE__*/__webpack_require__.n(mapValues);\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-lifecycles-compat/react-lifecycles-compat.es.js\nvar react_lifecycles_compat_es = __webpack_require__(45);\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js\nvar hoist_non_react_statics_cjs = __webpack_require__(23);\nvar hoist_non_react_statics_cjs_default = /*#__PURE__*/__webpack_require__.n(hoist_non_react_statics_cjs);\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/invariant/browser.js\nvar browser = __webpack_require__(21);\nvar browser_default = /*#__PURE__*/__webpack_require__.n(browser);\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/is-promise/index.js\nvar is_promise = __webpack_require__(36);\nvar is_promise_default = /*#__PURE__*/__webpack_require__.n(is_promise);\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(1);\nvar prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/@babel/runtime/helpers/esm/inheritsLoose.js\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-redux/es/utils/PropTypes.js\n\nvar subscriptionShape = prop_types_default.a.shape({\n  trySubscribe: prop_types_default.a.func.isRequired,\n  tryUnsubscribe: prop_types_default.a.func.isRequired,\n  notifyNestedSubs: prop_types_default.a.func.isRequired,\n  isSubscribed: prop_types_default.a.func.isRequired\n});\nvar storeShape = prop_types_default.a.shape({\n  subscribe: prop_types_default.a.func.isRequired,\n  dispatch: prop_types_default.a.func.isRequired,\n  getState: prop_types_default.a.func.isRequired\n});\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-redux/es/utils/warning.js\n/**\n * Prints a warning in the console if it exists.\n *\n * @param {String} message The warning message.\n * @returns {void}\n */\nfunction utils_warning_warning(message) {\n  /* eslint-disable no-console */\n  if (typeof console !== \'undefined\' && typeof console.error === \'function\') {\n    console.error(message);\n  }\n  /* eslint-enable no-console */\n\n\n  try {\n    // This error was thrown as a convenience so that if you enable\n    // "break on all exceptions" in your console,\n    // it would pause the execution at this line.\n    throw new Error(message);\n    /* eslint-disable no-empty */\n  } catch (e) {}\n  /* eslint-enable no-empty */\n\n}\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-redux/es/components/Provider.js\n\n\n\n\n\nvar didWarnAboutReceivingStore = false;\n\nfunction warnAboutReceivingStore() {\n  if (didWarnAboutReceivingStore) {\n    return;\n  }\n\n  didWarnAboutReceivingStore = true;\n  utils_warning_warning(\'<Provider> does not support changing `store` on the fly. \' + \'It is most likely that you see this error because you updated to \' + \'Redux 2.x and React Redux 2.x which no longer hot reload reducers \' + \'automatically. See https://github.com/reduxjs/react-redux/releases/\' + \'tag/v2.0.0 for the migration instructions.\');\n}\n\nfunction createProvider(storeKey) {\n  var _Provider$childContex;\n\n  if (storeKey === void 0) {\n    storeKey = \'store\';\n  }\n\n  var subscriptionKey = storeKey + "Subscription";\n\n  var Provider =\n  /*#__PURE__*/\n  function (_Component) {\n    _inheritsLoose(Provider, _Component);\n\n    var _proto = Provider.prototype;\n\n    _proto.getChildContext = function getChildContext() {\n      var _ref;\n\n      return _ref = {}, _ref[storeKey] = this[storeKey], _ref[subscriptionKey] = null, _ref;\n    };\n\n    function Provider(props, context) {\n      var _this;\n\n      _this = _Component.call(this, props, context) || this;\n      _this[storeKey] = props.store;\n      return _this;\n    }\n\n    _proto.render = function render() {\n      return react["Children"].only(this.props.children);\n    };\n\n    return Provider;\n  }(react["Component"]);\n\n  if (false) {}\n\n  Provider.propTypes = {\n    store: storeShape.isRequired,\n    children: prop_types_default.a.element.isRequired\n  };\n  Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[storeKey] = storeShape.isRequired, _Provider$childContex[subscriptionKey] = subscriptionShape, _Provider$childContex);\n  return Provider;\n}\n/* harmony default export */ var components_Provider = (createProvider());\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");\n  }\n\n  return self;\n}\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/@babel/runtime/helpers/esm/extends.js\nfunction extends_extends() {\n  extends_extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return extends_extends.apply(this, arguments);\n}\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-is/index.js\nvar react_is = __webpack_require__(35);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-redux/es/utils/Subscription.js\n// encapsulates the subscription logic for connecting a component to the redux store, as\n// well as nesting subscriptions of descendant components, so that we can ensure the\n// ancestor components re-render before descendants\nvar CLEARED = null;\nvar nullListeners = {\n  notify: function notify() {}\n};\n\nfunction createListenerCollection() {\n  // the current/next pattern is copied from redux\'s createStore code.\n  // TODO: refactor+expose that code to be reusable here?\n  var current = [];\n  var next = [];\n  return {\n    clear: function clear() {\n      next = CLEARED;\n      current = CLEARED;\n    },\n    notify: function notify() {\n      var listeners = current = next;\n\n      for (var i = 0; i < listeners.length; i++) {\n        listeners[i]();\n      }\n    },\n    get: function get() {\n      return next;\n    },\n    subscribe: function subscribe(listener) {\n      var isSubscribed = true;\n      if (next === current) next = current.slice();\n      next.push(listener);\n      return function unsubscribe() {\n        if (!isSubscribed || current === CLEARED) return;\n        isSubscribed = false;\n        if (next === current) next = current.slice();\n        next.splice(next.indexOf(listener), 1);\n      };\n    }\n  };\n}\n\nvar Subscription =\n/*#__PURE__*/\nfunction () {\n  function Subscription(store, parentSub, onStateChange) {\n    this.store = store;\n    this.parentSub = parentSub;\n    this.onStateChange = onStateChange;\n    this.unsubscribe = null;\n    this.listeners = nullListeners;\n  }\n\n  var _proto = Subscription.prototype;\n\n  _proto.addNestedSub = function addNestedSub(listener) {\n    this.trySubscribe();\n    return this.listeners.subscribe(listener);\n  };\n\n  _proto.notifyNestedSubs = function notifyNestedSubs() {\n    this.listeners.notify();\n  };\n\n  _proto.isSubscribed = function isSubscribed() {\n    return Boolean(this.unsubscribe);\n  };\n\n  _proto.trySubscribe = function trySubscribe() {\n    if (!this.unsubscribe) {\n      this.unsubscribe = this.parentSub ? this.parentSub.addNestedSub(this.onStateChange) : this.store.subscribe(this.onStateChange);\n      this.listeners = createListenerCollection();\n    }\n  };\n\n  _proto.tryUnsubscribe = function tryUnsubscribe() {\n    if (this.unsubscribe) {\n      this.unsubscribe();\n      this.unsubscribe = null;\n      this.listeners.clear();\n      this.listeners = nullListeners;\n    }\n  };\n\n  return Subscription;\n}();\n\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-redux/es/components/connectAdvanced.js\n\n\n\n\n\n\n\n\n\n\nvar hotReloadingVersion = 0;\nvar dummyState = {};\n\nfunction noop() {}\n\nfunction makeSelectorStateful(sourceSelector, store) {\n  // wrap the selector in an object that tracks its results between runs.\n  var selector = {\n    run: function runComponentSelector(props) {\n      try {\n        var nextProps = sourceSelector(store.getState(), props);\n\n        if (nextProps !== selector.props || selector.error) {\n          selector.shouldComponentUpdate = true;\n          selector.props = nextProps;\n          selector.error = null;\n        }\n      } catch (error) {\n        selector.shouldComponentUpdate = true;\n        selector.error = error;\n      }\n    }\n  };\n  return selector;\n}\n\nfunction connectAdvanced(\n/*\n  selectorFactory is a func that is responsible for returning the selector function used to\n  compute new props from state, props, and dispatch. For example:\n     export default connectAdvanced((dispatch, options) => (state, props) => ({\n      thing: state.things[props.thingId],\n      saveThing: fields => dispatch(actionCreators.saveThing(props.thingId, fields)),\n    }))(YourComponent)\n   Access to dispatch is provided to the factory so selectorFactories can bind actionCreators\n  outside of their selector as an optimization. Options passed to connectAdvanced are passed to\n  the selectorFactory, along with displayName and WrappedComponent, as the second argument.\n   Note that selectorFactory is responsible for all caching/memoization of inbound and outbound\n  props. Do not use connectAdvanced directly without memoizing results between calls to your\n  selector, otherwise the Connect component will re-render on every state or props change.\n*/\nselectorFactory, // options object:\n_ref) {\n  var _contextTypes, _childContextTypes;\n\n  if (_ref === void 0) {\n    _ref = {};\n  }\n\n  var _ref2 = _ref,\n      _ref2$getDisplayName = _ref2.getDisplayName,\n      getDisplayName = _ref2$getDisplayName === void 0 ? function (name) {\n    return "ConnectAdvanced(" + name + ")";\n  } : _ref2$getDisplayName,\n      _ref2$methodName = _ref2.methodName,\n      methodName = _ref2$methodName === void 0 ? \'connectAdvanced\' : _ref2$methodName,\n      _ref2$renderCountProp = _ref2.renderCountProp,\n      renderCountProp = _ref2$renderCountProp === void 0 ? undefined : _ref2$renderCountProp,\n      _ref2$shouldHandleSta = _ref2.shouldHandleStateChanges,\n      shouldHandleStateChanges = _ref2$shouldHandleSta === void 0 ? true : _ref2$shouldHandleSta,\n      _ref2$storeKey = _ref2.storeKey,\n      storeKey = _ref2$storeKey === void 0 ? \'store\' : _ref2$storeKey,\n      _ref2$withRef = _ref2.withRef,\n      withRef = _ref2$withRef === void 0 ? false : _ref2$withRef,\n      connectOptions = _objectWithoutPropertiesLoose(_ref2, ["getDisplayName", "methodName", "renderCountProp", "shouldHandleStateChanges", "storeKey", "withRef"]);\n\n  var subscriptionKey = storeKey + \'Subscription\';\n  var version = hotReloadingVersion++;\n  var contextTypes = (_contextTypes = {}, _contextTypes[storeKey] = storeShape, _contextTypes[subscriptionKey] = subscriptionShape, _contextTypes);\n  var childContextTypes = (_childContextTypes = {}, _childContextTypes[subscriptionKey] = subscriptionShape, _childContextTypes);\n  return function wrapWithConnect(WrappedComponent) {\n    browser_default()(Object(react_is["isValidElementType"])(WrappedComponent), "You must pass a component to the function returned by " + (methodName + ". Instead received " + JSON.stringify(WrappedComponent)));\n    var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || \'Component\';\n    var displayName = getDisplayName(wrappedComponentName);\n\n    var selectorFactoryOptions = extends_extends({}, connectOptions, {\n      getDisplayName: getDisplayName,\n      methodName: methodName,\n      renderCountProp: renderCountProp,\n      shouldHandleStateChanges: shouldHandleStateChanges,\n      storeKey: storeKey,\n      withRef: withRef,\n      displayName: displayName,\n      wrappedComponentName: wrappedComponentName,\n      WrappedComponent: WrappedComponent // TODO Actually fix our use of componentWillReceiveProps\n\n      /* eslint-disable react/no-deprecated */\n\n    });\n\n    var Connect =\n    /*#__PURE__*/\n    function (_Component) {\n      _inheritsLoose(Connect, _Component);\n\n      function Connect(props, context) {\n        var _this;\n\n        _this = _Component.call(this, props, context) || this;\n        _this.version = version;\n        _this.state = {};\n        _this.renderCount = 0;\n        _this.store = props[storeKey] || context[storeKey];\n        _this.propsMode = Boolean(props[storeKey]);\n        _this.setWrappedInstance = _this.setWrappedInstance.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n        browser_default()(_this.store, "Could not find \\"" + storeKey + "\\" in either the context or props of " + ("\\"" + displayName + "\\". Either wrap the root component in a <Provider>, ") + ("or explicitly pass \\"" + storeKey + "\\" as a prop to \\"" + displayName + "\\"."));\n\n        _this.initSelector();\n\n        _this.initSubscription();\n\n        return _this;\n      }\n\n      var _proto = Connect.prototype;\n\n      _proto.getChildContext = function getChildContext() {\n        var _ref3;\n\n        // If this component received store from props, its subscription should be transparent\n        // to any descendants receiving store+subscription from context; it passes along\n        // subscription passed to it. Otherwise, it shadows the parent subscription, which allows\n        // Connect to control ordering of notifications to flow top-down.\n        var subscription = this.propsMode ? null : this.subscription;\n        return _ref3 = {}, _ref3[subscriptionKey] = subscription || this.context[subscriptionKey], _ref3;\n      };\n\n      _proto.componentDidMount = function componentDidMount() {\n        if (!shouldHandleStateChanges) return; // componentWillMount fires during server side rendering, but componentDidMount and\n        // componentWillUnmount do not. Because of this, trySubscribe happens during ...didMount.\n        // Otherwise, unsubscription would never take place during SSR, causing a memory leak.\n        // To handle the case where a child component may have triggered a state change by\n        // dispatching an action in its componentWillMount, we have to re-run the select and maybe\n        // re-render.\n\n        this.subscription.trySubscribe();\n        this.selector.run(this.props);\n        if (this.selector.shouldComponentUpdate) this.forceUpdate();\n      };\n\n      _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n        this.selector.run(nextProps);\n      };\n\n      _proto.shouldComponentUpdate = function shouldComponentUpdate() {\n        return this.selector.shouldComponentUpdate;\n      };\n\n      _proto.componentWillUnmount = function componentWillUnmount() {\n        if (this.subscription) this.subscription.tryUnsubscribe();\n        this.subscription = null;\n        this.notifyNestedSubs = noop;\n        this.store = null;\n        this.selector.run = noop;\n        this.selector.shouldComponentUpdate = false;\n      };\n\n      _proto.getWrappedInstance = function getWrappedInstance() {\n        browser_default()(withRef, "To access the wrapped instance, you need to specify " + ("{ withRef: true } in the options argument of the " + methodName + "() call."));\n        return this.wrappedInstance;\n      };\n\n      _proto.setWrappedInstance = function setWrappedInstance(ref) {\n        this.wrappedInstance = ref;\n      };\n\n      _proto.initSelector = function initSelector() {\n        var sourceSelector = selectorFactory(this.store.dispatch, selectorFactoryOptions);\n        this.selector = makeSelectorStateful(sourceSelector, this.store);\n        this.selector.run(this.props);\n      };\n\n      _proto.initSubscription = function initSubscription() {\n        if (!shouldHandleStateChanges) return; // parentSub\'s source should match where store came from: props vs. context. A component\n        // connected to the store via props shouldn\'t use subscription from context, or vice versa.\n\n        var parentSub = (this.propsMode ? this.props : this.context)[subscriptionKey];\n        this.subscription = new Subscription(this.store, parentSub, this.onStateChange.bind(this)); // `notifyNestedSubs` is duplicated to handle the case where the component is unmounted in\n        // the middle of the notification loop, where `this.subscription` will then be null. An\n        // extra null check every change can be avoided by copying the method onto `this` and then\n        // replacing it with a no-op on unmount. This can probably be avoided if Subscription\'s\n        // listeners logic is changed to not call listeners that have been unsubscribed in the\n        // middle of the notification loop.\n\n        this.notifyNestedSubs = this.subscription.notifyNestedSubs.bind(this.subscription);\n      };\n\n      _proto.onStateChange = function onStateChange() {\n        this.selector.run(this.props);\n\n        if (!this.selector.shouldComponentUpdate) {\n          this.notifyNestedSubs();\n        } else {\n          this.componentDidUpdate = this.notifyNestedSubsOnComponentDidUpdate;\n          this.setState(dummyState);\n        }\n      };\n\n      _proto.notifyNestedSubsOnComponentDidUpdate = function notifyNestedSubsOnComponentDidUpdate() {\n        // `componentDidUpdate` is conditionally implemented when `onStateChange` determines it\n        // needs to notify nested subs. Once called, it unimplements itself until further state\n        // changes occur. Doing it this way vs having a permanent `componentDidUpdate` that does\n        // a boolean check every time avoids an extra method call most of the time, resulting\n        // in some perf boost.\n        this.componentDidUpdate = undefined;\n        this.notifyNestedSubs();\n      };\n\n      _proto.isSubscribed = function isSubscribed() {\n        return Boolean(this.subscription) && this.subscription.isSubscribed();\n      };\n\n      _proto.addExtraProps = function addExtraProps(props) {\n        if (!withRef && !renderCountProp && !(this.propsMode && this.subscription)) return props; // make a shallow copy so that fields added don\'t leak to the original selector.\n        // this is especially important for \'ref\' since that\'s a reference back to the component\n        // instance. a singleton memoized selector would then be holding a reference to the\n        // instance, preventing the instance from being garbage collected, and that would be bad\n\n        var withExtras = extends_extends({}, props);\n\n        if (withRef) withExtras.ref = this.setWrappedInstance;\n        if (renderCountProp) withExtras[renderCountProp] = this.renderCount++;\n        if (this.propsMode && this.subscription) withExtras[subscriptionKey] = this.subscription;\n        return withExtras;\n      };\n\n      _proto.render = function render() {\n        var selector = this.selector;\n        selector.shouldComponentUpdate = false;\n\n        if (selector.error) {\n          throw selector.error;\n        } else {\n          return Object(react["createElement"])(WrappedComponent, this.addExtraProps(selector.props));\n        }\n      };\n\n      return Connect;\n    }(react["Component"]);\n    /* eslint-enable react/no-deprecated */\n\n\n    Connect.WrappedComponent = WrappedComponent;\n    Connect.displayName = displayName;\n    Connect.childContextTypes = childContextTypes;\n    Connect.contextTypes = contextTypes;\n    Connect.propTypes = contextTypes;\n\n    if (false) {}\n\n    return hoist_non_react_statics_cjs_default()(Connect, WrappedComponent);\n  };\n}\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-redux/es/utils/shallowEqual.js\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nfunction shallowEqual_is(x, y) {\n  if (x === y) {\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\n\nfunction shallowEqual(objA, objB) {\n  if (shallowEqual_is(objA, objB)) return true;\n\n  if (typeof objA !== \'object\' || objA === null || typeof objB !== \'object\' || objB === null) {\n    return false;\n  }\n\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n  if (keysA.length !== keysB.length) return false;\n\n  for (var i = 0; i < keysA.length; i++) {\n    if (!hasOwn.call(objB, keysA[i]) || !shallowEqual_is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-redux/es/utils/isPlainObject.js\n/**\r\n * @param {any} obj The object to inspect.\r\n * @returns {boolean} True if the argument appears to be a plain object.\r\n */\nfunction isPlainObject_isPlainObject(obj) {\n  if (typeof obj !== \'object\' || obj === null) return false;\n  var proto = Object.getPrototypeOf(obj);\n  if (proto === null) return true;\n  var baseProto = proto;\n\n  while (Object.getPrototypeOf(baseProto) !== null) {\n    baseProto = Object.getPrototypeOf(baseProto);\n  }\n\n  return proto === baseProto;\n}\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-redux/es/utils/verifyPlainObject.js\n\n\nfunction verifyPlainObject(value, displayName, methodName) {\n  if (!isPlainObject_isPlainObject(value)) {\n    utils_warning_warning(methodName + "() in " + displayName + " must return a plain object. Instead received " + value + ".");\n  }\n}\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-redux/es/connect/wrapMapToProps.js\n\nfunction wrapMapToPropsConstant(getConstant) {\n  return function initConstantSelector(dispatch, options) {\n    var constant = getConstant(dispatch, options);\n\n    function constantSelector() {\n      return constant;\n    }\n\n    constantSelector.dependsOnOwnProps = false;\n    return constantSelector;\n  };\n} // dependsOnOwnProps is used by createMapToPropsProxy to determine whether to pass props as args\n// to the mapToProps function being wrapped. It is also used by makePurePropsSelector to determine\n// whether mapToProps needs to be invoked when props have changed.\n// \n// A length of one signals that mapToProps does not depend on props from the parent component.\n// A length of zero is assumed to mean mapToProps is getting args via arguments or ...args and\n// therefore not reporting its length accurately..\n\nfunction getDependsOnOwnProps(mapToProps) {\n  return mapToProps.dependsOnOwnProps !== null && mapToProps.dependsOnOwnProps !== undefined ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;\n} // Used by whenMapStateToPropsIsFunction and whenMapDispatchToPropsIsFunction,\n// this function wraps mapToProps in a proxy function which does several things:\n// \n//  * Detects whether the mapToProps function being called depends on props, which\n//    is used by selectorFactory to decide if it should reinvoke on props changes.\n//    \n//  * On first call, handles mapToProps if returns another function, and treats that\n//    new function as the true mapToProps for subsequent calls.\n//    \n//  * On first call, verifies the first result is a plain object, in order to warn\n//    the developer that their mapToProps function is not returning a valid result.\n//    \n\nfunction wrapMapToPropsFunc(mapToProps, methodName) {\n  return function initProxySelector(dispatch, _ref) {\n    var displayName = _ref.displayName;\n\n    var proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {\n      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch);\n    }; // allow detectFactoryAndVerify to get ownProps\n\n\n    proxy.dependsOnOwnProps = true;\n\n    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {\n      proxy.mapToProps = mapToProps;\n      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);\n      var props = proxy(stateOrDispatch, ownProps);\n\n      if (typeof props === \'function\') {\n        proxy.mapToProps = props;\n        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);\n        props = proxy(stateOrDispatch, ownProps);\n      }\n\n      if (false) {}\n      return props;\n    };\n\n    return proxy;\n  };\n}\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-redux/es/connect/mapDispatchToProps.js\n\n\nfunction whenMapDispatchToPropsIsFunction(mapDispatchToProps) {\n  return typeof mapDispatchToProps === \'function\' ? wrapMapToPropsFunc(mapDispatchToProps, \'mapDispatchToProps\') : undefined;\n}\nfunction whenMapDispatchToPropsIsMissing(mapDispatchToProps) {\n  return !mapDispatchToProps ? wrapMapToPropsConstant(function (dispatch) {\n    return {\n      dispatch: dispatch\n    };\n  }) : undefined;\n}\nfunction whenMapDispatchToPropsIsObject(mapDispatchToProps) {\n  return mapDispatchToProps && typeof mapDispatchToProps === \'object\' ? wrapMapToPropsConstant(function (dispatch) {\n    return bindActionCreators(mapDispatchToProps, dispatch);\n  }) : undefined;\n}\n/* harmony default export */ var connect_mapDispatchToProps = ([whenMapDispatchToPropsIsFunction, whenMapDispatchToPropsIsMissing, whenMapDispatchToPropsIsObject]);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-redux/es/connect/mapStateToProps.js\n\nfunction whenMapStateToPropsIsFunction(mapStateToProps) {\n  return typeof mapStateToProps === \'function\' ? wrapMapToPropsFunc(mapStateToProps, \'mapStateToProps\') : undefined;\n}\nfunction whenMapStateToPropsIsMissing(mapStateToProps) {\n  return !mapStateToProps ? wrapMapToPropsConstant(function () {\n    return {};\n  }) : undefined;\n}\n/* harmony default export */ var connect_mapStateToProps = ([whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing]);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-redux/es/connect/mergeProps.js\n\n\nfunction defaultMergeProps(stateProps, dispatchProps, ownProps) {\n  return extends_extends({}, ownProps, stateProps, dispatchProps);\n}\nfunction wrapMergePropsFunc(mergeProps) {\n  return function initMergePropsProxy(dispatch, _ref) {\n    var displayName = _ref.displayName,\n        pure = _ref.pure,\n        areMergedPropsEqual = _ref.areMergedPropsEqual;\n    var hasRunOnce = false;\n    var mergedProps;\n    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {\n      var nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n\n      if (hasRunOnce) {\n        if (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;\n      } else {\n        hasRunOnce = true;\n        mergedProps = nextMergedProps;\n        if (false) {}\n      }\n\n      return mergedProps;\n    };\n  };\n}\nfunction whenMergePropsIsFunction(mergeProps) {\n  return typeof mergeProps === \'function\' ? wrapMergePropsFunc(mergeProps) : undefined;\n}\nfunction whenMergePropsIsOmitted(mergeProps) {\n  return !mergeProps ? function () {\n    return defaultMergeProps;\n  } : undefined;\n}\n/* harmony default export */ var connect_mergeProps = ([whenMergePropsIsFunction, whenMergePropsIsOmitted]);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-redux/es/connect/verifySubselectors.js\n\n\nfunction verify(selector, methodName, displayName) {\n  if (!selector) {\n    throw new Error("Unexpected value for " + methodName + " in " + displayName + ".");\n  } else if (methodName === \'mapStateToProps\' || methodName === \'mapDispatchToProps\') {\n    if (!selector.hasOwnProperty(\'dependsOnOwnProps\')) {\n      utils_warning_warning("The selector for " + methodName + " of " + displayName + " did not specify a value for dependsOnOwnProps.");\n    }\n  }\n}\n\nfunction verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps, displayName) {\n  verify(mapStateToProps, \'mapStateToProps\', displayName);\n  verify(mapDispatchToProps, \'mapDispatchToProps\', displayName);\n  verify(mergeProps, \'mergeProps\', displayName);\n}\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-redux/es/connect/selectorFactory.js\n\n\nfunction impureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch) {\n  return function impureFinalPropsSelector(state, ownProps) {\n    return mergeProps(mapStateToProps(state, ownProps), mapDispatchToProps(dispatch, ownProps), ownProps);\n  };\n}\nfunction pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, _ref) {\n  var areStatesEqual = _ref.areStatesEqual,\n      areOwnPropsEqual = _ref.areOwnPropsEqual,\n      areStatePropsEqual = _ref.areStatePropsEqual;\n  var hasRunAtLeastOnce = false;\n  var state;\n  var ownProps;\n  var stateProps;\n  var dispatchProps;\n  var mergedProps;\n\n  function handleFirstCall(firstState, firstOwnProps) {\n    state = firstState;\n    ownProps = firstOwnProps;\n    stateProps = mapStateToProps(state, ownProps);\n    dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    hasRunAtLeastOnce = true;\n    return mergedProps;\n  }\n\n  function handleNewPropsAndNewState() {\n    stateProps = mapStateToProps(state, ownProps);\n    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n\n  function handleNewProps() {\n    if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);\n    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n\n  function handleNewState() {\n    var nextStateProps = mapStateToProps(state, ownProps);\n    var statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);\n    stateProps = nextStateProps;\n    if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n\n  function handleSubsequentCalls(nextState, nextOwnProps) {\n    var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);\n    var stateChanged = !areStatesEqual(nextState, state);\n    state = nextState;\n    ownProps = nextOwnProps;\n    if (propsChanged && stateChanged) return handleNewPropsAndNewState();\n    if (propsChanged) return handleNewProps();\n    if (stateChanged) return handleNewState();\n    return mergedProps;\n  }\n\n  return function pureFinalPropsSelector(nextState, nextOwnProps) {\n    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);\n  };\n} // TODO: Add more comments\n// If pure is true, the selector returned by selectorFactory will memoize its results,\n// allowing connectAdvanced\'s shouldComponentUpdate to return false if final\n// props have not changed. If false, the selector will always return a new\n// object and shouldComponentUpdate will always return true.\n\nfunction finalPropsSelectorFactory(dispatch, _ref2) {\n  var initMapStateToProps = _ref2.initMapStateToProps,\n      initMapDispatchToProps = _ref2.initMapDispatchToProps,\n      initMergeProps = _ref2.initMergeProps,\n      options = _objectWithoutPropertiesLoose(_ref2, ["initMapStateToProps", "initMapDispatchToProps", "initMergeProps"]);\n\n  var mapStateToProps = initMapStateToProps(dispatch, options);\n  var mapDispatchToProps = initMapDispatchToProps(dispatch, options);\n  var mergeProps = initMergeProps(dispatch, options);\n\n  if (false) {}\n\n  var selectorFactory = options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory;\n  return selectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);\n}\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-redux/es/connect/connect.js\n\n\n\n\n\n\n\n\n/*\n  connect is a facade over connectAdvanced. It turns its args into a compatible\n  selectorFactory, which has the signature:\n\n    (dispatch, options) => (nextState, nextOwnProps) => nextFinalProps\n  \n  connect passes its args to connectAdvanced as options, which will in turn pass them to\n  selectorFactory each time a Connect component instance is instantiated or hot reloaded.\n\n  selectorFactory returns a final props selector from its mapStateToProps,\n  mapStateToPropsFactories, mapDispatchToProps, mapDispatchToPropsFactories, mergeProps,\n  mergePropsFactories, and pure args.\n\n  The resulting final props selector is called by the Connect component instance whenever\n  it receives new props or store state.\n */\n\nfunction match(arg, factories, name) {\n  for (var i = factories.length - 1; i >= 0; i--) {\n    var result = factories[i](arg);\n    if (result) return result;\n  }\n\n  return function (dispatch, options) {\n    throw new Error("Invalid value of type " + typeof arg + " for " + name + " argument when connecting component " + options.wrappedComponentName + ".");\n  };\n}\n\nfunction strictEqual(a, b) {\n  return a === b;\n} // createConnect with default args builds the \'official\' connect behavior. Calling it with\n// different options opens up some testing and extensibility scenarios\n\n\nfunction createConnect(_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n      _ref$connectHOC = _ref.connectHOC,\n      connectHOC = _ref$connectHOC === void 0 ? connectAdvanced : _ref$connectHOC,\n      _ref$mapStateToPropsF = _ref.mapStateToPropsFactories,\n      mapStateToPropsFactories = _ref$mapStateToPropsF === void 0 ? connect_mapStateToProps : _ref$mapStateToPropsF,\n      _ref$mapDispatchToPro = _ref.mapDispatchToPropsFactories,\n      mapDispatchToPropsFactories = _ref$mapDispatchToPro === void 0 ? connect_mapDispatchToProps : _ref$mapDispatchToPro,\n      _ref$mergePropsFactor = _ref.mergePropsFactories,\n      mergePropsFactories = _ref$mergePropsFactor === void 0 ? connect_mergeProps : _ref$mergePropsFactor,\n      _ref$selectorFactory = _ref.selectorFactory,\n      selectorFactory = _ref$selectorFactory === void 0 ? finalPropsSelectorFactory : _ref$selectorFactory;\n\n  return function connect(mapStateToProps, mapDispatchToProps, mergeProps, _ref2) {\n    if (_ref2 === void 0) {\n      _ref2 = {};\n    }\n\n    var _ref3 = _ref2,\n        _ref3$pure = _ref3.pure,\n        pure = _ref3$pure === void 0 ? true : _ref3$pure,\n        _ref3$areStatesEqual = _ref3.areStatesEqual,\n        areStatesEqual = _ref3$areStatesEqual === void 0 ? strictEqual : _ref3$areStatesEqual,\n        _ref3$areOwnPropsEqua = _ref3.areOwnPropsEqual,\n        areOwnPropsEqual = _ref3$areOwnPropsEqua === void 0 ? shallowEqual : _ref3$areOwnPropsEqua,\n        _ref3$areStatePropsEq = _ref3.areStatePropsEqual,\n        areStatePropsEqual = _ref3$areStatePropsEq === void 0 ? shallowEqual : _ref3$areStatePropsEq,\n        _ref3$areMergedPropsE = _ref3.areMergedPropsEqual,\n        areMergedPropsEqual = _ref3$areMergedPropsE === void 0 ? shallowEqual : _ref3$areMergedPropsE,\n        extraOptions = _objectWithoutPropertiesLoose(_ref3, ["pure", "areStatesEqual", "areOwnPropsEqual", "areStatePropsEqual", "areMergedPropsEqual"]);\n\n    var initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, \'mapStateToProps\');\n    var initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, \'mapDispatchToProps\');\n    var initMergeProps = match(mergeProps, mergePropsFactories, \'mergeProps\');\n    return connectHOC(selectorFactory, extends_extends({\n      // used in error messages\n      methodName: \'connect\',\n      // used to compute Connect\'s displayName from the wrapped component\'s displayName.\n      getDisplayName: function getDisplayName(name) {\n        return "Connect(" + name + ")";\n      },\n      // if mapStateToProps is falsy, the Connect component doesn\'t subscribe to store state changes\n      shouldHandleStateChanges: Boolean(mapStateToProps),\n      // passed through to selectorFactory\n      initMapStateToProps: initMapStateToProps,\n      initMapDispatchToProps: initMapDispatchToProps,\n      initMergeProps: initMergeProps,\n      pure: pure,\n      areStatesEqual: areStatesEqual,\n      areOwnPropsEqual: areOwnPropsEqual,\n      areStatePropsEqual: areStatePropsEqual,\n      areMergedPropsEqual: areMergedPropsEqual\n    }, extraOptions));\n  };\n}\n/* harmony default export */ var connect_connect = (createConnect());\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-redux/es/index.js\n\n\n\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/actions.js\n\n\n\nvar actions_arrayInsert = function arrayInsert(form, field, index, value) {\n  return {\n    type: ARRAY_INSERT,\n    meta: {\n      form: form,\n      field: field,\n      index: index\n    },\n    payload: value\n  };\n};\n\nvar actions_arrayMove = function arrayMove(form, field, from, to) {\n  return {\n    type: ARRAY_MOVE,\n    meta: {\n      form: form,\n      field: field,\n      from: from,\n      to: to\n    }\n  };\n};\n\nvar actions_arrayPop = function arrayPop(form, field) {\n  return {\n    type: ARRAY_POP,\n    meta: {\n      form: form,\n      field: field\n    }\n  };\n};\n\nvar actions_arrayPush = function arrayPush(form, field, value) {\n  return {\n    type: ARRAY_PUSH,\n    meta: {\n      form: form,\n      field: field\n    },\n    payload: value\n  };\n};\n\nvar actions_arrayRemove = function arrayRemove(form, field, index) {\n  return {\n    type: ARRAY_REMOVE,\n    meta: {\n      form: form,\n      field: field,\n      index: index\n    }\n  };\n};\n\nvar actions_arrayRemoveAll = function arrayRemoveAll(form, field) {\n  return {\n    type: ARRAY_REMOVE_ALL,\n    meta: {\n      form: form,\n      field: field\n    }\n  };\n};\n\nvar actions_arrayShift = function arrayShift(form, field) {\n  return {\n    type: ARRAY_SHIFT,\n    meta: {\n      form: form,\n      field: field\n    }\n  };\n};\n\nvar actions_arraySplice = function arraySplice(form, field, index, removeNum, value) {\n  var action = {\n    type: ARRAY_SPLICE,\n    meta: {\n      form: form,\n      field: field,\n      index: index,\n      removeNum: removeNum\n    }\n  };\n\n  if (value !== undefined) {\n    action.payload = value;\n  }\n\n  return action;\n};\n\nvar actions_arraySwap = function arraySwap(form, field, indexA, indexB) {\n  if (indexA === indexB) {\n    throw new Error(\'Swap indices cannot be equal\');\n  }\n\n  if (indexA < 0 || indexB < 0) {\n    throw new Error(\'Swap indices cannot be negative\');\n  }\n\n  return {\n    type: ARRAY_SWAP,\n    meta: {\n      form: form,\n      field: field,\n      indexA: indexA,\n      indexB: indexB\n    }\n  };\n};\n\nvar actions_arrayUnshift = function arrayUnshift(form, field, value) {\n  return {\n    type: ARRAY_UNSHIFT,\n    meta: {\n      form: form,\n      field: field\n    },\n    payload: value\n  };\n};\n\nvar actions_autofill = function autofill(form, field, value) {\n  return {\n    type: AUTOFILL,\n    meta: {\n      form: form,\n      field: field\n    },\n    payload: value\n  };\n};\n\nvar actions_blur = function blur(form, field, value, touch) {\n  return {\n    type: BLUR,\n    meta: {\n      form: form,\n      field: field,\n      touch: touch\n    },\n    payload: value\n  };\n};\n\nvar actions_change = function change(form, field, value, touch, persistentSubmitErrors) {\n  return {\n    type: CHANGE,\n    meta: {\n      form: form,\n      field: field,\n      touch: touch,\n      persistentSubmitErrors: persistentSubmitErrors\n    },\n    payload: value\n  };\n};\n\nvar actions_clearSubmit = function clearSubmit(form) {\n  return {\n    type: CLEAR_SUBMIT,\n    meta: {\n      form: form\n    }\n  };\n};\n\nvar actions_clearSubmitErrors = function clearSubmitErrors(form) {\n  return {\n    type: CLEAR_SUBMIT_ERRORS,\n    meta: {\n      form: form\n    }\n  };\n};\n\nvar actions_clearAsyncError = function clearAsyncError(form, field) {\n  return {\n    type: CLEAR_ASYNC_ERROR,\n    meta: {\n      form: form,\n      field: field\n    }\n  };\n};\n\nvar actions_clearFields = function clearFields(form, keepTouched, persistentSubmitErrors) {\n  for (var _len = arguments.length, fields = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n    fields[_key - 3] = arguments[_key];\n  }\n\n  return {\n    type: CLEAR_FIELDS,\n    meta: {\n      form: form,\n      keepTouched: keepTouched,\n      persistentSubmitErrors: persistentSubmitErrors,\n      fields: fields\n    }\n  };\n};\n\nvar actions_destroy = function destroy() {\n  for (var _len2 = arguments.length, form = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    form[_key2] = arguments[_key2];\n  }\n\n  return {\n    type: DESTROY,\n    meta: {\n      form: form\n    }\n  };\n};\n\nvar actions_focus = function focus(form, field) {\n  return {\n    type: FOCUS,\n    meta: {\n      form: form,\n      field: field\n    }\n  };\n};\n\nvar actions_initialize = function initialize(form, values, keepDirty, otherMeta) {\n  if (otherMeta === void 0) {\n    otherMeta = {};\n  }\n\n  if (keepDirty instanceof Object) {\n    otherMeta = keepDirty;\n    keepDirty = false;\n  }\n\n  return {\n    type: INITIALIZE,\n    meta: extends_default()({\n      form: form,\n      keepDirty: keepDirty\n    }, otherMeta),\n    payload: values\n  };\n};\n\nvar actions_registerField = function registerField(form, name, type) {\n  return {\n    type: REGISTER_FIELD,\n    meta: {\n      form: form\n    },\n    payload: {\n      name: name,\n      type: type\n    }\n  };\n};\n\nvar actions_reset = function reset(form) {\n  return {\n    type: RESET,\n    meta: {\n      form: form\n    }\n  };\n};\n\nvar actions_resetSection = function resetSection(form) {\n  for (var _len3 = arguments.length, sections = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    sections[_key3 - 1] = arguments[_key3];\n  }\n\n  return {\n    type: RESET_SECTION,\n    meta: {\n      form: form,\n      sections: sections\n    }\n  };\n};\n\nvar actions_startAsyncValidation = function startAsyncValidation(form, field) {\n  return {\n    type: START_ASYNC_VALIDATION,\n    meta: {\n      form: form,\n      field: field\n    }\n  };\n};\n\nvar actions_startSubmit = function startSubmit(form) {\n  return {\n    type: START_SUBMIT,\n    meta: {\n      form: form\n    }\n  };\n};\n\nvar actions_stopAsyncValidation = function stopAsyncValidation(form, errors) {\n  return {\n    type: STOP_ASYNC_VALIDATION,\n    meta: {\n      form: form\n    },\n    payload: errors,\n    error: !!(errors && Object.keys(errors).length)\n  };\n};\n\nvar actions_stopSubmit = function stopSubmit(form, errors) {\n  return {\n    type: STOP_SUBMIT,\n    meta: {\n      form: form\n    },\n    payload: errors,\n    error: !!(errors && Object.keys(errors).length)\n  };\n};\n\nvar actions_submit = function submit(form) {\n  return {\n    type: SUBMIT,\n    meta: {\n      form: form\n    }\n  };\n};\n\nvar actions_setSubmitFailed = function setSubmitFailed(form) {\n  for (var _len4 = arguments.length, fields = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    fields[_key4 - 1] = arguments[_key4];\n  }\n\n  return {\n    type: SET_SUBMIT_FAILED,\n    meta: {\n      form: form,\n      fields: fields\n    },\n    error: true\n  };\n};\n\nvar actions_setSubmitSucceeded = function setSubmitSucceeded(form) {\n  for (var _len5 = arguments.length, fields = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n    fields[_key5 - 1] = arguments[_key5];\n  }\n\n  return {\n    type: SET_SUBMIT_SUCCEEDED,\n    meta: {\n      form: form,\n      fields: fields\n    },\n    error: false\n  };\n};\n\nvar actions_touch = function touch(form) {\n  for (var _len6 = arguments.length, fields = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n    fields[_key6 - 1] = arguments[_key6];\n  }\n\n  return {\n    type: TOUCH,\n    meta: {\n      form: form,\n      fields: fields\n    }\n  };\n};\n\nvar actions_unregisterField = function unregisterField(form, name, destroyOnUnmount) {\n  if (destroyOnUnmount === void 0) {\n    destroyOnUnmount = true;\n  }\n\n  return {\n    type: UNREGISTER_FIELD,\n    meta: {\n      form: form\n    },\n    payload: {\n      name: name,\n      destroyOnUnmount: destroyOnUnmount\n    }\n  };\n};\n\nvar actions_untouch = function untouch(form) {\n  for (var _len7 = arguments.length, fields = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n    fields[_key7 - 1] = arguments[_key7];\n  }\n\n  return {\n    type: UNTOUCH,\n    meta: {\n      form: form,\n      fields: fields\n    }\n  };\n};\n\nvar actions_updateSyncErrors = function updateSyncErrors(form, syncErrors, error) {\n  if (syncErrors === void 0) {\n    syncErrors = {};\n  }\n\n  return {\n    type: UPDATE_SYNC_ERRORS,\n    meta: {\n      form: form\n    },\n    payload: {\n      syncErrors: syncErrors,\n      error: error\n    }\n  };\n};\n\nvar actions_updateSyncWarnings = function updateSyncWarnings(form, syncWarnings, warning) {\n  if (syncWarnings === void 0) {\n    syncWarnings = {};\n  }\n\n  return {\n    type: UPDATE_SYNC_WARNINGS,\n    meta: {\n      form: form\n    },\n    payload: {\n      syncWarnings: syncWarnings,\n      warning: warning\n    }\n  };\n};\n\nvar actions = {\n  arrayInsert: actions_arrayInsert,\n  arrayMove: actions_arrayMove,\n  arrayPop: actions_arrayPop,\n  arrayPush: actions_arrayPush,\n  arrayRemove: actions_arrayRemove,\n  arrayRemoveAll: actions_arrayRemoveAll,\n  arrayShift: actions_arrayShift,\n  arraySplice: actions_arraySplice,\n  arraySwap: actions_arraySwap,\n  arrayUnshift: actions_arrayUnshift,\n  autofill: actions_autofill,\n  blur: actions_blur,\n  change: actions_change,\n  clearFields: actions_clearFields,\n  clearSubmit: actions_clearSubmit,\n  clearSubmitErrors: actions_clearSubmitErrors,\n  clearAsyncError: actions_clearAsyncError,\n  destroy: actions_destroy,\n  focus: actions_focus,\n  initialize: actions_initialize,\n  registerField: actions_registerField,\n  reset: actions_reset,\n  resetSection: actions_resetSection,\n  startAsyncValidation: actions_startAsyncValidation,\n  startSubmit: actions_startSubmit,\n  stopAsyncValidation: actions_stopAsyncValidation,\n  stopSubmit: actions_stopSubmit,\n  submit: actions_submit,\n  setSubmitFailed: actions_setSubmitFailed,\n  setSubmitSucceeded: actions_setSubmitSucceeded,\n  touch: actions_touch,\n  unregisterField: actions_unregisterField,\n  untouch: actions_untouch,\n  updateSyncErrors: actions_updateSyncErrors,\n  updateSyncWarnings: actions_updateSyncWarnings\n};\n/* harmony default export */ var es_actions = (actions);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/asyncValidation.js\n\n\nvar asyncValidation_asyncValidation = function asyncValidation(fn, start, stop, field) {\n  start(field);\n  var promise = fn();\n\n  if (!is_promise_default()(promise)) {\n    throw new Error(\'asyncValidate function passed to reduxForm must return a promise\');\n  }\n\n  var handleErrors = function handleErrors(rejected) {\n    return function (errors) {\n      if (rejected) {\n        if (errors && Object.keys(errors).length) {\n          stop(errors);\n          return errors;\n        } else {\n          stop();\n          throw new Error(\'Asynchronous validation promise was rejected without errors.\');\n        }\n      }\n\n      stop();\n      return Promise.resolve();\n    };\n  };\n\n  return promise.then(handleErrors(false), handleErrors(true));\n};\n\n/* harmony default export */ var es_asyncValidation = (asyncValidation_asyncValidation);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/defaultShouldAsyncValidate.js\nvar defaultShouldAsyncValidate = function defaultShouldAsyncValidate(_ref) {\n  var initialized = _ref.initialized,\n      trigger = _ref.trigger,\n      pristine = _ref.pristine,\n      syncValidationPasses = _ref.syncValidationPasses;\n\n  if (!syncValidationPasses) {\n    return false;\n  }\n\n  switch (trigger) {\n    case \'blur\':\n    case \'change\':\n      // blurring\n      return true;\n\n    case \'submit\':\n      // submitting, so only async validate if form is dirty or was never initialized\n      // conversely, DON\'T async validate if the form is pristine just as it was initialized\n      return !pristine || !initialized;\n\n    default:\n      return false;\n  }\n};\n\n/* harmony default export */ var es_defaultShouldAsyncValidate = (defaultShouldAsyncValidate);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/defaultShouldValidate.js\nvar defaultShouldValidate = function defaultShouldValidate(_ref) {\n  var values = _ref.values,\n      nextProps = _ref.nextProps,\n      initialRender = _ref.initialRender,\n      lastFieldValidatorKeys = _ref.lastFieldValidatorKeys,\n      fieldValidatorKeys = _ref.fieldValidatorKeys,\n      structure = _ref.structure;\n\n  if (initialRender) {\n    return true;\n  }\n\n  return !structure.deepEqual(values, nextProps && nextProps.values) || !structure.deepEqual(lastFieldValidatorKeys, fieldValidatorKeys);\n};\n\n/* harmony default export */ var es_defaultShouldValidate = (defaultShouldValidate);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/defaultShouldError.js\nvar defaultShouldError = function defaultShouldError(_ref) {\n  var values = _ref.values,\n      nextProps = _ref.nextProps,\n      initialRender = _ref.initialRender,\n      lastFieldValidatorKeys = _ref.lastFieldValidatorKeys,\n      fieldValidatorKeys = _ref.fieldValidatorKeys,\n      structure = _ref.structure;\n\n  if (initialRender) {\n    return true;\n  }\n\n  return !structure.deepEqual(values, nextProps && nextProps.values) || !structure.deepEqual(lastFieldValidatorKeys, fieldValidatorKeys);\n};\n\n/* harmony default export */ var es_defaultShouldError = (defaultShouldError);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/defaultShouldWarn.js\nvar defaultShouldWarn = function defaultShouldWarn(_ref) {\n  var values = _ref.values,\n      nextProps = _ref.nextProps,\n      initialRender = _ref.initialRender,\n      lastFieldValidatorKeys = _ref.lastFieldValidatorKeys,\n      fieldValidatorKeys = _ref.fieldValidatorKeys,\n      structure = _ref.structure;\n\n  if (initialRender) {\n    return true;\n  }\n\n  return !structure.deepEqual(values, nextProps && nextProps.values) || !structure.deepEqual(lastFieldValidatorKeys, fieldValidatorKeys);\n};\n\n/* harmony default export */ var es_defaultShouldWarn = (defaultShouldWarn);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/events/isEvent.js\nvar isEvent = function isEvent(candidate) {\n  return !!(candidate && candidate.stopPropagation && candidate.preventDefault);\n};\n\n/* harmony default export */ var events_isEvent = (isEvent);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/events/silenceEvent.js\n\n\nvar silenceEvent_silenceEvent = function silenceEvent(event) {\n  var is = events_isEvent(event);\n\n  if (is) {\n    event.preventDefault();\n  }\n\n  return is;\n};\n\n/* harmony default export */ var events_silenceEvent = (silenceEvent_silenceEvent);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/events/silenceEvents.js\n\n\nvar silenceEvents_silenceEvents = function silenceEvents(fn) {\n  return function (event) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    return events_silenceEvent(event) ? fn.apply(void 0, args) : fn.apply(void 0, [event].concat(args));\n  };\n};\n\n/* harmony default export */ var events_silenceEvents = (silenceEvents_silenceEvents);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/generateValidator.js\n\n\nvar toArray = function toArray(value) {\n  return Array.isArray(value) ? value : [value];\n};\n\nvar getError = function getError(value, values, props, validators, name) {\n  var array = toArray(validators);\n\n  for (var i = 0; i < array.length; i++) {\n    var error = array[i](value, values, props, name);\n\n    if (error) {\n      return error;\n    }\n  }\n};\n\nvar generateValidator_generateValidator = function generateValidator(validators, _ref) {\n  var getIn = _ref.getIn;\n  return function (values, props) {\n    var errors = {};\n    Object.keys(validators).forEach(function (name) {\n      var value = getIn(values, name);\n      var error = getError(value, values, props, validators[name], name);\n\n      if (error) {\n        errors = plain.setIn(errors, name, error);\n      }\n    });\n    return errors;\n  };\n};\n\n/* harmony default export */ var es_generateValidator = (generateValidator_generateValidator);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/es6-error/es6/index.js\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _extendableBuiltin(cls) {\n  function ExtendableBuiltin() {\n    cls.apply(this, arguments);\n  }\n\n  ExtendableBuiltin.prototype = Object.create(cls.prototype, {\n    constructor: {\n      value: cls,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n\n  if (Object.setPrototypeOf) {\n    Object.setPrototypeOf(ExtendableBuiltin, cls);\n  } else {\n    ExtendableBuiltin.__proto__ = cls;\n  }\n\n  return ExtendableBuiltin;\n}\n\nvar ExtendableError = function (_extendableBuiltin2) {\n  _inherits(ExtendableError, _extendableBuiltin2);\n\n  function ExtendableError() {\n    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \'\';\n\n    _classCallCheck(this, ExtendableError);\n\n    // extending Error is weird and does not propagate `message`\n    var _this = _possibleConstructorReturn(this, (ExtendableError.__proto__ || Object.getPrototypeOf(ExtendableError)).call(this, message));\n\n    Object.defineProperty(_this, \'message\', {\n      configurable: true,\n      enumerable: false,\n      value: message,\n      writable: true\n    });\n\n    Object.defineProperty(_this, \'name\', {\n      configurable: true,\n      enumerable: false,\n      value: _this.constructor.name,\n      writable: true\n    });\n\n    if (Error.hasOwnProperty(\'captureStackTrace\')) {\n      Error.captureStackTrace(_this, _this.constructor);\n      return _possibleConstructorReturn(_this);\n    }\n\n    Object.defineProperty(_this, \'stack\', {\n      configurable: true,\n      enumerable: false,\n      value: new Error(message).stack,\n      writable: true\n    });\n    return _this;\n  }\n\n  return ExtendableError;\n}(_extendableBuiltin(Error));\n\n/* harmony default export */ var es6 = (ExtendableError);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/SubmissionError.js\n\n\n\nvar SubmissionError_SubmissionError =\n/*#__PURE__*/\nfunction (_ExtendableError) {\n  inheritsLoose_default()(SubmissionError, _ExtendableError);\n\n  function SubmissionError(errors) {\n    var _this;\n\n    _this = _ExtendableError.call(this, \'Submit Validation Failed\') || this;\n    _this.errors = errors;\n    return _this;\n  }\n\n  return SubmissionError;\n}(es6);\n\n/* harmony default export */ var es_SubmissionError = (SubmissionError_SubmissionError);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/handleSubmit.js\n\n\n\n\nvar handleSubmit_isSubmissionError = function isSubmissionError(error) {\n  return error && error.name === es_SubmissionError.name;\n};\n\nvar handleSubmit_mergeErrors = function mergeErrors(_ref) {\n  var asyncErrors = _ref.asyncErrors,\n      syncErrors = _ref.syncErrors;\n  return asyncErrors && typeof asyncErrors.merge === \'function\' ? asyncErrors.merge(syncErrors).toJS() : extends_default()({}, asyncErrors, syncErrors);\n};\n\nvar handleSubmit_handleSubmit = function handleSubmit(submit, props, valid, asyncValidate, fields) {\n  var dispatch = props.dispatch,\n      onSubmitFail = props.onSubmitFail,\n      onSubmitSuccess = props.onSubmitSuccess,\n      startSubmit = props.startSubmit,\n      stopSubmit = props.stopSubmit,\n      setSubmitFailed = props.setSubmitFailed,\n      setSubmitSucceeded = props.setSubmitSucceeded,\n      syncErrors = props.syncErrors,\n      asyncErrors = props.asyncErrors,\n      touch = props.touch,\n      values = props.values,\n      persistentSubmitErrors = props.persistentSubmitErrors;\n  touch.apply(void 0, Array.from(fields)); // mark all fields as touched\n\n  if (valid || persistentSubmitErrors) {\n    var doSubmit = function doSubmit() {\n      var result;\n\n      try {\n        result = submit(values, dispatch, props);\n      } catch (submitError) {\n        var error = handleSubmit_isSubmissionError(submitError) ? submitError.errors : undefined;\n        stopSubmit(error);\n        setSubmitFailed.apply(void 0, fields);\n\n        if (onSubmitFail) {\n          onSubmitFail(error, dispatch, submitError, props);\n        }\n\n        if (error || onSubmitFail) {\n          // if you\'ve provided an onSubmitFail callback, don\'t re-throw the error\n          return error;\n        } else {\n          throw submitError;\n        }\n      }\n\n      if (is_promise_default()(result)) {\n        startSubmit();\n        return result.then(function (submitResult) {\n          stopSubmit();\n          setSubmitSucceeded();\n\n          if (onSubmitSuccess) {\n            onSubmitSuccess(submitResult, dispatch, props);\n          }\n\n          return submitResult;\n        }, function (submitError) {\n          var error = handleSubmit_isSubmissionError(submitError) ? submitError.errors : undefined;\n          stopSubmit(error);\n          setSubmitFailed.apply(void 0, fields);\n\n          if (onSubmitFail) {\n            onSubmitFail(error, dispatch, submitError, props);\n          }\n\n          if (error || onSubmitFail) {\n            // if you\'ve provided an onSubmitFail callback, don\'t re-throw the error\n            return error;\n          } else {\n            throw submitError;\n          }\n        });\n      } else {\n        setSubmitSucceeded();\n\n        if (onSubmitSuccess) {\n          onSubmitSuccess(result, dispatch, props);\n        }\n      }\n\n      return result;\n    };\n\n    var asyncValidateResult = asyncValidate && asyncValidate();\n\n    if (asyncValidateResult) {\n      return asyncValidateResult.then(function (asyncErrors) {\n        if (asyncErrors) {\n          throw asyncErrors;\n        }\n\n        return doSubmit();\n      }).catch(function (asyncErrors) {\n        setSubmitFailed.apply(void 0, fields);\n\n        if (onSubmitFail) {\n          onSubmitFail(asyncErrors, dispatch, null, props);\n        }\n\n        return Promise.reject(asyncErrors);\n      });\n    } else {\n      return doSubmit();\n    }\n  } else {\n    setSubmitFailed.apply(void 0, fields);\n    var errors = handleSubmit_mergeErrors({\n      asyncErrors: asyncErrors,\n      syncErrors: syncErrors\n    });\n\n    if (onSubmitFail) {\n      onSubmitFail(errors, dispatch, null, props);\n    }\n\n    return errors;\n  }\n};\n\n/* harmony default export */ var es_handleSubmit = (handleSubmit_handleSubmit);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/hasError.js\nvar getErrorKeys = function getErrorKeys(name, type) {\n  switch (type) {\n    case \'Field\':\n      return [name, name + "._error"];\n\n    case \'FieldArray\':\n      return [name + "._error"];\n\n    default:\n      throw new Error(\'Unknown field type\');\n  }\n};\n\nvar createHasError = function createHasError(_ref) {\n  var getIn = _ref.getIn;\n\n  var hasError = function hasError(field, syncErrors, asyncErrors, submitErrors) {\n    if (!syncErrors && !asyncErrors && !submitErrors) {\n      return false;\n    }\n\n    var name = getIn(field, \'name\');\n    var type = getIn(field, \'type\');\n    return getErrorKeys(name, type).some(function (key) {\n      return getIn(syncErrors, key) || getIn(asyncErrors, key) || getIn(submitErrors, key);\n    });\n  };\n\n  return hasError;\n};\n\n/* harmony default export */ var es_hasError = (createHasError);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/selectors/isValid.js\n\n\nvar isValid_createIsValid = function createIsValid(structure) {\n  var getIn = structure.getIn,\n      keys = structure.keys;\n  var hasError = es_hasError(structure);\n  return function (form, getFormState, ignoreSubmitErrors) {\n    if (ignoreSubmitErrors === void 0) {\n      ignoreSubmitErrors = false;\n    }\n\n    return function (state) {\n      var nonNullGetFormState = getFormState || function (state) {\n        return getIn(state, \'form\');\n      };\n\n      var formState = nonNullGetFormState(state);\n      var syncError = getIn(formState, form + ".syncError");\n\n      if (syncError) {\n        return false;\n      }\n\n      if (!ignoreSubmitErrors) {\n        var error = getIn(formState, form + ".error");\n\n        if (error) {\n          return false;\n        }\n      }\n\n      var syncErrors = getIn(formState, form + ".syncErrors");\n      var asyncErrors = getIn(formState, form + ".asyncErrors");\n      var submitErrors = ignoreSubmitErrors ? undefined : getIn(formState, form + ".submitErrors");\n\n      if (!syncErrors && !asyncErrors && !submitErrors) {\n        return true;\n      }\n\n      var registeredFields = getIn(formState, form + ".registeredFields");\n\n      if (!registeredFields) {\n        return true;\n      }\n\n      return !keys(registeredFields).filter(function (name) {\n        return getIn(registeredFields, "[\'" + name + "\'].count") > 0;\n      }).some(function (name) {\n        return hasError(getIn(registeredFields, "[\'" + name + "\']"), syncErrors, asyncErrors, submitErrors);\n      });\n    };\n  };\n};\n\n/* harmony default export */ var selectors_isValid = (isValid_createIsValid);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/util/getDisplayName.js\nvar getDisplayName_getDisplayName = function getDisplayName(Comp) {\n  return Comp.displayName || Comp.name || \'Component\';\n};\n\n/* harmony default export */ var util_getDisplayName = (getDisplayName_getDisplayName);\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/util/isHotReloading.js\nvar isHotReloading = __webpack_require__(61);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/ReduxFormContext.js\n\n\n\n\nvar ReduxFormContext = react["createContext"](null);\nvar ReduxFormContext_withReduxForm = function withReduxForm(Component) {\n  var Hoc =\n  /*#__PURE__*/\n  function (_React$Component) {\n    inheritsLoose_default()(Hoc, _React$Component);\n\n    function Hoc() {\n      return _React$Component.apply(this, arguments) || this;\n    }\n\n    var _proto = Hoc.prototype;\n\n    _proto.render = function render() {\n      var _this$props = this.props,\n          forwardedRef = _this$props.forwardedRef,\n          rest = objectWithoutPropertiesLoose_default()(_this$props, ["forwardedRef"]);\n\n      return react["createElement"](ReduxFormContext.Consumer, {\n        children: function children(_reduxForm) {\n          return react["createElement"](Component, extends_default()({\n            _reduxForm: _reduxForm,\n            ref: forwardedRef\n          }, rest));\n        }\n      });\n    };\n\n    return Hoc;\n  }(react["Component"]);\n\n  var ref = react["forwardRef"](function (props, ref) {\n    return react["createElement"](Hoc, extends_default()({}, props, {\n      forwardedRef: ref\n    }));\n  });\n  ref.displayName = Component.displayName || Component.name || \'Component\';\n  return ref;\n};\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/createReduxForm.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar isClassComponent = function isClassComponent(Component) {\n  return Boolean(Component && Component.prototype && typeof Component.prototype.isReactComponent === \'object\');\n}; // extract field-specific actions\n\n\nvar createReduxForm_arrayInsert = es_actions.arrayInsert,\n    createReduxForm_arrayMove = es_actions.arrayMove,\n    createReduxForm_arrayPop = es_actions.arrayPop,\n    createReduxForm_arrayPush = es_actions.arrayPush,\n    createReduxForm_arrayRemove = es_actions.arrayRemove,\n    createReduxForm_arrayRemoveAll = es_actions.arrayRemoveAll,\n    createReduxForm_arrayShift = es_actions.arrayShift,\n    createReduxForm_arraySplice = es_actions.arraySplice,\n    createReduxForm_arraySwap = es_actions.arraySwap,\n    createReduxForm_arrayUnshift = es_actions.arrayUnshift,\n    createReduxForm_blur = es_actions.blur,\n    createReduxForm_change = es_actions.change,\n    createReduxForm_focus = es_actions.focus,\n    formActions = objectWithoutPropertiesLoose_default()(es_actions, ["arrayInsert", "arrayMove", "arrayPop", "arrayPush", "arrayRemove", "arrayRemoveAll", "arrayShift", "arraySplice", "arraySwap", "arrayUnshift", "blur", "change", "focus"]);\n\nvar arrayActions = {\n  arrayInsert: createReduxForm_arrayInsert,\n  arrayMove: createReduxForm_arrayMove,\n  arrayPop: createReduxForm_arrayPop,\n  arrayPush: createReduxForm_arrayPush,\n  arrayRemove: createReduxForm_arrayRemove,\n  arrayRemoveAll: createReduxForm_arrayRemoveAll,\n  arrayShift: createReduxForm_arrayShift,\n  arraySplice: createReduxForm_arraySplice,\n  arraySwap: createReduxForm_arraySwap,\n  arrayUnshift: createReduxForm_arrayUnshift\n};\nvar propsToNotUpdateFor = [].concat(Object.keys(es_actions), [\'array\', \'asyncErrors\', \'initialValues\', \'syncErrors\', \'syncWarnings\', \'values\', \'registeredFields\']);\n\nvar checkSubmit = function checkSubmit(submit) {\n  if (!submit || typeof submit !== \'function\') {\n    throw new Error(\'You must either pass handleSubmit() an onSubmit function or pass onSubmit as a prop\');\n  }\n\n  return submit;\n};\n\n/**\n * The decorator that is the main API to redux-form\n */\nvar createReduxForm_createReduxForm = function createReduxForm(structure) {\n  var deepEqual = structure.deepEqual,\n      empty = structure.empty,\n      getIn = structure.getIn,\n      setIn = structure.setIn,\n      keys = structure.keys,\n      fromJS = structure.fromJS;\n  var isValid = selectors_isValid(structure);\n  return function (initialConfig) {\n    var config = extends_default()({\n      touchOnBlur: true,\n      touchOnChange: false,\n      persistentSubmitErrors: false,\n      destroyOnUnmount: true,\n      shouldAsyncValidate: es_defaultShouldAsyncValidate,\n      shouldValidate: es_defaultShouldValidate,\n      shouldError: es_defaultShouldError,\n      shouldWarn: es_defaultShouldWarn,\n      enableReinitialize: false,\n      keepDirtyOnReinitialize: false,\n      updateUnregisteredFields: false,\n      getFormState: function getFormState(state) {\n        return getIn(state, \'form\');\n      },\n      pure: true,\n      forceUnregisterOnUnmount: false\n    }, initialConfig);\n\n    return function (WrappedComponent) {\n      var Form =\n      /*#__PURE__*/\n      function (_React$Component) {\n        inheritsLoose_default()(Form, _React$Component);\n\n        function Form() {\n          var _this;\n\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n          _this.wrapped = react_default.a.createRef();\n          _this.destroyed = false;\n          _this.fieldCounts = {};\n          _this.fieldValidators = {};\n          _this.lastFieldValidatorKeys = [];\n          _this.fieldWarners = {};\n          _this.lastFieldWarnerKeys = [];\n          _this.innerOnSubmit = undefined;\n          _this.submitPromise = undefined;\n\n          _this.getValues = function () {\n            return _this.props.values;\n          };\n\n          _this.isValid = function () {\n            return _this.props.valid;\n          };\n\n          _this.isPristine = function () {\n            return _this.props.pristine;\n          };\n\n          _this.register = function (name, type, getValidator, getWarner) {\n            var lastCount = _this.fieldCounts[name];\n            var nextCount = (lastCount || 0) + 1;\n            _this.fieldCounts[name] = nextCount;\n\n            _this.props.registerField(name, type);\n\n            if (getValidator) {\n              _this.fieldValidators[name] = getValidator;\n            }\n\n            if (getWarner) {\n              _this.fieldWarners[name] = getWarner;\n            }\n          };\n\n          _this.unregister = function (name) {\n            var lastCount = _this.fieldCounts[name];\n            if (lastCount === 1) delete _this.fieldCounts[name];else if (lastCount != null) _this.fieldCounts[name] = lastCount - 1;\n\n            if (!_this.destroyed) {\n              var _this$props = _this.props,\n                  _destroyOnUnmount = _this$props.destroyOnUnmount,\n                  forceUnregisterOnUnmount = _this$props.forceUnregisterOnUnmount,\n                  unregisterField = _this$props.unregisterField;\n\n              if (_destroyOnUnmount || forceUnregisterOnUnmount) {\n                unregisterField(name, _destroyOnUnmount);\n\n                if (!_this.fieldCounts[name]) {\n                  delete _this.fieldValidators[name];\n                  delete _this.fieldWarners[name];\n                  _this.lastFieldValidatorKeys = _this.lastFieldValidatorKeys.filter(function (key) {\n                    return key !== name;\n                  });\n                }\n              } else {\n                unregisterField(name, false);\n              }\n            }\n          };\n\n          _this.getFieldList = function (options) {\n            var registeredFields = _this.props.registeredFields;\n            var list = [];\n\n            if (!registeredFields) {\n              return list;\n            }\n\n            var keySeq = keys(registeredFields);\n\n            if (options && options.excludeFieldArray) {\n              keySeq = keySeq.filter(function (name) {\n                return getIn(registeredFields, "[\'" + name + "\'].type") !== \'FieldArray\';\n              });\n            }\n\n            return fromJS(keySeq.reduce(function (acc, key) {\n              acc.push(key);\n              return acc;\n            }, list));\n          };\n\n          _this.getValidators = function () {\n            var validators = {};\n            Object.keys(_this.fieldValidators).forEach(function (name) {\n              var validator = _this.fieldValidators[name]();\n\n              if (validator) {\n                validators[name] = validator;\n              }\n            });\n            return validators;\n          };\n\n          _this.generateValidator = function () {\n            var validators = _this.getValidators();\n\n            return Object.keys(validators).length ? es_generateValidator(validators, structure) : undefined;\n          };\n\n          _this.getWarners = function () {\n            var warners = {};\n            Object.keys(_this.fieldWarners).forEach(function (name) {\n              var warner = _this.fieldWarners[name]();\n\n              if (warner) {\n                warners[name] = warner;\n              }\n            });\n            return warners;\n          };\n\n          _this.generateWarner = function () {\n            var warners = _this.getWarners();\n\n            return Object.keys(warners).length ? es_generateValidator(warners, structure) : undefined;\n          };\n\n          _this.asyncValidate = function (name, value, trigger) {\n            var _this$props2 = _this.props,\n                asyncBlurFields = _this$props2.asyncBlurFields,\n                asyncChangeFields = _this$props2.asyncChangeFields,\n                asyncErrors = _this$props2.asyncErrors,\n                asyncValidate = _this$props2.asyncValidate,\n                dispatch = _this$props2.dispatch,\n                initialized = _this$props2.initialized,\n                pristine = _this$props2.pristine,\n                shouldAsyncValidate = _this$props2.shouldAsyncValidate,\n                startAsyncValidation = _this$props2.startAsyncValidation,\n                stopAsyncValidation = _this$props2.stopAsyncValidation,\n                syncErrors = _this$props2.syncErrors,\n                values = _this$props2.values;\n            var submitting = !name;\n\n            var fieldNeedsValidation = function fieldNeedsValidation() {\n              var fieldNeedsValidationForBlur = asyncBlurFields && name && ~asyncBlurFields.indexOf(name.replace(/\\[[0-9]+\\]/g, \'[]\'));\n              var fieldNeedsValidationForChange = asyncChangeFields && name && ~asyncChangeFields.indexOf(name.replace(/\\[[0-9]+\\]/g, \'[]\'));\n              var asyncValidateByDefault = !(asyncBlurFields || asyncChangeFields);\n              return submitting || asyncValidateByDefault || (trigger === \'blur\' ? fieldNeedsValidationForBlur : fieldNeedsValidationForChange);\n            };\n\n            if (asyncValidate) {\n              var valuesToValidate = submitting ? values : setIn(values, name, value);\n              var syncValidationPasses = submitting || !getIn(syncErrors, name);\n\n              if (fieldNeedsValidation() && shouldAsyncValidate({\n                asyncErrors: asyncErrors,\n                initialized: initialized,\n                trigger: submitting ? \'submit\' : trigger,\n                blurredField: name,\n                pristine: pristine,\n                syncValidationPasses: syncValidationPasses\n              })) {\n                return es_asyncValidation(function () {\n                  return asyncValidate(valuesToValidate, dispatch, _this.props, name);\n                }, startAsyncValidation, stopAsyncValidation, name);\n              }\n            }\n          };\n\n          _this.submitCompleted = function (result) {\n            delete _this.submitPromise;\n            return result;\n          };\n\n          _this.submitFailed = function (error) {\n            delete _this.submitPromise;\n            throw error;\n          };\n\n          _this.listenToSubmit = function (promise) {\n            if (!is_promise_default()(promise)) {\n              return promise;\n            }\n\n            _this.submitPromise = promise;\n            return promise.then(_this.submitCompleted, _this.submitFailed);\n          };\n\n          _this.submit = function (submitOrEvent) {\n            var _this$props3 = _this.props,\n                onSubmit = _this$props3.onSubmit,\n                blur = _this$props3.blur,\n                change = _this$props3.change,\n                dispatch = _this$props3.dispatch;\n\n            if (!submitOrEvent || events_silenceEvent(submitOrEvent)) {\n              // submitOrEvent is an event: fire submit if not already submitting\n              if (!_this.submitPromise) {\n                // avoid recursive stack trace if use Form with onSubmit as handleSubmit\n                if (_this.innerOnSubmit && _this.innerOnSubmit !== _this.submit) {\n                  // will call "submitOrEvent is the submit function" block below\n                  return _this.innerOnSubmit();\n                } else {\n                  return _this.listenToSubmit(es_handleSubmit(checkSubmit(onSubmit), extends_default()({}, _this.props, bindActionCreators({\n                    blur: blur,\n                    change: change\n                  }, dispatch)), _this.props.validExceptSubmit, _this.asyncValidate, _this.getFieldList({\n                    excludeFieldArray: true\n                  })));\n                }\n              }\n            } else {\n              // submitOrEvent is the submit function: return deferred submit thunk\n              return events_silenceEvents(function () {\n                return !_this.submitPromise && _this.listenToSubmit(es_handleSubmit(checkSubmit(submitOrEvent), extends_default()({}, _this.props, bindActionCreators({\n                  blur: blur,\n                  change: change\n                }, dispatch)), _this.props.validExceptSubmit, _this.asyncValidate, _this.getFieldList({\n                  excludeFieldArray: true\n                })));\n              });\n            }\n          };\n\n          _this.reset = function () {\n            return _this.props.reset();\n          };\n\n          return _this;\n        }\n\n        var _proto = Form.prototype;\n\n        _proto.initIfNeeded = function initIfNeeded(nextProps) {\n          var enableReinitialize = this.props.enableReinitialize;\n\n          if (nextProps) {\n            if ((enableReinitialize || !nextProps.initialized) && !deepEqual(this.props.initialValues, nextProps.initialValues)) {\n              var _keepDirty = nextProps.initialized && this.props.keepDirtyOnReinitialize;\n\n              this.props.initialize(nextProps.initialValues, _keepDirty, {\n                keepValues: nextProps.keepValues,\n                lastInitialValues: this.props.initialValues,\n                updateUnregisteredFields: nextProps.updateUnregisteredFields\n              });\n            }\n          } else if (this.props.initialValues && (!this.props.initialized || enableReinitialize)) {\n            this.props.initialize(this.props.initialValues, this.props.keepDirtyOnReinitialize, {\n              keepValues: this.props.keepValues,\n              updateUnregisteredFields: this.props.updateUnregisteredFields\n            });\n          }\n        };\n\n        _proto.updateSyncErrorsIfNeeded = function updateSyncErrorsIfNeeded(nextSyncErrors, nextError, lastSyncErrors) {\n          var _this$props4 = this.props,\n              error = _this$props4.error,\n              updateSyncErrors = _this$props4.updateSyncErrors;\n          var noErrors = (!lastSyncErrors || !Object.keys(lastSyncErrors).length) && !error;\n          var nextNoErrors = (!nextSyncErrors || !Object.keys(nextSyncErrors).length) && !nextError;\n\n          if (!(noErrors && nextNoErrors) && (!plain.deepEqual(lastSyncErrors, nextSyncErrors) || !plain.deepEqual(error, nextError))) {\n            updateSyncErrors(nextSyncErrors, nextError);\n          }\n        };\n\n        _proto.clearSubmitPromiseIfNeeded = function clearSubmitPromiseIfNeeded(nextProps) {\n          var submitting = this.props.submitting;\n\n          if (this.submitPromise && submitting && !nextProps.submitting) {\n            delete this.submitPromise;\n          }\n        };\n\n        _proto.submitIfNeeded = function submitIfNeeded(nextProps) {\n          var _this$props5 = this.props,\n              clearSubmit = _this$props5.clearSubmit,\n              triggerSubmit = _this$props5.triggerSubmit;\n\n          if (!triggerSubmit && nextProps.triggerSubmit) {\n            clearSubmit();\n            this.submit();\n          }\n        };\n\n        _proto.shouldErrorFunction = function shouldErrorFunction() {\n          var _this$props6 = this.props,\n              shouldValidate = _this$props6.shouldValidate,\n              shouldError = _this$props6.shouldError;\n          var shouldValidateOverridden = shouldValidate !== es_defaultShouldValidate;\n          var shouldErrorOverridden = shouldError !== es_defaultShouldError;\n          return shouldValidateOverridden && !shouldErrorOverridden ? shouldValidate : shouldError;\n        };\n\n        _proto.validateIfNeeded = function validateIfNeeded(nextProps) {\n          var _this$props7 = this.props,\n              validate = _this$props7.validate,\n              values = _this$props7.values;\n          var shouldError = this.shouldErrorFunction();\n          var fieldLevelValidate = this.generateValidator();\n\n          if (validate || fieldLevelValidate) {\n            var initialRender = nextProps === undefined;\n            var fieldValidatorKeys = Object.keys(this.getValidators());\n            var validateParams = {\n              values: values,\n              nextProps: nextProps,\n              props: this.props,\n              initialRender: initialRender,\n              lastFieldValidatorKeys: this.lastFieldValidatorKeys,\n              fieldValidatorKeys: fieldValidatorKeys,\n              structure: structure\n            };\n\n            if (shouldError(validateParams)) {\n              var propsToValidate = initialRender || !nextProps ? this.props : nextProps;\n\n              var _merge2 = merge_default()(validate ? validate(propsToValidate.values, propsToValidate) || {} : {}, fieldLevelValidate ? fieldLevelValidate(propsToValidate.values, propsToValidate) || {} : {}),\n                  _error = _merge2._error,\n                  nextSyncErrors = objectWithoutPropertiesLoose_default()(_merge2, ["_error"]);\n\n              this.lastFieldValidatorKeys = fieldValidatorKeys;\n              this.updateSyncErrorsIfNeeded(nextSyncErrors, _error, propsToValidate.syncErrors);\n            }\n          } else {\n            this.lastFieldValidatorKeys = [];\n          }\n        };\n\n        _proto.updateSyncWarningsIfNeeded = function updateSyncWarningsIfNeeded(nextSyncWarnings, nextWarning, lastSyncWarnings) {\n          var _this$props8 = this.props,\n              warning = _this$props8.warning,\n              syncWarnings = _this$props8.syncWarnings,\n              updateSyncWarnings = _this$props8.updateSyncWarnings;\n          var noWarnings = (!syncWarnings || !Object.keys(syncWarnings).length) && !warning;\n          var nextNoWarnings = (!nextSyncWarnings || !Object.keys(nextSyncWarnings).length) && !nextWarning;\n\n          if (!(noWarnings && nextNoWarnings) && (!plain.deepEqual(lastSyncWarnings, nextSyncWarnings) || !plain.deepEqual(warning, nextWarning))) {\n            updateSyncWarnings(nextSyncWarnings, nextWarning);\n          }\n        };\n\n        _proto.shouldWarnFunction = function shouldWarnFunction() {\n          var _this$props9 = this.props,\n              shouldValidate = _this$props9.shouldValidate,\n              shouldWarn = _this$props9.shouldWarn;\n          var shouldValidateOverridden = shouldValidate !== es_defaultShouldValidate;\n          var shouldWarnOverridden = shouldWarn !== es_defaultShouldWarn;\n          return shouldValidateOverridden && !shouldWarnOverridden ? shouldValidate : shouldWarn;\n        };\n\n        _proto.warnIfNeeded = function warnIfNeeded(nextProps) {\n          var _this$props10 = this.props,\n              warn = _this$props10.warn,\n              values = _this$props10.values;\n          var shouldWarn = this.shouldWarnFunction();\n          var fieldLevelWarn = this.generateWarner();\n\n          if (warn || fieldLevelWarn) {\n            var initialRender = nextProps === undefined;\n            var fieldWarnerKeys = Object.keys(this.getWarners());\n            var validateParams = {\n              values: values,\n              nextProps: nextProps,\n              props: this.props,\n              initialRender: initialRender,\n              lastFieldValidatorKeys: this.lastFieldWarnerKeys,\n              fieldValidatorKeys: fieldWarnerKeys,\n              structure: structure\n            };\n\n            if (shouldWarn(validateParams)) {\n              var propsToWarn = initialRender || !nextProps ? this.props : nextProps;\n\n              var _merge3 = merge_default()(warn ? warn(propsToWarn.values, propsToWarn) : {}, fieldLevelWarn ? fieldLevelWarn(propsToWarn.values, propsToWarn) : {}),\n                  _warning = _merge3._warning,\n                  nextSyncWarnings = objectWithoutPropertiesLoose_default()(_merge3, ["_warning"]);\n\n              this.lastFieldWarnerKeys = fieldWarnerKeys;\n              this.updateSyncWarningsIfNeeded(nextSyncWarnings, _warning, propsToWarn.syncWarnings);\n            }\n          }\n        };\n\n        _proto.componentWillMount = function componentWillMount() {\n          if (!Object(isHotReloading["a" /* default */])()) {\n            this.initIfNeeded();\n            this.validateIfNeeded();\n            this.warnIfNeeded();\n          }\n\n          browser_default()(this.props.shouldValidate, \'shouldValidate() is deprecated and will be removed in v9.0.0. Use shouldWarn() or shouldError() instead.\');\n        };\n\n        _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n          this.initIfNeeded(nextProps);\n          this.validateIfNeeded(nextProps);\n          this.warnIfNeeded(nextProps);\n          this.clearSubmitPromiseIfNeeded(nextProps);\n          this.submitIfNeeded(nextProps);\n          var onChange = nextProps.onChange,\n              values = nextProps.values,\n              dispatch = nextProps.dispatch;\n\n          if (onChange && !deepEqual(values, this.props.values)) {\n            onChange(values, dispatch, nextProps, this.props.values);\n          }\n        };\n\n        _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {\n          var _this2 = this;\n\n          if (!this.props.pure) return true;\n          var _config$immutableProp = config.immutableProps,\n              immutableProps = _config$immutableProp === void 0 ? [] : _config$immutableProp; // if we have children, we MUST update in React 16\n          // https://twitter.com/erikras/status/915866544558788608\n\n          return !!(this.props.children || nextProps.children || Object.keys(nextProps).some(function (prop) {\n            // useful to debug rerenders\n            // if (!plain.deepEqual(this.props[ prop ], nextProps[ prop ])) {\n            //   console.info(prop, \'changed\', this.props[ prop ], \'==>\', nextProps[ prop ])\n            // }\n            if (~immutableProps.indexOf(prop)) {\n              return _this2.props[prop] !== nextProps[prop];\n            }\n\n            return !~propsToNotUpdateFor.indexOf(prop) && !deepEqual(_this2.props[prop], nextProps[prop]);\n          }));\n        };\n\n        _proto.componentDidMount = function componentDidMount() {\n          if (!Object(isHotReloading["a" /* default */])()) {\n            this.initIfNeeded(this.props);\n            this.validateIfNeeded();\n            this.warnIfNeeded();\n          }\n\n          browser_default()(this.props.shouldValidate, \'shouldValidate() is deprecated and will be removed in v9.0.0. Use shouldWarn() or shouldError() instead.\');\n        };\n\n        _proto.componentWillUnmount = function componentWillUnmount() {\n          var _this$props11 = this.props,\n              destroyOnUnmount = _this$props11.destroyOnUnmount,\n              destroy = _this$props11.destroy;\n\n          if (destroyOnUnmount && !Object(isHotReloading["a" /* default */])()) {\n            this.destroyed = true;\n            destroy();\n          }\n        };\n\n        _proto.render = function render() {\n          var _ref,\n              _this3 = this;\n\n          // remove some redux-form config-only props\n\n          /* eslint-disable no-unused-vars */\n          var _this$props12 = this.props,\n              anyTouched = _this$props12.anyTouched,\n              array = _this$props12.array,\n              arrayInsert = _this$props12.arrayInsert,\n              arrayMove = _this$props12.arrayMove,\n              arrayPop = _this$props12.arrayPop,\n              arrayPush = _this$props12.arrayPush,\n              arrayRemove = _this$props12.arrayRemove,\n              arrayRemoveAll = _this$props12.arrayRemoveAll,\n              arrayShift = _this$props12.arrayShift,\n              arraySplice = _this$props12.arraySplice,\n              arraySwap = _this$props12.arraySwap,\n              arrayUnshift = _this$props12.arrayUnshift,\n              asyncErrors = _this$props12.asyncErrors,\n              asyncValidate = _this$props12.asyncValidate,\n              asyncValidating = _this$props12.asyncValidating,\n              blur = _this$props12.blur,\n              change = _this$props12.change,\n              clearSubmit = _this$props12.clearSubmit,\n              destroy = _this$props12.destroy,\n              destroyOnUnmount = _this$props12.destroyOnUnmount,\n              forceUnregisterOnUnmount = _this$props12.forceUnregisterOnUnmount,\n              dirty = _this$props12.dirty,\n              dispatch = _this$props12.dispatch,\n              enableReinitialize = _this$props12.enableReinitialize,\n              error = _this$props12.error,\n              focus = _this$props12.focus,\n              form = _this$props12.form,\n              getFormState = _this$props12.getFormState,\n              immutableProps = _this$props12.immutableProps,\n              initialize = _this$props12.initialize,\n              initialized = _this$props12.initialized,\n              initialValues = _this$props12.initialValues,\n              invalid = _this$props12.invalid,\n              keepDirtyOnReinitialize = _this$props12.keepDirtyOnReinitialize,\n              keepValues = _this$props12.keepValues,\n              updateUnregisteredFields = _this$props12.updateUnregisteredFields,\n              pristine = _this$props12.pristine,\n              propNamespace = _this$props12.propNamespace,\n              registeredFields = _this$props12.registeredFields,\n              registerField = _this$props12.registerField,\n              reset = _this$props12.reset,\n              resetSection = _this$props12.resetSection,\n              setSubmitFailed = _this$props12.setSubmitFailed,\n              setSubmitSucceeded = _this$props12.setSubmitSucceeded,\n              shouldAsyncValidate = _this$props12.shouldAsyncValidate,\n              shouldValidate = _this$props12.shouldValidate,\n              shouldError = _this$props12.shouldError,\n              shouldWarn = _this$props12.shouldWarn,\n              startAsyncValidation = _this$props12.startAsyncValidation,\n              startSubmit = _this$props12.startSubmit,\n              stopAsyncValidation = _this$props12.stopAsyncValidation,\n              stopSubmit = _this$props12.stopSubmit,\n              submitting = _this$props12.submitting,\n              submitFailed = _this$props12.submitFailed,\n              submitSucceeded = _this$props12.submitSucceeded,\n              touch = _this$props12.touch,\n              touchOnBlur = _this$props12.touchOnBlur,\n              touchOnChange = _this$props12.touchOnChange,\n              persistentSubmitErrors = _this$props12.persistentSubmitErrors,\n              syncErrors = _this$props12.syncErrors,\n              syncWarnings = _this$props12.syncWarnings,\n              unregisterField = _this$props12.unregisterField,\n              untouch = _this$props12.untouch,\n              updateSyncErrors = _this$props12.updateSyncErrors,\n              updateSyncWarnings = _this$props12.updateSyncWarnings,\n              valid = _this$props12.valid,\n              validExceptSubmit = _this$props12.validExceptSubmit,\n              values = _this$props12.values,\n              warning = _this$props12.warning,\n              rest = objectWithoutPropertiesLoose_default()(_this$props12, ["anyTouched", "array", "arrayInsert", "arrayMove", "arrayPop", "arrayPush", "arrayRemove", "arrayRemoveAll", "arrayShift", "arraySplice", "arraySwap", "arrayUnshift", "asyncErrors", "asyncValidate", "asyncValidating", "blur", "change", "clearSubmit", "destroy", "destroyOnUnmount", "forceUnregisterOnUnmount", "dirty", "dispatch", "enableReinitialize", "error", "focus", "form", "getFormState", "immutableProps", "initialize", "initialized", "initialValues", "invalid", "keepDirtyOnReinitialize", "keepValues", "updateUnregisteredFields", "pristine", "propNamespace", "registeredFields", "registerField", "reset", "resetSection", "setSubmitFailed", "setSubmitSucceeded", "shouldAsyncValidate", "shouldValidate", "shouldError", "shouldWarn", "startAsyncValidation", "startSubmit", "stopAsyncValidation", "stopSubmit", "submitting", "submitFailed", "submitSucceeded", "touch", "touchOnBlur", "touchOnChange", "persistentSubmitErrors", "syncErrors", "syncWarnings", "unregisterField", "untouch", "updateSyncErrors", "updateSyncWarnings", "valid", "validExceptSubmit", "values", "warning"]);\n          /* eslint-enable no-unused-vars */\n\n\n          var reduxFormProps = extends_default()({\n            array: array,\n            anyTouched: anyTouched,\n            asyncValidate: this.asyncValidate,\n            asyncValidating: asyncValidating\n          }, bindActionCreators({\n            blur: blur,\n            change: change\n          }, dispatch), {\n            clearSubmit: clearSubmit,\n            destroy: destroy,\n            dirty: dirty,\n            dispatch: dispatch,\n            error: error,\n            form: form,\n            handleSubmit: this.submit,\n            initialize: initialize,\n            initialized: initialized,\n            initialValues: initialValues,\n            invalid: invalid,\n            pristine: pristine,\n            reset: reset,\n            resetSection: resetSection,\n            submitting: submitting,\n            submitFailed: submitFailed,\n            submitSucceeded: submitSucceeded,\n            touch: touch,\n            untouch: untouch,\n            valid: valid,\n            warning: warning\n          });\n\n          var propsToPass = extends_default()({}, propNamespace ? (_ref = {}, _ref[propNamespace] = reduxFormProps, _ref) : reduxFormProps, rest);\n\n          if (isClassComponent(WrappedComponent)) {\n            ;\n            propsToPass.ref = this.wrapped;\n          }\n\n          var _reduxForm = extends_default()({}, this.props, {\n            getFormState: function getFormState(state) {\n              return getIn(_this3.props.getFormState(state), _this3.props.form);\n            },\n            asyncValidate: this.asyncValidate,\n            getValues: this.getValues,\n            sectionPrefix: undefined,\n            register: this.register,\n            unregister: this.unregister,\n            registerInnerOnSubmit: function registerInnerOnSubmit(innerOnSubmit) {\n              return _this3.innerOnSubmit = innerOnSubmit;\n            }\n          });\n\n          return Object(react["createElement"])(ReduxFormContext.Provider, {\n            value: _reduxForm,\n            children: Object(react["createElement"])(WrappedComponent, propsToPass)\n          });\n        };\n\n        return Form;\n      }(react_default.a.Component);\n\n      Form.displayName = "Form(" + util_getDisplayName(WrappedComponent) + ")";\n      Form.WrappedComponent = WrappedComponent;\n      Form.propTypes = {\n        destroyOnUnmount: prop_types_default.a.bool,\n        forceUnregisterOnUnmount: prop_types_default.a.bool,\n        form: prop_types_default.a.string.isRequired,\n        immutableProps: prop_types_default.a.arrayOf(prop_types_default.a.string),\n        initialValues: prop_types_default.a.oneOfType([prop_types_default.a.array, prop_types_default.a.object]),\n        getFormState: prop_types_default.a.func,\n        onSubmitFail: prop_types_default.a.func,\n        onSubmitSuccess: prop_types_default.a.func,\n        propNamespace: prop_types_default.a.string,\n        validate: prop_types_default.a.func,\n        warn: prop_types_default.a.func,\n        touchOnBlur: prop_types_default.a.bool,\n        touchOnChange: prop_types_default.a.bool,\n        triggerSubmit: prop_types_default.a.bool,\n        persistentSubmitErrors: prop_types_default.a.bool,\n        registeredFields: prop_types_default.a.any\n      };\n      var connector = connect_connect(function (state, props) {\n        var form = props.form,\n            getFormState = props.getFormState,\n            initialValues = props.initialValues,\n            enableReinitialize = props.enableReinitialize,\n            keepDirtyOnReinitialize = props.keepDirtyOnReinitialize;\n        var formState = getIn(getFormState(state) || empty, form) || empty;\n        var stateInitial = getIn(formState, \'initial\');\n        var initialized = !!stateInitial;\n        var shouldUpdateInitialValues = enableReinitialize && initialized && !deepEqual(initialValues, stateInitial);\n        var shouldResetValues = shouldUpdateInitialValues && !keepDirtyOnReinitialize;\n        var initial = initialValues || stateInitial || empty;\n\n        if (!shouldUpdateInitialValues) {\n          initial = stateInitial || empty;\n        }\n\n        var values = getIn(formState, \'values\') || initial;\n\n        if (shouldResetValues) {\n          values = initial;\n        }\n\n        var pristine = shouldResetValues || deepEqual(initial, values);\n        var asyncErrors = getIn(formState, \'asyncErrors\');\n        var syncErrors = getIn(formState, \'syncErrors\') || plain.empty;\n        var syncWarnings = getIn(formState, \'syncWarnings\') || plain.empty;\n        var registeredFields = getIn(formState, \'registeredFields\');\n        var valid = isValid(form, getFormState, false)(state);\n        var validExceptSubmit = isValid(form, getFormState, true)(state);\n        var anyTouched = !!getIn(formState, \'anyTouched\');\n        var submitting = !!getIn(formState, \'submitting\');\n        var submitFailed = !!getIn(formState, \'submitFailed\');\n        var submitSucceeded = !!getIn(formState, \'submitSucceeded\');\n        var error = getIn(formState, \'error\');\n        var warning = getIn(formState, \'warning\');\n        var triggerSubmit = getIn(formState, \'triggerSubmit\');\n        return {\n          anyTouched: anyTouched,\n          asyncErrors: asyncErrors,\n          asyncValidating: getIn(formState, \'asyncValidating\') || false,\n          dirty: !pristine,\n          error: error,\n          initialized: initialized,\n          invalid: !valid,\n          pristine: pristine,\n          registeredFields: registeredFields,\n          submitting: submitting,\n          submitFailed: submitFailed,\n          submitSucceeded: submitSucceeded,\n          syncErrors: syncErrors,\n          syncWarnings: syncWarnings,\n          triggerSubmit: triggerSubmit,\n          values: values,\n          valid: valid,\n          validExceptSubmit: validExceptSubmit,\n          warning: warning\n        };\n      }, function (dispatch, initialProps) {\n        var bindForm = function bindForm(actionCreator) {\n          return actionCreator.bind(null, initialProps.form);\n        }; // Bind the first parameter on `props.form`\n\n\n        var boundFormACs = mapValues_default()(formActions, bindForm);\n\n        var boundArrayACs = mapValues_default()(arrayActions, bindForm);\n\n        var boundBlur = function boundBlur(field, value) {\n          return createReduxForm_blur(initialProps.form, field, value, !!initialProps.touchOnBlur);\n        };\n\n        var boundChange = function boundChange(field, value) {\n          return createReduxForm_change(initialProps.form, field, value, !!initialProps.touchOnChange, !!initialProps.persistentSubmitErrors);\n        };\n\n        var boundFocus = bindForm(createReduxForm_focus); // Wrap action creators with `dispatch`\n\n        var connectedFormACs = bindActionCreators(boundFormACs, dispatch);\n        var connectedArrayACs = {\n          insert: bindActionCreators(boundArrayACs.arrayInsert, dispatch),\n          move: bindActionCreators(boundArrayACs.arrayMove, dispatch),\n          pop: bindActionCreators(boundArrayACs.arrayPop, dispatch),\n          push: bindActionCreators(boundArrayACs.arrayPush, dispatch),\n          remove: bindActionCreators(boundArrayACs.arrayRemove, dispatch),\n          removeAll: bindActionCreators(boundArrayACs.arrayRemoveAll, dispatch),\n          shift: bindActionCreators(boundArrayACs.arrayShift, dispatch),\n          splice: bindActionCreators(boundArrayACs.arraySplice, dispatch),\n          swap: bindActionCreators(boundArrayACs.arraySwap, dispatch),\n          unshift: bindActionCreators(boundArrayACs.arrayUnshift, dispatch)\n        };\n\n        var computedActions = extends_default()({}, connectedFormACs, boundArrayACs, {\n          blur: boundBlur,\n          change: boundChange,\n          array: connectedArrayACs,\n          focus: boundFocus,\n          dispatch: dispatch\n        });\n\n        return function () {\n          return computedActions;\n        };\n      }, undefined, {\n        forwardRef: true\n      });\n      var ConnectedForm = hoist_non_react_statics_cjs_default()(connector(Form), WrappedComponent);\n      ConnectedForm.defaultProps = config; // build outer component to expose instance api\n\n      var ReduxForm =\n      /*#__PURE__*/\n      function (_React$Component2) {\n        inheritsLoose_default()(ReduxForm, _React$Component2);\n\n        function ReduxForm() {\n          var _this4;\n\n          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            args[_key2] = arguments[_key2];\n          }\n\n          _this4 = _React$Component2.call.apply(_React$Component2, [this].concat(args)) || this;\n          _this4.ref = react_default.a.createRef();\n          return _this4;\n        }\n\n        var _proto2 = ReduxForm.prototype;\n\n        _proto2.submit = function submit() {\n          return this.ref.current && this.ref.current.submit();\n        };\n\n        _proto2.reset = function reset() {\n          if (this.ref) {\n            this.ref.current.reset();\n          }\n        };\n\n        _proto2.render = function render() {\n          var _this$props13 = this.props,\n              initialValues = _this$props13.initialValues,\n              rest = objectWithoutPropertiesLoose_default()(_this$props13, ["initialValues"]);\n\n          return Object(react["createElement"])(ConnectedForm, extends_default()({}, rest, {\n            ref: this.ref,\n            // convert initialValues if need to\n            initialValues: fromJS(initialValues)\n          }));\n        };\n\n        createClass_default()(ReduxForm, [{\n          key: "valid",\n          get: function get() {\n            return !!(this.ref.current && this.ref.current.isValid());\n          }\n        }, {\n          key: "invalid",\n          get: function get() {\n            return !this.valid;\n          }\n        }, {\n          key: "pristine",\n          get: function get() {\n            return !!(this.ref.current && this.ref.current.isPristine());\n          }\n        }, {\n          key: "dirty",\n          get: function get() {\n            return !this.pristine;\n          }\n        }, {\n          key: "values",\n          get: function get() {\n            return this.ref.current ? this.ref.current.getValues() : empty;\n          }\n        }, {\n          key: "fieldList",\n          get: function get() {\n            // mainly provided for testing\n            return this.ref.current ? this.ref.current.getFieldList() : [];\n          }\n        }, {\n          key: "wrappedInstance",\n          get: function get() {\n            // for testing\n            return this.ref.current && this.ref.current.wrapped.current;\n          }\n        }]);\n\n        return ReduxForm;\n      }(react_default.a.Component);\n\n      Object(react_lifecycles_compat_es["polyfill"])(ReduxForm);\n      var WithContext = hoist_non_react_statics_cjs_default()(ReduxFormContext_withReduxForm(ReduxForm), WrappedComponent);\n      WithContext.defaultProps = config;\n      return WithContext;\n    };\n  };\n};\n\n/* harmony default export */ var es_createReduxForm = (createReduxForm_createReduxForm);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/reduxForm.js\n\n\n/* harmony default export */ var reduxForm = (es_createReduxForm(plain));\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/createFieldProps.js\n\n\n\nvar createFieldProps_processProps = function processProps(type, props, _value, deepEqual) {\n  var value = props.value;\n\n  if (type === \'checkbox\') {\n    return extends_default()({}, props, {\n      checked: !!value\n    });\n  }\n\n  if (type === \'radio\') {\n    return extends_default()({}, props, {\n      checked: deepEqual(value, _value),\n      value: _value\n    });\n  }\n\n  if (type === \'select-multiple\') {\n    return extends_default()({}, props, {\n      value: value || []\n    });\n  }\n\n  if (type === \'file\') {\n    return extends_default()({}, props, {\n      value: value || undefined\n    });\n  }\n\n  return props;\n};\n\nvar createFieldProps_createFieldProps = function createFieldProps(_ref, name, _ref2) {\n  var getIn = _ref.getIn,\n      toJS = _ref.toJS,\n      deepEqual = _ref.deepEqual;\n\n  var asyncError = _ref2.asyncError,\n      asyncValidating = _ref2.asyncValidating,\n      onBlur = _ref2.onBlur,\n      onChange = _ref2.onChange,\n      onDrop = _ref2.onDrop,\n      onDragStart = _ref2.onDragStart,\n      dirty = _ref2.dirty,\n      dispatch = _ref2.dispatch,\n      onFocus = _ref2.onFocus,\n      form = _ref2.form,\n      format = _ref2.format,\n      initial = _ref2.initial,\n      parse = _ref2.parse,\n      pristine = _ref2.pristine,\n      props = _ref2.props,\n      state = _ref2.state,\n      submitError = _ref2.submitError,\n      submitFailed = _ref2.submitFailed,\n      submitting = _ref2.submitting,\n      syncError = _ref2.syncError,\n      syncWarning = _ref2.syncWarning,\n      validate = _ref2.validate,\n      value = _ref2.value,\n      _value = _ref2._value,\n      warn = _ref2.warn,\n      custom = objectWithoutPropertiesLoose_default()(_ref2, ["asyncError", "asyncValidating", "onBlur", "onChange", "onDrop", "onDragStart", "dirty", "dispatch", "onFocus", "form", "format", "initial", "parse", "pristine", "props", "state", "submitError", "submitFailed", "submitting", "syncError", "syncWarning", "validate", "value", "_value", "warn"]);\n\n  var error = syncError || asyncError || submitError;\n  var warning = syncWarning;\n\n  var formatFieldValue = function formatFieldValue(value, format) {\n    if (format === null) {\n      return value;\n    }\n\n    var defaultFormattedValue = value == null ? \'\' : value;\n    return format ? format(value, name) : defaultFormattedValue;\n  };\n\n  var formattedFieldValue = formatFieldValue(value, format);\n  return {\n    input: createFieldProps_processProps(custom.type, {\n      name: name,\n      onBlur: onBlur,\n      onChange: onChange,\n      onDragStart: onDragStart,\n      onDrop: onDrop,\n      onFocus: onFocus,\n      value: formattedFieldValue\n    }, _value, deepEqual),\n    meta: extends_default()({}, toJS(state), {\n      active: !!(state && getIn(state, \'active\')),\n      asyncValidating: asyncValidating,\n      autofilled: !!(state && getIn(state, \'autofilled\')),\n      dirty: dirty,\n      dispatch: dispatch,\n      error: error,\n      form: form,\n      initial: initial,\n      warning: warning,\n      invalid: !!error,\n      pristine: pristine,\n      submitting: !!submitting,\n      submitFailed: !!submitFailed,\n      touched: !!(state && getIn(state, \'touched\')),\n      valid: !error,\n      visited: !!(state && getIn(state, \'visited\'))\n    }),\n    custom: extends_default()({}, custom, props)\n  };\n};\n\n/* harmony default export */ var es_createFieldProps = (createFieldProps_createFieldProps);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/events/getValue.js\n\n\nvar getSelectedValues = function getSelectedValues(options) {\n  var result = [];\n\n  if (options) {\n    for (var index = 0; index < options.length; index++) {\n      var option = options[index];\n\n      if (option.selected) {\n        result.push(option.value);\n      }\n    }\n  }\n\n  return result;\n};\n\nvar getValue_getValue = function getValue(event, isReactNative) {\n  if (events_isEvent(event)) {\n    if (!isReactNative && event.nativeEvent && event.nativeEvent.text !== undefined) {\n      return event.nativeEvent.text;\n    }\n\n    if (isReactNative && event.nativeEvent !== undefined) {\n      return event.nativeEvent.text;\n    }\n\n    var detypedEvent = event;\n    var _detypedEvent$target = detypedEvent.target,\n        type = _detypedEvent$target.type,\n        value = _detypedEvent$target.value,\n        checked = _detypedEvent$target.checked,\n        files = _detypedEvent$target.files,\n        dataTransfer = detypedEvent.dataTransfer;\n\n    if (type === \'checkbox\') {\n      return !!checked;\n    }\n\n    if (type === \'file\') {\n      return files || dataTransfer && dataTransfer.files;\n    }\n\n    if (type === \'select-multiple\') {\n      return getSelectedValues(event.target.options);\n    }\n\n    return value;\n  }\n\n  return event;\n};\n\n/* harmony default export */ var events_getValue = (getValue_getValue);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/isReactNative.js\nvar isReactNative_isReactNative = typeof window !== \'undefined\' && window.navigator && window.navigator.product && window.navigator.product === \'ReactNative\';\n/* harmony default export */ var es_isReactNative = (isReactNative_isReactNative);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/events/onChangeValue.js\n\n\n\nvar onChangeValue_onChangeValue = function onChangeValue(event, _ref) {\n  var name = _ref.name,\n      parse = _ref.parse,\n      normalize = _ref.normalize;\n  // read value from input\n  var value = events_getValue(event, es_isReactNative); // parse value if we have a parser\n\n  if (parse) {\n    value = parse(value, name);\n  } // normalize value\n\n\n  if (normalize) {\n    value = normalize(name, value);\n  }\n\n  return value;\n};\n\n/* harmony default export */ var events_onChangeValue = (onChangeValue_onChangeValue);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/util/eventConsts.js\nvar dataKey = \'text\';\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/util/validateComponentProp.js\n\n\nvar validateComponentProp_validateComponentProp = function validateComponentProp(props, propName, componentName) {\n  if (!Object(react_is["isValidElementType"])(props[propName])) {\n    return new Error(\'Invalid prop `\' + propName + \'` supplied to\' + \' `\' + componentName + \'`.\');\n  }\n\n  return null;\n};\n\n/* harmony default export */ var util_validateComponentProp = (validateComponentProp_validateComponentProp);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/ConnectedField.js\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar ConnectedField_propsToNotUpdateFor = [\'_reduxForm\'];\n\nvar isObject = function isObject(entity) {\n  return entity && typeof entity === \'object\';\n};\n\nvar ConnectedField_isFunction = function isFunction(entity) {\n  return entity && typeof entity === \'function\';\n};\n\nvar eventPreventDefault = function eventPreventDefault(event) {\n  if (isObject(event) && ConnectedField_isFunction(event.preventDefault)) {\n    event.preventDefault();\n  }\n};\n\nvar eventDataTransferGetData = function eventDataTransferGetData(event, key) {\n  if (isObject(event) && isObject(event.dataTransfer) && ConnectedField_isFunction(event.dataTransfer.getData)) {\n    return event.dataTransfer.getData(key);\n  }\n};\n\nvar eventDataTransferSetData = function eventDataTransferSetData(event, key, value) {\n  if (isObject(event) && isObject(event.dataTransfer) && ConnectedField_isFunction(event.dataTransfer.setData)) {\n    event.dataTransfer.setData(key, value);\n  }\n};\n\nvar ConnectedField_createConnectedField = function createConnectedField(structure) {\n  var deepEqual = structure.deepEqual,\n      getIn = structure.getIn;\n\n  var getSyncError = function getSyncError(syncErrors, name) {\n    var error = plain.getIn(syncErrors, name); // Because the error for this field might not be at a level in the error structure where\n    // it can be set directly, it might need to be unwrapped from the _error property\n\n    return error && error._error ? error._error : error;\n  };\n\n  var getSyncWarning = function getSyncWarning(syncWarnings, name) {\n    var warning = getIn(syncWarnings, name); // Because the warning for this field might not be at a level in the warning structure where\n    // it can be set directly, it might need to be unwrapped from the _warning property\n\n    return warning && warning._warning ? warning._warning : warning;\n  };\n\n  var ConnectedField =\n  /*#__PURE__*/\n  function (_Component) {\n    inheritsLoose_default()(ConnectedField, _Component);\n\n    function ConnectedField() {\n      var _this;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this = _Component.call.apply(_Component, [this].concat(args)) || this;\n      _this.ref = react_default.a.createRef();\n\n      _this.isPristine = function () {\n        return _this.props.pristine;\n      };\n\n      _this.getValue = function () {\n        return _this.props.value;\n      };\n\n      _this.handleChange = function (event) {\n        var _this$props = _this.props,\n            name = _this$props.name,\n            dispatch = _this$props.dispatch,\n            parse = _this$props.parse,\n            normalize = _this$props.normalize,\n            onChange = _this$props.onChange,\n            _reduxForm = _this$props._reduxForm,\n            previousValue = _this$props.value;\n        var newValue = events_onChangeValue(event, {\n          name: name,\n          parse: parse,\n          normalize: normalize\n        });\n        var defaultPrevented = false;\n\n        if (onChange) {\n          // Can\'t seem to find a way to extend Event in React Native,\n          // thus I simply avoid adding preventDefault() in a RN environment\n          // to prevent the following error:\n          // `One of the sources for assign has an enumerable key on the prototype chain`\n          // Reference: https://github.com/facebook/react-native/issues/5507\n          if (!es_isReactNative && events_isEvent(event)) {\n            onChange(extends_default()({}, event, {\n              preventDefault: function preventDefault() {\n                defaultPrevented = true;\n                return eventPreventDefault(event);\n              }\n            }), newValue, previousValue, name);\n          } else {\n            defaultPrevented = onChange(event, newValue, previousValue, name);\n          }\n        }\n\n        if (!defaultPrevented) {\n          // dispatch change action\n          dispatch(_reduxForm.change(name, newValue)); // call post-change callback\n\n          if (_reduxForm.asyncValidate) {\n            _reduxForm.asyncValidate(name, newValue, \'change\');\n          }\n        }\n      };\n\n      _this.handleFocus = function (event) {\n        var _this$props2 = _this.props,\n            name = _this$props2.name,\n            dispatch = _this$props2.dispatch,\n            onFocus = _this$props2.onFocus,\n            _reduxForm = _this$props2._reduxForm;\n        var defaultPrevented = false;\n\n        if (onFocus) {\n          if (!es_isReactNative) {\n            onFocus(extends_default()({}, event, {\n              preventDefault: function preventDefault() {\n                defaultPrevented = true;\n                return eventPreventDefault(event);\n              }\n            }), name);\n          } else {\n            defaultPrevented = onFocus(event, name);\n          }\n        }\n\n        if (!defaultPrevented) {\n          dispatch(_reduxForm.focus(name));\n        }\n      };\n\n      _this.handleBlur = function (event) {\n        var _this$props3 = _this.props,\n            name = _this$props3.name,\n            dispatch = _this$props3.dispatch,\n            parse = _this$props3.parse,\n            normalize = _this$props3.normalize,\n            onBlur = _this$props3.onBlur,\n            _reduxForm = _this$props3._reduxForm,\n            _value = _this$props3._value,\n            previousValue = _this$props3.value;\n        var newValue = events_onChangeValue(event, {\n          name: name,\n          parse: parse,\n          normalize: normalize\n        }); // for checkbox and radio, if the value property of checkbox or radio equals\n        // the value passed by blur event, then fire blur action with previousValue.\n\n        if (newValue === _value && _value !== undefined) {\n          newValue = previousValue;\n        }\n\n        var defaultPrevented = false;\n\n        if (onBlur) {\n          if (!es_isReactNative) {\n            onBlur(extends_default()({}, event, {\n              preventDefault: function preventDefault() {\n                defaultPrevented = true;\n                return eventPreventDefault(event);\n              }\n            }), newValue, previousValue, name);\n          } else {\n            defaultPrevented = onBlur(event, newValue, previousValue, name);\n          }\n        }\n\n        if (!defaultPrevented) {\n          // dispatch blur action\n          dispatch(_reduxForm.blur(name, newValue)); // call post-blur callback\n\n          if (_reduxForm.asyncValidate) {\n            _reduxForm.asyncValidate(name, newValue, \'blur\');\n          }\n        }\n      };\n\n      _this.handleDragStart = function (event) {\n        var _this$props4 = _this.props,\n            name = _this$props4.name,\n            onDragStart = _this$props4.onDragStart,\n            value = _this$props4.value;\n        eventDataTransferSetData(event, dataKey, value == null ? \'\' : value);\n\n        if (onDragStart) {\n          onDragStart(event, name);\n        }\n      };\n\n      _this.handleDrop = function (event) {\n        var _this$props5 = _this.props,\n            name = _this$props5.name,\n            dispatch = _this$props5.dispatch,\n            onDrop = _this$props5.onDrop,\n            _reduxForm = _this$props5._reduxForm,\n            previousValue = _this$props5.value;\n        var newValue = eventDataTransferGetData(event, dataKey);\n        var defaultPrevented = false;\n\n        if (onDrop) {\n          onDrop(extends_default()({}, event, {\n            preventDefault: function preventDefault() {\n              defaultPrevented = true;\n              return eventPreventDefault(event);\n            }\n          }), newValue, previousValue, name);\n        }\n\n        if (!defaultPrevented) {\n          // dispatch change action\n          dispatch(_reduxForm.change(name, newValue));\n          eventPreventDefault(event);\n        }\n      };\n\n      return _this;\n    }\n\n    var _proto = ConnectedField.prototype;\n\n    _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {\n      var _this2 = this;\n\n      var nextPropsKeys = Object.keys(nextProps);\n      var thisPropsKeys = Object.keys(this.props); // if we have children, we MUST update in React 16\n      // https://twitter.com/erikras/status/915866544558788608\n\n      return !!(this.props.children || nextProps.children || nextPropsKeys.length !== thisPropsKeys.length || nextPropsKeys.some(function (prop) {\n        if (~(nextProps.immutableProps || []).indexOf(prop)) {\n          return _this2.props[prop] !== nextProps[prop];\n        }\n\n        return !~ConnectedField_propsToNotUpdateFor.indexOf(prop) && !deepEqual(_this2.props[prop], nextProps[prop]);\n      }));\n    };\n\n    _proto.getRenderedComponent = function getRenderedComponent() {\n      return this.ref.current;\n    };\n\n    _proto.render = function render() {\n      var _this$props6 = this.props,\n          component = _this$props6.component,\n          forwardRef = _this$props6.forwardRef,\n          name = _this$props6.name,\n          _reduxForm = _this$props6._reduxForm,\n          normalize = _this$props6.normalize,\n          onBlur = _this$props6.onBlur,\n          onChange = _this$props6.onChange,\n          onFocus = _this$props6.onFocus,\n          onDragStart = _this$props6.onDragStart,\n          onDrop = _this$props6.onDrop,\n          immutableProps = _this$props6.immutableProps,\n          rest = objectWithoutPropertiesLoose_default()(_this$props6, ["component", "forwardRef", "name", "_reduxForm", "normalize", "onBlur", "onChange", "onFocus", "onDragStart", "onDrop", "immutableProps"]);\n\n      var _createFieldProps = es_createFieldProps(structure, name, extends_default()({}, rest, {\n        form: _reduxForm.form,\n        onBlur: this.handleBlur,\n        onChange: this.handleChange,\n        onDrop: this.handleDrop,\n        onDragStart: this.handleDragStart,\n        onFocus: this.handleFocus\n      })),\n          custom = _createFieldProps.custom,\n          props = objectWithoutPropertiesLoose_default()(_createFieldProps, ["custom"]);\n\n      if (forwardRef) {\n        custom.ref = this.ref;\n      }\n\n      if (typeof component === \'string\') {\n        var input = props.input,\n            meta = props.meta; // eslint-disable-line no-unused-vars\n        // flatten input into other props\n\n        return Object(react["createElement"])(component, extends_default()({}, input, custom));\n      } else {\n        return Object(react["createElement"])(component, extends_default()({}, props, custom));\n      }\n    };\n\n    return ConnectedField;\n  }(react["Component"]);\n\n  ConnectedField.propTypes = {\n    component: util_validateComponentProp,\n    props: prop_types_default.a.object\n  };\n  var connector = connect_connect(function (state, ownProps) {\n    var name = ownProps.name,\n        _ownProps$_reduxForm = ownProps._reduxForm,\n        initialValues = _ownProps$_reduxForm.initialValues,\n        getFormState = _ownProps$_reduxForm.getFormState;\n    var formState = getFormState(state);\n    var initialState = getIn(formState, "initial." + name);\n    var initial = initialState !== undefined ? initialState : initialValues && getIn(initialValues, name);\n    var value = getIn(formState, "values." + name);\n    var submitting = getIn(formState, \'submitting\');\n    var syncError = getSyncError(getIn(formState, \'syncErrors\'), name);\n    var syncWarning = getSyncWarning(getIn(formState, \'syncWarnings\'), name);\n    var pristine = deepEqual(value, initial);\n    return {\n      asyncError: getIn(formState, "asyncErrors." + name),\n      asyncValidating: getIn(formState, \'asyncValidating\') === name,\n      dirty: !pristine,\n      pristine: pristine,\n      state: getIn(formState, "fields." + name),\n      submitError: getIn(formState, "submitErrors." + name),\n      submitFailed: getIn(formState, \'submitFailed\'),\n      submitting: submitting,\n      syncError: syncError,\n      syncWarning: syncWarning,\n      initial: initial,\n      value: value,\n      _value: ownProps.value // save value passed in (for radios)\n\n    };\n  }, undefined, undefined, {\n    forwardRef: true\n  });\n  return connector(ConnectedField);\n};\n\n/* harmony default export */ var es_ConnectedField = (ConnectedField_createConnectedField);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/util/shallowCompare.js\n\n\nvar shallowCompare_customizer = function customizer(objectValue, otherValue, indexOrkey, object, other, stack) {\n  // https://lodash.com/docs/4.17.4#isEqualWith\n  if (stack) {\n    // Shallow compares\n    // For 1st level, stack === undefined.\n    //   -> Do nothing (and implicitly return undefined so that it goes to compare 2nd level)\n    // For 2nd level and up, stack !== undefined.\n    //   -> Compare by === operator\n    return objectValue === otherValue;\n  }\n};\n\nvar shallowCompare_shallowCompare = function shallowCompare(instance, nextProps, nextState) {\n  var propsEqual = isEqualWith_default()(instance.props, nextProps, shallowCompare_customizer);\n\n  var stateEqual = isEqualWith_default()(instance.state, nextState, shallowCompare_customizer);\n\n  return !propsEqual || !stateEqual;\n};\n\n/* harmony default export */ var util_shallowCompare = (shallowCompare_shallowCompare);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/util/prefixName.js\nvar formatName = function formatName(_ref, name) {\n  var sectionPrefix = _ref._reduxForm.sectionPrefix;\n  return sectionPrefix ? sectionPrefix + "." + name : name;\n};\n\n/* harmony default export */ var prefixName = (formatName);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/createField.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar createField_createField = function createField(structure) {\n  var ConnectedField = es_ConnectedField(structure);\n  var setIn = structure.setIn;\n\n  var Field =\n  /*#__PURE__*/\n  function (_Component) {\n    inheritsLoose_default()(Field, _Component);\n\n    function Field(props) {\n      var _this;\n\n      _this = _Component.call(this, props) || this;\n      _this.ref = react_default.a.createRef();\n      _this.ref = react_default.a.createRef();\n\n      _this.normalize = function (name, value) {\n        var normalize = _this.props.normalize;\n\n        if (!normalize) {\n          return value;\n        }\n\n        var previousValues = _this.props._reduxForm.getValues();\n\n        var previousValue = _this.value;\n        var nextValues = setIn(previousValues, name, value);\n        return normalize(value, previousValue, nextValues, previousValues, name);\n      };\n\n      if (!props._reduxForm) {\n        throw new Error(\'Field must be inside a component decorated with reduxForm()\');\n      }\n\n      return _this;\n    }\n\n    var _proto = Field.prototype;\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this2 = this;\n\n      this.props._reduxForm.register(this.name, \'Field\', function () {\n        return _this2.props.validate;\n      }, function () {\n        return _this2.props.warn;\n      });\n    };\n\n    _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {\n      return util_shallowCompare(this, nextProps, nextState);\n    };\n\n    _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n      var oldName = prefixName(this.props, this.props.name);\n      var newName = prefixName(nextProps, nextProps.name);\n\n      if (oldName !== newName || // use deepEqual here because they could be a function or an array of functions\n      !plain.deepEqual(this.props.validate, nextProps.validate) || !plain.deepEqual(this.props.warn, nextProps.warn)) {\n        // unregister old name\n        this.props._reduxForm.unregister(oldName); // register new name\n\n\n        this.props._reduxForm.register(newName, \'Field\', function () {\n          return nextProps.validate;\n        }, function () {\n          return nextProps.warn;\n        });\n      }\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      this.props._reduxForm.unregister(this.name);\n    };\n\n    _proto.getRenderedComponent = function getRenderedComponent() {\n      browser_default()(this.props.forwardRef, \'If you want to access getRenderedComponent(), \' + \'you must specify a forwardRef prop to Field\');\n      return this.ref.current ? this.ref.current.getRenderedComponent() : undefined;\n    };\n\n    _proto.render = function render() {\n      return Object(react["createElement"])(ConnectedField, extends_default()({}, this.props, {\n        name: this.name,\n        normalize: this.normalize,\n        ref: this.ref\n      }));\n    };\n\n    createClass_default()(Field, [{\n      key: "name",\n      get: function get() {\n        return prefixName(this.props, this.props.name);\n      }\n    }, {\n      key: "dirty",\n      get: function get() {\n        return !this.pristine;\n      }\n    }, {\n      key: "pristine",\n      get: function get() {\n        return !!(this.ref.current && this.ref.current.isPristine());\n      }\n    }, {\n      key: "value",\n      get: function get() {\n        return this.ref.current && this.ref.current.getValue();\n      }\n    }]);\n\n    return Field;\n  }(react["Component"]);\n\n  Field.propTypes = {\n    name: prop_types_default.a.string.isRequired,\n    component: util_validateComponentProp,\n    format: prop_types_default.a.func,\n    normalize: prop_types_default.a.func,\n    onBlur: prop_types_default.a.func,\n    onChange: prop_types_default.a.func,\n    onFocus: prop_types_default.a.func,\n    onDragStart: prop_types_default.a.func,\n    onDrop: prop_types_default.a.func,\n    parse: prop_types_default.a.func,\n    props: prop_types_default.a.object,\n    validate: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.arrayOf(prop_types_default.a.func)]),\n    warn: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.arrayOf(prop_types_default.a.func)]),\n    forwardRef: prop_types_default.a.bool,\n    immutableProps: prop_types_default.a.arrayOf(prop_types_default.a.string),\n    _reduxForm: prop_types_default.a.object\n  };\n  Object(react_lifecycles_compat_es["polyfill"])(Field);\n  return ReduxFormContext_withReduxForm(Field);\n};\n\n/* harmony default export */ var es_createField = (createField_createField);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/Field.js\n\n\n/* harmony default export */ var es_Field = (es_createField(plain));\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/@material-ui/core/FormControl/index.js\nvar FormControl = __webpack_require__(86);\nvar FormControl_default = /*#__PURE__*/__webpack_require__.n(FormControl);\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/@material-ui/core/Grid/index.js\nvar Grid = __webpack_require__(106);\nvar Grid_default = /*#__PURE__*/__webpack_require__.n(Grid);\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/@material-ui/core/InputLabel/index.js\nvar InputLabel = __webpack_require__(84);\nvar InputLabel_default = /*#__PURE__*/__webpack_require__.n(InputLabel);\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/@material-ui/core/MenuItem/index.js\nvar MenuItem = __webpack_require__(209);\nvar MenuItem_default = /*#__PURE__*/__webpack_require__.n(MenuItem);\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/@material-ui/core/Select/index.js\nvar Select = __webpack_require__(67);\nvar Select_default = /*#__PURE__*/__webpack_require__.n(Select);\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/@material-ui/core/TextField/index.js\nvar TextField = __webpack_require__(138);\nvar TextField_default = /*#__PURE__*/__webpack_require__.n(TextField);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/@material-ui/core/index.es.js\n/** @license Material-UI v3.8.3\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// CONCATENATED MODULE: ./src/form/control/TextField.tsx\nfunction TextField_extends() { TextField_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return TextField_extends.apply(this, arguments); }\n\n\n\n/* harmony default export */ var control_TextField = (function (field) {\n  return react["createElement"](TextField_default.a, TextField_extends({}, field.input, {\n    label: field.label,\n    required: field.required,\n    disabled: field.disabled\n  }));\n});\n// CONCATENATED MODULE: ./src/form/control/Select.tsx\nfunction Select_extends() { Select_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return Select_extends.apply(this, arguments); }\n\n\n\n/* harmony default export */ var control_Select = (function (field) {\n  return react["createElement"](FormControl_default.a, {\n    style: {\n      minWidth: 120\n    }\n  }, react["createElement"](InputLabel_default.a, null, field.label), react["createElement"](Select_default.a, Select_extends({}, field.input, {\n    required: field.required,\n    disabled: field.disabled\n  }), field.children));\n});\n// CONCATENATED MODULE: ./src/form/control/RemoteSelect.tsx\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction RemoteSelect_extends() { RemoteSelect_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return RemoteSelect_extends.apply(this, arguments); }\n\nfunction RemoteSelect_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction RemoteSelect_possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return RemoteSelect_assertThisInitialized(self); }\n\nfunction RemoteSelect_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction RemoteSelect_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\nvar RemoteSelect_RemoteSelect =\n/*#__PURE__*/\nfunction (_React$Component) {\n  RemoteSelect_inherits(RemoteSelect, _React$Component);\n\n  function RemoteSelect(props) {\n    var _this;\n\n    RemoteSelect_classCallCheck(this, RemoteSelect);\n\n    _this = RemoteSelect_possibleConstructorReturn(this, _getPrototypeOf(RemoteSelect).call(this, props));\n    _this.state = {};\n    return _this;\n  }\n\n  _createClass(RemoteSelect, [{\n    key: "componentDidMount",\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      setTimeout(function () {\n        _this2.updateState({\n          select: react["createElement"](Select_default.a, RemoteSelect_extends({}, _this2.props.input, {\n            required: _this2.props.required,\n            disabled: _this2.props.disabled\n          }), react["createElement"](MenuItem_default.a, {\n            value: 10\n          }, "Ten"), react["createElement"](MenuItem_default.a, {\n            value: 20\n          }, "Twenty"), react["createElement"](MenuItem_default.a, {\n            value: 30\n          }, "Thirty"))\n        });\n      }, 3000);\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      return react["createElement"](FormControl_default.a, {\n        style: {\n          minWidth: 120\n        }\n      }, react["createElement"](InputLabel_default.a, null, this.props.label), this.state.select);\n    }\n  }]);\n\n  return RemoteSelect;\n}(react["Component"]);\n\n\n// CONCATENATED MODULE: ./src/SimpleFormComponent.tsx\nvar _dec, _dec2, _class;\n\nfunction SimpleFormComponent_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { SimpleFormComponent_typeof = function _typeof(obj) { return typeof obj; }; } else { SimpleFormComponent_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return SimpleFormComponent_typeof(obj); }\n\nfunction SimpleFormComponent_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction SimpleFormComponent_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction SimpleFormComponent_createClass(Constructor, protoProps, staticProps) { if (protoProps) SimpleFormComponent_defineProperties(Constructor.prototype, protoProps); if (staticProps) SimpleFormComponent_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction SimpleFormComponent_possibleConstructorReturn(self, call) { if (call && (SimpleFormComponent_typeof(call) === "object" || typeof call === "function")) { return call; } return SimpleFormComponent_assertThisInitialized(self); }\n\nfunction SimpleFormComponent_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction SimpleFormComponent_getPrototypeOf(o) { SimpleFormComponent_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return SimpleFormComponent_getPrototypeOf(o); }\n\nfunction SimpleFormComponent_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) SimpleFormComponent_setPrototypeOf(subClass, superClass); }\n\nfunction SimpleFormComponent_setPrototypeOf(o, p) { SimpleFormComponent_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return SimpleFormComponent_setPrototypeOf(o, p); }\n\n\n\n\n\n\n\n\n/**\r\n * Simple Form Component \r\n */\n\nvar SimpleFormComponent_SimpleFormComponent = (_dec = connect_connect( // map state to props\nfunction (state) {\n  // console.log(state);\n  return {\n    simple: state && state.form && state.form.simple && state.form.simple.values ? state.form.simple.values : {}\n  };\n}, // map dispatch to props\nfunction (dispatch) {\n  return {};\n}), _dec2 = reduxForm({\n  form: \'simple\'\n}), _dec(_class = _dec2(_class =\n/*#__PURE__*/\nfunction (_React$Component) {\n  SimpleFormComponent_inherits(SimpleFormComponent, _React$Component);\n\n  function SimpleFormComponent(props) {\n    var _this;\n\n    SimpleFormComponent_classCallCheck(this, SimpleFormComponent);\n\n    _this = SimpleFormComponent_possibleConstructorReturn(this, SimpleFormComponent_getPrototypeOf(SimpleFormComponent).call(this, props));\n    _this.state = props;\n    return _this;\n  }\n\n  SimpleFormComponent_createClass(SimpleFormComponent, [{\n    key: "render",\n    value: function render() {\n      return react["createElement"]("form", null, react["createElement"](Grid_default.a, {\n        container: true\n      }, react["createElement"](Grid_default.a, {\n        item: true\n      }, react["createElement"](es_Field, {\n        name: "simpleTextField1",\n        label: "Simple Text Field 1",\n        component: control_TextField\n      }))), react["createElement"](Grid_default.a, {\n        container: true\n      }, react["createElement"](Grid_default.a, {\n        item: true\n      }, react["createElement"](es_Field, {\n        name: "simpleSelectField",\n        label: "Simple Select",\n        component: control_Select\n      }, react["createElement"](MenuItem_default.a, {\n        value: 10\n      }, "Ten"), react["createElement"](MenuItem_default.a, {\n        value: 20\n      }, "Twenty"), react["createElement"](MenuItem_default.a, {\n        value: 30\n      }, "Thirty")))), react["createElement"](Grid_default.a, {\n        container: true\n      }, react["createElement"](Grid_default.a, {\n        item: true\n      }, react["createElement"](es_Field, {\n        name: "remoteSelectField",\n        label: "Remote Select",\n        component: RemoteSelect_RemoteSelect\n      }))));\n    }\n  }]);\n\n  return SimpleFormComponent;\n}(react["Component"])) || _class) || _class);\n\n// CONCATENATED MODULE: ./src/App.tsx\nvar App_dec, App_class;\n\nfunction App_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { App_typeof = function _typeof(obj) { return typeof obj; }; } else { App_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return App_typeof(obj); }\n\nfunction App_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction App_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction App_createClass(Constructor, protoProps, staticProps) { if (protoProps) App_defineProperties(Constructor.prototype, protoProps); if (staticProps) App_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction App_possibleConstructorReturn(self, call) { if (call && (App_typeof(call) === "object" || typeof call === "function")) { return call; } return App_assertThisInitialized(self); }\n\nfunction App_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction App_getPrototypeOf(o) { App_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return App_getPrototypeOf(o); }\n\nfunction App_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) App_setPrototypeOf(subClass, superClass); }\n\nfunction App_setPrototypeOf(o, p) { App_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return App_setPrototypeOf(o, p); }\n\n\n\n\n\n\n\nvar rootReducer = combineReducers({\n  form: es_reducer\n});\nvar App_store = createStore_createStore(rootReducer);\nvar App_App = (App_dec = connect_connect( // map state to props\nfunction (state) {\n  // console.log(state);\n  return {\n    simple: state && state.form && state.form.simple && state.form.simple.values ? state.form.simple.values : {},\n    form: state && state.form && state.form.simple ? state.form.simple : {}\n  };\n}, // map dispatch to props\nfunction (dispatch) {\n  return {};\n}), App_dec(App_class =\n/*#__PURE__*/\nfunction (_React$Component) {\n  App_inherits(App, _React$Component);\n\n  function App(props) {\n    var _this;\n\n    App_classCallCheck(this, App);\n\n    _this = App_possibleConstructorReturn(this, App_getPrototypeOf(App).call(this, props));\n    _this.state = props;\n    return _this;\n  }\n\n  App_createClass(App, [{\n    key: "componentWillReceiveProps",\n    value: function componentWillReceiveProps(nextProps) {\n      console.log(\'componentWillReceiveProps\', nextProps);\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      return react["createElement"]("div", null, react["createElement"]("h1", null, "Hello World"), react["createElement"](SimpleFormComponent_SimpleFormComponent, null), react["createElement"]("div", null, this.props.simple.simpleTextField1), react["createElement"]("div", null, this.props.simple.simpleSelectField), react["createElement"]("div", null, this.props.simple.remoteSelectField));\n    }\n  }]);\n\n  return App;\n}(react["Component"])) || App_class);\nreact_dom["render"](react["createElement"](components_Provider, {\n  store: App_store\n}, react["createElement"](App_App, null)), document.getElementById(\'app\'));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fcm9vdC5qcz9lNTc1Iiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19TeW1ib2wuanM/YTJmNCIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UmF3VGFnLmpzPzEzMjIiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX29iamVjdFRvU3RyaW5nLmpzPzgzODAiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VHZXRUYWcuanM/ZTJhMSIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb3ZlckFyZy5qcz85MzAwIiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRQcm90b3R5cGUuanM/MzU1NCIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdExpa2UuanM/NzU0NSIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1BsYWluT2JqZWN0LmpzPzMwODAiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9yZWR1eC9lcy9jcmVhdGVTdG9yZS5qcz8zM2NlIiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVkdXgvZXMvdXRpbHMvd2FybmluZy5qcz80Njk5Iiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVkdXgvZXMvY29tYmluZVJlZHVjZXJzLmpzP2EyMDciLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9yZWR1eC9lcy9iaW5kQWN0aW9uQ3JlYXRvcnMuanM/YTQ0NSIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlZHV4L2VzL2NvbXBvc2UuanM/ZjFkYyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlZHV4L2VzL2FwcGx5TWlkZGxld2FyZS5qcz84NzdjIiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVkdXgvZXMvaW5kZXguanM/NGU3ZiIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlZHV4LWZvcm0vZXMvYWN0aW9uVHlwZXMuanM/ZmI2OSIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlZHV4LWZvcm0vZXMvZGVsZXRlSW5XaXRoQ2xlYW5VcC5qcz9lMGRkIiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVkdXgtZm9ybS9lcy9zdHJ1Y3R1cmUvcGxhaW4vc3BsaWNlLmpzPzQ4YWYiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9yZWR1eC1mb3JtL2VzL3N0cnVjdHVyZS9wbGFpbi9nZXRJbi5qcz81OWY4Iiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVkdXgtZm9ybS9lcy9zdHJ1Y3R1cmUvcGxhaW4vc2V0SW4uanM/YjE0NiIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlZHV4LWZvcm0vZXMvc3RydWN0dXJlL3BsYWluL2RlZXBFcXVhbC5qcz9mOGI0Iiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVkdXgtZm9ybS9lcy9zdHJ1Y3R1cmUvcGxhaW4vZGVsZXRlSW4uanM/YjY5YyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlZHV4LWZvcm0vZXMvc3RydWN0dXJlL3BsYWluL2tleXMuanM/MmU3NiIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlZHV4LWZvcm0vZXMvc3RydWN0dXJlL3BsYWluL2luZGV4LmpzPzQ2Y2MiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9yZWR1eC1mb3JtL2VzL2NyZWF0ZVJlZHVjZXIuanM/N2IxZCIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlZHV4LWZvcm0vZXMvcmVkdWNlci5qcz9iYWY5Iiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNMb29zZS5qcz9kZWNlIiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvdXRpbHMvUHJvcFR5cGVzLmpzPzcxMjYiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy93YXJuaW5nLmpzPzEzN2EiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb21wb25lbnRzL1Byb3ZpZGVyLmpzPzAxNjAiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanM/MzI4MiIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMuanM/ZWVkMSIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UuanM/ZWNiMyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL3V0aWxzL1N1YnNjcmlwdGlvbi5qcz9mMGFkIiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29tcG9uZW50cy9jb25uZWN0QWR2YW5jZWQuanM/MTBhNiIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL3V0aWxzL3NoYWxsb3dFcXVhbC5qcz9kOTQ1Iiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvdXRpbHMvaXNQbGFpbk9iamVjdC5qcz8yNTI2Iiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvdXRpbHMvdmVyaWZ5UGxhaW5PYmplY3QuanM/ODM4YSIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3Qvd3JhcE1hcFRvUHJvcHMuanM/MmNhNyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3QvbWFwRGlzcGF0Y2hUb1Byb3BzLmpzPzVlMWMiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L21hcFN0YXRlVG9Qcm9wcy5qcz84YjA0Iiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29ubmVjdC9tZXJnZVByb3BzLmpzP2FlYmQiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L3ZlcmlmeVN1YnNlbGVjdG9ycy5qcz80YzQ3Iiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29ubmVjdC9zZWxlY3RvckZhY3RvcnkuanM/NDZkNiIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3QvY29ubmVjdC5qcz9hNjAyIiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvaW5kZXguanM/N2JkYyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlZHV4LWZvcm0vZXMvYWN0aW9ucy5qcz8yMDhkIiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVkdXgtZm9ybS9lcy9hc3luY1ZhbGlkYXRpb24uanM/ZjdmZSIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlZHV4LWZvcm0vZXMvZGVmYXVsdFNob3VsZEFzeW5jVmFsaWRhdGUuanM/ODExYSIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlZHV4LWZvcm0vZXMvZGVmYXVsdFNob3VsZFZhbGlkYXRlLmpzPzA5OTgiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9yZWR1eC1mb3JtL2VzL2RlZmF1bHRTaG91bGRFcnJvci5qcz8zYzE3Iiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVkdXgtZm9ybS9lcy9kZWZhdWx0U2hvdWxkV2Fybi5qcz85YzczIiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVkdXgtZm9ybS9lcy9ldmVudHMvaXNFdmVudC5qcz8wMmE0Iiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVkdXgtZm9ybS9lcy9ldmVudHMvc2lsZW5jZUV2ZW50LmpzP2RiYzQiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9yZWR1eC1mb3JtL2VzL2V2ZW50cy9zaWxlbmNlRXZlbnRzLmpzPzY3NzEiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9yZWR1eC1mb3JtL2VzL2dlbmVyYXRlVmFsaWRhdG9yLmpzPzllNzciLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9lczYtZXJyb3IvZXM2L2luZGV4LmpzPzhkZDUiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9yZWR1eC1mb3JtL2VzL1N1Ym1pc3Npb25FcnJvci5qcz8zNDU0Iiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVkdXgtZm9ybS9lcy9oYW5kbGVTdWJtaXQuanM/ZDdlYyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlZHV4LWZvcm0vZXMvaGFzRXJyb3IuanM/Y2ZjYyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlZHV4LWZvcm0vZXMvc2VsZWN0b3JzL2lzVmFsaWQuanM/ODBjNSIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlZHV4LWZvcm0vZXMvdXRpbC9nZXREaXNwbGF5TmFtZS5qcz80NjE5Iiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVkdXgtZm9ybS9lcy9SZWR1eEZvcm1Db250ZXh0LmpzPzQxMGUiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9yZWR1eC1mb3JtL2VzL2NyZWF0ZVJlZHV4Rm9ybS5qcz8yZjk0Iiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVkdXgtZm9ybS9lcy9yZWR1eEZvcm0uanM/ODkzYSIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlZHV4LWZvcm0vZXMvY3JlYXRlRmllbGRQcm9wcy5qcz9mMjUzIiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVkdXgtZm9ybS9lcy9ldmVudHMvZ2V0VmFsdWUuanM/NTIwMSIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlZHV4LWZvcm0vZXMvaXNSZWFjdE5hdGl2ZS5qcz8zNDI0Iiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVkdXgtZm9ybS9lcy9ldmVudHMvb25DaGFuZ2VWYWx1ZS5qcz9lNzA4Iiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVkdXgtZm9ybS9lcy91dGlsL2V2ZW50Q29uc3RzLmpzPzAwNjgiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9yZWR1eC1mb3JtL2VzL3V0aWwvdmFsaWRhdGVDb21wb25lbnRQcm9wLmpzPzE1ZGIiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9yZWR1eC1mb3JtL2VzL0Nvbm5lY3RlZEZpZWxkLmpzPzMyYTMiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9yZWR1eC1mb3JtL2VzL3V0aWwvc2hhbGxvd0NvbXBhcmUuanM/YjVhZCIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlZHV4LWZvcm0vZXMvdXRpbC9wcmVmaXhOYW1lLmpzPzVkZTQiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9yZWR1eC1mb3JtL2VzL2NyZWF0ZUZpZWxkLmpzPzM5NTciLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9yZWR1eC1mb3JtL2VzL0ZpZWxkLmpzPzBjMmUiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9pbmRleC5lcy5qcz80YTU2Iiwid2VicGFjazovLy8uL3NyYy9mb3JtL2NvbnRyb2wvVGV4dEZpZWxkLnRzeD8wNjE1Iiwid2VicGFjazovLy8uL3NyYy9mb3JtL2NvbnRyb2wvU2VsZWN0LnRzeD81ZDY4Iiwid2VicGFjazovLy8uL3NyYy9mb3JtL2NvbnRyb2wvUmVtb3RlU2VsZWN0LnRzeD9lNTYyIiwid2VicGFjazovLy8uL3NyYy9TaW1wbGVGb3JtQ29tcG9uZW50LnRzeD8wNzhkIiwid2VicGFjazovLy8uL3NyYy9BcHAudHN4PzFjNmQiXSwibmFtZXMiOlsiZmllbGQiLCJpbnB1dCIsImxhYmVsIiwicmVxdWlyZWQiLCJkaXNhYmxlZCIsIm1pbldpZHRoIiwiY2hpbGRyZW4iLCJSZW1vdGVTZWxlY3QiLCJwcm9wcyIsInN0YXRlIiwic2V0VGltZW91dCIsInVwZGF0ZVN0YXRlIiwic2VsZWN0IiwiUmVhY3QiLCJTaW1wbGVGb3JtQ29tcG9uZW50IiwiY29ubmVjdCIsInNpbXBsZSIsImZvcm0iLCJ2YWx1ZXMiLCJkaXNwYXRjaCIsInJlZHV4Rm9ybSIsIlRleHRGaWVsZCIsIlNlbGVjdCIsInJvb3RSZWR1Y2VyIiwiY29tYmluZVJlZHVjZXJzIiwicmVkdWNlciIsInN0b3JlIiwiY3JlYXRlU3RvcmUiLCJBcHAiLCJuZXh0UHJvcHMiLCJjb25zb2xlIiwibG9nIiwic2ltcGxlVGV4dEZpZWxkMSIsInNpbXBsZVNlbGVjdEZpZWxkIiwicmVtb3RlU2VsZWN0RmllbGQiLCJSZWFjdERPTSIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBMEM7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLDhCQUFVOztBQUVOLDhDQUFJLEVBQUM7OztBQ1JVOztBQUU5QjtBQUNBLElBQUksY0FBTSxHQUFHLEtBQUk7O0FBRUYsMERBQU0sRUFBQzs7O0FDTFk7O0FBRWxDO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLHlCQUFjOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsT0FBTSxHQUFHLE9BQU07O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQSxjQUFjLHlCQUFjO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZSx3REFBUyxFQUFDOzs7QUM3Q3pCO0FBQ0EsSUFBSSwyQkFBVzs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxvQ0FBb0IsR0FBRywyQkFBVzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBLFNBQVMsb0NBQW9CO0FBQzdCOztBQUVlLGtFQUFjLEVBQUM7OztBQ3JCSTtBQUNNO0FBQ1U7O0FBRWxEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksMEJBQWMsR0FBRyxPQUFNLEdBQUcsT0FBTTs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMEJBQWMsSUFBSSwwQkFBYztBQUMxQyxNQUFNLFVBQVM7QUFDZixNQUFNLGVBQWM7QUFDcEI7O0FBRWUsMERBQVUsRUFBQzs7O0FDM0IxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZSxvREFBTyxFQUFDOzs7QUNkYTs7QUFFcEM7QUFDQSxtQkFBbUIsUUFBTzs7QUFFWCw4REFBWSxFQUFDOzs7QUNMNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWUsdUVBQVksRUFBQzs7O0FDNUJjO0FBQ0k7QUFDRDs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSx5QkFBVzs7QUFFZjtBQUNBOztBQUVBO0FBQ0EsSUFBSSw0QkFBYyxHQUFHLHlCQUFXOztBQUVoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHNCQUFZLFdBQVcsV0FBVTtBQUN4QztBQUNBO0FBQ0EsY0FBYyxhQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNEJBQWM7QUFDM0I7QUFDQTtBQUNBOztBQUVlLHlFQUFhLEVBQUM7Ozs7OztBQzdEdUI7QUFDUDs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0EsRUFBaUIsU0FBUyx1QkFBVztBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsdUJBQVc7QUFDL0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLElBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHVCQUFhO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLHlCQUF5QjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBLG1CQUFtQixhQUFhO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLEtBQUssT0FBTyxhQUFZO0FBQ3hCO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxRQUFRLGFBQVk7QUFDdkIsQzs7QUN2UEE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNlLFNBQVMsZUFBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQzs7QUNwQjRDO0FBQ1E7QUFDZDs7QUFFdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQyxXQUFXOztBQUUxRDtBQUNBO0FBQ0E7O0FBRUEsT0FBTyx1QkFBYTtBQUNwQixtRUFBbUU7QUFDbkU7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE9BQU8sV0FBVyxPQUFPOztBQUVwRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsYUFBYTtBQUNoRCwrSEFBK0gsV0FBVztBQUMxSTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDOztBQUVBLFFBQVEsS0FBcUMsRUFBRSxFQUkxQzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxLQUFxQyxFQUFFLEVBRTFDOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxLQUFxQyxFQUFFLHVCQUsxQzs7QUFFTDtBQUNBO0FBQ0Esb0JBQW9CLDhCQUE4QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEM7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEM7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFZTtBQUNmLGtFQUFrRSxhQUFhO0FBQy9FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQzs7QUMvQkEsbURBQW1ELGdCQUFnQixzQkFBc0IsT0FBTywyQkFBMkIsMEJBQTBCLHlEQUF5RCwyQkFBMkIsRUFBRSxFQUFFLEVBQUUsZUFBZTs7QUFFOU47O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLGFBQWEsU0FBUztBQUN0QjtBQUNlO0FBQ2Ysd0VBQXdFLGFBQWE7QUFDckY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asa0JBQWtCLE9BQU87O0FBRXpCLHdCQUF3QjtBQUN4QjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsQzs7QUMvQ3dDO0FBQ1E7QUFDTTtBQUNOO0FBQ2hCO0FBQ007O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxLQUE2RyxFQUFFLEVBRWxIOzs7Ozs7Ozs7Ozs7QUNmTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkQ7Ozs7OztBQ25DNkI7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdCQUFPOztBQUVoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWUsb0ZBQXlCLEU7O0FDeER4QyxJQUFJLGFBQU07QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0M7OztBQUdwQyxnQ0FBZ0M7O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw2Q0FBNkM7OztBQUc3QztBQUNBOztBQUVBOztBQUVBLG1DQUFtQzs7O0FBR25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7O0FBRWUsOERBQU0sRTs7QUM1Q2U7O0FBRXBDLElBQUksV0FBSztBQUNUO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLGdCQUFPOztBQUVwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7O0FBRWUsMkRBQUssRTs7Ozs7O0FDeEJrQztBQUNsQjs7QUFFcEMsSUFBSSxtQkFBYTtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLGlCQUFRLEdBQUcsd0JBQXdCO0FBQzVDOztBQUVBLElBQUksV0FBSztBQUNULFNBQVMsbUJBQWEsZUFBZSxnQkFBTztBQUM1Qzs7QUFFZSwyREFBSyxFOzs7Ozs7QUN2QzBCO0FBQ3BCOztBQUUxQixJQUFJLG9CQUFVO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxlQUFLLHdCQUF3QixlQUFLO0FBQ3hDOztBQUVBLElBQUksbUJBQVM7QUFDYixTQUFTLHFCQUFZLE9BQU8sb0JBQVU7QUFDdEM7O0FBRWUsdUVBQVMsRTs7QUNyQjhCO0FBQ2xCOztBQUVwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3RkFBd0YsYUFBYTtBQUNyRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGdEQUFnRCxpQkFBUSxHQUFHLHdCQUF3QjtBQUNuRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGlCQUFRLEdBQUc7O0FBRTVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUksaUJBQVE7QUFDWix1REFBdUQsZ0JBQU87QUFDOUQ7O0FBRWUsb0VBQVEsRTs7QUM1RXZCLFNBQVMsU0FBSTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFZSx3REFBSSxFOztBQ2RXO0FBQ0Y7QUFDQTtBQUNRO0FBQ0Y7QUFDUjtBQUMxQixJQUFJLGVBQVM7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVMsV0FBSztBQUNkLFNBQVMsV0FBSztBQUNkLGFBQWEsZUFBUztBQUN0QixZQUFZLGNBQVE7QUFDcEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILFFBQVEsVUFBSTtBQUNaO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCxVQUFVLFlBQU07QUFDaEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ2UseURBQVMsRTs7QUMxQ3dFO0FBQ3BEO0FBQ3VlO0FBQ3JkO0FBQ3hCOztBQUV0QyxJQUFJLDBCQUFZO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSwrQkFBaUI7QUFDckIsdURBQXVELE1BQU0sb0NBQW9DLE1BQU0sYUFBYSxNQUFNO0FBQzFIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQkFBeUIsWUFBWSwwQkFBWTtBQUM3RSxpQ0FBaUMsc0JBQXlCLENBQUMsS0FBSyxFQUFFLDBCQUFZOztBQUU5RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLEtBQUs7QUFDeEIsaURBQWlELEtBQUsscUJBQXFCLEtBQUs7QUFDaEY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsYUFBYSxZQUFZO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGFBQWEsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZFQUE2RTs7QUFFN0Usa0ZBQWtGO0FBQ2xGO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRyxhQUFhLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGFBQWEsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxhQUFhLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGFBQWEsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxhQUFhLFdBQVc7QUFDM0I7QUFDQTtBQUNBLEdBQUcsYUFBYSxZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsYUFBYSxVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHLGFBQWEsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxHQUFHLGFBQWEsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxhQUFhLElBQUk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHLGFBQWEsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSyxVQUFVLG9CQUFXO0FBQzFCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHLGFBQWEsWUFBWTtBQUM1QjtBQUNBLEdBQUcsYUFBYSxtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGFBQWEsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQSxHQUFHLGFBQWEsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRyxhQUFhLEtBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsYUFBYSxVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGFBQWEsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLEdBQUcsYUFBYSxLQUFLO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRyxhQUFhLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHLGFBQWEsTUFBTTtBQUN0QjtBQUNBLEdBQUcsYUFBYSxzQkFBc0I7QUFDdEM7QUFDQTtBQUNBLEdBQUcsYUFBYSxZQUFZO0FBQzVCO0FBQ0EsR0FBRyxhQUFhLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixzQ0FBNkI7O0FBRXJEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRyxhQUFhLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLHNDQUE2Qjs7QUFFckQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHLGFBQWEsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHLGFBQWEsb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxhQUFhLEtBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUcsYUFBYSxnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsWUFBWSxLQUFLLHVCQUF1QixLQUFLO0FBQzdDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLFlBQVksS0FBSyx5QkFBeUIsS0FBSztBQUMvQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHLGFBQWEsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHLGFBQWEsa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsR0FBRyxhQUFhLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQiwrQkFBaUI7QUFDckM7QUFDQTs7QUFFQSwwQkFBMEIsT0FBTztBQUNqQztBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDOzs7QUFHN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRWUsa0VBQWEsRTs7QUN2c0JnQjtBQUNOO0FBQ3ZCLCtEQUFhLENBQUMsS0FBSyxDQUFDLEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNGcEI7QUFDZjtBQUNBO0FBQ0E7QUFDQSxDOztBQ0ptQztBQUM1Qix3QkFBd0Isb0JBQVM7QUFDeEMsZ0JBQWdCLG9CQUFTO0FBQ3pCLGtCQUFrQixvQkFBUztBQUMzQixvQkFBb0Isb0JBQVM7QUFDN0IsZ0JBQWdCLG9CQUFTO0FBQ3pCLENBQUM7QUFDTSxpQkFBaUIsb0JBQVM7QUFDakMsYUFBYSxvQkFBUztBQUN0QixZQUFZLG9CQUFTO0FBQ3JCLFlBQVksb0JBQVM7QUFDckIsQ0FBQyxFOztBQ1hEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDZSxTQUFTLHFCQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSxDOztBQ3ZCc0U7QUFDMUI7QUFDVDtBQUNnQztBQUM1QjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUUscUJBQU87QUFDVDs7QUFFTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGNBQWM7O0FBRWxCOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGlCQUFRO0FBQ3JCOztBQUVBO0FBQ0EsR0FBRyxDQUFDLGtCQUFTOztBQUViLE1BQU0sS0FBcUMsRUFBRSxFQU0xQzs7QUFFSDtBQUNBLFdBQVcsVUFBVTtBQUNyQixjQUFjLG9CQUFTO0FBQ3ZCO0FBQ0EsMERBQTBELG9DQUFvQyxVQUFVLHNEQUFzRCxpQkFBaUI7QUFDL0s7QUFDQTtBQUNlLHdFQUFnQixFOztBQ3BFaEI7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDOztBQ05lLFNBQVMsZUFBUTtBQUNoQyxFQUFFLGVBQVE7QUFDVixtQkFBbUIsc0JBQXNCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFNBQVMsZUFBUTtBQUNqQixDOztBQ2hCZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQzs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7OztBQ3JGcUU7QUFDZ0I7QUFDNUI7QUFDMEM7QUFDakQ7QUFDakI7QUFDZTtBQUNIO0FBQ0c7QUFDa0I7QUFDbkU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNkJBQTZCOztBQUVwRDtBQUNBO0FBQ0Esd0NBQXdDLDRCQUE0QixVQUFVLG1DQUFtQyxpQkFBaUI7QUFDbEksa0RBQWtELHdDQUF3QyxpQkFBaUI7QUFDM0c7QUFDQSxJQUFJLGlCQUFTLENBQUMsc0NBQWtCO0FBQ2hDO0FBQ0E7O0FBRUEsaUNBQWlDLGVBQVEsR0FBRztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxNQUFNLGNBQWM7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLHNCQUFzQixDQUFDLHNCQUFzQjtBQUM5RyxRQUFRLGlCQUFTOztBQUVqQjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxpQkFBUyxzRUFBc0UsZ0JBQWdCO0FBQ3ZHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQSxnQ0FBZ0MsWUFBWSx1REFBdUQ7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUdBQWlHO0FBQ2pHO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsZUFBUSxHQUFHOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNULGlCQUFpQiw4QkFBYTtBQUM5QjtBQUNBOztBQUVBO0FBQ0EsS0FBSyxDQUFDLGtCQUFTO0FBQ2Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxLQUFxQyxFQUFFLEVBOEIxQzs7QUFFTCxXQUFXLHFDQUFZO0FBQ3ZCO0FBQ0EsQzs7QUNwU0E7O0FBRUEsU0FBUyxlQUFFO0FBQ1g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRWU7QUFDZixNQUFNLGVBQUU7O0FBRVI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsa0JBQWtCO0FBQ25DLHlDQUF5QyxlQUFFO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEM7O0FDNUJBO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsYUFBYSxRQUFRO0FBQ3JCO0FBQ2UsU0FBUywyQkFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDOztBQ2Y0QztBQUNaO0FBQ2pCO0FBQ2YsT0FBTywyQkFBYTtBQUNwQixJQUFJLHFCQUFPO0FBQ1g7QUFDQSxDOztBQ04yRDtBQUNwRDtBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLEtBQXFDLEVBQUUsRUFBa0Q7QUFDbkc7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQzs7QUMvRDJDO0FBQ21DO0FBQ3ZFO0FBQ1Asb0RBQW9ELGtCQUFrQjtBQUN0RTtBQUNPO0FBQ1AsK0JBQStCLHNCQUFzQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDTztBQUNQLHdFQUF3RSxzQkFBc0I7QUFDOUYsV0FBVyxrQkFBa0I7QUFDN0IsR0FBRztBQUNIO0FBQ2Usa0tBQW1HLEU7O0FDakJwQztBQUN2RTtBQUNQLGlEQUFpRCxrQkFBa0I7QUFDbkU7QUFDTztBQUNQLDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQSxHQUFHO0FBQ0g7QUFDZSx5SEFBNkQsRTs7QUNUbEI7QUFDQztBQUNwRDtBQUNQLFNBQVMsZUFBUSxHQUFHO0FBQ3BCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFlBQVksS0FBcUMsRUFBRSxFQUEwRDtBQUM3Rzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNlLDBHQUFtRCxFOztBQ25DM0I7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLE1BQU0scUJBQU87QUFDYjtBQUNBO0FBQ0E7O0FBRWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxDOztBQ2hCb0c7QUFDOUM7QUFDL0M7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkI7O0FBRTdDO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLEtBQXFDLEVBQUUsRUFFMUM7O0FBRUg7QUFDQTtBQUNBLEM7O0FDdEYwRDtBQUMwQztBQUN4QztBQUNYO0FBQ3FCO0FBQ047QUFDVjtBQUNDO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR087QUFDUCxrQ0FBa0M7QUFDbEM7QUFDQSxnREFBZ0QsZUFBZTtBQUMvRDtBQUNBLG9FQUFvRSx1QkFBK0I7QUFDbkc7QUFDQSx1RUFBdUUsMEJBQWtDO0FBQ3pHO0FBQ0EsK0RBQStELGtCQUEwQjtBQUN6RjtBQUNBLDBEQUEwRCx5QkFBc0I7O0FBRWhGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxZQUFZO0FBQzFFO0FBQ0EsZ0VBQWdFLFlBQVk7QUFDNUU7QUFDQSxpRUFBaUUsWUFBWTtBQUM3RSx1QkFBdUIsNkJBQTZCOztBQUVwRDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNlLG1FQUFlLEU7O0FDakdtQztBQUNOO0FBQ25COzs7QUNGYztBQUNxZDs7QUFFM2dCLElBQUksbUJBQVc7QUFDZjtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxpQkFBUztBQUNiO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxnQkFBUTtBQUNaO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGlCQUFTO0FBQ2I7QUFDQSxVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLG1CQUFXO0FBQ2Y7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxzQkFBYztBQUNsQjtBQUNBLFVBQVUsZ0JBQWdCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGtCQUFVO0FBQ2Q7QUFDQSxVQUFVLFdBQVc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksbUJBQVc7QUFDZjtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJLGlCQUFTO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksb0JBQVk7QUFDaEI7QUFDQSxVQUFVLGFBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGdCQUFRO0FBQ1o7QUFDQSxVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLFlBQUk7QUFDUjtBQUNBLFVBQVUsSUFBSTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGNBQU07QUFDVjtBQUNBLFVBQVUsTUFBTTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLG1CQUFXO0FBQ2Y7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLHlCQUFpQjtBQUNyQjtBQUNBLFVBQVUsbUJBQW1CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSx1QkFBZTtBQUNuQjtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLG1CQUFXO0FBQ2YsMEZBQTBGLGFBQWE7QUFDdkc7QUFDQTs7QUFFQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksZUFBTztBQUNYLHdFQUF3RSxlQUFlO0FBQ3ZGO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGFBQUs7QUFDVDtBQUNBLFVBQVUsS0FBSztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGtCQUFVO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCLFVBQVUsaUJBQVE7QUFDbEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxxQkFBYTtBQUNqQjtBQUNBLFVBQVUsY0FBYztBQUN4QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGFBQUs7QUFDVDtBQUNBLFVBQVUsS0FBSztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxvQkFBWTtBQUNoQixnR0FBZ0csZUFBZTtBQUMvRztBQUNBOztBQUVBO0FBQ0EsVUFBVSxhQUFhO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLDRCQUFvQjtBQUN4QjtBQUNBLFVBQVUsc0JBQXNCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLG1CQUFXO0FBQ2Y7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLDJCQUFtQjtBQUN2QjtBQUNBLFVBQVUscUJBQXFCO0FBQy9CO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxrQkFBVTtBQUNkO0FBQ0EsVUFBVSxXQUFXO0FBQ3JCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxjQUFNO0FBQ1Y7QUFDQSxVQUFVLE1BQU07QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLHVCQUFlO0FBQ25CLDhGQUE4RixlQUFlO0FBQzdHO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLElBQUksMEJBQWtCO0FBQ3RCLDhGQUE4RixlQUFlO0FBQzdHO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLG9CQUFvQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLElBQUksYUFBSztBQUNULDhGQUE4RixlQUFlO0FBQzdHO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLEtBQUs7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSx1QkFBZTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGVBQU87QUFDWCw4RkFBOEYsZUFBZTtBQUM3RztBQUNBOztBQUVBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLHdCQUFnQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLGtCQUFrQjtBQUM1QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLDBCQUFrQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLG9CQUFvQjtBQUM5QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsbUJBQVc7QUFDMUIsYUFBYSxpQkFBUztBQUN0QixZQUFZLGdCQUFRO0FBQ3BCLGFBQWEsaUJBQVM7QUFDdEIsZUFBZSxtQkFBVztBQUMxQixrQkFBa0Isc0JBQWM7QUFDaEMsY0FBYyxrQkFBVTtBQUN4QixlQUFlLG1CQUFXO0FBQzFCLGFBQWEsaUJBQVM7QUFDdEIsZ0JBQWdCLG9CQUFZO0FBQzVCLFlBQVksZ0JBQVE7QUFDcEIsUUFBUSxZQUFJO0FBQ1osVUFBVSxjQUFNO0FBQ2hCLGVBQWUsbUJBQVc7QUFDMUIsZUFBZSxtQkFBVztBQUMxQixxQkFBcUIseUJBQWlCO0FBQ3RDLG1CQUFtQix1QkFBZTtBQUNsQyxXQUFXLGVBQU87QUFDbEIsU0FBUyxhQUFLO0FBQ2QsY0FBYyxrQkFBVTtBQUN4QixpQkFBaUIscUJBQWE7QUFDOUIsU0FBUyxhQUFLO0FBQ2QsZ0JBQWdCLG9CQUFZO0FBQzVCLHdCQUF3Qiw0QkFBb0I7QUFDNUMsZUFBZSxtQkFBVztBQUMxQix1QkFBdUIsMkJBQW1CO0FBQzFDLGNBQWMsa0JBQVU7QUFDeEIsVUFBVSxjQUFNO0FBQ2hCLG1CQUFtQix1QkFBZTtBQUNsQyxzQkFBc0IsMEJBQWtCO0FBQ3hDLFNBQVMsYUFBSztBQUNkLG1CQUFtQix1QkFBZTtBQUNsQyxXQUFXLGVBQU87QUFDbEIsb0JBQW9CLHdCQUFnQjtBQUNwQyxzQkFBc0IsMEJBQWtCO0FBQ3hDO0FBQ2Usc0RBQU8sRTs7QUNuZWE7O0FBRW5DLElBQUksK0JBQWU7QUFDbkI7QUFDQTs7QUFFQSxPQUFPLG9CQUFTO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRWUsc0ZBQWUsRTs7QUM5QjlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRWUsNEZBQTBCLEU7O0FDMUJ6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFZSxrRkFBcUIsRTs7QUNmcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRWUsNEVBQWtCLEU7O0FDZmpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVlLDBFQUFpQixFOztBQ2ZoQztBQUNBO0FBQ0E7O0FBRWUsMERBQU8sRTs7QUNKVTs7QUFFaEMsSUFBSSx5QkFBWTtBQUNoQixXQUFXLGNBQU87O0FBRWxCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVlLGlGQUFZLEU7O0FDWmU7O0FBRTFDLElBQUksMkJBQWE7QUFDakI7QUFDQSwwRkFBMEYsYUFBYTtBQUN2RztBQUNBOztBQUVBLFdBQVcsbUJBQVk7QUFDdkI7QUFDQTs7QUFFZSxvRkFBYSxFOztBQ1pVOztBQUV0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsa0JBQWtCO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxtQ0FBaUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLEtBQUs7QUFDdEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVlLDRGQUFpQixFOztBQ2xDaEMsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdkosaURBQWlELGFBQWEsdUZBQXVGLEVBQUUsdUZBQXVGOztBQUU5TywwQ0FBMEMsK0RBQStELHFHQUFxRyxFQUFFLHlFQUF5RSxlQUFlLHlFQUF5RSxFQUFFLEVBQUUsdUhBQXVIOztBQUU1ZTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFYyx1REFBZSxFQUFDOzs7QUN2RW1DO0FBQzFCOztBQUV4QyxJQUFJLCtCQUFlO0FBQ25CO0FBQ0E7QUFDQSxFQUFFLHVCQUFjOztBQUVoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQyxDQUFDLEdBQWU7O0FBRUYsc0ZBQWUsRTs7QUNuQndCO0FBQ25CO0FBQ2E7O0FBRWhELElBQUksOEJBQWlCO0FBQ3JCLGlDQUFpQyxrQkFBZTtBQUNoRDs7QUFFQSxJQUFJLHdCQUFXO0FBQ2Y7QUFDQTtBQUNBLHlHQUF5RyxpQkFBUSxHQUFHO0FBQ3BIOztBQUVBLElBQUkseUJBQVk7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCxvQkFBb0IsOEJBQWlCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxvQkFBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Qsc0JBQXNCLDhCQUFpQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGlCQUFpQix3QkFBVztBQUM1QjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVlLDZFQUFZLEU7O0FDOUgzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFZSw4REFBYyxFOztBQy9CWTs7QUFFekMsSUFBSSxxQkFBYTtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCLFdBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFZSwyRUFBYSxFOztBQ3RENUIsSUFBSSw2QkFBYztBQUNsQjtBQUNBOztBQUVlLHFGQUFjLEU7Ozs7O0FDSnlCO0FBQzBDO0FBQzlCO0FBQ25DO0FBQ3hCLHVCQUF1QixzQkFBbUI7QUFDMUMsSUFBSSw4QkFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVCQUFjOztBQUVsQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNDQUE2Qjs7QUFFOUMsYUFBYSxzQkFBbUI7QUFDaEM7QUFDQSxpQkFBaUIsc0JBQW1CLFlBQVksaUJBQVE7QUFDeEQ7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLEdBQUcsQ0FBQyxrQkFBZTs7QUFFbkIsWUFBWSxtQkFBZ0I7QUFDNUIsV0FBVyxzQkFBbUIsTUFBTSxpQkFBUSxHQUFHO0FBQy9DO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRTs7QUMxQzhEO0FBQ0k7QUFDWjtBQUMwQztBQUM5RDtBQUNRO0FBQ1M7QUFDQTtBQUNqQjtBQUNDO0FBQ0E7QUFDVTtBQUNQO0FBQ0s7QUFDSDtBQUNRO0FBQ3NCO0FBQ1Y7QUFDTjtBQUNGO0FBQ0g7QUFDRTtBQUNDO0FBQ1Y7QUFDTTtBQUNWO0FBQ2E7QUFDQTtBQUNrQjs7QUFFckU7QUFDQTtBQUNBLEVBQUU7OztBQUdGLElBQUksMkJBQVcsR0FBRyxVQUFlO0FBQ2pDLElBQUkseUJBQVMsR0FBRyxVQUFlO0FBQy9CLElBQUksd0JBQVEsR0FBRyxVQUFlO0FBQzlCLElBQUkseUJBQVMsR0FBRyxVQUFlO0FBQy9CLElBQUksMkJBQVcsR0FBRyxVQUFlO0FBQ2pDLElBQUksOEJBQWMsR0FBRyxVQUFlO0FBQ3BDLElBQUksMEJBQVUsR0FBRyxVQUFlO0FBQ2hDLElBQUksMkJBQVcsR0FBRyxVQUFlO0FBQ2pDLElBQUkseUJBQVMsR0FBRyxVQUFlO0FBQy9CLElBQUksNEJBQVksR0FBRyxVQUFlO0FBQ2xDLElBQUksb0JBQUksR0FBRyxVQUFlO0FBQzFCLElBQUksc0JBQU0sR0FBRyxVQUFlO0FBQzVCLElBQUkscUJBQUssR0FBRyxVQUFlO0FBQzNCLGtCQUFrQixzQ0FBNkIsQ0FBQyxVQUFlOztBQUUvRDtBQUNBLGVBQWUsMkJBQVc7QUFDMUIsYUFBYSx5QkFBUztBQUN0QixZQUFZLHdCQUFRO0FBQ3BCLGFBQWEseUJBQVM7QUFDdEIsZUFBZSwyQkFBVztBQUMxQixrQkFBa0IsOEJBQWM7QUFDaEMsY0FBYywwQkFBVTtBQUN4QixlQUFlLDJCQUFXO0FBQzFCLGFBQWEseUJBQVM7QUFDdEIsZ0JBQWdCLDRCQUFZO0FBQzVCO0FBQ0EsZ0RBQWdELFVBQWU7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrQkFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWE7QUFDN0I7QUFDQSxpQkFBaUIsaUJBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNkJBQTBCO0FBQ3JELHNCQUFzQix3QkFBcUI7QUFDM0MsbUJBQW1CLHFCQUFrQjtBQUNyQyxrQkFBa0Isb0JBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVCQUFjOztBQUV0QjtBQUNBOztBQUVBLDZFQUE2RSxhQUFhO0FBQzFGO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsZUFBSztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0VBQWdFOztBQUVoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvREFBb0Qsb0JBQWlCO0FBQ3JFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaURBQWlELG9CQUFpQjtBQUNsRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZix1QkFBdUIsa0JBQWU7QUFDdEM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLG9CQUFTO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsbUJBQVk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLDhDQUE4QyxlQUFZLHdCQUF3QixpQkFBUSxHQUFHLGVBQWUsa0JBQWtCO0FBQzlIO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHFCQUFxQixvQkFBYTtBQUNsQyxvRUFBb0UsZUFBWSw2QkFBNkIsaUJBQVEsR0FBRyxlQUFlLGtCQUFrQjtBQUN6SjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0MsS0FBSywrQ0FBK0MsS0FBSztBQUN4RztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELHdCQUFxQjtBQUNqRixzREFBc0QscUJBQWtCO0FBQ3hFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0QixlQUFNLG1FQUFtRSxLQUFLLHdGQUF3RixLQUFLO0FBQ3ZNO0FBQ0EsbUNBQW1DLHNDQUE2Qjs7QUFFaEU7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtREFBbUQsS0FBSyxtREFBbUQsS0FBSztBQUNoSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsd0JBQXFCO0FBQ2pGLG9EQUFvRCxvQkFBaUI7QUFDckU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNEJBQTRCLGVBQU0sa0RBQWtELHVFQUF1RTtBQUMzSjtBQUNBLHFDQUFxQyxzQ0FBNkI7O0FBRWxFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLHlDQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsaUJBQVM7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZGQUE2RjtBQUM3Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0EsZUFBZSx5Q0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGlCQUFTO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyx5Q0FBYztBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQ0FBNkI7QUFDbEQ7OztBQUdBLCtCQUErQixpQkFBUTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYLDRCQUE0QixpQkFBUSxHQUFHLDRCQUE0Qjs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLGlCQUFRLEdBQUc7QUFDdEM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWCxpQkFBaUIsOEJBQWEsQ0FBQyxnQkFBZ0I7QUFDL0M7QUFDQSxzQkFBc0IsOEJBQWE7QUFDbkMsV0FBVztBQUNYOztBQUVBO0FBQ0EsT0FBTyxDQUFDLGVBQUs7O0FBRWIsbUNBQW1DLG1CQUFjO0FBQ2pEO0FBQ0E7QUFDQSwwQkFBMEIsb0JBQVM7QUFDbkMsa0NBQWtDLG9CQUFTO0FBQzNDLGNBQWMsb0JBQVM7QUFDdkIsd0JBQXdCLG9CQUFTLFNBQVMsb0JBQVM7QUFDbkQsdUJBQXVCLG9CQUFTLFlBQVksb0JBQVMsUUFBUSxvQkFBUztBQUN0RSxzQkFBc0Isb0JBQVM7QUFDL0Isc0JBQXNCLG9CQUFTO0FBQy9CLHlCQUF5QixvQkFBUztBQUNsQyx1QkFBdUIsb0JBQVM7QUFDaEMsa0JBQWtCLG9CQUFTO0FBQzNCLGNBQWMsb0JBQVM7QUFDdkIscUJBQXFCLG9CQUFTO0FBQzlCLHVCQUF1QixvQkFBUztBQUNoQyx1QkFBdUIsb0JBQVM7QUFDaEMsZ0NBQWdDLG9CQUFTO0FBQ3pDLDBCQUEwQixvQkFBUztBQUNuQztBQUNBLHNCQUFzQixlQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkRBQTJELEtBQUs7QUFDaEUsK0RBQStELEtBQUs7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFVBQVU7OztBQUdWLDJCQUEyQixtQkFBVTs7QUFFckMsNEJBQTRCLG1CQUFVOztBQUV0QztBQUNBLGlCQUFpQixvQkFBSTtBQUNyQjs7QUFFQTtBQUNBLGlCQUFpQixzQkFBTTtBQUN2Qjs7QUFFQSxrQ0FBa0MscUJBQUssRUFBRTs7QUFFekMsK0JBQStCLGtCQUFrQjtBQUNqRDtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEMsZ0JBQWdCLGtCQUFrQjtBQUNsQyxlQUFlLGtCQUFrQjtBQUNqQyxnQkFBZ0Isa0JBQWtCO0FBQ2xDLGtCQUFrQixrQkFBa0I7QUFDcEMscUJBQXFCLGtCQUFrQjtBQUN2QyxpQkFBaUIsa0JBQWtCO0FBQ25DLGtCQUFrQixrQkFBa0I7QUFDcEMsZ0JBQWdCLGtCQUFrQjtBQUNsQyxtQkFBbUIsa0JBQWtCO0FBQ3JDOztBQUVBLDhCQUE4QixpQkFBUSxHQUFHO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCwwQkFBMEIscUNBQVk7QUFDdEMsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQSxRQUFRLHVCQUFjOztBQUV0QjtBQUNBOztBQUVBLGdGQUFnRixlQUFlO0FBQy9GO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsZUFBSztBQUM1QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQ0FBNkI7O0FBRWxELGlCQUFpQiw4QkFBYSxnQkFBZ0IsaUJBQVEsR0FBRztBQUN6RDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUEsUUFBUSxxQkFBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsT0FBTyxDQUFDLGVBQUs7O0FBRWIsTUFBTSw4Q0FBUTtBQUNkLHdCQUF3QixxQ0FBWSxDQUFDLDhCQUFhO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWUsc0ZBQWUsRTs7QUM5NUJrQjtBQUNWO0FBQ3ZCLGdFQUFlLENBQUMsS0FBSyxDQUFDLEU7O0FDRjJEO0FBQzFDOztBQUV0RCxJQUFJLDZCQUFZO0FBQ2hCOztBQUVBO0FBQ0EsV0FBVyxpQkFBUSxHQUFHO0FBQ3RCO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsV0FBVyxpQkFBUSxHQUFHO0FBQ3RCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxXQUFXLGlCQUFRLEdBQUc7QUFDdEI7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxXQUFXLGlCQUFRLEdBQUc7QUFDdEI7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQSxJQUFJLGlDQUFnQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNDQUE2Qjs7QUFFNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsNkJBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsVUFBVSxpQkFBUSxHQUFHO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksaUJBQVEsR0FBRztBQUN2QjtBQUNBOztBQUVlLHlGQUFnQixFOztBQy9HQzs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBLHVCQUF1Qix3QkFBd0I7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUksaUJBQVE7QUFDWixNQUFNLGNBQU87QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFZSxxRUFBUSxFOztBQ3REdkIsSUFBSSwyQkFBYTtBQUNGLGdGQUFhLEU7O0FDRE07QUFDVzs7QUFFN0MsSUFBSSwyQkFBYTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZUFBUSxRQUFRLGdCQUFhLEVBQUU7O0FBRTdDO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFZSxvRkFBYSxFOztBQ3RCckIscUI7O0FDQXVDOztBQUU5QyxJQUFJLDJDQUFxQjtBQUN6QixPQUFPLHNDQUFrQjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7O0FBRWUsMEdBQXFCLEU7O0FDVjREO0FBQzFDO0FBQ1k7QUFDVjtBQUNyQjtBQUNHO0FBQ1k7QUFDQztBQUNOO0FBQ1A7QUFDTTtBQUNxQjtBQUMxQjtBQUN2QyxJQUFJLGtDQUFtQjs7QUFFdkI7QUFDQTtBQUNBOztBQUVBLElBQUkseUJBQVU7QUFDZDtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLHlCQUFVO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlEQUF5RCx5QkFBVTtBQUNuRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQseUJBQVU7QUFDbkU7QUFDQTtBQUNBOztBQUVBLElBQUksbUNBQW9CO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsS0FBSyx5QkFBeUI7QUFDOUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QztBQUM1Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUksdUJBQWM7O0FBRWxCO0FBQ0E7O0FBRUEseUVBQXlFLGFBQWE7QUFDdEY7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixlQUFLOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBYSxJQUFJLGNBQU87QUFDdkMscUJBQXFCLGlCQUFRLEdBQUc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0RBQXNEOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxnQkFBYTtBQUM1QixvQkFBb0IsaUJBQVEsR0FBRztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLFNBQVMsRUFBRTtBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGVBQWUsZ0JBQWE7QUFDNUIsbUJBQW1CLGlCQUFRLEdBQUc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9EOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDs7QUFFQTtBQUNBLGlCQUFpQixpQkFBUSxHQUFHO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0Q7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGtDQUFtQjtBQUNwQyxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNDQUE2Qjs7QUFFOUMsOEJBQThCLG1CQUFnQixrQkFBa0IsaUJBQVEsR0FBRztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxrQkFBa0Isc0NBQTZCOztBQUUvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qjs7QUFFQSxlQUFlLDhCQUFhLFlBQVksaUJBQVEsR0FBRztBQUNuRCxPQUFPO0FBQ1AsZUFBZSw4QkFBYSxZQUFZLGlCQUFRLEdBQUc7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBLEdBQUcsQ0FBQyxrQkFBUzs7QUFFYjtBQUNBLGVBQWUsMEJBQXFCO0FBQ3BDLFdBQVcsb0JBQVM7QUFDcEI7QUFDQSxrQkFBa0IsZUFBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRWUseUZBQW9CLEU7O0FDeFZXOztBQUU5QyxJQUFJLHlCQUFVO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSw2QkFBYztBQUNsQixtQkFBbUIscUJBQVksNEJBQTRCLHlCQUFVOztBQUVyRSxtQkFBbUIscUJBQVksNEJBQTRCLHlCQUFVOztBQUVyRTtBQUNBOztBQUVlLHFGQUFjLEU7O0FDdEI3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFZSx5REFBVSxFOztBQ0w2QjtBQUNRO0FBQ0k7QUFDVjtBQUNMO0FBQ2hCO0FBQ0Q7QUFDa0I7QUFDRDtBQUNSO0FBQ0w7QUFDYTtBQUNjOztBQUVqRSxJQUFJLHVCQUFXO0FBQ2YsdUJBQXVCLGlCQUFvQjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVCQUFjOztBQUVsQjtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGVBQUs7QUFDdkIsa0JBQWtCLGVBQUs7O0FBRXZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLGFBQWEsbUJBQWM7QUFDM0I7O0FBRUE7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QixvQkFBb0IsVUFBVTs7QUFFOUI7QUFDQSxPQUFPLEtBQUssd0RBQXdELEtBQUs7QUFDekU7QUFDQSxrREFBa0Q7OztBQUdsRDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxpQkFBUztBQUNmO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLDhCQUFhLGlCQUFpQixpQkFBUSxHQUFHO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQSxJQUFJLHFCQUFZO0FBQ2hCO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRyxDQUFDLGtCQUFTOztBQUViO0FBQ0EsVUFBVSxvQkFBUztBQUNuQixlQUFlLDBCQUFxQjtBQUNwQyxZQUFZLG9CQUFTO0FBQ3JCLGVBQWUsb0JBQVM7QUFDeEIsWUFBWSxvQkFBUztBQUNyQixjQUFjLG9CQUFTO0FBQ3ZCLGFBQWEsb0JBQVM7QUFDdEIsaUJBQWlCLG9CQUFTO0FBQzFCLFlBQVksb0JBQVM7QUFDckIsV0FBVyxvQkFBUztBQUNwQixXQUFXLG9CQUFTO0FBQ3BCLGNBQWMsb0JBQVMsWUFBWSxvQkFBUyxPQUFPLG9CQUFTLFNBQVMsb0JBQVM7QUFDOUUsVUFBVSxvQkFBUyxZQUFZLG9CQUFTLE9BQU8sb0JBQVMsU0FBUyxvQkFBUztBQUMxRSxnQkFBZ0Isb0JBQVM7QUFDekIsb0JBQW9CLG9CQUFTLFNBQVMsb0JBQVM7QUFDL0MsZ0JBQWdCLG9CQUFTO0FBQ3pCO0FBQ0EsRUFBRSw4Q0FBUTtBQUNWLFNBQVMsOEJBQWE7QUFDdEI7O0FBRWUsMEVBQVcsRTs7QUNySmM7QUFDRjtBQUN2QiwyREFBVyxDQUFDLEtBQUssQ0FBQyxFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0ZqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ21DO0FBQ2pCO0FBQ21IO0FBQ3hGO0FBQ0E7QUFDSTtBQUNOO0FBQ3NCO0FBQ1k7QUFDaEM7QUFDUTtBQUNaO0FBQ29CO0FBQ047QUFDQTtBQUNGO0FBQ0Y7QUFDRjtBQUNSO0FBQ3dCO0FBQ0U7QUFDbEI7QUFDTTtBQUNWO0FBQ2M7QUFDQTtBQUNRO0FBQ1o7QUFDUjtBQUNGO0FBQ2dCO0FBQ2M7QUFDQTtBQUNBO0FBQ3BDO0FBQ0U7QUFDYztBQUNBO0FBQ1U7QUFDZDtBQUNVO0FBQ1Y7QUFDVjtBQUNRO0FBQ1E7QUFDTTtBQUN0QjtBQUNJO0FBQ0o7QUFDWTtBQUNWO0FBQ2tCO0FBQ1Y7QUFDRTtBQUNRO0FBQ3BCO0FBQ0E7QUFDUTtBQUNZO0FBQ0o7QUFDc0I7QUFDdEI7QUFDRTtBQUNsQjtBQUNRO0FBQ0E7QUFDVTtBQUNGO0FBQ0E7QUFDZDtBQUNnQjtBQUNoQjtBQUNJO0FBQ0Y7QUFDQTtBQUNGO0FBQ1U7QUFDTjtBQUNGO0FBQ0Y7QUFDTTtBQUNjO0FBQ3RCO0FBQ1k7QUFDTTtBQUNKO0FBQ047QUFDRTtBQUNKO0FBQ0E7QUFDZ0I7QUFDbEI7QUFDTjtBQUNJO0FBQ1E7QUFDQTtBQUNJO0FBQ0o7QUFDWTtBQUNkO0FBQ1k7QUFDcEI7QUFDVTtBQUNKO0FBQ0E7QUFDTTtBQUNZO0FBQ2Q7QUFDVjs7Ozs7QUNqSHpDO0FBQ0E7QUFFZSxnRUFBQ0EsS0FBRDtBQUFBLFNBQ1gsdUJBQUMsbUJBQUQsd0JBQWVBLEtBQUssQ0FBQ0MsS0FBckI7QUFBNEIsU0FBSyxFQUFFRCxLQUFLLENBQUNFLEtBQXpDO0FBQWdELFlBQVEsRUFBRUYsS0FBSyxDQUFDRyxRQUFoRTtBQUEwRSxZQUFRLEVBQUVILEtBQUssQ0FBQ0k7QUFBMUYsS0FEVztBQUFBLENBQWYsRTs7OztBQ0hBO0FBQ0E7QUFFZSw2REFBQ0osS0FBRDtBQUFBLFNBQ1gsdUJBQUMscUJBQUQ7QUFBYSxTQUFLLEVBQUU7QUFBQ0ssY0FBUSxFQUFFO0FBQVg7QUFBcEIsS0FDSSx1QkFBQyxvQkFBRCxRQUFhTCxLQUFLLENBQUNFLEtBQW5CLENBREosRUFFSSx1QkFBQyxnQkFBRCxxQkFBWUYsS0FBSyxDQUFDQyxLQUFsQjtBQUF5QixZQUFRLEVBQUVELEtBQUssQ0FBQ0csUUFBekM7QUFBbUQsWUFBUSxFQUFFSCxLQUFLLENBQUNJO0FBQW5FLE1BQ0tKLEtBQUssQ0FBQ00sUUFEWCxDQUZKLENBRFc7QUFBQSxDQUFmLEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNIQTtBQUNBOztJQUVxQkMseUI7Ozs7O0FBRWpCLHdCQUFZQyxLQUFaLEVBQWtCO0FBQUE7O0FBQUE7O0FBQ2Qsa0dBQU1BLEtBQU47QUFDQSxVQUFLQyxLQUFMLEdBQWEsRUFBYjtBQUZjO0FBR2pCOzs7O3dDQUVrQjtBQUFBOztBQUNmQyxnQkFBVSxDQUFDLFlBQUk7QUFDWCxjQUFJLENBQUNDLFdBQUwsQ0FBaUI7QUFBQ0MsZ0JBQU0sRUFDcEIsdUJBQUMsZ0JBQUQsMkJBQVksTUFBSSxDQUFDSixLQUFMLENBQVdQLEtBQXZCO0FBQThCLG9CQUFRLEVBQUUsTUFBSSxDQUFDTyxLQUFMLENBQVdMLFFBQW5EO0FBQTZELG9CQUFRLEVBQUUsTUFBSSxDQUFDSyxLQUFMLENBQVdKO0FBQWxGLGNBQ0ksdUJBQUMsa0JBQUQ7QUFBVSxpQkFBSyxFQUFFO0FBQWpCLG1CQURKLEVBRUksdUJBQUMsa0JBQUQ7QUFBVSxpQkFBSyxFQUFFO0FBQWpCLHNCQUZKLEVBR0ksdUJBQUMsa0JBQUQ7QUFBVSxpQkFBSyxFQUFFO0FBQWpCLHNCQUhKO0FBRGEsU0FBakI7QUFPSCxPQVJTLEVBUVAsSUFSTyxDQUFWO0FBU0g7Ozs2QkFFTztBQUNKLGFBQ0ksdUJBQUMscUJBQUQ7QUFBYSxhQUFLLEVBQUU7QUFBQ0Msa0JBQVEsRUFBRTtBQUFYO0FBQXBCLFNBQ0ksdUJBQUMsb0JBQUQsUUFBYSxLQUFLRyxLQUFMLENBQVdOLEtBQXhCLENBREosRUFFSyxLQUFLTyxLQUFMLENBQVdHLE1BRmhCLENBREo7QUFNSDs7OztFQTFCcUNDLGtCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNIMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7OztJQWVxQkMsdUMsV0FabkJDLGVBQU8sRUFDTDtBQUNBLFVBQVNOLEtBQVQsRUFBb0I7QUFDaEI7QUFDQSxTQUFPO0FBQUNPLFVBQU0sRUFBRVAsS0FBSyxJQUFJQSxLQUFLLENBQUNRLElBQWYsSUFBdUJSLEtBQUssQ0FBQ1EsSUFBTixDQUFXRCxNQUFsQyxJQUE0Q1AsS0FBSyxDQUFDUSxJQUFOLENBQVdELE1BQVgsQ0FBa0JFLE1BQTlELEdBQXVFVCxLQUFLLENBQUNRLElBQU4sQ0FBV0QsTUFBWCxDQUFrQkUsTUFBekYsR0FBa0c7QUFBM0csR0FBUDtBQUNILENBTEksRUFNTDtBQUNBLFVBQVNDLFFBQVQsRUFBa0I7QUFDZCxTQUFPLEVBQVA7QUFDSCxDQVRJLEMsVUFXUEMsU0FBUyxDQUFDO0FBQUNILE1BQUksRUFBRztBQUFSLENBQUQsQzs7Ozs7QUFHUCwrQkFBWVQsS0FBWixFQUF1QjtBQUFBOztBQUFBOztBQUNuQixtSUFBTUEsS0FBTjtBQUNBLFVBQUtDLEtBQUwsR0FBYUQsS0FBYjtBQUZtQjtBQUd0Qjs7Ozs2QkFFTztBQUNKLGFBQ0kscUNBQ0ksdUJBQUMsY0FBRDtBQUFNLGlCQUFTO0FBQWYsU0FDSSx1QkFBQyxjQUFEO0FBQU0sWUFBSTtBQUFWLFNBQ0ksdUJBQUMsUUFBRDtBQUFPLFlBQUksRUFBQyxrQkFBWjtBQUErQixhQUFLLEVBQUMscUJBQXJDO0FBQTJELGlCQUFTLEVBQUVhLGlCQUFTQTtBQUEvRSxRQURKLENBREosQ0FESixFQU1JLHVCQUFDLGNBQUQ7QUFBTSxpQkFBUztBQUFmLFNBQ0ksdUJBQUMsY0FBRDtBQUFNLFlBQUk7QUFBVixTQUNJLHVCQUFDLFFBQUQ7QUFBTyxZQUFJLEVBQUMsbUJBQVo7QUFBZ0MsYUFBSyxFQUFDLGVBQXRDO0FBQXNELGlCQUFTLEVBQUVDLGNBQU1BO0FBQXZFLFNBQ0ksdUJBQUMsa0JBQUQ7QUFBVSxhQUFLLEVBQUU7QUFBakIsZUFESixFQUVJLHVCQUFDLGtCQUFEO0FBQVUsYUFBSyxFQUFFO0FBQWpCLGtCQUZKLEVBR0ksdUJBQUMsa0JBQUQ7QUFBVSxhQUFLLEVBQUU7QUFBakIsa0JBSEosQ0FESixDQURKLENBTkosRUFlSSx1QkFBQyxjQUFEO0FBQU0saUJBQVM7QUFBZixTQUNJLHVCQUFDLGNBQUQ7QUFBTSxZQUFJO0FBQVYsU0FDSSx1QkFBQyxRQUFEO0FBQU8sWUFBSSxFQUFDLG1CQUFaO0FBQWdDLGFBQUssRUFBQyxlQUF0QztBQUFzRCxpQkFBUyxFQUFFZix5QkFBWUE7QUFBN0UsUUFESixDQURKLENBZkosQ0FESjtBQXVCSDs7OztFQS9CNENNLGtCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZCakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsSUFBTVUsV0FBVyxHQUFHQyxlQUFlLENBQUM7QUFDaENQLE1BQUksRUFBRVEsVUFBT0E7QUFEbUIsQ0FBRCxDQUFuQztBQUlBLElBQU1DLFNBQUssR0FBR0MsdUJBQVcsQ0FBQ0osV0FBRCxDQUF6QjtJQWdCTUssTyxjQWRKYixlQUFPLEVBQ0w7QUFDQSxVQUFTTixLQUFULEVBQW9CO0FBQ2hCO0FBQ0EsU0FBTztBQUNITyxVQUFNLEVBQUVQLEtBQUssSUFBSUEsS0FBSyxDQUFDUSxJQUFmLElBQXVCUixLQUFLLENBQUNRLElBQU4sQ0FBV0QsTUFBbEMsSUFBNENQLEtBQUssQ0FBQ1EsSUFBTixDQUFXRCxNQUFYLENBQWtCRSxNQUE5RCxHQUF1RVQsS0FBSyxDQUFDUSxJQUFOLENBQVdELE1BQVgsQ0FBa0JFLE1BQXpGLEdBQWtHLEVBRHZHO0FBRUhELFFBQUksRUFBRVIsS0FBSyxJQUFJQSxLQUFLLENBQUNRLElBQWYsSUFBdUJSLEtBQUssQ0FBQ1EsSUFBTixDQUFXRCxNQUFsQyxHQUEyQ1AsS0FBSyxDQUFDUSxJQUFOLENBQVdELE1BQXRELEdBQStEO0FBRmxFLEdBQVA7QUFJSCxDQVJJLEVBU0w7QUFDQSxVQUFTRyxRQUFULEVBQWtCO0FBQ2QsU0FBTyxFQUFQO0FBQ0gsQ0FaSSxDOzs7OztBQWdCTCxlQUFZWCxLQUFaLEVBQWtCO0FBQUE7O0FBQUE7O0FBQ2QsbUZBQU1BLEtBQU47QUFDQSxVQUFLQyxLQUFMLEdBQWFELEtBQWI7QUFGYztBQUdqQjs7Ozs4Q0FFeUJxQixTLEVBQVU7QUFDaENDLGFBQU8sQ0FBQ0MsR0FBUixDQUFZLDJCQUFaLEVBQXlDRixTQUF6QztBQUNIOzs7NkJBRU87QUFDSixhQUNJLG9DQUNJLGlEQURKLEVBRVEsdUJBQUMsdUNBQUQsT0FGUixFQUdJLG9DQUNLLEtBQUtyQixLQUFMLENBQVdRLE1BQVgsQ0FBa0JnQixnQkFEdkIsQ0FISixFQU1JLG9DQUNLLEtBQUt4QixLQUFMLENBQVdRLE1BQVgsQ0FBa0JpQixpQkFEdkIsQ0FOSixFQVNJLG9DQUNLLEtBQUt6QixLQUFMLENBQVdRLE1BQVgsQ0FBa0JrQixpQkFEdkIsQ0FUSixDQURKO0FBZUg7Ozs7RUEzQmFyQixrQjtBQStCbEJzQixtQkFBQSxDQUNJLHVCQUFDLG1CQUFEO0FBQVUsT0FBSyxFQUFFVCxTQUFLQTtBQUF0QixHQUNJLHVCQUFDLE9BQUQsT0FESixDQURKLEVBSUFVLFFBQVEsQ0FBQ0MsY0FBVCxDQUF3QixLQUF4QixDQUpBIiwiZmlsZSI6IjQ1NS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmcmVlR2xvYmFsIGZyb20gJy4vX2ZyZWVHbG9iYWwuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbmV4cG9ydCBkZWZhdWx0IHJvb3Q7XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbmV4cG9ydCBkZWZhdWx0IFN5bWJvbDtcbiIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRSYXdUYWc7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb2JqZWN0VG9TdHJpbmc7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5pbXBvcnQgZ2V0UmF3VGFnIGZyb20gJy4vX2dldFJhd1RhZy5qcyc7XG5pbXBvcnQgb2JqZWN0VG9TdHJpbmcgZnJvbSAnLi9fb2JqZWN0VG9TdHJpbmcuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUdldFRhZztcbiIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBvdmVyQXJnO1xuIiwiaW1wb3J0IG92ZXJBcmcgZnJvbSAnLi9fb3ZlckFyZy5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5leHBvcnQgZGVmYXVsdCBnZXRQcm90b3R5cGU7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNPYmplY3RMaWtlO1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgZ2V0UHJvdG90eXBlIGZyb20gJy4vX2dldFByb3RvdHlwZS5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuOC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fCBiYXNlR2V0VGFnKHZhbHVlKSAhPSBvYmplY3RUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcbiAgICBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1BsYWluT2JqZWN0O1xuIiwiaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnbG9kYXNoLWVzL2lzUGxhaW5PYmplY3QnO1xuaW1wb3J0ICQkb2JzZXJ2YWJsZSBmcm9tICdzeW1ib2wtb2JzZXJ2YWJsZSc7XG5cbi8qKlxuICogVGhlc2UgYXJlIHByaXZhdGUgYWN0aW9uIHR5cGVzIHJlc2VydmVkIGJ5IFJlZHV4LlxuICogRm9yIGFueSB1bmtub3duIGFjdGlvbnMsIHlvdSBtdXN0IHJldHVybiB0aGUgY3VycmVudCBzdGF0ZS5cbiAqIElmIHRoZSBjdXJyZW50IHN0YXRlIGlzIHVuZGVmaW5lZCwgeW91IG11c3QgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLlxuICogRG8gbm90IHJlZmVyZW5jZSB0aGVzZSBhY3Rpb24gdHlwZXMgZGlyZWN0bHkgaW4geW91ciBjb2RlLlxuICovXG5leHBvcnQgdmFyIEFjdGlvblR5cGVzID0ge1xuICBJTklUOiAnQEByZWR1eC9JTklUJ1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUmVkdXggc3RvcmUgdGhhdCBob2xkcyB0aGUgc3RhdGUgdHJlZS5cbiAgICogVGhlIG9ubHkgd2F5IHRvIGNoYW5nZSB0aGUgZGF0YSBpbiB0aGUgc3RvcmUgaXMgdG8gY2FsbCBgZGlzcGF0Y2goKWAgb24gaXQuXG4gICAqXG4gICAqIFRoZXJlIHNob3VsZCBvbmx5IGJlIGEgc2luZ2xlIHN0b3JlIGluIHlvdXIgYXBwLiBUbyBzcGVjaWZ5IGhvdyBkaWZmZXJlbnRcbiAgICogcGFydHMgb2YgdGhlIHN0YXRlIHRyZWUgcmVzcG9uZCB0byBhY3Rpb25zLCB5b3UgbWF5IGNvbWJpbmUgc2V2ZXJhbCByZWR1Y2Vyc1xuICAgKiBpbnRvIGEgc2luZ2xlIHJlZHVjZXIgZnVuY3Rpb24gYnkgdXNpbmcgYGNvbWJpbmVSZWR1Y2Vyc2AuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlZHVjZXIgQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG5leHQgc3RhdGUgdHJlZSwgZ2l2ZW5cbiAgICogdGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBhbmQgdGhlIGFjdGlvbiB0byBoYW5kbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSBbcHJlbG9hZGVkU3RhdGVdIFRoZSBpbml0aWFsIHN0YXRlLiBZb3UgbWF5IG9wdGlvbmFsbHkgc3BlY2lmeSBpdFxuICAgKiB0byBoeWRyYXRlIHRoZSBzdGF0ZSBmcm9tIHRoZSBzZXJ2ZXIgaW4gdW5pdmVyc2FsIGFwcHMsIG9yIHRvIHJlc3RvcmUgYVxuICAgKiBwcmV2aW91c2x5IHNlcmlhbGl6ZWQgdXNlciBzZXNzaW9uLlxuICAgKiBJZiB5b3UgdXNlIGBjb21iaW5lUmVkdWNlcnNgIHRvIHByb2R1Y2UgdGhlIHJvb3QgcmVkdWNlciBmdW5jdGlvbiwgdGhpcyBtdXN0IGJlXG4gICAqIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNoYXBlIGFzIGBjb21iaW5lUmVkdWNlcnNgIGtleXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlbmhhbmNlcl0gVGhlIHN0b3JlIGVuaGFuY2VyLiBZb3UgbWF5IG9wdGlvbmFsbHkgc3BlY2lmeSBpdFxuICAgKiB0byBlbmhhbmNlIHRoZSBzdG9yZSB3aXRoIHRoaXJkLXBhcnR5IGNhcGFiaWxpdGllcyBzdWNoIGFzIG1pZGRsZXdhcmUsXG4gICAqIHRpbWUgdHJhdmVsLCBwZXJzaXN0ZW5jZSwgZXRjLiBUaGUgb25seSBzdG9yZSBlbmhhbmNlciB0aGF0IHNoaXBzIHdpdGggUmVkdXhcbiAgICogaXMgYGFwcGx5TWlkZGxld2FyZSgpYC5cbiAgICpcbiAgICogQHJldHVybnMge1N0b3JlfSBBIFJlZHV4IHN0b3JlIHRoYXQgbGV0cyB5b3UgcmVhZCB0aGUgc3RhdGUsIGRpc3BhdGNoIGFjdGlvbnNcbiAgICogYW5kIHN1YnNjcmliZSB0byBjaGFuZ2VzLlxuICAgKi9cbn07ZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlU3RvcmUocmVkdWNlciwgcHJlbG9hZGVkU3RhdGUsIGVuaGFuY2VyKSB7XG4gIHZhciBfcmVmMjtcblxuICBpZiAodHlwZW9mIHByZWxvYWRlZFN0YXRlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBlbmhhbmNlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBlbmhhbmNlciA9IHByZWxvYWRlZFN0YXRlO1xuICAgIHByZWxvYWRlZFN0YXRlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmhhbmNlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIGVuaGFuY2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSBlbmhhbmNlciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIHJldHVybiBlbmhhbmNlcihjcmVhdGVTdG9yZSkocmVkdWNlciwgcHJlbG9hZGVkU3RhdGUpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiByZWR1Y2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgcmVkdWNlciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRSZWR1Y2VyID0gcmVkdWNlcjtcbiAgdmFyIGN1cnJlbnRTdGF0ZSA9IHByZWxvYWRlZFN0YXRlO1xuICB2YXIgY3VycmVudExpc3RlbmVycyA9IFtdO1xuICB2YXIgbmV4dExpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnM7XG4gIHZhciBpc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpIHtcbiAgICBpZiAobmV4dExpc3RlbmVycyA9PT0gY3VycmVudExpc3RlbmVycykge1xuICAgICAgbmV4dExpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnMuc2xpY2UoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgdGhlIHN0YXRlIHRyZWUgbWFuYWdlZCBieSB0aGUgc3RvcmUuXG4gICAqXG4gICAqIEByZXR1cm5zIHthbnl9IFRoZSBjdXJyZW50IHN0YXRlIHRyZWUgb2YgeW91ciBhcHBsaWNhdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGdldFN0YXRlKCkge1xuICAgIHJldHVybiBjdXJyZW50U3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGNoYW5nZSBsaXN0ZW5lci4gSXQgd2lsbCBiZSBjYWxsZWQgYW55IHRpbWUgYW4gYWN0aW9uIGlzIGRpc3BhdGNoZWQsXG4gICAqIGFuZCBzb21lIHBhcnQgb2YgdGhlIHN0YXRlIHRyZWUgbWF5IHBvdGVudGlhbGx5IGhhdmUgY2hhbmdlZC4gWW91IG1heSB0aGVuXG4gICAqIGNhbGwgYGdldFN0YXRlKClgIHRvIHJlYWQgdGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBpbnNpZGUgdGhlIGNhbGxiYWNrLlxuICAgKlxuICAgKiBZb3UgbWF5IGNhbGwgYGRpc3BhdGNoKClgIGZyb20gYSBjaGFuZ2UgbGlzdGVuZXIsIHdpdGggdGhlIGZvbGxvd2luZ1xuICAgKiBjYXZlYXRzOlxuICAgKlxuICAgKiAxLiBUaGUgc3Vic2NyaXB0aW9ucyBhcmUgc25hcHNob3R0ZWQganVzdCBiZWZvcmUgZXZlcnkgYGRpc3BhdGNoKClgIGNhbGwuXG4gICAqIElmIHlvdSBzdWJzY3JpYmUgb3IgdW5zdWJzY3JpYmUgd2hpbGUgdGhlIGxpc3RlbmVycyBhcmUgYmVpbmcgaW52b2tlZCwgdGhpc1xuICAgKiB3aWxsIG5vdCBoYXZlIGFueSBlZmZlY3Qgb24gdGhlIGBkaXNwYXRjaCgpYCB0aGF0IGlzIGN1cnJlbnRseSBpbiBwcm9ncmVzcy5cbiAgICogSG93ZXZlciwgdGhlIG5leHQgYGRpc3BhdGNoKClgIGNhbGwsIHdoZXRoZXIgbmVzdGVkIG9yIG5vdCwgd2lsbCB1c2UgYSBtb3JlXG4gICAqIHJlY2VudCBzbmFwc2hvdCBvZiB0aGUgc3Vic2NyaXB0aW9uIGxpc3QuXG4gICAqXG4gICAqIDIuIFRoZSBsaXN0ZW5lciBzaG91bGQgbm90IGV4cGVjdCB0byBzZWUgYWxsIHN0YXRlIGNoYW5nZXMsIGFzIHRoZSBzdGF0ZVxuICAgKiBtaWdodCBoYXZlIGJlZW4gdXBkYXRlZCBtdWx0aXBsZSB0aW1lcyBkdXJpbmcgYSBuZXN0ZWQgYGRpc3BhdGNoKClgIGJlZm9yZVxuICAgKiB0aGUgbGlzdGVuZXIgaXMgY2FsbGVkLiBJdCBpcywgaG93ZXZlciwgZ3VhcmFudGVlZCB0aGF0IGFsbCBzdWJzY3JpYmVyc1xuICAgKiByZWdpc3RlcmVkIGJlZm9yZSB0aGUgYGRpc3BhdGNoKClgIHN0YXJ0ZWQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgbGF0ZXN0XG4gICAqIHN0YXRlIGJ5IHRoZSB0aW1lIGl0IGV4aXRzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBBIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgb24gZXZlcnkgZGlzcGF0Y2guXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0byByZW1vdmUgdGhpcyBjaGFuZ2UgbGlzdGVuZXIuXG4gICAqL1xuICBmdW5jdGlvbiBzdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgdmFyIGlzU3Vic2NyaWJlZCA9IHRydWU7XG5cbiAgICBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCk7XG4gICAgbmV4dExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgIGlmICghaXNTdWJzY3JpYmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaXNTdWJzY3JpYmVkID0gZmFsc2U7XG5cbiAgICAgIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKTtcbiAgICAgIHZhciBpbmRleCA9IG5leHRMaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICBuZXh0TGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGFuIGFjdGlvbi4gSXQgaXMgdGhlIG9ubHkgd2F5IHRvIHRyaWdnZXIgYSBzdGF0ZSBjaGFuZ2UuXG4gICAqXG4gICAqIFRoZSBgcmVkdWNlcmAgZnVuY3Rpb24sIHVzZWQgdG8gY3JlYXRlIHRoZSBzdG9yZSwgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGVcbiAgICogY3VycmVudCBzdGF0ZSB0cmVlIGFuZCB0aGUgZ2l2ZW4gYGFjdGlvbmAuIEl0cyByZXR1cm4gdmFsdWUgd2lsbFxuICAgKiBiZSBjb25zaWRlcmVkIHRoZSAqKm5leHQqKiBzdGF0ZSBvZiB0aGUgdHJlZSwgYW5kIHRoZSBjaGFuZ2UgbGlzdGVuZXJzXG4gICAqIHdpbGwgYmUgbm90aWZpZWQuXG4gICAqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9ubHkgc3VwcG9ydHMgcGxhaW4gb2JqZWN0IGFjdGlvbnMuIElmIHlvdSB3YW50IHRvXG4gICAqIGRpc3BhdGNoIGEgUHJvbWlzZSwgYW4gT2JzZXJ2YWJsZSwgYSB0aHVuaywgb3Igc29tZXRoaW5nIGVsc2UsIHlvdSBuZWVkIHRvXG4gICAqIHdyYXAgeW91ciBzdG9yZSBjcmVhdGluZyBmdW5jdGlvbiBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIG1pZGRsZXdhcmUuIEZvclxuICAgKiBleGFtcGxlLCBzZWUgdGhlIGRvY3VtZW50YXRpb24gZm9yIHRoZSBgcmVkdXgtdGh1bmtgIHBhY2thZ2UuIEV2ZW4gdGhlXG4gICAqIG1pZGRsZXdhcmUgd2lsbCBldmVudHVhbGx5IGRpc3BhdGNoIHBsYWluIG9iamVjdCBhY3Rpb25zIHVzaW5nIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uIEEgcGxhaW4gb2JqZWN0IHJlcHJlc2VudGluZyDigJx3aGF0IGNoYW5nZWTigJ0uIEl0IGlzXG4gICAqIGEgZ29vZCBpZGVhIHRvIGtlZXAgYWN0aW9ucyBzZXJpYWxpemFibGUgc28geW91IGNhbiByZWNvcmQgYW5kIHJlcGxheSB1c2VyXG4gICAqIHNlc3Npb25zLCBvciB1c2UgdGhlIHRpbWUgdHJhdmVsbGluZyBgcmVkdXgtZGV2dG9vbHNgLiBBbiBhY3Rpb24gbXVzdCBoYXZlXG4gICAqIGEgYHR5cGVgIHByb3BlcnR5IHdoaWNoIG1heSBub3QgYmUgYHVuZGVmaW5lZGAuIEl0IGlzIGEgZ29vZCBpZGVhIHRvIHVzZVxuICAgKiBzdHJpbmcgY29uc3RhbnRzIGZvciBhY3Rpb24gdHlwZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEZvciBjb252ZW5pZW5jZSwgdGhlIHNhbWUgYWN0aW9uIG9iamVjdCB5b3UgZGlzcGF0Y2hlZC5cbiAgICpcbiAgICogTm90ZSB0aGF0LCBpZiB5b3UgdXNlIGEgY3VzdG9tIG1pZGRsZXdhcmUsIGl0IG1heSB3cmFwIGBkaXNwYXRjaCgpYCB0b1xuICAgKiByZXR1cm4gc29tZXRoaW5nIGVsc2UgKGZvciBleGFtcGxlLCBhIFByb21pc2UgeW91IGNhbiBhd2FpdCkuXG4gICAqL1xuICBmdW5jdGlvbiBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QoYWN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY3Rpb25zIG11c3QgYmUgcGxhaW4gb2JqZWN0cy4gJyArICdVc2UgY3VzdG9tIG1pZGRsZXdhcmUgZm9yIGFzeW5jIGFjdGlvbnMuJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBhY3Rpb24udHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWN0aW9ucyBtYXkgbm90IGhhdmUgYW4gdW5kZWZpbmVkIFwidHlwZVwiIHByb3BlcnR5LiAnICsgJ0hhdmUgeW91IG1pc3NwZWxsZWQgYSBjb25zdGFudD8nKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2VycyBtYXkgbm90IGRpc3BhdGNoIGFjdGlvbnMuJyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlzRGlzcGF0Y2hpbmcgPSB0cnVlO1xuICAgICAgY3VycmVudFN0YXRlID0gY3VycmVudFJlZHVjZXIoY3VycmVudFN0YXRlLCBhY3Rpb24pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGxpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnMgPSBuZXh0TGlzdGVuZXJzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV07XG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH1cblxuICAgIHJldHVybiBhY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZXMgdGhlIHJlZHVjZXIgY3VycmVudGx5IHVzZWQgYnkgdGhlIHN0b3JlIHRvIGNhbGN1bGF0ZSB0aGUgc3RhdGUuXG4gICAqXG4gICAqIFlvdSBtaWdodCBuZWVkIHRoaXMgaWYgeW91ciBhcHAgaW1wbGVtZW50cyBjb2RlIHNwbGl0dGluZyBhbmQgeW91IHdhbnQgdG9cbiAgICogbG9hZCBzb21lIG9mIHRoZSByZWR1Y2VycyBkeW5hbWljYWxseS4gWW91IG1pZ2h0IGFsc28gbmVlZCB0aGlzIGlmIHlvdVxuICAgKiBpbXBsZW1lbnQgYSBob3QgcmVsb2FkaW5nIG1lY2hhbmlzbSBmb3IgUmVkdXguXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRSZWR1Y2VyIFRoZSByZWR1Y2VyIGZvciB0aGUgc3RvcmUgdG8gdXNlIGluc3RlYWQuXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZnVuY3Rpb24gcmVwbGFjZVJlZHVjZXIobmV4dFJlZHVjZXIpIHtcbiAgICBpZiAodHlwZW9mIG5leHRSZWR1Y2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSBuZXh0UmVkdWNlciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIGN1cnJlbnRSZWR1Y2VyID0gbmV4dFJlZHVjZXI7XG4gICAgZGlzcGF0Y2goeyB0eXBlOiBBY3Rpb25UeXBlcy5JTklUIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVyb3BlcmFiaWxpdHkgcG9pbnQgZm9yIG9ic2VydmFibGUvcmVhY3RpdmUgbGlicmFyaWVzLlxuICAgKiBAcmV0dXJucyB7b2JzZXJ2YWJsZX0gQSBtaW5pbWFsIG9ic2VydmFibGUgb2Ygc3RhdGUgY2hhbmdlcy5cbiAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSB0aGUgb2JzZXJ2YWJsZSBwcm9wb3NhbDpcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JzZXJ2YWJsZVxuICAgKi9cbiAgZnVuY3Rpb24gb2JzZXJ2YWJsZSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBvdXRlclN1YnNjcmliZSA9IHN1YnNjcmliZTtcbiAgICByZXR1cm4gX3JlZiA9IHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIG1pbmltYWwgb2JzZXJ2YWJsZSBzdWJzY3JpcHRpb24gbWV0aG9kLlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9ic2VydmVyIEFueSBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCBhcyBhbiBvYnNlcnZlci5cbiAgICAgICAqIFRoZSBvYnNlcnZlciBvYmplY3Qgc2hvdWxkIGhhdmUgYSBgbmV4dGAgbWV0aG9kLlxuICAgICAgICogQHJldHVybnMge3N1YnNjcmlwdGlvbn0gQW4gb2JqZWN0IHdpdGggYW4gYHVuc3Vic2NyaWJlYCBtZXRob2QgdGhhdCBjYW5cbiAgICAgICAqIGJlIHVzZWQgdG8gdW5zdWJzY3JpYmUgdGhlIG9ic2VydmFibGUgZnJvbSB0aGUgc3RvcmUsIGFuZCBwcmV2ZW50IGZ1cnRoZXJcbiAgICAgICAqIGVtaXNzaW9uIG9mIHZhbHVlcyBmcm9tIHRoZSBvYnNlcnZhYmxlLlxuICAgICAgICovXG4gICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIHN1YnNjcmliZShvYnNlcnZlcikge1xuICAgICAgICBpZiAodHlwZW9mIG9ic2VydmVyICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIHRoZSBvYnNlcnZlciB0byBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvYnNlcnZlU3RhdGUoKSB7XG4gICAgICAgICAgaWYgKG9ic2VydmVyLm5leHQpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQoZ2V0U3RhdGUoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb2JzZXJ2ZVN0YXRlKCk7XG4gICAgICAgIHZhciB1bnN1YnNjcmliZSA9IG91dGVyU3Vic2NyaWJlKG9ic2VydmVTdGF0ZSk7XG4gICAgICAgIHJldHVybiB7IHVuc3Vic2NyaWJlOiB1bnN1YnNjcmliZSB9O1xuICAgICAgfVxuICAgIH0sIF9yZWZbJCRvYnNlcnZhYmxlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIF9yZWY7XG4gIH1cblxuICAvLyBXaGVuIGEgc3RvcmUgaXMgY3JlYXRlZCwgYW4gXCJJTklUXCIgYWN0aW9uIGlzIGRpc3BhdGNoZWQgc28gdGhhdCBldmVyeVxuICAvLyByZWR1Y2VyIHJldHVybnMgdGhlaXIgaW5pdGlhbCBzdGF0ZS4gVGhpcyBlZmZlY3RpdmVseSBwb3B1bGF0ZXNcbiAgLy8gdGhlIGluaXRpYWwgc3RhdGUgdHJlZS5cbiAgZGlzcGF0Y2goeyB0eXBlOiBBY3Rpb25UeXBlcy5JTklUIH0pO1xuXG4gIHJldHVybiBfcmVmMiA9IHtcbiAgICBkaXNwYXRjaDogZGlzcGF0Y2gsXG4gICAgc3Vic2NyaWJlOiBzdWJzY3JpYmUsXG4gICAgZ2V0U3RhdGU6IGdldFN0YXRlLFxuICAgIHJlcGxhY2VSZWR1Y2VyOiByZXBsYWNlUmVkdWNlclxuICB9LCBfcmVmMlskJG9ic2VydmFibGVdID0gb2JzZXJ2YWJsZSwgX3JlZjI7XG59IiwiLyoqXG4gKiBQcmludHMgYSB3YXJuaW5nIGluIHRoZSBjb25zb2xlIGlmIGl0IGV4aXN0cy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgd2FybmluZyBtZXNzYWdlLlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHdhcm5pbmcobWVzc2FnZSkge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICB0cnkge1xuICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgaWYgeW91IGVuYWJsZVxuICAgIC8vIFwiYnJlYWsgb24gYWxsIGV4Y2VwdGlvbnNcIiBpbiB5b3VyIGNvbnNvbGUsXG4gICAgLy8gaXQgd291bGQgcGF1c2UgdGhlIGV4ZWN1dGlvbiBhdCB0aGlzIGxpbmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWVtcHR5ICovXG4gIH0gY2F0Y2ggKGUpIHt9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tZW1wdHkgKi9cbn0iLCJpbXBvcnQgeyBBY3Rpb25UeXBlcyB9IGZyb20gJy4vY3JlYXRlU3RvcmUnO1xuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnbG9kYXNoLWVzL2lzUGxhaW5PYmplY3QnO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAnLi91dGlscy93YXJuaW5nJztcblxuZnVuY3Rpb24gZ2V0VW5kZWZpbmVkU3RhdGVFcnJvck1lc3NhZ2Uoa2V5LCBhY3Rpb24pIHtcbiAgdmFyIGFjdGlvblR5cGUgPSBhY3Rpb24gJiYgYWN0aW9uLnR5cGU7XG4gIHZhciBhY3Rpb25OYW1lID0gYWN0aW9uVHlwZSAmJiAnXCInICsgYWN0aW9uVHlwZS50b1N0cmluZygpICsgJ1wiJyB8fCAnYW4gYWN0aW9uJztcblxuICByZXR1cm4gJ0dpdmVuIGFjdGlvbiAnICsgYWN0aW9uTmFtZSArICcsIHJlZHVjZXIgXCInICsga2V5ICsgJ1wiIHJldHVybmVkIHVuZGVmaW5lZC4gJyArICdUbyBpZ25vcmUgYW4gYWN0aW9uLCB5b3UgbXVzdCBleHBsaWNpdGx5IHJldHVybiB0aGUgcHJldmlvdXMgc3RhdGUuICcgKyAnSWYgeW91IHdhbnQgdGhpcyByZWR1Y2VyIHRvIGhvbGQgbm8gdmFsdWUsIHlvdSBjYW4gcmV0dXJuIG51bGwgaW5zdGVhZCBvZiB1bmRlZmluZWQuJztcbn1cblxuZnVuY3Rpb24gZ2V0VW5leHBlY3RlZFN0YXRlU2hhcGVXYXJuaW5nTWVzc2FnZShpbnB1dFN0YXRlLCByZWR1Y2VycywgYWN0aW9uLCB1bmV4cGVjdGVkS2V5Q2FjaGUpIHtcbiAgdmFyIHJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICB2YXIgYXJndW1lbnROYW1lID0gYWN0aW9uICYmIGFjdGlvbi50eXBlID09PSBBY3Rpb25UeXBlcy5JTklUID8gJ3ByZWxvYWRlZFN0YXRlIGFyZ3VtZW50IHBhc3NlZCB0byBjcmVhdGVTdG9yZScgOiAncHJldmlvdXMgc3RhdGUgcmVjZWl2ZWQgYnkgdGhlIHJlZHVjZXInO1xuXG4gIGlmIChyZWR1Y2VyS2V5cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJ1N0b3JlIGRvZXMgbm90IGhhdmUgYSB2YWxpZCByZWR1Y2VyLiBNYWtlIHN1cmUgdGhlIGFyZ3VtZW50IHBhc3NlZCAnICsgJ3RvIGNvbWJpbmVSZWR1Y2VycyBpcyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSByZWR1Y2Vycy4nO1xuICB9XG5cbiAgaWYgKCFpc1BsYWluT2JqZWN0KGlucHV0U3RhdGUpKSB7XG4gICAgcmV0dXJuICdUaGUgJyArIGFyZ3VtZW50TmFtZSArICcgaGFzIHVuZXhwZWN0ZWQgdHlwZSBvZiBcIicgKyB7fS50b1N0cmluZy5jYWxsKGlucHV0U3RhdGUpLm1hdGNoKC9cXHMoW2EtenxBLVpdKykvKVsxXSArICdcIi4gRXhwZWN0ZWQgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyAnICsgKCdrZXlzOiBcIicgKyByZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKSArICdcIicpO1xuICB9XG5cbiAgdmFyIHVuZXhwZWN0ZWRLZXlzID0gT2JqZWN0LmtleXMoaW5wdXRTdGF0ZSkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gIXJlZHVjZXJzLmhhc093blByb3BlcnR5KGtleSkgJiYgIXVuZXhwZWN0ZWRLZXlDYWNoZVtrZXldO1xuICB9KTtcblxuICB1bmV4cGVjdGVkS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB1bmV4cGVjdGVkS2V5Q2FjaGVba2V5XSA9IHRydWU7XG4gIH0pO1xuXG4gIGlmICh1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuICdVbmV4cGVjdGVkICcgKyAodW5leHBlY3RlZEtleXMubGVuZ3RoID4gMSA/ICdrZXlzJyA6ICdrZXknKSArICcgJyArICgnXCInICsgdW5leHBlY3RlZEtleXMuam9pbignXCIsIFwiJykgKyAnXCIgZm91bmQgaW4gJyArIGFyZ3VtZW50TmFtZSArICcuICcpICsgJ0V4cGVjdGVkIHRvIGZpbmQgb25lIG9mIHRoZSBrbm93biByZWR1Y2VyIGtleXMgaW5zdGVhZDogJyArICgnXCInICsgcmVkdWNlcktleXMuam9pbignXCIsIFwiJykgKyAnXCIuIFVuZXhwZWN0ZWQga2V5cyB3aWxsIGJlIGlnbm9yZWQuJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0UmVkdWNlclNoYXBlKHJlZHVjZXJzKSB7XG4gIE9iamVjdC5rZXlzKHJlZHVjZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgcmVkdWNlciA9IHJlZHVjZXJzW2tleV07XG4gICAgdmFyIGluaXRpYWxTdGF0ZSA9IHJlZHVjZXIodW5kZWZpbmVkLCB7IHR5cGU6IEFjdGlvblR5cGVzLklOSVQgfSk7XG5cbiAgICBpZiAodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVkdWNlciBcIicgKyBrZXkgKyAnXCIgcmV0dXJuZWQgdW5kZWZpbmVkIGR1cmluZyBpbml0aWFsaXphdGlvbi4gJyArICdJZiB0aGUgc3RhdGUgcGFzc2VkIHRvIHRoZSByZWR1Y2VyIGlzIHVuZGVmaW5lZCwgeW91IG11c3QgJyArICdleHBsaWNpdGx5IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZS4gVGhlIGluaXRpYWwgc3RhdGUgbWF5ICcgKyAnbm90IGJlIHVuZGVmaW5lZC4gSWYgeW91IGRvblxcJ3Qgd2FudCB0byBzZXQgYSB2YWx1ZSBmb3IgdGhpcyByZWR1Y2VyLCAnICsgJ3lvdSBjYW4gdXNlIG51bGwgaW5zdGVhZCBvZiB1bmRlZmluZWQuJyk7XG4gICAgfVxuXG4gICAgdmFyIHR5cGUgPSAnQEByZWR1eC9QUk9CRV9VTktOT1dOX0FDVElPTl8nICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDcpLnNwbGl0KCcnKS5qb2luKCcuJyk7XG4gICAgaWYgKHR5cGVvZiByZWR1Y2VyKHVuZGVmaW5lZCwgeyB0eXBlOiB0eXBlIH0pID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2VyIFwiJyArIGtleSArICdcIiByZXR1cm5lZCB1bmRlZmluZWQgd2hlbiBwcm9iZWQgd2l0aCBhIHJhbmRvbSB0eXBlLiAnICsgKCdEb25cXCd0IHRyeSB0byBoYW5kbGUgJyArIEFjdGlvblR5cGVzLklOSVQgKyAnIG9yIG90aGVyIGFjdGlvbnMgaW4gXCJyZWR1eC8qXCIgJykgKyAnbmFtZXNwYWNlLiBUaGV5IGFyZSBjb25zaWRlcmVkIHByaXZhdGUuIEluc3RlYWQsIHlvdSBtdXN0IHJldHVybiB0aGUgJyArICdjdXJyZW50IHN0YXRlIGZvciBhbnkgdW5rbm93biBhY3Rpb25zLCB1bmxlc3MgaXQgaXMgdW5kZWZpbmVkLCAnICsgJ2luIHdoaWNoIGNhc2UgeW91IG11c3QgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLCByZWdhcmRsZXNzIG9mIHRoZSAnICsgJ2FjdGlvbiB0eXBlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgbm90IGJlIHVuZGVmaW5lZCwgYnV0IGNhbiBiZSBudWxsLicpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogVHVybnMgYW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgZGlmZmVyZW50IHJlZHVjZXIgZnVuY3Rpb25zLCBpbnRvIGEgc2luZ2xlXG4gKiByZWR1Y2VyIGZ1bmN0aW9uLiBJdCB3aWxsIGNhbGwgZXZlcnkgY2hpbGQgcmVkdWNlciwgYW5kIGdhdGhlciB0aGVpciByZXN1bHRzXG4gKiBpbnRvIGEgc2luZ2xlIHN0YXRlIG9iamVjdCwgd2hvc2Uga2V5cyBjb3JyZXNwb25kIHRvIHRoZSBrZXlzIG9mIHRoZSBwYXNzZWRcbiAqIHJlZHVjZXIgZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWR1Y2VycyBBbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGNvcnJlc3BvbmQgdG8gZGlmZmVyZW50XG4gKiByZWR1Y2VyIGZ1bmN0aW9ucyB0aGF0IG5lZWQgdG8gYmUgY29tYmluZWQgaW50byBvbmUuIE9uZSBoYW5keSB3YXkgdG8gb2J0YWluXG4gKiBpdCBpcyB0byB1c2UgRVM2IGBpbXBvcnQgKiBhcyByZWR1Y2Vyc2Agc3ludGF4LiBUaGUgcmVkdWNlcnMgbWF5IG5ldmVyIHJldHVyblxuICogdW5kZWZpbmVkIGZvciBhbnkgYWN0aW9uLiBJbnN0ZWFkLCB0aGV5IHNob3VsZCByZXR1cm4gdGhlaXIgaW5pdGlhbCBzdGF0ZVxuICogaWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGVtIHdhcyB1bmRlZmluZWQsIGFuZCB0aGUgY3VycmVudCBzdGF0ZSBmb3IgYW55XG4gKiB1bnJlY29nbml6ZWQgYWN0aW9uLlxuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSByZWR1Y2VyIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBldmVyeSByZWR1Y2VyIGluc2lkZSB0aGVcbiAqIHBhc3NlZCBvYmplY3QsIGFuZCBidWlsZHMgYSBzdGF0ZSBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzaGFwZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tYmluZVJlZHVjZXJzKHJlZHVjZXJzKSB7XG4gIHZhciByZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKTtcbiAgdmFyIGZpbmFsUmVkdWNlcnMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWR1Y2VyS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSByZWR1Y2VyS2V5c1tpXTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodHlwZW9mIHJlZHVjZXJzW2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHdhcm5pbmcoJ05vIHJlZHVjZXIgcHJvdmlkZWQgZm9yIGtleSBcIicgKyBrZXkgKyAnXCInKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHJlZHVjZXJzW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZpbmFsUmVkdWNlcnNba2V5XSA9IHJlZHVjZXJzW2tleV07XG4gICAgfVxuICB9XG4gIHZhciBmaW5hbFJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMoZmluYWxSZWR1Y2Vycyk7XG5cbiAgdmFyIHVuZXhwZWN0ZWRLZXlDYWNoZSA9IHZvaWQgMDtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB1bmV4cGVjdGVkS2V5Q2FjaGUgPSB7fTtcbiAgfVxuXG4gIHZhciBzaGFwZUFzc2VydGlvbkVycm9yID0gdm9pZCAwO1xuICB0cnkge1xuICAgIGFzc2VydFJlZHVjZXJTaGFwZShmaW5hbFJlZHVjZXJzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHNoYXBlQXNzZXJ0aW9uRXJyb3IgPSBlO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbWJpbmF0aW9uKCkge1xuICAgIHZhciBzdGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdmFyIGFjdGlvbiA9IGFyZ3VtZW50c1sxXTtcblxuICAgIGlmIChzaGFwZUFzc2VydGlvbkVycm9yKSB7XG4gICAgICB0aHJvdyBzaGFwZUFzc2VydGlvbkVycm9yO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgd2FybmluZ01lc3NhZ2UgPSBnZXRVbmV4cGVjdGVkU3RhdGVTaGFwZVdhcm5pbmdNZXNzYWdlKHN0YXRlLCBmaW5hbFJlZHVjZXJzLCBhY3Rpb24sIHVuZXhwZWN0ZWRLZXlDYWNoZSk7XG4gICAgICBpZiAod2FybmluZ01lc3NhZ2UpIHtcbiAgICAgICAgd2FybmluZyh3YXJuaW5nTWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGhhc0NoYW5nZWQgPSBmYWxzZTtcbiAgICB2YXIgbmV4dFN0YXRlID0ge307XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGZpbmFsUmVkdWNlcktleXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2tleSA9IGZpbmFsUmVkdWNlcktleXNbX2ldO1xuICAgICAgdmFyIHJlZHVjZXIgPSBmaW5hbFJlZHVjZXJzW19rZXldO1xuICAgICAgdmFyIHByZXZpb3VzU3RhdGVGb3JLZXkgPSBzdGF0ZVtfa2V5XTtcbiAgICAgIHZhciBuZXh0U3RhdGVGb3JLZXkgPSByZWR1Y2VyKHByZXZpb3VzU3RhdGVGb3JLZXksIGFjdGlvbik7XG4gICAgICBpZiAodHlwZW9mIG5leHRTdGF0ZUZvcktleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IGdldFVuZGVmaW5lZFN0YXRlRXJyb3JNZXNzYWdlKF9rZXksIGFjdGlvbik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgbmV4dFN0YXRlW19rZXldID0gbmV4dFN0YXRlRm9yS2V5O1xuICAgICAgaGFzQ2hhbmdlZCA9IGhhc0NoYW5nZWQgfHwgbmV4dFN0YXRlRm9yS2V5ICE9PSBwcmV2aW91c1N0YXRlRm9yS2V5O1xuICAgIH1cbiAgICByZXR1cm4gaGFzQ2hhbmdlZCA/IG5leHRTdGF0ZSA6IHN0YXRlO1xuICB9O1xufSIsImZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3IsIGRpc3BhdGNoKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoKGFjdGlvbkNyZWF0b3IuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUdXJucyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBhY3Rpb24gY3JlYXRvcnMsIGludG8gYW4gb2JqZWN0IHdpdGggdGhlXG4gKiBzYW1lIGtleXMsIGJ1dCB3aXRoIGV2ZXJ5IGZ1bmN0aW9uIHdyYXBwZWQgaW50byBhIGBkaXNwYXRjaGAgY2FsbCBzbyB0aGV5XG4gKiBtYXkgYmUgaW52b2tlZCBkaXJlY3RseS4gVGhpcyBpcyBqdXN0IGEgY29udmVuaWVuY2UgbWV0aG9kLCBhcyB5b3UgY2FuIGNhbGxcbiAqIGBzdG9yZS5kaXNwYXRjaChNeUFjdGlvbkNyZWF0b3JzLmRvU29tZXRoaW5nKCkpYCB5b3Vyc2VsZiBqdXN0IGZpbmUuXG4gKlxuICogRm9yIGNvbnZlbmllbmNlLCB5b3UgY2FuIGFsc28gcGFzcyBhIHNpbmdsZSBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQsXG4gKiBhbmQgZ2V0IGEgZnVuY3Rpb24gaW4gcmV0dXJuLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBhY3Rpb25DcmVhdG9ycyBBbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBhY3Rpb25cbiAqIGNyZWF0b3IgZnVuY3Rpb25zLiBPbmUgaGFuZHkgd2F5IHRvIG9idGFpbiBpdCBpcyB0byB1c2UgRVM2IGBpbXBvcnQgKiBhc2BcbiAqIHN5bnRheC4gWW91IG1heSBhbHNvIHBhc3MgYSBzaW5nbGUgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZGlzcGF0Y2ggVGhlIGBkaXNwYXRjaGAgZnVuY3Rpb24gYXZhaWxhYmxlIG9uIHlvdXIgUmVkdXhcbiAqIHN0b3JlLlxuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbnxPYmplY3R9IFRoZSBvYmplY3QgbWltaWNraW5nIHRoZSBvcmlnaW5hbCBvYmplY3QsIGJ1dCB3aXRoXG4gKiBldmVyeSBhY3Rpb24gY3JlYXRvciB3cmFwcGVkIGludG8gdGhlIGBkaXNwYXRjaGAgY2FsbC4gSWYgeW91IHBhc3NlZCBhXG4gKiBmdW5jdGlvbiBhcyBgYWN0aW9uQ3JlYXRvcnNgLCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgYWxzbyBiZSBhIHNpbmdsZVxuICogZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9ycyhhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpIHtcbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyAhPT0gJ29iamVjdCcgfHwgYWN0aW9uQ3JlYXRvcnMgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBY3Rpb25DcmVhdG9ycyBleHBlY3RlZCBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvbiwgaW5zdGVhZCByZWNlaXZlZCAnICsgKGFjdGlvbkNyZWF0b3JzID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIGFjdGlvbkNyZWF0b3JzKSArICcuICcgKyAnRGlkIHlvdSB3cml0ZSBcImltcG9ydCBBY3Rpb25DcmVhdG9ycyBmcm9tXCIgaW5zdGVhZCBvZiBcImltcG9ydCAqIGFzIEFjdGlvbkNyZWF0b3JzIGZyb21cIj8nKTtcbiAgfVxuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWN0aW9uQ3JlYXRvcnMpO1xuICB2YXIgYm91bmRBY3Rpb25DcmVhdG9ycyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICB2YXIgYWN0aW9uQ3JlYXRvciA9IGFjdGlvbkNyZWF0b3JzW2tleV07XG4gICAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBib3VuZEFjdGlvbkNyZWF0b3JzW2tleV0gPSBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9yLCBkaXNwYXRjaCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBib3VuZEFjdGlvbkNyZWF0b3JzO1xufSIsIi8qKlxuICogQ29tcG9zZXMgc2luZ2xlLWFyZ3VtZW50IGZ1bmN0aW9ucyBmcm9tIHJpZ2h0IHRvIGxlZnQuIFRoZSByaWdodG1vc3RcbiAqIGZ1bmN0aW9uIGNhbiB0YWtlIG11bHRpcGxlIGFyZ3VtZW50cyBhcyBpdCBwcm92aWRlcyB0aGUgc2lnbmF0dXJlIGZvclxuICogdGhlIHJlc3VsdGluZyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gZnVuY3MgVGhlIGZ1bmN0aW9ucyB0byBjb21wb3NlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIG9idGFpbmVkIGJ5IGNvbXBvc2luZyB0aGUgYXJndW1lbnQgZnVuY3Rpb25zXG4gKiBmcm9tIHJpZ2h0IHRvIGxlZnQuIEZvciBleGFtcGxlLCBjb21wb3NlKGYsIGcsIGgpIGlzIGlkZW50aWNhbCB0byBkb2luZ1xuICogKC4uLmFyZ3MpID0+IGYoZyhoKC4uLmFyZ3MpKSkuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcG9zZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZ1bmNzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgZnVuY3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAoZnVuY3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIHJldHVybiBhcmc7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChmdW5jcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZnVuY3NbMF07XG4gIH1cblxuICByZXR1cm4gZnVuY3MucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhKGIuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KTtcbn0iLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5pbXBvcnQgY29tcG9zZSBmcm9tICcuL2NvbXBvc2UnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdG9yZSBlbmhhbmNlciB0aGF0IGFwcGxpZXMgbWlkZGxld2FyZSB0byB0aGUgZGlzcGF0Y2ggbWV0aG9kXG4gKiBvZiB0aGUgUmVkdXggc3RvcmUuIFRoaXMgaXMgaGFuZHkgZm9yIGEgdmFyaWV0eSBvZiB0YXNrcywgc3VjaCBhcyBleHByZXNzaW5nXG4gKiBhc3luY2hyb25vdXMgYWN0aW9ucyBpbiBhIGNvbmNpc2UgbWFubmVyLCBvciBsb2dnaW5nIGV2ZXJ5IGFjdGlvbiBwYXlsb2FkLlxuICpcbiAqIFNlZSBgcmVkdXgtdGh1bmtgIHBhY2thZ2UgYXMgYW4gZXhhbXBsZSBvZiB0aGUgUmVkdXggbWlkZGxld2FyZS5cbiAqXG4gKiBCZWNhdXNlIG1pZGRsZXdhcmUgaXMgcG90ZW50aWFsbHkgYXN5bmNocm9ub3VzLCB0aGlzIHNob3VsZCBiZSB0aGUgZmlyc3RcbiAqIHN0b3JlIGVuaGFuY2VyIGluIHRoZSBjb21wb3NpdGlvbiBjaGFpbi5cbiAqXG4gKiBOb3RlIHRoYXQgZWFjaCBtaWRkbGV3YXJlIHdpbGwgYmUgZ2l2ZW4gdGhlIGBkaXNwYXRjaGAgYW5kIGBnZXRTdGF0ZWAgZnVuY3Rpb25zXG4gKiBhcyBuYW1lZCBhcmd1bWVudHMuXG4gKlxuICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gbWlkZGxld2FyZXMgVGhlIG1pZGRsZXdhcmUgY2hhaW4gdG8gYmUgYXBwbGllZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBzdG9yZSBlbmhhbmNlciBhcHBseWluZyB0aGUgbWlkZGxld2FyZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXBwbHlNaWRkbGV3YXJlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbWlkZGxld2FyZXMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBtaWRkbGV3YXJlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoY3JlYXRlU3RvcmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBlbmhhbmNlcikge1xuICAgICAgdmFyIHN0b3JlID0gY3JlYXRlU3RvcmUocmVkdWNlciwgcHJlbG9hZGVkU3RhdGUsIGVuaGFuY2VyKTtcbiAgICAgIHZhciBfZGlzcGF0Y2ggPSBzdG9yZS5kaXNwYXRjaDtcbiAgICAgIHZhciBjaGFpbiA9IFtdO1xuXG4gICAgICB2YXIgbWlkZGxld2FyZUFQSSA9IHtcbiAgICAgICAgZ2V0U3RhdGU6IHN0b3JlLmdldFN0YXRlLFxuICAgICAgICBkaXNwYXRjaDogZnVuY3Rpb24gZGlzcGF0Y2goYWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIF9kaXNwYXRjaChhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY2hhaW4gPSBtaWRkbGV3YXJlcy5tYXAoZnVuY3Rpb24gKG1pZGRsZXdhcmUpIHtcbiAgICAgICAgcmV0dXJuIG1pZGRsZXdhcmUobWlkZGxld2FyZUFQSSk7XG4gICAgICB9KTtcbiAgICAgIF9kaXNwYXRjaCA9IGNvbXBvc2UuYXBwbHkodW5kZWZpbmVkLCBjaGFpbikoc3RvcmUuZGlzcGF0Y2gpO1xuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0b3JlLCB7XG4gICAgICAgIGRpc3BhdGNoOiBfZGlzcGF0Y2hcbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG59IiwiaW1wb3J0IGNyZWF0ZVN0b3JlIGZyb20gJy4vY3JlYXRlU3RvcmUnO1xuaW1wb3J0IGNvbWJpbmVSZWR1Y2VycyBmcm9tICcuL2NvbWJpbmVSZWR1Y2Vycyc7XG5pbXBvcnQgYmluZEFjdGlvbkNyZWF0b3JzIGZyb20gJy4vYmluZEFjdGlvbkNyZWF0b3JzJztcbmltcG9ydCBhcHBseU1pZGRsZXdhcmUgZnJvbSAnLi9hcHBseU1pZGRsZXdhcmUnO1xuaW1wb3J0IGNvbXBvc2UgZnJvbSAnLi9jb21wb3NlJztcbmltcG9ydCB3YXJuaW5nIGZyb20gJy4vdXRpbHMvd2FybmluZyc7XG5cbi8qXG4qIFRoaXMgaXMgYSBkdW1teSBmdW5jdGlvbiB0byBjaGVjayBpZiB0aGUgZnVuY3Rpb24gbmFtZSBoYXMgYmVlbiBhbHRlcmVkIGJ5IG1pbmlmaWNhdGlvbi5cbiogSWYgdGhlIGZ1bmN0aW9uIGhhcyBiZWVuIG1pbmlmaWVkIGFuZCBOT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLCB3YXJuIHRoZSB1c2VyLlxuKi9cbmZ1bmN0aW9uIGlzQ3J1c2hlZCgpIHt9XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBpc0NydXNoZWQubmFtZSA9PT0gJ3N0cmluZycgJiYgaXNDcnVzaGVkLm5hbWUgIT09ICdpc0NydXNoZWQnKSB7XG4gIHdhcm5pbmcoJ1lvdSBhcmUgY3VycmVudGx5IHVzaW5nIG1pbmlmaWVkIGNvZGUgb3V0c2lkZSBvZiBOT0RFX0VOViA9PT0gXFwncHJvZHVjdGlvblxcJy4gJyArICdUaGlzIG1lYW5zIHRoYXQgeW91IGFyZSBydW5uaW5nIGEgc2xvd2VyIGRldmVsb3BtZW50IGJ1aWxkIG9mIFJlZHV4LiAnICsgJ1lvdSBjYW4gdXNlIGxvb3NlLWVudmlmeSAoaHR0cHM6Ly9naXRodWIuY29tL3plcnRvc2gvbG9vc2UtZW52aWZ5KSBmb3IgYnJvd3NlcmlmeSAnICsgJ29yIERlZmluZVBsdWdpbiBmb3Igd2VicGFjayAoaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zMDAzMDAzMSkgJyArICd0byBlbnN1cmUgeW91IGhhdmUgdGhlIGNvcnJlY3QgY29kZSBmb3IgeW91ciBwcm9kdWN0aW9uIGJ1aWxkLicpO1xufVxuXG5leHBvcnQgeyBjcmVhdGVTdG9yZSwgY29tYmluZVJlZHVjZXJzLCBiaW5kQWN0aW9uQ3JlYXRvcnMsIGFwcGx5TWlkZGxld2FyZSwgY29tcG9zZSB9OyIsImV4cG9ydCB2YXIgcHJlZml4ID0gJ0BAcmVkdXgtZm9ybS8nO1xuZXhwb3J0IHZhciBBUlJBWV9JTlNFUlQgPSBwcmVmaXggKyBcIkFSUkFZX0lOU0VSVFwiO1xuZXhwb3J0IHZhciBBUlJBWV9NT1ZFID0gcHJlZml4ICsgXCJBUlJBWV9NT1ZFXCI7XG5leHBvcnQgdmFyIEFSUkFZX1BPUCA9IHByZWZpeCArIFwiQVJSQVlfUE9QXCI7XG5leHBvcnQgdmFyIEFSUkFZX1BVU0ggPSBwcmVmaXggKyBcIkFSUkFZX1BVU0hcIjtcbmV4cG9ydCB2YXIgQVJSQVlfUkVNT1ZFID0gcHJlZml4ICsgXCJBUlJBWV9SRU1PVkVcIjtcbmV4cG9ydCB2YXIgQVJSQVlfUkVNT1ZFX0FMTCA9IHByZWZpeCArIFwiQVJSQVlfUkVNT1ZFX0FMTFwiO1xuZXhwb3J0IHZhciBBUlJBWV9TSElGVCA9IHByZWZpeCArIFwiQVJSQVlfU0hJRlRcIjtcbmV4cG9ydCB2YXIgQVJSQVlfU1BMSUNFID0gcHJlZml4ICsgXCJBUlJBWV9TUExJQ0VcIjtcbmV4cG9ydCB2YXIgQVJSQVlfVU5TSElGVCA9IHByZWZpeCArIFwiQVJSQVlfVU5TSElGVFwiO1xuZXhwb3J0IHZhciBBUlJBWV9TV0FQID0gcHJlZml4ICsgXCJBUlJBWV9TV0FQXCI7XG5leHBvcnQgdmFyIEFVVE9GSUxMID0gcHJlZml4ICsgXCJBVVRPRklMTFwiO1xuZXhwb3J0IHZhciBCTFVSID0gcHJlZml4ICsgXCJCTFVSXCI7XG5leHBvcnQgdmFyIENIQU5HRSA9IHByZWZpeCArIFwiQ0hBTkdFXCI7XG5leHBvcnQgdmFyIENMRUFSX0ZJRUxEUyA9IHByZWZpeCArIFwiQ0xFQVJfRklFTERTXCI7XG5leHBvcnQgdmFyIENMRUFSX1NVQk1JVCA9IHByZWZpeCArIFwiQ0xFQVJfU1VCTUlUXCI7XG5leHBvcnQgdmFyIENMRUFSX1NVQk1JVF9FUlJPUlMgPSBwcmVmaXggKyBcIkNMRUFSX1NVQk1JVF9FUlJPUlNcIjtcbmV4cG9ydCB2YXIgQ0xFQVJfQVNZTkNfRVJST1IgPSBwcmVmaXggKyBcIkNMRUFSX0FTWU5DX0VSUk9SXCI7XG5leHBvcnQgdmFyIERFU1RST1kgPSBwcmVmaXggKyBcIkRFU1RST1lcIjtcbmV4cG9ydCB2YXIgRk9DVVMgPSBwcmVmaXggKyBcIkZPQ1VTXCI7XG5leHBvcnQgdmFyIElOSVRJQUxJWkUgPSBwcmVmaXggKyBcIklOSVRJQUxJWkVcIjtcbmV4cG9ydCB2YXIgUkVHSVNURVJfRklFTEQgPSBwcmVmaXggKyBcIlJFR0lTVEVSX0ZJRUxEXCI7XG5leHBvcnQgdmFyIFJFU0VUID0gcHJlZml4ICsgXCJSRVNFVFwiO1xuZXhwb3J0IHZhciBSRVNFVF9TRUNUSU9OID0gcHJlZml4ICsgXCJSRVNFVF9TRUNUSU9OXCI7XG5leHBvcnQgdmFyIFNFVF9TVUJNSVRfRkFJTEVEID0gcHJlZml4ICsgXCJTRVRfU1VCTUlUX0ZBSUxFRFwiO1xuZXhwb3J0IHZhciBTRVRfU1VCTUlUX1NVQ0NFRURFRCA9IHByZWZpeCArIFwiU0VUX1NVQk1JVF9TVUNDRUVERURcIjtcbmV4cG9ydCB2YXIgU1RBUlRfQVNZTkNfVkFMSURBVElPTiA9IHByZWZpeCArIFwiU1RBUlRfQVNZTkNfVkFMSURBVElPTlwiO1xuZXhwb3J0IHZhciBTVEFSVF9TVUJNSVQgPSBwcmVmaXggKyBcIlNUQVJUX1NVQk1JVFwiO1xuZXhwb3J0IHZhciBTVE9QX0FTWU5DX1ZBTElEQVRJT04gPSBwcmVmaXggKyBcIlNUT1BfQVNZTkNfVkFMSURBVElPTlwiO1xuZXhwb3J0IHZhciBTVE9QX1NVQk1JVCA9IHByZWZpeCArIFwiU1RPUF9TVUJNSVRcIjtcbmV4cG9ydCB2YXIgU1VCTUlUID0gcHJlZml4ICsgXCJTVUJNSVRcIjtcbmV4cG9ydCB2YXIgVE9VQ0ggPSBwcmVmaXggKyBcIlRPVUNIXCI7XG5leHBvcnQgdmFyIFVOUkVHSVNURVJfRklFTEQgPSBwcmVmaXggKyBcIlVOUkVHSVNURVJfRklFTERcIjtcbmV4cG9ydCB2YXIgVU5UT1VDSCA9IHByZWZpeCArIFwiVU5UT1VDSFwiO1xuZXhwb3J0IHZhciBVUERBVEVfU1lOQ19FUlJPUlMgPSBwcmVmaXggKyBcIlVQREFURV9TWU5DX0VSUk9SU1wiO1xuZXhwb3J0IHZhciBVUERBVEVfU1lOQ19XQVJOSU5HUyA9IHByZWZpeCArIFwiVVBEQVRFX1NZTkNfV0FSTklOR1NcIjsiLCJpbXBvcnQgX3RvUGF0aCBmcm9tIFwibG9kYXNoL3RvUGF0aFwiO1xuXG5mdW5jdGlvbiBjcmVhdGVEZWxldGVJbldpdGhDbGVhblVwKHN0cnVjdHVyZSkge1xuICB2YXIgc2hvdWxkRGVsZXRlRGVmYXVsdCA9IGZ1bmN0aW9uIHNob3VsZERlbGV0ZURlZmF1bHQoc3RydWN0dXJlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgcGF0aCkge1xuICAgICAgcmV0dXJuIHN0cnVjdHVyZS5nZXRJbihzdGF0ZSwgcGF0aCkgIT09IHVuZGVmaW5lZDtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBkZWVwRXF1YWwgPSBzdHJ1Y3R1cmUuZGVlcEVxdWFsLFxuICAgICAgZW1wdHkgPSBzdHJ1Y3R1cmUuZW1wdHksXG4gICAgICBnZXRJbiA9IHN0cnVjdHVyZS5nZXRJbixcbiAgICAgIGRlbGV0ZUluID0gc3RydWN0dXJlLmRlbGV0ZUluLFxuICAgICAgc2V0SW4gPSBzdHJ1Y3R1cmUuc2V0SW47XG4gIHJldHVybiBmdW5jdGlvbiAoc2hvdWxkRGVsZXRlKSB7XG4gICAgaWYgKHNob3VsZERlbGV0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzaG91bGREZWxldGUgPSBzaG91bGREZWxldGVEZWZhdWx0O1xuICAgIH1cblxuICAgIHZhciBkZWxldGVJbldpdGhDbGVhblVwID0gZnVuY3Rpb24gZGVsZXRlSW5XaXRoQ2xlYW5VcChzdGF0ZSwgcGF0aCkge1xuICAgICAgaWYgKHBhdGhbcGF0aC5sZW5ndGggLSAxXSA9PT0gJ10nKSB7XG4gICAgICAgIC8vIGFycmF5IHBhdGhcbiAgICAgICAgdmFyIHBhdGhUb2tlbnMgPSBfdG9QYXRoKHBhdGgpO1xuXG4gICAgICAgIHBhdGhUb2tlbnMucG9wKCk7XG4gICAgICAgIHZhciBwYXJlbnQgPSBnZXRJbihzdGF0ZSwgcGF0aFRva2Vucy5qb2luKCcuJykpO1xuICAgICAgICByZXR1cm4gcGFyZW50ID8gc2V0SW4oc3RhdGUsIHBhdGgpIDogc3RhdGU7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBzdGF0ZTtcblxuICAgICAgaWYgKHNob3VsZERlbGV0ZShzdHJ1Y3R1cmUpKHN0YXRlLCBwYXRoKSkge1xuICAgICAgICByZXN1bHQgPSBkZWxldGVJbihzdGF0ZSwgcGF0aCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkb3RJbmRleCA9IHBhdGgubGFzdEluZGV4T2YoJy4nKTtcblxuICAgICAgaWYgKGRvdEluZGV4ID4gMCkge1xuICAgICAgICB2YXIgcGFyZW50UGF0aCA9IHBhdGguc3Vic3RyaW5nKDAsIGRvdEluZGV4KTtcblxuICAgICAgICBpZiAocGFyZW50UGF0aFtwYXJlbnRQYXRoLmxlbmd0aCAtIDFdICE9PSAnXScpIHtcbiAgICAgICAgICB2YXIgX3BhcmVudCA9IGdldEluKHJlc3VsdCwgcGFyZW50UGF0aCk7XG5cbiAgICAgICAgICBpZiAoZGVlcEVxdWFsKF9wYXJlbnQsIGVtcHR5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZUluV2l0aENsZWFuVXAocmVzdWx0LCBwYXJlbnRQYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRlbGV0ZUluV2l0aENsZWFuVXA7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZURlbGV0ZUluV2l0aENsZWFuVXA7IiwidmFyIHNwbGljZSA9IGZ1bmN0aW9uIHNwbGljZShhcnJheSwgaW5kZXgsIHJlbW92ZU51bSwgdmFsdWUpIHtcbiAgYXJyYXkgPSBhcnJheSB8fCBbXTtcblxuICBpZiAoaW5kZXggPCBhcnJheS5sZW5ndGgpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhcmVtb3ZlTnVtKSB7XG4gICAgICAvLyBpbnNlcnRpbmcgdW5kZWZpbmVkXG4gICAgICB2YXIgX2NvcHkyID0gW10uY29uY2F0KGFycmF5KTtcblxuICAgICAgX2NvcHkyLnNwbGljZShpbmRleCwgMCwgdHJ1ZSk7IC8vIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuXG5cbiAgICAgIF9jb3B5MltpbmRleF0gPSB1bmRlZmluZWQ7IC8vIHNldCB0byB1bmRlZmluZWRcblxuICAgICAgcmV0dXJuIF9jb3B5MjtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgdmFyIF9jb3B5MyA9IFtdLmNvbmNhdChhcnJheSk7XG5cbiAgICAgIF9jb3B5My5zcGxpY2UoaW5kZXgsIHJlbW92ZU51bSwgdmFsdWUpOyAvLyByZW1vdmluZyBhbmQgYWRkaW5nXG5cblxuICAgICAgcmV0dXJuIF9jb3B5MztcbiAgICB9XG5cbiAgICB2YXIgX2NvcHkgPSBbXS5jb25jYXQoYXJyYXkpO1xuXG4gICAgX2NvcHkuc3BsaWNlKGluZGV4LCByZW1vdmVOdW0pOyAvLyByZW1vdmluZ1xuXG5cbiAgICByZXR1cm4gX2NvcHk7XG4gIH1cblxuICBpZiAocmVtb3ZlTnVtKSB7XG4gICAgLy8gdHJ5aW5nIHRvIHJlbW92ZSBub24tZXhpc3RhbnQgaXRlbTogcmV0dXJuIG9yaWdpbmFsIGFycmF5XG4gICAgcmV0dXJuIGFycmF5O1xuICB9IC8vIHRyeWluZyB0byBhZGQgb3V0c2lkZSBvZiByYW5nZToganVzdCBzZXQgdmFsdWVcblxuXG4gIHZhciBjb3B5ID0gW10uY29uY2F0KGFycmF5KTtcbiAgY29weVtpbmRleF0gPSB2YWx1ZTtcbiAgcmV0dXJuIGNvcHk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBzcGxpY2U7IiwiaW1wb3J0IF90b1BhdGggZnJvbSBcImxvZGFzaC90b1BhdGhcIjtcblxudmFyIGdldEluID0gZnVuY3Rpb24gZ2V0SW4oc3RhdGUsIGZpZWxkKSB7XG4gIGlmICghc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICB2YXIgcGF0aCA9IF90b1BhdGgoZmllbGQpO1xuXG4gIHZhciBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICBpZiAoIWxlbmd0aCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gc3RhdGU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGggJiYgcmVzdWx0OyArK2kpIHtcbiAgICByZXN1bHQgPSByZXN1bHRbcGF0aFtpXV07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZ2V0SW47IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2V4dGVuZHNcIjtcbmltcG9ydCBfdG9QYXRoIGZyb20gXCJsb2Rhc2gvdG9QYXRoXCI7XG5cbnZhciBzZXRJbldpdGhQYXRoID0gZnVuY3Rpb24gc2V0SW5XaXRoUGF0aChzdGF0ZSwgdmFsdWUsIHBhdGgsIHBhdGhJbmRleCkge1xuICB2YXIgX2V4dGVuZHMyO1xuXG4gIGlmIChwYXRoSW5kZXggPj0gcGF0aC5sZW5ndGgpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICB2YXIgZmlyc3QgPSBwYXRoW3BhdGhJbmRleF07XG4gIHZhciBmaXJzdFN0YXRlID0gc3RhdGUgJiYgKEFycmF5LmlzQXJyYXkoc3RhdGUpID8gc3RhdGVbTnVtYmVyKGZpcnN0KV0gOiBzdGF0ZVtmaXJzdF0pO1xuICB2YXIgbmV4dCA9IHNldEluV2l0aFBhdGgoZmlyc3RTdGF0ZSwgdmFsdWUsIHBhdGgsIHBhdGhJbmRleCArIDEpO1xuXG4gIGlmICghc3RhdGUpIHtcbiAgICBpZiAoaXNOYU4oZmlyc3QpKSB7XG4gICAgICB2YXIgX3JlZjtcblxuICAgICAgcmV0dXJuIF9yZWYgPSB7fSwgX3JlZltmaXJzdF0gPSBuZXh0LCBfcmVmO1xuICAgIH1cblxuICAgIHZhciBpbml0aWFsaXplZCA9IFtdO1xuICAgIGluaXRpYWxpemVkW3BhcnNlSW50KGZpcnN0LCAxMCldID0gbmV4dDtcbiAgICByZXR1cm4gaW5pdGlhbGl6ZWQ7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShzdGF0ZSkpIHtcbiAgICB2YXIgY29weSA9IFtdLmNvbmNhdChzdGF0ZSk7XG4gICAgY29weVtwYXJzZUludChmaXJzdCwgMTApXSA9IG5leHQ7XG4gICAgcmV0dXJuIGNvcHk7XG4gIH1cblxuICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCAoX2V4dGVuZHMyID0ge30sIF9leHRlbmRzMltmaXJzdF0gPSBuZXh0LCBfZXh0ZW5kczIpKTtcbn07XG5cbnZhciBzZXRJbiA9IGZ1bmN0aW9uIHNldEluKHN0YXRlLCBmaWVsZCwgdmFsdWUpIHtcbiAgcmV0dXJuIHNldEluV2l0aFBhdGgoc3RhdGUsIHZhbHVlLCBfdG9QYXRoKGZpZWxkKSwgMCk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBzZXRJbjsiLCJpbXBvcnQgX2lzRXF1YWxXaXRoIGZyb20gXCJsb2Rhc2gvaXNFcXVhbFdpdGhcIjtcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbnZhciBjdXN0b21pemVyID0gZnVuY3Rpb24gY3VzdG9taXplcihvYmosIG90aGVyKSB7XG4gIGlmIChvYmogPT09IG90aGVyKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoIW9iaiAmJiAhb3RoZXIpIHtcbiAgICB2YXIgb2JqSXNFbXB0eSA9IG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHVuZGVmaW5lZCB8fCBvYmogPT09ICcnO1xuICAgIHZhciBvdGhlcklzRW1wdHkgPSBvdGhlciA9PT0gbnVsbCB8fCBvdGhlciA9PT0gdW5kZWZpbmVkIHx8IG90aGVyID09PSAnJztcbiAgICByZXR1cm4gb2JqSXNFbXB0eSA9PT0gb3RoZXJJc0VtcHR5O1xuICB9XG5cbiAgaWYgKG9iaiAmJiBvdGhlciAmJiBvYmouX2Vycm9yICE9PSBvdGhlci5fZXJyb3IpIHJldHVybiBmYWxzZTtcbiAgaWYgKG9iaiAmJiBvdGhlciAmJiBvYmouX3dhcm5pbmcgIT09IG90aGVyLl93YXJuaW5nKSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWFjdC5pc1ZhbGlkRWxlbWVudChvYmopIHx8IFJlYWN0LmlzVmFsaWRFbGVtZW50KG90aGVyKSkgcmV0dXJuIGZhbHNlO1xufTtcblxudmFyIGRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhLCBiKSB7XG4gIHJldHVybiBfaXNFcXVhbFdpdGgoYSwgYiwgY3VzdG9taXplcik7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBkZWVwRXF1YWw7IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2V4dGVuZHNcIjtcbmltcG9ydCBfdG9QYXRoIGZyb20gXCJsb2Rhc2gvdG9QYXRoXCI7XG5cbmZ1bmN0aW9uIGRlbGV0ZUluV2l0aFBhdGgoc3RhdGUsIGZpcnN0KSB7XG4gIGlmIChzdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHN0YXRlID09PSBudWxsIHx8IGZpcnN0ID09PSB1bmRlZmluZWQgfHwgZmlyc3QgPT09IG51bGwpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgcmVzdFtfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAocmVzdC5sZW5ndGgpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdGF0ZSkpIHtcbiAgICAgIGlmIChpc05hTihmaXJzdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBhY2Nlc3MgYXJyYXkgZWxlbWVudHMgd2l0aCBhIG51bWJlciwgbm90IFxcXCJcIiArIFN0cmluZyhmaXJzdCkgKyBcIlxcXCIuXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmlyc3RJbmRleCA9IE51bWJlcihmaXJzdCk7XG5cbiAgICAgIGlmIChmaXJzdEluZGV4IDwgc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBkZWxldGVJbldpdGhQYXRoLmFwcGx5KHZvaWQgMCwgW3N0YXRlICYmIHN0YXRlW2ZpcnN0SW5kZXhdXS5jb25jYXQocmVzdCkpO1xuXG4gICAgICAgIGlmIChyZXN1bHQgIT09IHN0YXRlW2ZpcnN0SW5kZXhdKSB7XG4gICAgICAgICAgdmFyIGNvcHkgPSBbXS5jb25jYXQoc3RhdGUpO1xuICAgICAgICAgIGNvcHlbZmlyc3RJbmRleF0gPSByZXN1bHQ7XG4gICAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cblxuICAgIGlmIChmaXJzdCBpbiBzdGF0ZSkge1xuICAgICAgdmFyIF9leHRlbmRzMjtcblxuICAgICAgdmFyIF9yZXN1bHQgPSBkZWxldGVJbldpdGhQYXRoLmFwcGx5KHZvaWQgMCwgW3N0YXRlICYmIHN0YXRlW2ZpcnN0XV0uY29uY2F0KHJlc3QpKTtcblxuICAgICAgcmV0dXJuIHN0YXRlW2ZpcnN0XSA9PT0gX3Jlc3VsdCA/IHN0YXRlIDogX2V4dGVuZHMoe30sIHN0YXRlLCAoX2V4dGVuZHMyID0ge30sIF9leHRlbmRzMltmaXJzdF0gPSBfcmVzdWx0LCBfZXh0ZW5kczIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShzdGF0ZSkpIHtcbiAgICBpZiAoaXNOYU4oZmlyc3QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZGVsZXRlIG5vbi1udW1lcmljYWwgaW5kZXggZnJvbSBhbiBhcnJheS4gR2l2ZW46IFxcXCJcIiArIFN0cmluZyhmaXJzdCkpO1xuICAgIH1cblxuICAgIHZhciBfZmlyc3RJbmRleCA9IE51bWJlcihmaXJzdCk7XG5cbiAgICBpZiAoX2ZpcnN0SW5kZXggPCBzdGF0ZS5sZW5ndGgpIHtcbiAgICAgIHZhciBfY29weSA9IFtdLmNvbmNhdChzdGF0ZSk7XG5cbiAgICAgIF9jb3B5LnNwbGljZShfZmlyc3RJbmRleCwgMSk7XG5cbiAgICAgIHJldHVybiBfY29weTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBpZiAoZmlyc3QgaW4gc3RhdGUpIHtcbiAgICB2YXIgX2NvcHkyID0gX2V4dGVuZHMoe30sIHN0YXRlKTtcblxuICAgIGRlbGV0ZSBfY29weTJbZmlyc3RdO1xuICAgIHJldHVybiBfY29weTI7XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59XG5cbnZhciBkZWxldGVJbiA9IGZ1bmN0aW9uIGRlbGV0ZUluKHN0YXRlLCBmaWVsZCkge1xuICByZXR1cm4gZGVsZXRlSW5XaXRoUGF0aC5hcHBseSh2b2lkIDAsIFtzdGF0ZV0uY29uY2F0KF90b1BhdGgoZmllbGQpKSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBkZWxldGVJbjsiLCJmdW5jdGlvbiBrZXlzKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gaS5uYW1lO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQga2V5czsiLCJpbXBvcnQgc3BsaWNlIGZyb20gJy4vc3BsaWNlJztcbmltcG9ydCBnZXRJbiBmcm9tICcuL2dldEluJztcbmltcG9ydCBzZXRJbiBmcm9tICcuL3NldEluJztcbmltcG9ydCBkZWVwRXF1YWwgZnJvbSAnLi9kZWVwRXF1YWwnO1xuaW1wb3J0IGRlbGV0ZUluIGZyb20gJy4vZGVsZXRlSW4nO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzJztcbnZhciBzdHJ1Y3R1cmUgPSB7XG4gIGFsbG93c0FycmF5RXJyb3JzOiB0cnVlLFxuICBlbXB0eToge30sXG4gIGVtcHR5TGlzdDogW10sXG4gIGdldEluOiBnZXRJbixcbiAgc2V0SW46IHNldEluLFxuICBkZWVwRXF1YWw6IGRlZXBFcXVhbCxcbiAgZGVsZXRlSW46IGRlbGV0ZUluLFxuICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGl0ZW1zLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBpdGVtcy5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgfSxcbiAgZnJvbUpTOiBmdW5jdGlvbiBmcm9tSlModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIGtleXM6IGtleXMsXG4gIHNpemU6IGZ1bmN0aW9uIHNpemUoYXJyYXkpIHtcbiAgICByZXR1cm4gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICB9LFxuICBzb21lOiBmdW5jdGlvbiBzb21lKGl0ZW1zLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBpdGVtcy5zb21lKGNhbGxiYWNrKTtcbiAgfSxcbiAgc3BsaWNlOiBzcGxpY2UsXG4gIGVxdWFsczogZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gYi5ldmVyeShmdW5jdGlvbiAodmFsKSB7XG4gICAgICByZXR1cm4gfmEuaW5kZXhPZih2YWwpO1xuICAgIH0pO1xuICB9LFxuICBvcmRlckNoYW5nZWQ6IGZ1bmN0aW9uIG9yZGVyQ2hhbmdlZChhLCBiKSB7XG4gICAgcmV0dXJuIGIuc29tZShmdW5jdGlvbiAodmFsLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHZhbCAhPT0gYVtpbmRleF07XG4gICAgfSk7XG4gIH0sXG4gIHRvSlM6IGZ1bmN0aW9uIHRvSlModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn07XG5leHBvcnQgZGVmYXVsdCBzdHJ1Y3R1cmU7IiwiaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2VcIjtcbmltcG9ydCBfaXNGdW5jdGlvbiBmcm9tIFwibG9kYXNoL2lzRnVuY3Rpb25cIjtcbmltcG9ydCB7IEFSUkFZX0lOU0VSVCwgQVJSQVlfTU9WRSwgQVJSQVlfUE9QLCBBUlJBWV9QVVNILCBBUlJBWV9SRU1PVkUsIEFSUkFZX1JFTU9WRV9BTEwsIEFSUkFZX1NISUZULCBBUlJBWV9TUExJQ0UsIEFSUkFZX1NXQVAsIEFSUkFZX1VOU0hJRlQsIEFVVE9GSUxMLCBCTFVSLCBDSEFOR0UsIENMRUFSX0FTWU5DX0VSUk9SLCBDTEVBUl9TVUJNSVQsIENMRUFSX1NVQk1JVF9FUlJPUlMsIERFU1RST1ksIEZPQ1VTLCBJTklUSUFMSVpFLCBwcmVmaXgsIFJFR0lTVEVSX0ZJRUxELCBSRVNFVCwgUkVTRVRfU0VDVElPTiwgU0VUX1NVQk1JVF9GQUlMRUQsIFNFVF9TVUJNSVRfU1VDQ0VFREVELCBTVEFSVF9BU1lOQ19WQUxJREFUSU9OLCBTVEFSVF9TVUJNSVQsIFNUT1BfQVNZTkNfVkFMSURBVElPTiwgU1RPUF9TVUJNSVQsIFNVQk1JVCwgVE9VQ0gsIFVOUkVHSVNURVJfRklFTEQsIFVOVE9VQ0gsIFVQREFURV9TWU5DX0VSUk9SUywgQ0xFQVJfRklFTERTLCBVUERBVEVfU1lOQ19XQVJOSU5HUyB9IGZyb20gJy4vYWN0aW9uVHlwZXMnO1xuaW1wb3J0IGNyZWF0ZURlbGV0ZUluV2l0aENsZWFuVXAgZnJvbSAnLi9kZWxldGVJbldpdGhDbGVhblVwJztcbmltcG9ydCBwbGFpbiBmcm9tICcuL3N0cnVjdHVyZS9wbGFpbic7XG5cbnZhciBzaG91bGREZWxldGUgPSBmdW5jdGlvbiBzaG91bGREZWxldGUoX3JlZikge1xuICB2YXIgZ2V0SW4gPSBfcmVmLmdldEluO1xuICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBwYXRoKSB7XG4gICAgdmFyIGluaXRpYWxWYWx1ZXNQYXRoID0gbnVsbDtcblxuICAgIGlmICgvXnZhbHVlcy8udGVzdChwYXRoKSkge1xuICAgICAgaW5pdGlhbFZhbHVlc1BhdGggPSBwYXRoLnJlcGxhY2UoJ3ZhbHVlcycsICdpbml0aWFsJyk7XG4gICAgfVxuXG4gICAgdmFyIGluaXRpYWxWYWx1ZUNvbXBhcmlzb24gPSBpbml0aWFsVmFsdWVzUGF0aCA/IGdldEluKHN0YXRlLCBpbml0aWFsVmFsdWVzUGF0aCkgPT09IHVuZGVmaW5lZCA6IHRydWU7XG4gICAgcmV0dXJuIGdldEluKHN0YXRlLCBwYXRoKSAhPT0gdW5kZWZpbmVkICYmIGluaXRpYWxWYWx1ZUNvbXBhcmlzb247XG4gIH07XG59O1xuXG52YXIgaXNSZWR1eEZvcm1BY3Rpb24gPSBmdW5jdGlvbiBpc1JlZHV4Rm9ybUFjdGlvbihhY3Rpb24pIHtcbiAgcmV0dXJuIGFjdGlvbiAmJiBhY3Rpb24udHlwZSAmJiBhY3Rpb24udHlwZS5sZW5ndGggPiBwcmVmaXgubGVuZ3RoICYmIGFjdGlvbi50eXBlLnN1YnN0cmluZygwLCBwcmVmaXgubGVuZ3RoKSA9PT0gcHJlZml4O1xufTtcblxuZnVuY3Rpb24gY3JlYXRlUmVkdWNlcihzdHJ1Y3R1cmUpIHtcbiAgdmFyIF9iZWhhdmlvcnM7XG5cbiAgdmFyIGRlZXBFcXVhbCA9IHN0cnVjdHVyZS5kZWVwRXF1YWwsXG4gICAgICBlbXB0eSA9IHN0cnVjdHVyZS5lbXB0eSxcbiAgICAgIGZvckVhY2ggPSBzdHJ1Y3R1cmUuZm9yRWFjaCxcbiAgICAgIGdldEluID0gc3RydWN0dXJlLmdldEluLFxuICAgICAgc2V0SW4gPSBzdHJ1Y3R1cmUuc2V0SW4sXG4gICAgICBkZWxldGVJbiA9IHN0cnVjdHVyZS5kZWxldGVJbixcbiAgICAgIGZyb21KUyA9IHN0cnVjdHVyZS5mcm9tSlMsXG4gICAgICBrZXlzID0gc3RydWN0dXJlLmtleXMsXG4gICAgICBzaXplID0gc3RydWN0dXJlLnNpemUsXG4gICAgICBzb21lID0gc3RydWN0dXJlLnNvbWUsXG4gICAgICBzcGxpY2UgPSBzdHJ1Y3R1cmUuc3BsaWNlO1xuICB2YXIgZGVsZXRlSW5XaXRoQ2xlYW5VcCA9IGNyZWF0ZURlbGV0ZUluV2l0aENsZWFuVXAoc3RydWN0dXJlKShzaG91bGREZWxldGUpO1xuICB2YXIgcGxhaW5EZWxldGVJbldpdGhDbGVhblVwID0gY3JlYXRlRGVsZXRlSW5XaXRoQ2xlYW5VcChwbGFpbikoc2hvdWxkRGVsZXRlKTtcblxuICB2YXIgZG9TcGxpY2UgPSBmdW5jdGlvbiBkb1NwbGljZShzdGF0ZSwga2V5LCBmaWVsZCwgaW5kZXgsIHJlbW92ZU51bSwgdmFsdWUsIGZvcmNlKSB7XG4gICAgdmFyIGV4aXN0aW5nID0gZ2V0SW4oc3RhdGUsIGtleSArIFwiLlwiICsgZmllbGQpO1xuICAgIHJldHVybiBleGlzdGluZyB8fCBmb3JjZSA/IHNldEluKHN0YXRlLCBrZXkgKyBcIi5cIiArIGZpZWxkLCBzcGxpY2UoZXhpc3RpbmcsIGluZGV4LCByZW1vdmVOdW0sIHZhbHVlKSkgOiBzdGF0ZTtcbiAgfTtcblxuICB2YXIgZG9QbGFpblNwbGljZSA9IGZ1bmN0aW9uIGRvUGxhaW5TcGxpY2Uoc3RhdGUsIGtleSwgZmllbGQsIGluZGV4LCByZW1vdmVOdW0sIHZhbHVlLCBmb3JjZSkge1xuICAgIHZhciBzbGljZSA9IGdldEluKHN0YXRlLCBrZXkpO1xuICAgIHZhciBleGlzdGluZyA9IHBsYWluLmdldEluKHNsaWNlLCBmaWVsZCk7XG4gICAgcmV0dXJuIGV4aXN0aW5nIHx8IGZvcmNlID8gc2V0SW4oc3RhdGUsIGtleSwgcGxhaW4uc2V0SW4oc2xpY2UsIGZpZWxkLCBwbGFpbi5zcGxpY2UoZXhpc3RpbmcsIGluZGV4LCByZW1vdmVOdW0sIHZhbHVlKSkpIDogc3RhdGU7XG4gIH07XG5cbiAgdmFyIHJvb3RLZXlzID0gWyd2YWx1ZXMnLCAnZmllbGRzJywgJ3N1Ym1pdEVycm9ycycsICdhc3luY0Vycm9ycyddO1xuXG4gIHZhciBhcnJheVNwbGljZSA9IGZ1bmN0aW9uIGFycmF5U3BsaWNlKHN0YXRlLCBmaWVsZCwgaW5kZXgsIHJlbW92ZU51bSwgdmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gc3RhdGU7XG4gICAgdmFyIG5vblZhbHVlc1ZhbHVlID0gdmFsdWUgIT0gbnVsbCA/IGVtcHR5IDogdW5kZWZpbmVkO1xuICAgIHJlc3VsdCA9IGRvU3BsaWNlKHJlc3VsdCwgJ3ZhbHVlcycsIGZpZWxkLCBpbmRleCwgcmVtb3ZlTnVtLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgcmVzdWx0ID0gZG9TcGxpY2UocmVzdWx0LCAnZmllbGRzJywgZmllbGQsIGluZGV4LCByZW1vdmVOdW0sIG5vblZhbHVlc1ZhbHVlKTtcbiAgICByZXN1bHQgPSBkb1BsYWluU3BsaWNlKHJlc3VsdCwgJ3N5bmNFcnJvcnMnLCBmaWVsZCwgaW5kZXgsIHJlbW92ZU51bSwgdW5kZWZpbmVkKTtcbiAgICByZXN1bHQgPSBkb1BsYWluU3BsaWNlKHJlc3VsdCwgJ3N5bmNXYXJuaW5ncycsIGZpZWxkLCBpbmRleCwgcmVtb3ZlTnVtLCB1bmRlZmluZWQpO1xuICAgIHJlc3VsdCA9IGRvU3BsaWNlKHJlc3VsdCwgJ3N1Ym1pdEVycm9ycycsIGZpZWxkLCBpbmRleCwgcmVtb3ZlTnVtLCB1bmRlZmluZWQpO1xuICAgIHJlc3VsdCA9IGRvU3BsaWNlKHJlc3VsdCwgJ2FzeW5jRXJyb3JzJywgZmllbGQsIGluZGV4LCByZW1vdmVOdW0sIHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgYmVoYXZpb3JzID0gKF9iZWhhdmlvcnMgPSB7fSwgX2JlaGF2aW9yc1tBUlJBWV9JTlNFUlRdID0gZnVuY3Rpb24gKHN0YXRlLCBfcmVmMikge1xuICAgIHZhciBfcmVmMiRtZXRhID0gX3JlZjIubWV0YSxcbiAgICAgICAgZmllbGQgPSBfcmVmMiRtZXRhLmZpZWxkLFxuICAgICAgICBpbmRleCA9IF9yZWYyJG1ldGEuaW5kZXgsXG4gICAgICAgIHBheWxvYWQgPSBfcmVmMi5wYXlsb2FkO1xuICAgIHJldHVybiBhcnJheVNwbGljZShzdGF0ZSwgZmllbGQsIGluZGV4LCAwLCBwYXlsb2FkKTtcbiAgfSwgX2JlaGF2aW9yc1tBUlJBWV9NT1ZFXSA9IGZ1bmN0aW9uIChzdGF0ZSwgX3JlZjMpIHtcbiAgICB2YXIgX3JlZjMkbWV0YSA9IF9yZWYzLm1ldGEsXG4gICAgICAgIGZpZWxkID0gX3JlZjMkbWV0YS5maWVsZCxcbiAgICAgICAgZnJvbSA9IF9yZWYzJG1ldGEuZnJvbSxcbiAgICAgICAgdG8gPSBfcmVmMyRtZXRhLnRvO1xuICAgIHZhciBhcnJheSA9IGdldEluKHN0YXRlLCBcInZhbHVlcy5cIiArIGZpZWxkKTtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBzaXplKGFycmF5KSA6IDA7XG4gICAgdmFyIHJlc3VsdCA9IHN0YXRlO1xuXG4gICAgaWYgKGxlbmd0aCkge1xuICAgICAgcm9vdEtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBwYXRoID0ga2V5ICsgXCIuXCIgKyBmaWVsZDtcblxuICAgICAgICBpZiAoZ2V0SW4ocmVzdWx0LCBwYXRoKSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGdldEluKHJlc3VsdCwgcGF0aCArIFwiW1wiICsgZnJvbSArIFwiXVwiKTtcbiAgICAgICAgICByZXN1bHQgPSBzZXRJbihyZXN1bHQsIHBhdGgsIHNwbGljZShnZXRJbihyZXN1bHQsIHBhdGgpLCBmcm9tLCAxKSk7IC8vIHJlbW92ZVxuXG4gICAgICAgICAgcmVzdWx0ID0gc2V0SW4ocmVzdWx0LCBwYXRoLCBzcGxpY2UoZ2V0SW4ocmVzdWx0LCBwYXRoKSwgdG8sIDAsIHZhbHVlKSk7IC8vIGluc2VydFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCBfYmVoYXZpb3JzW0FSUkFZX1BPUF0gPSBmdW5jdGlvbiAoc3RhdGUsIF9yZWY0KSB7XG4gICAgdmFyIGZpZWxkID0gX3JlZjQubWV0YS5maWVsZDtcbiAgICB2YXIgYXJyYXkgPSBnZXRJbihzdGF0ZSwgXCJ2YWx1ZXMuXCIgKyBmaWVsZCk7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gc2l6ZShhcnJheSkgOiAwO1xuICAgIHJldHVybiBsZW5ndGggPyBhcnJheVNwbGljZShzdGF0ZSwgZmllbGQsIGxlbmd0aCAtIDEsIDEpIDogc3RhdGU7XG4gIH0sIF9iZWhhdmlvcnNbQVJSQVlfUFVTSF0gPSBmdW5jdGlvbiAoc3RhdGUsIF9yZWY1KSB7XG4gICAgdmFyIGZpZWxkID0gX3JlZjUubWV0YS5maWVsZCxcbiAgICAgICAgcGF5bG9hZCA9IF9yZWY1LnBheWxvYWQ7XG4gICAgdmFyIGFycmF5ID0gZ2V0SW4oc3RhdGUsIFwidmFsdWVzLlwiICsgZmllbGQpO1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA/IHNpemUoYXJyYXkpIDogMDtcbiAgICByZXR1cm4gYXJyYXlTcGxpY2Uoc3RhdGUsIGZpZWxkLCBsZW5ndGgsIDAsIHBheWxvYWQpO1xuICB9LCBfYmVoYXZpb3JzW0FSUkFZX1JFTU9WRV0gPSBmdW5jdGlvbiAoc3RhdGUsIF9yZWY2KSB7XG4gICAgdmFyIF9yZWY2JG1ldGEgPSBfcmVmNi5tZXRhLFxuICAgICAgICBmaWVsZCA9IF9yZWY2JG1ldGEuZmllbGQsXG4gICAgICAgIGluZGV4ID0gX3JlZjYkbWV0YS5pbmRleDtcbiAgICByZXR1cm4gYXJyYXlTcGxpY2Uoc3RhdGUsIGZpZWxkLCBpbmRleCwgMSk7XG4gIH0sIF9iZWhhdmlvcnNbQVJSQVlfUkVNT1ZFX0FMTF0gPSBmdW5jdGlvbiAoc3RhdGUsIF9yZWY3KSB7XG4gICAgdmFyIGZpZWxkID0gX3JlZjcubWV0YS5maWVsZDtcbiAgICB2YXIgYXJyYXkgPSBnZXRJbihzdGF0ZSwgXCJ2YWx1ZXMuXCIgKyBmaWVsZCk7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gc2l6ZShhcnJheSkgOiAwO1xuICAgIHJldHVybiBsZW5ndGggPyBhcnJheVNwbGljZShzdGF0ZSwgZmllbGQsIDAsIGxlbmd0aCkgOiBzdGF0ZTtcbiAgfSwgX2JlaGF2aW9yc1tBUlJBWV9TSElGVF0gPSBmdW5jdGlvbiAoc3RhdGUsIF9yZWY4KSB7XG4gICAgdmFyIGZpZWxkID0gX3JlZjgubWV0YS5maWVsZDtcbiAgICByZXR1cm4gYXJyYXlTcGxpY2Uoc3RhdGUsIGZpZWxkLCAwLCAxKTtcbiAgfSwgX2JlaGF2aW9yc1tBUlJBWV9TUExJQ0VdID0gZnVuY3Rpb24gKHN0YXRlLCBfcmVmOSkge1xuICAgIHZhciBfcmVmOSRtZXRhID0gX3JlZjkubWV0YSxcbiAgICAgICAgZmllbGQgPSBfcmVmOSRtZXRhLmZpZWxkLFxuICAgICAgICBpbmRleCA9IF9yZWY5JG1ldGEuaW5kZXgsXG4gICAgICAgIHJlbW92ZU51bSA9IF9yZWY5JG1ldGEucmVtb3ZlTnVtLFxuICAgICAgICBwYXlsb2FkID0gX3JlZjkucGF5bG9hZDtcbiAgICByZXR1cm4gYXJyYXlTcGxpY2Uoc3RhdGUsIGZpZWxkLCBpbmRleCwgcmVtb3ZlTnVtLCBwYXlsb2FkKTtcbiAgfSwgX2JlaGF2aW9yc1tBUlJBWV9TV0FQXSA9IGZ1bmN0aW9uIChzdGF0ZSwgX3JlZjEwKSB7XG4gICAgdmFyIF9yZWYxMCRtZXRhID0gX3JlZjEwLm1ldGEsXG4gICAgICAgIGZpZWxkID0gX3JlZjEwJG1ldGEuZmllbGQsXG4gICAgICAgIGluZGV4QSA9IF9yZWYxMCRtZXRhLmluZGV4QSxcbiAgICAgICAgaW5kZXhCID0gX3JlZjEwJG1ldGEuaW5kZXhCO1xuICAgIHZhciByZXN1bHQgPSBzdGF0ZTtcbiAgICByb290S2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciB2YWx1ZUEgPSBnZXRJbihyZXN1bHQsIGtleSArIFwiLlwiICsgZmllbGQgKyBcIltcIiArIGluZGV4QSArIFwiXVwiKTtcbiAgICAgIHZhciB2YWx1ZUIgPSBnZXRJbihyZXN1bHQsIGtleSArIFwiLlwiICsgZmllbGQgKyBcIltcIiArIGluZGV4QiArIFwiXVwiKTtcblxuICAgICAgaWYgKHZhbHVlQSAhPT0gdW5kZWZpbmVkIHx8IHZhbHVlQiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdCA9IHNldEluKHJlc3VsdCwga2V5ICsgXCIuXCIgKyBmaWVsZCArIFwiW1wiICsgaW5kZXhBICsgXCJdXCIsIHZhbHVlQik7XG4gICAgICAgIHJlc3VsdCA9IHNldEluKHJlc3VsdCwga2V5ICsgXCIuXCIgKyBmaWVsZCArIFwiW1wiICsgaW5kZXhCICsgXCJdXCIsIHZhbHVlQSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgX2JlaGF2aW9yc1tBUlJBWV9VTlNISUZUXSA9IGZ1bmN0aW9uIChzdGF0ZSwgX3JlZjExKSB7XG4gICAgdmFyIGZpZWxkID0gX3JlZjExLm1ldGEuZmllbGQsXG4gICAgICAgIHBheWxvYWQgPSBfcmVmMTEucGF5bG9hZDtcbiAgICByZXR1cm4gYXJyYXlTcGxpY2Uoc3RhdGUsIGZpZWxkLCAwLCAwLCBwYXlsb2FkKTtcbiAgfSwgX2JlaGF2aW9yc1tBVVRPRklMTF0gPSBmdW5jdGlvbiAoc3RhdGUsIF9yZWYxMikge1xuICAgIHZhciBmaWVsZCA9IF9yZWYxMi5tZXRhLmZpZWxkLFxuICAgICAgICBwYXlsb2FkID0gX3JlZjEyLnBheWxvYWQ7XG4gICAgdmFyIHJlc3VsdCA9IHN0YXRlO1xuICAgIHJlc3VsdCA9IGRlbGV0ZUluV2l0aENsZWFuVXAocmVzdWx0LCBcImFzeW5jRXJyb3JzLlwiICsgZmllbGQpO1xuICAgIHJlc3VsdCA9IGRlbGV0ZUluV2l0aENsZWFuVXAocmVzdWx0LCBcInN1Ym1pdEVycm9ycy5cIiArIGZpZWxkKTtcbiAgICByZXN1bHQgPSBzZXRJbihyZXN1bHQsIFwiZmllbGRzLlwiICsgZmllbGQgKyBcIi5hdXRvZmlsbGVkXCIsIHRydWUpO1xuICAgIHJlc3VsdCA9IHNldEluKHJlc3VsdCwgXCJ2YWx1ZXMuXCIgKyBmaWVsZCwgcGF5bG9hZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgX2JlaGF2aW9yc1tCTFVSXSA9IGZ1bmN0aW9uIChzdGF0ZSwgX3JlZjEzKSB7XG4gICAgdmFyIF9yZWYxMyRtZXRhID0gX3JlZjEzLm1ldGEsXG4gICAgICAgIGZpZWxkID0gX3JlZjEzJG1ldGEuZmllbGQsXG4gICAgICAgIHRvdWNoID0gX3JlZjEzJG1ldGEudG91Y2gsXG4gICAgICAgIHBheWxvYWQgPSBfcmVmMTMucGF5bG9hZDtcbiAgICB2YXIgcmVzdWx0ID0gc3RhdGU7XG4gICAgdmFyIGluaXRpYWwgPSBnZXRJbihyZXN1bHQsIFwiaW5pdGlhbC5cIiArIGZpZWxkKTtcblxuICAgIGlmIChpbml0aWFsID09PSB1bmRlZmluZWQgJiYgcGF5bG9hZCA9PT0gJycpIHtcbiAgICAgIHJlc3VsdCA9IGRlbGV0ZUluV2l0aENsZWFuVXAocmVzdWx0LCBcInZhbHVlcy5cIiArIGZpZWxkKTtcbiAgICB9IGVsc2UgaWYgKHBheWxvYWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVzdWx0ID0gc2V0SW4ocmVzdWx0LCBcInZhbHVlcy5cIiArIGZpZWxkLCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICBpZiAoZmllbGQgPT09IGdldEluKHJlc3VsdCwgJ2FjdGl2ZScpKSB7XG4gICAgICByZXN1bHQgPSBkZWxldGVJbihyZXN1bHQsICdhY3RpdmUnKTtcbiAgICB9XG5cbiAgICByZXN1bHQgPSBkZWxldGVJbihyZXN1bHQsIFwiZmllbGRzLlwiICsgZmllbGQgKyBcIi5hY3RpdmVcIik7XG5cbiAgICBpZiAodG91Y2gpIHtcbiAgICAgIHJlc3VsdCA9IHNldEluKHJlc3VsdCwgXCJmaWVsZHMuXCIgKyBmaWVsZCArIFwiLnRvdWNoZWRcIiwgdHJ1ZSk7XG4gICAgICByZXN1bHQgPSBzZXRJbihyZXN1bHQsICdhbnlUb3VjaGVkJywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgX2JlaGF2aW9yc1tDSEFOR0VdID0gZnVuY3Rpb24gKHN0YXRlLCBfcmVmMTQpIHtcbiAgICB2YXIgX3JlZjE0JG1ldGEgPSBfcmVmMTQubWV0YSxcbiAgICAgICAgZmllbGQgPSBfcmVmMTQkbWV0YS5maWVsZCxcbiAgICAgICAgdG91Y2ggPSBfcmVmMTQkbWV0YS50b3VjaCxcbiAgICAgICAgcGVyc2lzdGVudFN1Ym1pdEVycm9ycyA9IF9yZWYxNCRtZXRhLnBlcnNpc3RlbnRTdWJtaXRFcnJvcnMsXG4gICAgICAgIHBheWxvYWQgPSBfcmVmMTQucGF5bG9hZDtcbiAgICB2YXIgcmVzdWx0ID0gc3RhdGU7XG4gICAgdmFyIGluaXRpYWwgPSBnZXRJbihyZXN1bHQsIFwiaW5pdGlhbC5cIiArIGZpZWxkKTtcblxuICAgIGlmIChpbml0aWFsID09PSB1bmRlZmluZWQgJiYgcGF5bG9hZCA9PT0gJycpIHtcbiAgICAgIHJlc3VsdCA9IGRlbGV0ZUluV2l0aENsZWFuVXAocmVzdWx0LCBcInZhbHVlcy5cIiArIGZpZWxkKTtcbiAgICB9IGVsc2UgaWYgKF9pc0Z1bmN0aW9uKHBheWxvYWQpKSB7XG4gICAgICB2YXIgZmllbGRDdXJyZW50VmFsdWUgPSBnZXRJbihzdGF0ZSwgXCJ2YWx1ZXMuXCIgKyBmaWVsZCk7XG4gICAgICByZXN1bHQgPSBzZXRJbihyZXN1bHQsIFwidmFsdWVzLlwiICsgZmllbGQsIHBheWxvYWQoZmllbGRDdXJyZW50VmFsdWUsIHN0YXRlLnZhbHVlcykpO1xuICAgIH0gZWxzZSBpZiAocGF5bG9hZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXN1bHQgPSBzZXRJbihyZXN1bHQsIFwidmFsdWVzLlwiICsgZmllbGQsIHBheWxvYWQpO1xuICAgIH1cblxuICAgIHJlc3VsdCA9IGRlbGV0ZUluV2l0aENsZWFuVXAocmVzdWx0LCBcImFzeW5jRXJyb3JzLlwiICsgZmllbGQpO1xuXG4gICAgaWYgKCFwZXJzaXN0ZW50U3VibWl0RXJyb3JzKSB7XG4gICAgICByZXN1bHQgPSBkZWxldGVJbldpdGhDbGVhblVwKHJlc3VsdCwgXCJzdWJtaXRFcnJvcnMuXCIgKyBmaWVsZCk7XG4gICAgfVxuXG4gICAgcmVzdWx0ID0gZGVsZXRlSW5XaXRoQ2xlYW5VcChyZXN1bHQsIFwiZmllbGRzLlwiICsgZmllbGQgKyBcIi5hdXRvZmlsbGVkXCIpO1xuXG4gICAgaWYgKHRvdWNoKSB7XG4gICAgICByZXN1bHQgPSBzZXRJbihyZXN1bHQsIFwiZmllbGRzLlwiICsgZmllbGQgKyBcIi50b3VjaGVkXCIsIHRydWUpO1xuICAgICAgcmVzdWx0ID0gc2V0SW4ocmVzdWx0LCAnYW55VG91Y2hlZCcsIHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIF9iZWhhdmlvcnNbQ0xFQVJfU1VCTUlUXSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgIHJldHVybiBkZWxldGVJbihzdGF0ZSwgJ3RyaWdnZXJTdWJtaXQnKTtcbiAgfSwgX2JlaGF2aW9yc1tDTEVBUl9TVUJNSVRfRVJST1JTXSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBzdGF0ZTtcbiAgICByZXN1bHQgPSBkZWxldGVJbldpdGhDbGVhblVwKHJlc3VsdCwgJ3N1Ym1pdEVycm9ycycpO1xuICAgIHJlc3VsdCA9IGRlbGV0ZUluKHJlc3VsdCwgJ2Vycm9yJyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgX2JlaGF2aW9yc1tDTEVBUl9BU1lOQ19FUlJPUl0gPSBmdW5jdGlvbiAoc3RhdGUsIF9yZWYxNSkge1xuICAgIHZhciBmaWVsZCA9IF9yZWYxNS5tZXRhLmZpZWxkO1xuICAgIHJldHVybiBkZWxldGVJbihzdGF0ZSwgXCJhc3luY0Vycm9ycy5cIiArIGZpZWxkKTtcbiAgfSwgX2JlaGF2aW9yc1tDTEVBUl9GSUVMRFNdID0gZnVuY3Rpb24gKHN0YXRlLCBfcmVmMTYpIHtcbiAgICB2YXIgX3JlZjE2JG1ldGEgPSBfcmVmMTYubWV0YSxcbiAgICAgICAga2VlcFRvdWNoZWQgPSBfcmVmMTYkbWV0YS5rZWVwVG91Y2hlZCxcbiAgICAgICAgcGVyc2lzdGVudFN1Ym1pdEVycm9ycyA9IF9yZWYxNiRtZXRhLnBlcnNpc3RlbnRTdWJtaXRFcnJvcnMsXG4gICAgICAgIGZpZWxkcyA9IF9yZWYxNiRtZXRhLmZpZWxkcztcbiAgICB2YXIgcmVzdWx0ID0gc3RhdGU7XG4gICAgZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICByZXN1bHQgPSBkZWxldGVJbldpdGhDbGVhblVwKHJlc3VsdCwgXCJ2YWx1ZXMuXCIgKyBmaWVsZCk7XG4gICAgICByZXN1bHQgPSBkZWxldGVJbldpdGhDbGVhblVwKHJlc3VsdCwgXCJhc3luY0Vycm9ycy5cIiArIGZpZWxkKTtcblxuICAgICAgaWYgKCFwZXJzaXN0ZW50U3VibWl0RXJyb3JzKSB7XG4gICAgICAgIHJlc3VsdCA9IGRlbGV0ZUluV2l0aENsZWFuVXAocmVzdWx0LCBcInN1Ym1pdEVycm9ycy5cIiArIGZpZWxkKTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0ID0gZGVsZXRlSW5XaXRoQ2xlYW5VcChyZXN1bHQsIFwiZmllbGRzLlwiICsgZmllbGQgKyBcIi5hdXRvZmlsbGVkXCIpO1xuXG4gICAgICBpZiAoIWtlZXBUb3VjaGVkKSB7XG4gICAgICAgIHJlc3VsdCA9IGRlbGV0ZUluKHJlc3VsdCwgXCJmaWVsZHMuXCIgKyBmaWVsZCArIFwiLnRvdWNoZWRcIik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIGFueVRvdWNoZWQgPSBzb21lKGtleXMoZ2V0SW4ocmVzdWx0LCAncmVnaXN0ZXJlZEZpZWxkcycpKSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIGdldEluKHJlc3VsdCwgXCJmaWVsZHMuXCIgKyBrZXkgKyBcIi50b3VjaGVkXCIpO1xuICAgIH0pO1xuICAgIHJlc3VsdCA9IGFueVRvdWNoZWQgPyBzZXRJbihyZXN1bHQsICdhbnlUb3VjaGVkJywgdHJ1ZSkgOiBkZWxldGVJbihyZXN1bHQsICdhbnlUb3VjaGVkJyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgX2JlaGF2aW9yc1tGT0NVU10gPSBmdW5jdGlvbiAoc3RhdGUsIF9yZWYxNykge1xuICAgIHZhciBmaWVsZCA9IF9yZWYxNy5tZXRhLmZpZWxkO1xuICAgIHZhciByZXN1bHQgPSBzdGF0ZTtcbiAgICB2YXIgcHJldmlvdXNseUFjdGl2ZSA9IGdldEluKHN0YXRlLCAnYWN0aXZlJyk7XG4gICAgcmVzdWx0ID0gZGVsZXRlSW4ocmVzdWx0LCBcImZpZWxkcy5cIiArIHByZXZpb3VzbHlBY3RpdmUgKyBcIi5hY3RpdmVcIik7XG4gICAgcmVzdWx0ID0gc2V0SW4ocmVzdWx0LCBcImZpZWxkcy5cIiArIGZpZWxkICsgXCIudmlzaXRlZFwiLCB0cnVlKTtcbiAgICByZXN1bHQgPSBzZXRJbihyZXN1bHQsIFwiZmllbGRzLlwiICsgZmllbGQgKyBcIi5hY3RpdmVcIiwgdHJ1ZSk7XG4gICAgcmVzdWx0ID0gc2V0SW4ocmVzdWx0LCAnYWN0aXZlJywgZmllbGQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIF9iZWhhdmlvcnNbSU5JVElBTElaRV0gPSBmdW5jdGlvbiAoc3RhdGUsIF9yZWYxOCkge1xuICAgIHZhciBwYXlsb2FkID0gX3JlZjE4LnBheWxvYWQsXG4gICAgICAgIF9yZWYxOCRtZXRhID0gX3JlZjE4Lm1ldGEsXG4gICAgICAgIGtlZXBEaXJ0eSA9IF9yZWYxOCRtZXRhLmtlZXBEaXJ0eSxcbiAgICAgICAga2VlcFN1Ym1pdFN1Y2NlZWRlZCA9IF9yZWYxOCRtZXRhLmtlZXBTdWJtaXRTdWNjZWVkZWQsXG4gICAgICAgIHVwZGF0ZVVucmVnaXN0ZXJlZEZpZWxkcyA9IF9yZWYxOCRtZXRhLnVwZGF0ZVVucmVnaXN0ZXJlZEZpZWxkcyxcbiAgICAgICAga2VlcFZhbHVlcyA9IF9yZWYxOCRtZXRhLmtlZXBWYWx1ZXM7XG4gICAgdmFyIG1hcERhdGEgPSBmcm9tSlMocGF5bG9hZCk7XG4gICAgdmFyIHJlc3VsdCA9IGVtcHR5OyAvLyBjbGVhbiBhbGwgZmllbGQgc3RhdGVcbiAgICAvLyBwZXJzaXN0IG9sZCB3YXJuaW5ncywgdGhleSB3aWxsIGdldCByZWNhbGN1bGF0ZWQgaWYgdGhlIG5ldyBmb3JtIHZhbHVlcyBhcmUgZGlmZmVyZW50IGZyb20gdGhlIG9sZCB2YWx1ZXNcblxuICAgIHZhciB3YXJuaW5nID0gZ2V0SW4oc3RhdGUsICd3YXJuaW5nJyk7XG5cbiAgICBpZiAod2FybmluZykge1xuICAgICAgcmVzdWx0ID0gc2V0SW4ocmVzdWx0LCAnd2FybmluZycsIHdhcm5pbmcpO1xuICAgIH1cblxuICAgIHZhciBzeW5jV2FybmluZ3MgPSBnZXRJbihzdGF0ZSwgJ3N5bmNXYXJuaW5ncycpO1xuXG4gICAgaWYgKHN5bmNXYXJuaW5ncykge1xuICAgICAgcmVzdWx0ID0gc2V0SW4ocmVzdWx0LCAnc3luY1dhcm5pbmdzJywgc3luY1dhcm5pbmdzKTtcbiAgICB9IC8vIHBlcnNpc3Qgb2xkIGVycm9ycywgdGhleSB3aWxsIGdldCByZWNhbGN1bGF0ZWQgaWYgdGhlIG5ldyBmb3JtIHZhbHVlcyBhcmUgZGlmZmVyZW50IGZyb20gdGhlIG9sZCB2YWx1ZXNcblxuXG4gICAgdmFyIGVycm9yID0gZ2V0SW4oc3RhdGUsICdlcnJvcicpO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICByZXN1bHQgPSBzZXRJbihyZXN1bHQsICdlcnJvcicsIGVycm9yKTtcbiAgICB9XG5cbiAgICB2YXIgc3luY0Vycm9ycyA9IGdldEluKHN0YXRlLCAnc3luY0Vycm9ycycpO1xuXG4gICAgaWYgKHN5bmNFcnJvcnMpIHtcbiAgICAgIHJlc3VsdCA9IHNldEluKHJlc3VsdCwgJ3N5bmNFcnJvcnMnLCBzeW5jRXJyb3JzKTtcbiAgICB9XG5cbiAgICB2YXIgcmVnaXN0ZXJlZEZpZWxkcyA9IGdldEluKHN0YXRlLCAncmVnaXN0ZXJlZEZpZWxkcycpO1xuXG4gICAgaWYgKHJlZ2lzdGVyZWRGaWVsZHMpIHtcbiAgICAgIHJlc3VsdCA9IHNldEluKHJlc3VsdCwgJ3JlZ2lzdGVyZWRGaWVsZHMnLCByZWdpc3RlcmVkRmllbGRzKTtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNWYWx1ZXMgPSBnZXRJbihzdGF0ZSwgJ3ZhbHVlcycpO1xuICAgIHZhciBwcmV2aW91c0luaXRpYWxWYWx1ZXMgPSBnZXRJbihzdGF0ZSwgJ2luaXRpYWwnKTtcbiAgICB2YXIgbmV3SW5pdGlhbFZhbHVlcyA9IG1hcERhdGE7XG4gICAgdmFyIG5ld1ZhbHVlcyA9IHByZXZpb3VzVmFsdWVzO1xuXG4gICAgaWYgKGtlZXBEaXJ0eSAmJiByZWdpc3RlcmVkRmllbGRzKSB7XG4gICAgICBpZiAoIWRlZXBFcXVhbChuZXdJbml0aWFsVmFsdWVzLCBwcmV2aW91c0luaXRpYWxWYWx1ZXMpKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEtlZXAgdGhlIHZhbHVlIG9mIGRpcnR5IGZpZWxkcyB3aGlsZSB1cGRhdGluZyB0aGUgdmFsdWUgb2ZcbiAgICAgICAgLy8gcHJpc3RpbmUgZmllbGRzLiBUaGlzIHdheSwgYXBwcyBjYW4gcmVpbml0aWFsaXplIGZvcm1zIHdoaWxlXG4gICAgICAgIC8vIGF2b2lkaW5nIHN0b21waW5nIG9uIHVzZXIgZWRpdHMuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIE5vdGUgMTogVGhlIGluaXRpYWxpemUgYWN0aW9uIHJlcGxhY2VzIGFsbCBpbml0aWFsIHZhbHVlc1xuICAgICAgICAvLyByZWdhcmRsZXNzIG9mIGtlZXBEaXJ0eS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gTm90ZSAyOiBXaGVuIGEgZmllbGQgaXMgZGlydHksIGtlZXBEaXJ0eSBpcyBlbmFibGVkLCBhbmQgdGhlIGZpZWxkXG4gICAgICAgIC8vIHZhbHVlIGlzIHRoZSBzYW1lIGFzIHRoZSBuZXcgaW5pdGlhbCB2YWx1ZSBmb3IgdGhlIGZpZWxkLCB0aGVcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBhY3Rpb24gY2F1c2VzIHRoZSBmaWVsZCB0byBiZWNvbWUgcHJpc3RpbmUuIFRoYXQgZWZmZWN0XG4gICAgICAgIC8vIGlzIHdoYXQgd2Ugd2FudC5cbiAgICAgICAgLy9cbiAgICAgICAgdmFyIG92ZXJ3cml0ZVByaXN0aW5lVmFsdWUgPSBmdW5jdGlvbiBvdmVyd3JpdGVQcmlzdGluZVZhbHVlKG5hbWUpIHtcbiAgICAgICAgICB2YXIgcHJldmlvdXNJbml0aWFsVmFsdWUgPSBnZXRJbihwcmV2aW91c0luaXRpYWxWYWx1ZXMsIG5hbWUpO1xuICAgICAgICAgIHZhciBwcmV2aW91c1ZhbHVlID0gZ2V0SW4ocHJldmlvdXNWYWx1ZXMsIG5hbWUpO1xuXG4gICAgICAgICAgaWYgKGRlZXBFcXVhbChwcmV2aW91c1ZhbHVlLCBwcmV2aW91c0luaXRpYWxWYWx1ZSkpIHtcbiAgICAgICAgICAgIC8vIE92ZXJ3cml0ZSB0aGUgb2xkIHByaXN0aW5lIHZhbHVlIHdpdGggdGhlIG5ldyBwcmlzdGluZSB2YWx1ZVxuICAgICAgICAgICAgdmFyIG5ld0luaXRpYWxWYWx1ZSA9IGdldEluKG5ld0luaXRpYWxWYWx1ZXMsIG5hbWUpOyAvLyBUaGlzIGNoZWNrIHByZXZlbnRzIGFueSAnc2V0SW4nIGNhbGwgdGhhdCB3b3VsZCBjcmVhdGUgdXNlbGVzc1xuICAgICAgICAgICAgLy8gbmVzdGVkIG9iamVjdHMsIHNpbmNlIHRoZSBwYXRoIHRvIHRoZSBuZXcgZmllbGQgdmFsdWUgd291bGRcbiAgICAgICAgICAgIC8vIGV2YWx1YXRlIHRvIHRoZSBzYW1lIChlc3BlY2lhbGx5IGZvciB1bmRlZmluZWQgdmFsdWVzKVxuXG4gICAgICAgICAgICBpZiAoZ2V0SW4obmV3VmFsdWVzLCBuYW1lKSAhPT0gbmV3SW5pdGlhbFZhbHVlKSB7XG4gICAgICAgICAgICAgIG5ld1ZhbHVlcyA9IHNldEluKG5ld1ZhbHVlcywgbmFtZSwgbmV3SW5pdGlhbFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCF1cGRhdGVVbnJlZ2lzdGVyZWRGaWVsZHMpIHtcbiAgICAgICAgICBmb3JFYWNoKGtleXMocmVnaXN0ZXJlZEZpZWxkcyksIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gb3ZlcndyaXRlUHJpc3RpbmVWYWx1ZShuYW1lKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvckVhY2goa2V5cyhuZXdJbml0aWFsVmFsdWVzKSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICB2YXIgcHJldmlvdXNJbml0aWFsVmFsdWUgPSBnZXRJbihwcmV2aW91c0luaXRpYWxWYWx1ZXMsIG5hbWUpO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBwcmV2aW91c0luaXRpYWxWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIEFkZCBuZXcgdmFsdWVzIGF0IHRoZSByb290IGxldmVsLlxuICAgICAgICAgICAgdmFyIG5ld0luaXRpYWxWYWx1ZSA9IGdldEluKG5ld0luaXRpYWxWYWx1ZXMsIG5hbWUpO1xuICAgICAgICAgICAgbmV3VmFsdWVzID0gc2V0SW4obmV3VmFsdWVzLCBuYW1lLCBuZXdJbml0aWFsVmFsdWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh1cGRhdGVVbnJlZ2lzdGVyZWRGaWVsZHMpIHtcbiAgICAgICAgICAgIG92ZXJ3cml0ZVByaXN0aW5lVmFsdWUobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmV3VmFsdWVzID0gbmV3SW5pdGlhbFZhbHVlcztcbiAgICB9XG5cbiAgICBpZiAoa2VlcFZhbHVlcykge1xuICAgICAgZm9yRWFjaChrZXlzKHByZXZpb3VzVmFsdWVzKSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzVmFsdWUgPSBnZXRJbihwcmV2aW91c1ZhbHVlcywgbmFtZSk7XG4gICAgICAgIG5ld1ZhbHVlcyA9IHNldEluKG5ld1ZhbHVlcywgbmFtZSwgcHJldmlvdXNWYWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIGZvckVhY2goa2V5cyhwcmV2aW91c0luaXRpYWxWYWx1ZXMpLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgcHJldmlvdXNJbml0aWFsVmFsdWUgPSBnZXRJbihwcmV2aW91c0luaXRpYWxWYWx1ZXMsIG5hbWUpO1xuICAgICAgICBuZXdJbml0aWFsVmFsdWVzID0gc2V0SW4obmV3SW5pdGlhbFZhbHVlcywgbmFtZSwgcHJldmlvdXNJbml0aWFsVmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGtlZXBTdWJtaXRTdWNjZWVkZWQgJiYgZ2V0SW4oc3RhdGUsICdzdWJtaXRTdWNjZWVkZWQnKSkge1xuICAgICAgcmVzdWx0ID0gc2V0SW4ocmVzdWx0LCAnc3VibWl0U3VjY2VlZGVkJywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmVzdWx0ID0gc2V0SW4ocmVzdWx0LCAndmFsdWVzJywgbmV3VmFsdWVzKTtcbiAgICByZXN1bHQgPSBzZXRJbihyZXN1bHQsICdpbml0aWFsJywgbmV3SW5pdGlhbFZhbHVlcyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgX2JlaGF2aW9yc1tSRUdJU1RFUl9GSUVMRF0gPSBmdW5jdGlvbiAoc3RhdGUsIF9yZWYxOSkge1xuICAgIHZhciBfcmVmMTkkcGF5bG9hZCA9IF9yZWYxOS5wYXlsb2FkLFxuICAgICAgICBuYW1lID0gX3JlZjE5JHBheWxvYWQubmFtZSxcbiAgICAgICAgdHlwZSA9IF9yZWYxOSRwYXlsb2FkLnR5cGU7XG4gICAgdmFyIGtleSA9IFwicmVnaXN0ZXJlZEZpZWxkc1snXCIgKyBuYW1lICsgXCInXVwiO1xuICAgIHZhciBmaWVsZCA9IGdldEluKHN0YXRlLCBrZXkpO1xuXG4gICAgaWYgKGZpZWxkKSB7XG4gICAgICB2YXIgY291bnQgPSBnZXRJbihmaWVsZCwgJ2NvdW50JykgKyAxO1xuICAgICAgZmllbGQgPSBzZXRJbihmaWVsZCwgJ2NvdW50JywgY291bnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaWVsZCA9IGZyb21KUyh7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIGNvdW50OiAxXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2V0SW4oc3RhdGUsIGtleSwgZmllbGQpO1xuICB9LCBfYmVoYXZpb3JzW1JFU0VUXSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBlbXB0eTtcbiAgICB2YXIgcmVnaXN0ZXJlZEZpZWxkcyA9IGdldEluKHN0YXRlLCAncmVnaXN0ZXJlZEZpZWxkcycpO1xuXG4gICAgaWYgKHJlZ2lzdGVyZWRGaWVsZHMpIHtcbiAgICAgIHJlc3VsdCA9IHNldEluKHJlc3VsdCwgJ3JlZ2lzdGVyZWRGaWVsZHMnLCByZWdpc3RlcmVkRmllbGRzKTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWVzID0gZ2V0SW4oc3RhdGUsICdpbml0aWFsJyk7XG5cbiAgICBpZiAodmFsdWVzKSB7XG4gICAgICByZXN1bHQgPSBzZXRJbihyZXN1bHQsICd2YWx1ZXMnLCB2YWx1ZXMpO1xuICAgICAgcmVzdWx0ID0gc2V0SW4ocmVzdWx0LCAnaW5pdGlhbCcsIHZhbHVlcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgX2JlaGF2aW9yc1tSRVNFVF9TRUNUSU9OXSA9IGZ1bmN0aW9uIChzdGF0ZSwgX3JlZjIwKSB7XG4gICAgdmFyIHNlY3Rpb25zID0gX3JlZjIwLm1ldGEuc2VjdGlvbnM7XG4gICAgdmFyIHJlc3VsdCA9IHN0YXRlO1xuICAgIHNlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKHNlY3Rpb24pIHtcbiAgICAgIHJlc3VsdCA9IGRlbGV0ZUluV2l0aENsZWFuVXAocmVzdWx0LCBcImFzeW5jRXJyb3JzLlwiICsgc2VjdGlvbik7XG4gICAgICByZXN1bHQgPSBkZWxldGVJbldpdGhDbGVhblVwKHJlc3VsdCwgXCJzdWJtaXRFcnJvcnMuXCIgKyBzZWN0aW9uKTtcbiAgICAgIHJlc3VsdCA9IGRlbGV0ZUluV2l0aENsZWFuVXAocmVzdWx0LCBcImZpZWxkcy5cIiArIHNlY3Rpb24pO1xuICAgICAgdmFyIHZhbHVlcyA9IGdldEluKHN0YXRlLCBcImluaXRpYWwuXCIgKyBzZWN0aW9uKTtcbiAgICAgIHJlc3VsdCA9IHZhbHVlcyA/IHNldEluKHJlc3VsdCwgXCJ2YWx1ZXMuXCIgKyBzZWN0aW9uLCB2YWx1ZXMpIDogZGVsZXRlSW5XaXRoQ2xlYW5VcChyZXN1bHQsIFwidmFsdWVzLlwiICsgc2VjdGlvbik7XG4gICAgfSk7XG4gICAgdmFyIGFueVRvdWNoZWQgPSBzb21lKGtleXMoZ2V0SW4ocmVzdWx0LCAncmVnaXN0ZXJlZEZpZWxkcycpKSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIGdldEluKHJlc3VsdCwgXCJmaWVsZHMuXCIgKyBrZXkgKyBcIi50b3VjaGVkXCIpO1xuICAgIH0pO1xuICAgIHJlc3VsdCA9IGFueVRvdWNoZWQgPyBzZXRJbihyZXN1bHQsICdhbnlUb3VjaGVkJywgdHJ1ZSkgOiBkZWxldGVJbihyZXN1bHQsICdhbnlUb3VjaGVkJyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgX2JlaGF2aW9yc1tTVUJNSVRdID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgcmV0dXJuIHNldEluKHN0YXRlLCAndHJpZ2dlclN1Ym1pdCcsIHRydWUpO1xuICB9LCBfYmVoYXZpb3JzW1NUQVJUX0FTWU5DX1ZBTElEQVRJT05dID0gZnVuY3Rpb24gKHN0YXRlLCBfcmVmMjEpIHtcbiAgICB2YXIgZmllbGQgPSBfcmVmMjEubWV0YS5maWVsZDtcbiAgICByZXR1cm4gc2V0SW4oc3RhdGUsICdhc3luY1ZhbGlkYXRpbmcnLCBmaWVsZCB8fCB0cnVlKTtcbiAgfSwgX2JlaGF2aW9yc1tTVEFSVF9TVUJNSVRdID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgcmV0dXJuIHNldEluKHN0YXRlLCAnc3VibWl0dGluZycsIHRydWUpO1xuICB9LCBfYmVoYXZpb3JzW1NUT1BfQVNZTkNfVkFMSURBVElPTl0gPSBmdW5jdGlvbiAoc3RhdGUsIF9yZWYyMikge1xuICAgIHZhciBwYXlsb2FkID0gX3JlZjIyLnBheWxvYWQ7XG4gICAgdmFyIHJlc3VsdCA9IHN0YXRlO1xuICAgIHJlc3VsdCA9IGRlbGV0ZUluKHJlc3VsdCwgJ2FzeW5jVmFsaWRhdGluZycpO1xuXG4gICAgaWYgKHBheWxvYWQgJiYgT2JqZWN0LmtleXMocGF5bG9hZCkubGVuZ3RoKSB7XG4gICAgICB2YXIgX2Vycm9yID0gcGF5bG9hZC5fZXJyb3IsXG4gICAgICAgICAgZmllbGRFcnJvcnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwYXlsb2FkLCBbXCJfZXJyb3JcIl0pO1xuXG4gICAgICBpZiAoX2Vycm9yKSB7XG4gICAgICAgIHJlc3VsdCA9IHNldEluKHJlc3VsdCwgJ2Vycm9yJywgX2Vycm9yKTtcbiAgICAgIH1cblxuICAgICAgaWYgKE9iamVjdC5rZXlzKGZpZWxkRXJyb3JzKS5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0ID0gc2V0SW4ocmVzdWx0LCAnYXN5bmNFcnJvcnMnLCBmcm9tSlMoZmllbGRFcnJvcnMpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gZGVsZXRlSW4ocmVzdWx0LCAnZXJyb3InKTtcbiAgICAgIHJlc3VsdCA9IGRlbGV0ZUluKHJlc3VsdCwgJ2FzeW5jRXJyb3JzJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgX2JlaGF2aW9yc1tTVE9QX1NVQk1JVF0gPSBmdW5jdGlvbiAoc3RhdGUsIF9yZWYyMykge1xuICAgIHZhciBwYXlsb2FkID0gX3JlZjIzLnBheWxvYWQ7XG4gICAgdmFyIHJlc3VsdCA9IHN0YXRlO1xuICAgIHJlc3VsdCA9IGRlbGV0ZUluKHJlc3VsdCwgJ3N1Ym1pdHRpbmcnKTtcbiAgICByZXN1bHQgPSBkZWxldGVJbihyZXN1bHQsICdzdWJtaXRGYWlsZWQnKTtcbiAgICByZXN1bHQgPSBkZWxldGVJbihyZXN1bHQsICdzdWJtaXRTdWNjZWVkZWQnKTtcblxuICAgIGlmIChwYXlsb2FkICYmIE9iamVjdC5rZXlzKHBheWxvYWQpLmxlbmd0aCkge1xuICAgICAgdmFyIF9lcnJvciA9IHBheWxvYWQuX2Vycm9yLFxuICAgICAgICAgIGZpZWxkRXJyb3JzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocGF5bG9hZCwgW1wiX2Vycm9yXCJdKTtcblxuICAgICAgaWYgKF9lcnJvcikge1xuICAgICAgICByZXN1bHQgPSBzZXRJbihyZXN1bHQsICdlcnJvcicsIF9lcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBkZWxldGVJbihyZXN1bHQsICdlcnJvcicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoT2JqZWN0LmtleXMoZmllbGRFcnJvcnMpLmxlbmd0aCkge1xuICAgICAgICByZXN1bHQgPSBzZXRJbihyZXN1bHQsICdzdWJtaXRFcnJvcnMnLCBmcm9tSlMoZmllbGRFcnJvcnMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGRlbGV0ZUluKHJlc3VsdCwgJ3N1Ym1pdEVycm9ycycpO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQgPSBzZXRJbihyZXN1bHQsICdzdWJtaXRGYWlsZWQnLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gZGVsZXRlSW4ocmVzdWx0LCAnZXJyb3InKTtcbiAgICAgIHJlc3VsdCA9IGRlbGV0ZUluKHJlc3VsdCwgJ3N1Ym1pdEVycm9ycycpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIF9iZWhhdmlvcnNbU0VUX1NVQk1JVF9GQUlMRURdID0gZnVuY3Rpb24gKHN0YXRlLCBfcmVmMjQpIHtcbiAgICB2YXIgZmllbGRzID0gX3JlZjI0Lm1ldGEuZmllbGRzO1xuICAgIHZhciByZXN1bHQgPSBzdGF0ZTtcbiAgICByZXN1bHQgPSBzZXRJbihyZXN1bHQsICdzdWJtaXRGYWlsZWQnLCB0cnVlKTtcbiAgICByZXN1bHQgPSBkZWxldGVJbihyZXN1bHQsICdzdWJtaXRTdWNjZWVkZWQnKTtcbiAgICByZXN1bHQgPSBkZWxldGVJbihyZXN1bHQsICdzdWJtaXR0aW5nJyk7XG4gICAgZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICByZXR1cm4gcmVzdWx0ID0gc2V0SW4ocmVzdWx0LCBcImZpZWxkcy5cIiArIGZpZWxkICsgXCIudG91Y2hlZFwiLCB0cnVlKTtcbiAgICB9KTtcblxuICAgIGlmIChmaWVsZHMubGVuZ3RoKSB7XG4gICAgICByZXN1bHQgPSBzZXRJbihyZXN1bHQsICdhbnlUb3VjaGVkJywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgX2JlaGF2aW9yc1tTRVRfU1VCTUlUX1NVQ0NFRURFRF0gPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gc3RhdGU7XG4gICAgcmVzdWx0ID0gZGVsZXRlSW4ocmVzdWx0LCAnc3VibWl0RmFpbGVkJyk7XG4gICAgcmVzdWx0ID0gc2V0SW4ocmVzdWx0LCAnc3VibWl0U3VjY2VlZGVkJywgdHJ1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgX2JlaGF2aW9yc1tUT1VDSF0gPSBmdW5jdGlvbiAoc3RhdGUsIF9yZWYyNSkge1xuICAgIHZhciBmaWVsZHMgPSBfcmVmMjUubWV0YS5maWVsZHM7XG4gICAgdmFyIHJlc3VsdCA9IHN0YXRlO1xuICAgIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCA9IHNldEluKHJlc3VsdCwgXCJmaWVsZHMuXCIgKyBmaWVsZCArIFwiLnRvdWNoZWRcIiwgdHJ1ZSk7XG4gICAgfSk7XG4gICAgcmVzdWx0ID0gc2V0SW4ocmVzdWx0LCAnYW55VG91Y2hlZCcsIHRydWUpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIF9iZWhhdmlvcnNbVU5SRUdJU1RFUl9GSUVMRF0gPSBmdW5jdGlvbiAoc3RhdGUsIF9yZWYyNikge1xuICAgIHZhciBfcmVmMjYkcGF5bG9hZCA9IF9yZWYyNi5wYXlsb2FkLFxuICAgICAgICBuYW1lID0gX3JlZjI2JHBheWxvYWQubmFtZSxcbiAgICAgICAgZGVzdHJveU9uVW5tb3VudCA9IF9yZWYyNiRwYXlsb2FkLmRlc3Ryb3lPblVubW91bnQ7XG4gICAgdmFyIHJlc3VsdCA9IHN0YXRlO1xuICAgIHZhciBrZXkgPSBcInJlZ2lzdGVyZWRGaWVsZHNbJ1wiICsgbmFtZSArIFwiJ11cIjtcbiAgICB2YXIgZmllbGQgPSBnZXRJbihyZXN1bHQsIGtleSk7XG5cbiAgICBpZiAoIWZpZWxkKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHZhciBjb3VudCA9IGdldEluKGZpZWxkLCAnY291bnQnKSAtIDE7XG5cbiAgICBpZiAoY291bnQgPD0gMCAmJiBkZXN0cm95T25Vbm1vdW50KSB7XG4gICAgICAvLyBOb3RlOiBDYW5ub3QgdXNlIGRlbGV0ZVdpdGhDbGVhblVwIGhlcmUgYmVjYXVzZSBvZiB0aGUgZmxhdCBuYXR1cmUgb2YgcmVnaXN0ZXJlZEZpZWxkc1xuICAgICAgcmVzdWx0ID0gZGVsZXRlSW4ocmVzdWx0LCBrZXkpO1xuXG4gICAgICBpZiAoZGVlcEVxdWFsKGdldEluKHJlc3VsdCwgJ3JlZ2lzdGVyZWRGaWVsZHMnKSwgZW1wdHkpKSB7XG4gICAgICAgIHJlc3VsdCA9IGRlbGV0ZUluKHJlc3VsdCwgJ3JlZ2lzdGVyZWRGaWVsZHMnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN5bmNFcnJvcnMgPSBnZXRJbihyZXN1bHQsICdzeW5jRXJyb3JzJyk7XG5cbiAgICAgIGlmIChzeW5jRXJyb3JzKSB7XG4gICAgICAgIHN5bmNFcnJvcnMgPSBwbGFpbkRlbGV0ZUluV2l0aENsZWFuVXAoc3luY0Vycm9ycywgbmFtZSk7XG5cbiAgICAgICAgaWYgKHBsYWluLmRlZXBFcXVhbChzeW5jRXJyb3JzLCBwbGFpbi5lbXB0eSkpIHtcbiAgICAgICAgICByZXN1bHQgPSBkZWxldGVJbihyZXN1bHQsICdzeW5jRXJyb3JzJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gc2V0SW4ocmVzdWx0LCAnc3luY0Vycm9ycycsIHN5bmNFcnJvcnMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzeW5jV2FybmluZ3MgPSBnZXRJbihyZXN1bHQsICdzeW5jV2FybmluZ3MnKTtcblxuICAgICAgaWYgKHN5bmNXYXJuaW5ncykge1xuICAgICAgICBzeW5jV2FybmluZ3MgPSBwbGFpbkRlbGV0ZUluV2l0aENsZWFuVXAoc3luY1dhcm5pbmdzLCBuYW1lKTtcblxuICAgICAgICBpZiAocGxhaW4uZGVlcEVxdWFsKHN5bmNXYXJuaW5ncywgcGxhaW4uZW1wdHkpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZGVsZXRlSW4ocmVzdWx0LCAnc3luY1dhcm5pbmdzJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gc2V0SW4ocmVzdWx0LCAnc3luY1dhcm5pbmdzJywgc3luY1dhcm5pbmdzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXN1bHQgPSBkZWxldGVJbldpdGhDbGVhblVwKHJlc3VsdCwgXCJzdWJtaXRFcnJvcnMuXCIgKyBuYW1lKTtcbiAgICAgIHJlc3VsdCA9IGRlbGV0ZUluV2l0aENsZWFuVXAocmVzdWx0LCBcImFzeW5jRXJyb3JzLlwiICsgbmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpZWxkID0gc2V0SW4oZmllbGQsICdjb3VudCcsIGNvdW50KTtcbiAgICAgIHJlc3VsdCA9IHNldEluKHJlc3VsdCwga2V5LCBmaWVsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgX2JlaGF2aW9yc1tVTlRPVUNIXSA9IGZ1bmN0aW9uIChzdGF0ZSwgX3JlZjI3KSB7XG4gICAgdmFyIGZpZWxkcyA9IF9yZWYyNy5tZXRhLmZpZWxkcztcbiAgICB2YXIgcmVzdWx0ID0gc3RhdGU7XG4gICAgZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICByZXR1cm4gcmVzdWx0ID0gZGVsZXRlSW4ocmVzdWx0LCBcImZpZWxkcy5cIiArIGZpZWxkICsgXCIudG91Y2hlZFwiKTtcbiAgICB9KTtcbiAgICB2YXIgYW55VG91Y2hlZCA9IHNvbWUoa2V5cyhnZXRJbihyZXN1bHQsICdyZWdpc3RlcmVkRmllbGRzJykpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gZ2V0SW4ocmVzdWx0LCBcImZpZWxkcy5cIiArIGtleSArIFwiLnRvdWNoZWRcIik7XG4gICAgfSk7XG4gICAgcmVzdWx0ID0gYW55VG91Y2hlZCA/IHNldEluKHJlc3VsdCwgJ2FueVRvdWNoZWQnLCB0cnVlKSA6IGRlbGV0ZUluKHJlc3VsdCwgJ2FueVRvdWNoZWQnKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCBfYmVoYXZpb3JzW1VQREFURV9TWU5DX0VSUk9SU10gPSBmdW5jdGlvbiAoc3RhdGUsIF9yZWYyOCkge1xuICAgIHZhciBfcmVmMjgkcGF5bG9hZCA9IF9yZWYyOC5wYXlsb2FkLFxuICAgICAgICBzeW5jRXJyb3JzID0gX3JlZjI4JHBheWxvYWQuc3luY0Vycm9ycyxcbiAgICAgICAgZXJyb3IgPSBfcmVmMjgkcGF5bG9hZC5lcnJvcjtcbiAgICB2YXIgcmVzdWx0ID0gc3RhdGU7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHJlc3VsdCA9IHNldEluKHJlc3VsdCwgJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgcmVzdWx0ID0gc2V0SW4ocmVzdWx0LCAnc3luY0Vycm9yJywgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGRlbGV0ZUluKHJlc3VsdCwgJ2Vycm9yJyk7XG4gICAgICByZXN1bHQgPSBkZWxldGVJbihyZXN1bHQsICdzeW5jRXJyb3InKTtcbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LmtleXMoc3luY0Vycm9ycykubGVuZ3RoKSB7XG4gICAgICByZXN1bHQgPSBzZXRJbihyZXN1bHQsICdzeW5jRXJyb3JzJywgc3luY0Vycm9ycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGRlbGV0ZUluKHJlc3VsdCwgJ3N5bmNFcnJvcnMnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCBfYmVoYXZpb3JzW1VQREFURV9TWU5DX1dBUk5JTkdTXSA9IGZ1bmN0aW9uIChzdGF0ZSwgX3JlZjI5KSB7XG4gICAgdmFyIF9yZWYyOSRwYXlsb2FkID0gX3JlZjI5LnBheWxvYWQsXG4gICAgICAgIHN5bmNXYXJuaW5ncyA9IF9yZWYyOSRwYXlsb2FkLnN5bmNXYXJuaW5ncyxcbiAgICAgICAgd2FybmluZyA9IF9yZWYyOSRwYXlsb2FkLndhcm5pbmc7XG4gICAgdmFyIHJlc3VsdCA9IHN0YXRlO1xuXG4gICAgaWYgKHdhcm5pbmcpIHtcbiAgICAgIHJlc3VsdCA9IHNldEluKHJlc3VsdCwgJ3dhcm5pbmcnLCB3YXJuaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gZGVsZXRlSW4ocmVzdWx0LCAnd2FybmluZycpO1xuICAgIH1cblxuICAgIGlmIChPYmplY3Qua2V5cyhzeW5jV2FybmluZ3MpLmxlbmd0aCkge1xuICAgICAgcmVzdWx0ID0gc2V0SW4ocmVzdWx0LCAnc3luY1dhcm5pbmdzJywgc3luY1dhcm5pbmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gZGVsZXRlSW4ocmVzdWx0LCAnc3luY1dhcm5pbmdzJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgX2JlaGF2aW9ycyk7XG5cbiAgdmFyIHJlZHVjZXIgPSBmdW5jdGlvbiByZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgICBpZiAoc3RhdGUgPT09IHZvaWQgMCkge1xuICAgICAgc3RhdGUgPSBlbXB0eTtcbiAgICB9XG5cbiAgICB2YXIgYmVoYXZpb3IgPSBiZWhhdmlvcnNbYWN0aW9uLnR5cGVdO1xuICAgIHJldHVybiBiZWhhdmlvciA/IGJlaGF2aW9yKHN0YXRlLCBhY3Rpb24pIDogc3RhdGU7XG4gIH07XG5cbiAgdmFyIGJ5Rm9ybSA9IGZ1bmN0aW9uIGJ5Rm9ybShyZWR1Y2VyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IHZvaWQgMCkge1xuICAgICAgICBzdGF0ZSA9IGVtcHR5O1xuICAgICAgfVxuXG4gICAgICBpZiAoYWN0aW9uID09PSB2b2lkIDApIHtcbiAgICAgICAgYWN0aW9uID0ge1xuICAgICAgICAgIHR5cGU6ICdOT05FJ1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB2YXIgZm9ybSA9IGFjdGlvbiAmJiBhY3Rpb24ubWV0YSAmJiBhY3Rpb24ubWV0YS5mb3JtO1xuXG4gICAgICBpZiAoIWZvcm0gfHwgIWlzUmVkdXhGb3JtQWN0aW9uKGFjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWN0aW9uLnR5cGUgPT09IERFU1RST1kgJiYgYWN0aW9uLm1ldGEgJiYgYWN0aW9uLm1ldGEuZm9ybSkge1xuICAgICAgICByZXR1cm4gYWN0aW9uLm1ldGEuZm9ybS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgZm9ybSkge1xuICAgICAgICAgIHJldHVybiBkZWxldGVJbldpdGhDbGVhblVwKHJlc3VsdCwgZm9ybSk7XG4gICAgICAgIH0sIHN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZvcm1TdGF0ZSA9IGdldEluKHN0YXRlLCBmb3JtKTtcbiAgICAgIHZhciByZXN1bHQgPSByZWR1Y2VyKGZvcm1TdGF0ZSwgYWN0aW9uKTtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IGZvcm1TdGF0ZSA/IHN0YXRlIDogc2V0SW4oc3RhdGUsIGZvcm0sIHJlc3VsdCk7XG4gICAgfTtcbiAgfTtcbiAgLyoqXG4gICAqIEFkZHMgYWRkaXRpb25hbCBmdW5jdGlvbmFsaXR5IHRvIHRoZSByZWR1Y2VyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZGVjb3JhdGUodGFyZ2V0KSB7XG4gICAgdGFyZ2V0LnBsdWdpbiA9IGZ1bmN0aW9uIChyZWR1Y2VycywgY29uZmlnKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHtcbiAgICAgICAgY29uZmlnID0ge307XG4gICAgICB9XG5cbiAgICAgIC8vIHVzZSAnZnVuY3Rpb24nIGtleXdvcmQgdG8gZW5hYmxlICd0aGlzJ1xuICAgICAgcmV0dXJuIGRlY29yYXRlKGZ1bmN0aW9uIChzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgc3RhdGUgPSBlbXB0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhY3Rpb24gPT09IHZvaWQgMCkge1xuICAgICAgICAgIGFjdGlvbiA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdOT05FJ1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2FsbFBsdWdpbiA9IGZ1bmN0aW9uIGNhbGxQbHVnaW4ocHJvY2Vzc2VkLCBrZXkpIHtcbiAgICAgICAgICB2YXIgcHJldmlvdXNTdGF0ZSA9IGdldEluKHByb2Nlc3NlZCwga2V5KTtcbiAgICAgICAgICB2YXIgbmV4dFN0YXRlID0gcmVkdWNlcnNba2V5XShwcmV2aW91c1N0YXRlLCBhY3Rpb24sIGdldEluKHN0YXRlLCBrZXkpKTtcbiAgICAgICAgICByZXR1cm4gbmV4dFN0YXRlICE9PSBwcmV2aW91c1N0YXRlID8gc2V0SW4ocHJvY2Vzc2VkLCBrZXksIG5leHRTdGF0ZSkgOiBwcm9jZXNzZWQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHByb2Nlc3NlZCA9IF90aGlzKHN0YXRlLCBhY3Rpb24pOyAvLyBydW4gdGhyb3VnaCByZWR1eC1mb3JtIHJlZHVjZXJcblxuXG4gICAgICAgIHZhciBmb3JtID0gYWN0aW9uICYmIGFjdGlvbi5tZXRhICYmIGFjdGlvbi5tZXRhLmZvcm07XG5cbiAgICAgICAgaWYgKGZvcm0gJiYgIWNvbmZpZy5yZWNlaXZlQWxsRm9ybUFjdGlvbnMpIHtcbiAgICAgICAgICAvLyB0aGlzIGlzIGFuIGFjdGlvbiBhaW1lZCBhdCBmb3Jtcywgc28gb25seSBnaXZlIGl0IHRvIHRoZSBzcGVjaWZpZWQgZm9ybSdzIHBsdWdpblxuICAgICAgICAgIHJldHVybiByZWR1Y2Vyc1tmb3JtXSA/IGNhbGxQbHVnaW4ocHJvY2Vzc2VkLCBmb3JtKSA6IHByb2Nlc3NlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBhIGZvcm0tc3BlY2lmaWMgYWN0aW9uLCBzbyBzZW5kIGl0IHRvIGFsbCB0aGUgcGx1Z2luc1xuICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhyZWR1Y2VycykucmVkdWNlKGNhbGxQbHVnaW4sIHByb2Nlc3NlZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgcmV0dXJuIGRlY29yYXRlKGJ5Rm9ybShyZWR1Y2VyKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVJlZHVjZXI7IiwiaW1wb3J0IGNyZWF0ZVJlZHVjZXIgZnJvbSAnLi9jcmVhdGVSZWR1Y2VyJztcbmltcG9ydCBwbGFpbiBmcm9tICcuL3N0cnVjdHVyZS9wbGFpbic7XG5leHBvcnQgZGVmYXVsdCBjcmVhdGVSZWR1Y2VyKHBsYWluKTsiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59IiwiaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmV4cG9ydCB2YXIgc3Vic2NyaXB0aW9uU2hhcGUgPSBQcm9wVHlwZXMuc2hhcGUoe1xuICB0cnlTdWJzY3JpYmU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHRyeVVuc3Vic2NyaWJlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBub3RpZnlOZXN0ZWRTdWJzOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBpc1N1YnNjcmliZWQ6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbn0pO1xuZXhwb3J0IHZhciBzdG9yZVNoYXBlID0gUHJvcFR5cGVzLnNoYXBlKHtcbiAgc3Vic2NyaWJlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBkaXNwYXRjaDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgZ2V0U3RhdGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbn0pOyIsIi8qKlxuICogUHJpbnRzIGEgd2FybmluZyBpbiB0aGUgY29uc29sZSBpZiBpdCBleGlzdHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIHdhcm5pbmcgbWVzc2FnZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cblxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCBpZiB5b3UgZW5hYmxlXG4gICAgLy8gXCJicmVhayBvbiBhbGwgZXhjZXB0aW9uc1wiIGluIHlvdXIgY29uc29sZSxcbiAgICAvLyBpdCB3b3VsZCBwYXVzZSB0aGUgZXhlY3V0aW9uIGF0IHRoaXMgbGluZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHkgKi9cbiAgfSBjYXRjaCAoZSkge31cbiAgLyogZXNsaW50LWVuYWJsZSBuby1lbXB0eSAqL1xuXG59IiwiaW1wb3J0IF9pbmhlcml0c0xvb3NlIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c0xvb3NlXCI7XG5pbXBvcnQgeyBDb21wb25lbnQsIENoaWxkcmVuIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IHN0b3JlU2hhcGUsIHN1YnNjcmlwdGlvblNoYXBlIH0gZnJvbSAnLi4vdXRpbHMvUHJvcFR5cGVzJztcbmltcG9ydCB3YXJuaW5nIGZyb20gJy4uL3V0aWxzL3dhcm5pbmcnO1xudmFyIGRpZFdhcm5BYm91dFJlY2VpdmluZ1N0b3JlID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHdhcm5BYm91dFJlY2VpdmluZ1N0b3JlKCkge1xuICBpZiAoZGlkV2FybkFib3V0UmVjZWl2aW5nU3RvcmUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBkaWRXYXJuQWJvdXRSZWNlaXZpbmdTdG9yZSA9IHRydWU7XG4gIHdhcm5pbmcoJzxQcm92aWRlcj4gZG9lcyBub3Qgc3VwcG9ydCBjaGFuZ2luZyBgc3RvcmVgIG9uIHRoZSBmbHkuICcgKyAnSXQgaXMgbW9zdCBsaWtlbHkgdGhhdCB5b3Ugc2VlIHRoaXMgZXJyb3IgYmVjYXVzZSB5b3UgdXBkYXRlZCB0byAnICsgJ1JlZHV4IDIueCBhbmQgUmVhY3QgUmVkdXggMi54IHdoaWNoIG5vIGxvbmdlciBob3QgcmVsb2FkIHJlZHVjZXJzICcgKyAnYXV0b21hdGljYWxseS4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWR1eGpzL3JlYWN0LXJlZHV4L3JlbGVhc2VzLycgKyAndGFnL3YyLjAuMCBmb3IgdGhlIG1pZ3JhdGlvbiBpbnN0cnVjdGlvbnMuJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQcm92aWRlcihzdG9yZUtleSkge1xuICB2YXIgX1Byb3ZpZGVyJGNoaWxkQ29udGV4O1xuXG4gIGlmIChzdG9yZUtleSA9PT0gdm9pZCAwKSB7XG4gICAgc3RvcmVLZXkgPSAnc3RvcmUnO1xuICB9XG5cbiAgdmFyIHN1YnNjcmlwdGlvbktleSA9IHN0b3JlS2V5ICsgXCJTdWJzY3JpcHRpb25cIjtcblxuICB2YXIgUHJvdmlkZXIgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzTG9vc2UoUHJvdmlkZXIsIF9Db21wb25lbnQpO1xuXG4gICAgdmFyIF9wcm90byA9IFByb3ZpZGVyLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5nZXRDaGlsZENvbnRleHQgPSBmdW5jdGlvbiBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgICB2YXIgX3JlZjtcblxuICAgICAgcmV0dXJuIF9yZWYgPSB7fSwgX3JlZltzdG9yZUtleV0gPSB0aGlzW3N0b3JlS2V5XSwgX3JlZltzdWJzY3JpcHRpb25LZXldID0gbnVsbCwgX3JlZjtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gUHJvdmlkZXIocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgX3RoaXMgPSBfQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICBfdGhpc1tzdG9yZUtleV0gPSBwcm9wcy5zdG9yZTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgcmV0dXJuIENoaWxkcmVuLm9ubHkodGhpcy5wcm9wcy5jaGlsZHJlbik7XG4gICAgfTtcblxuICAgIHJldHVybiBQcm92aWRlcjtcbiAgfShDb21wb25lbnQpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgUHJvdmlkZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiAobmV4dFByb3BzKSB7XG4gICAgICBpZiAodGhpc1tzdG9yZUtleV0gIT09IG5leHRQcm9wcy5zdG9yZSkge1xuICAgICAgICB3YXJuQWJvdXRSZWNlaXZpbmdTdG9yZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBQcm92aWRlci5wcm9wVHlwZXMgPSB7XG4gICAgc3RvcmU6IHN0b3JlU2hhcGUuaXNSZXF1aXJlZCxcbiAgICBjaGlsZHJlbjogUHJvcFR5cGVzLmVsZW1lbnQuaXNSZXF1aXJlZFxuICB9O1xuICBQcm92aWRlci5jaGlsZENvbnRleHRUeXBlcyA9IChfUHJvdmlkZXIkY2hpbGRDb250ZXggPSB7fSwgX1Byb3ZpZGVyJGNoaWxkQ29udGV4W3N0b3JlS2V5XSA9IHN0b3JlU2hhcGUuaXNSZXF1aXJlZCwgX1Byb3ZpZGVyJGNoaWxkQ29udGV4W3N1YnNjcmlwdGlvbktleV0gPSBzdWJzY3JpcHRpb25TaGFwZSwgX1Byb3ZpZGVyJGNoaWxkQ29udGV4KTtcbiAgcmV0dXJuIFByb3ZpZGVyO1xufVxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlUHJvdmlkZXIoKTsiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59IiwiLy8gZW5jYXBzdWxhdGVzIHRoZSBzdWJzY3JpcHRpb24gbG9naWMgZm9yIGNvbm5lY3RpbmcgYSBjb21wb25lbnQgdG8gdGhlIHJlZHV4IHN0b3JlLCBhc1xuLy8gd2VsbCBhcyBuZXN0aW5nIHN1YnNjcmlwdGlvbnMgb2YgZGVzY2VuZGFudCBjb21wb25lbnRzLCBzbyB0aGF0IHdlIGNhbiBlbnN1cmUgdGhlXG4vLyBhbmNlc3RvciBjb21wb25lbnRzIHJlLXJlbmRlciBiZWZvcmUgZGVzY2VuZGFudHNcbnZhciBDTEVBUkVEID0gbnVsbDtcbnZhciBudWxsTGlzdGVuZXJzID0ge1xuICBub3RpZnk6IGZ1bmN0aW9uIG5vdGlmeSgpIHt9XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVMaXN0ZW5lckNvbGxlY3Rpb24oKSB7XG4gIC8vIHRoZSBjdXJyZW50L25leHQgcGF0dGVybiBpcyBjb3BpZWQgZnJvbSByZWR1eCdzIGNyZWF0ZVN0b3JlIGNvZGUuXG4gIC8vIFRPRE86IHJlZmFjdG9yK2V4cG9zZSB0aGF0IGNvZGUgdG8gYmUgcmV1c2FibGUgaGVyZT9cbiAgdmFyIGN1cnJlbnQgPSBbXTtcbiAgdmFyIG5leHQgPSBbXTtcbiAgcmV0dXJuIHtcbiAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICBuZXh0ID0gQ0xFQVJFRDtcbiAgICAgIGN1cnJlbnQgPSBDTEVBUkVEO1xuICAgIH0sXG4gICAgbm90aWZ5OiBmdW5jdGlvbiBub3RpZnkoKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gY3VycmVudCA9IG5leHQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxpc3RlbmVyc1tpXSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9LFxuICAgIHN1YnNjcmliZTogZnVuY3Rpb24gc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgICB2YXIgaXNTdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICAgIGlmIChuZXh0ID09PSBjdXJyZW50KSBuZXh0ID0gY3VycmVudC5zbGljZSgpO1xuICAgICAgbmV4dC5wdXNoKGxpc3RlbmVyKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgaWYgKCFpc1N1YnNjcmliZWQgfHwgY3VycmVudCA9PT0gQ0xFQVJFRCkgcmV0dXJuO1xuICAgICAgICBpc1N1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKG5leHQgPT09IGN1cnJlbnQpIG5leHQgPSBjdXJyZW50LnNsaWNlKCk7XG4gICAgICAgIG5leHQuc3BsaWNlKG5leHQuaW5kZXhPZihsaXN0ZW5lciksIDEpO1xuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBTdWJzY3JpcHRpb24gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdWJzY3JpcHRpb24oc3RvcmUsIHBhcmVudFN1Yiwgb25TdGF0ZUNoYW5nZSkge1xuICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICB0aGlzLnBhcmVudFN1YiA9IHBhcmVudFN1YjtcbiAgICB0aGlzLm9uU3RhdGVDaGFuZ2UgPSBvblN0YXRlQ2hhbmdlO1xuICAgIHRoaXMudW5zdWJzY3JpYmUgPSBudWxsO1xuICAgIHRoaXMubGlzdGVuZXJzID0gbnVsbExpc3RlbmVycztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBTdWJzY3JpcHRpb24ucHJvdG90eXBlO1xuXG4gIF9wcm90by5hZGROZXN0ZWRTdWIgPSBmdW5jdGlvbiBhZGROZXN0ZWRTdWIobGlzdGVuZXIpIHtcbiAgICB0aGlzLnRyeVN1YnNjcmliZSgpO1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVycy5zdWJzY3JpYmUobGlzdGVuZXIpO1xuICB9O1xuXG4gIF9wcm90by5ub3RpZnlOZXN0ZWRTdWJzID0gZnVuY3Rpb24gbm90aWZ5TmVzdGVkU3VicygpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5ub3RpZnkoKTtcbiAgfTtcblxuICBfcHJvdG8uaXNTdWJzY3JpYmVkID0gZnVuY3Rpb24gaXNTdWJzY3JpYmVkKCkge1xuICAgIHJldHVybiBCb29sZWFuKHRoaXMudW5zdWJzY3JpYmUpO1xuICB9O1xuXG4gIF9wcm90by50cnlTdWJzY3JpYmUgPSBmdW5jdGlvbiB0cnlTdWJzY3JpYmUoKSB7XG4gICAgaWYgKCF0aGlzLnVuc3Vic2NyaWJlKSB7XG4gICAgICB0aGlzLnVuc3Vic2NyaWJlID0gdGhpcy5wYXJlbnRTdWIgPyB0aGlzLnBhcmVudFN1Yi5hZGROZXN0ZWRTdWIodGhpcy5vblN0YXRlQ2hhbmdlKSA6IHRoaXMuc3RvcmUuc3Vic2NyaWJlKHRoaXMub25TdGF0ZUNoYW5nZSk7XG4gICAgICB0aGlzLmxpc3RlbmVycyA9IGNyZWF0ZUxpc3RlbmVyQ29sbGVjdGlvbigpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8udHJ5VW5zdWJzY3JpYmUgPSBmdW5jdGlvbiB0cnlVbnN1YnNjcmliZSgpIHtcbiAgICBpZiAodGhpcy51bnN1YnNjcmliZSkge1xuICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgdGhpcy51bnN1YnNjcmliZSA9IG51bGw7XG4gICAgICB0aGlzLmxpc3RlbmVycy5jbGVhcigpO1xuICAgICAgdGhpcy5saXN0ZW5lcnMgPSBudWxsTGlzdGVuZXJzO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gU3Vic2NyaXB0aW9uO1xufSgpO1xuXG5leHBvcnQgeyBTdWJzY3JpcHRpb24gYXMgZGVmYXVsdCB9OyIsImltcG9ydCBfaW5oZXJpdHNMb29zZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNMb29zZVwiO1xuaW1wb3J0IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2Fzc2VydFRoaXNJbml0aWFsaXplZFwiO1xuaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2VcIjtcbmltcG9ydCBob2lzdFN0YXRpY3MgZnJvbSAnaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdpbnZhcmlhbnQnO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBjcmVhdGVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgaXNWYWxpZEVsZW1lbnRUeXBlIH0gZnJvbSAncmVhY3QtaXMnO1xuaW1wb3J0IFN1YnNjcmlwdGlvbiBmcm9tICcuLi91dGlscy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgc3RvcmVTaGFwZSwgc3Vic2NyaXB0aW9uU2hhcGUgfSBmcm9tICcuLi91dGlscy9Qcm9wVHlwZXMnO1xudmFyIGhvdFJlbG9hZGluZ1ZlcnNpb24gPSAwO1xudmFyIGR1bW15U3RhdGUgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIG1ha2VTZWxlY3RvclN0YXRlZnVsKHNvdXJjZVNlbGVjdG9yLCBzdG9yZSkge1xuICAvLyB3cmFwIHRoZSBzZWxlY3RvciBpbiBhbiBvYmplY3QgdGhhdCB0cmFja3MgaXRzIHJlc3VsdHMgYmV0d2VlbiBydW5zLlxuICB2YXIgc2VsZWN0b3IgPSB7XG4gICAgcnVuOiBmdW5jdGlvbiBydW5Db21wb25lbnRTZWxlY3Rvcihwcm9wcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG5leHRQcm9wcyA9IHNvdXJjZVNlbGVjdG9yKHN0b3JlLmdldFN0YXRlKCksIHByb3BzKTtcblxuICAgICAgICBpZiAobmV4dFByb3BzICE9PSBzZWxlY3Rvci5wcm9wcyB8fCBzZWxlY3Rvci5lcnJvcikge1xuICAgICAgICAgIHNlbGVjdG9yLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgc2VsZWN0b3IucHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgICAgICAgc2VsZWN0b3IuZXJyb3IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBzZWxlY3Rvci5zaG91bGRDb21wb25lbnRVcGRhdGUgPSB0cnVlO1xuICAgICAgICBzZWxlY3Rvci5lcnJvciA9IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHNlbGVjdG9yO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb25uZWN0QWR2YW5jZWQoXG4vKlxuICBzZWxlY3RvckZhY3RvcnkgaXMgYSBmdW5jIHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIHJldHVybmluZyB0aGUgc2VsZWN0b3IgZnVuY3Rpb24gdXNlZCB0b1xuICBjb21wdXRlIG5ldyBwcm9wcyBmcm9tIHN0YXRlLCBwcm9wcywgYW5kIGRpc3BhdGNoLiBGb3IgZXhhbXBsZTpcbiAgICAgZXhwb3J0IGRlZmF1bHQgY29ubmVjdEFkdmFuY2VkKChkaXNwYXRjaCwgb3B0aW9ucykgPT4gKHN0YXRlLCBwcm9wcykgPT4gKHtcbiAgICAgIHRoaW5nOiBzdGF0ZS50aGluZ3NbcHJvcHMudGhpbmdJZF0sXG4gICAgICBzYXZlVGhpbmc6IGZpZWxkcyA9PiBkaXNwYXRjaChhY3Rpb25DcmVhdG9ycy5zYXZlVGhpbmcocHJvcHMudGhpbmdJZCwgZmllbGRzKSksXG4gICAgfSkpKFlvdXJDb21wb25lbnQpXG4gICBBY2Nlc3MgdG8gZGlzcGF0Y2ggaXMgcHJvdmlkZWQgdG8gdGhlIGZhY3Rvcnkgc28gc2VsZWN0b3JGYWN0b3JpZXMgY2FuIGJpbmQgYWN0aW9uQ3JlYXRvcnNcbiAgb3V0c2lkZSBvZiB0aGVpciBzZWxlY3RvciBhcyBhbiBvcHRpbWl6YXRpb24uIE9wdGlvbnMgcGFzc2VkIHRvIGNvbm5lY3RBZHZhbmNlZCBhcmUgcGFzc2VkIHRvXG4gIHRoZSBzZWxlY3RvckZhY3RvcnksIGFsb25nIHdpdGggZGlzcGxheU5hbWUgYW5kIFdyYXBwZWRDb21wb25lbnQsIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXG4gICBOb3RlIHRoYXQgc2VsZWN0b3JGYWN0b3J5IGlzIHJlc3BvbnNpYmxlIGZvciBhbGwgY2FjaGluZy9tZW1vaXphdGlvbiBvZiBpbmJvdW5kIGFuZCBvdXRib3VuZFxuICBwcm9wcy4gRG8gbm90IHVzZSBjb25uZWN0QWR2YW5jZWQgZGlyZWN0bHkgd2l0aG91dCBtZW1vaXppbmcgcmVzdWx0cyBiZXR3ZWVuIGNhbGxzIHRvIHlvdXJcbiAgc2VsZWN0b3IsIG90aGVyd2lzZSB0aGUgQ29ubmVjdCBjb21wb25lbnQgd2lsbCByZS1yZW5kZXIgb24gZXZlcnkgc3RhdGUgb3IgcHJvcHMgY2hhbmdlLlxuKi9cbnNlbGVjdG9yRmFjdG9yeSwgLy8gb3B0aW9ucyBvYmplY3Q6XG5fcmVmKSB7XG4gIHZhciBfY29udGV4dFR5cGVzLCBfY2hpbGRDb250ZXh0VHlwZXM7XG5cbiAgaWYgKF9yZWYgPT09IHZvaWQgMCkge1xuICAgIF9yZWYgPSB7fTtcbiAgfVxuXG4gIHZhciBfcmVmMiA9IF9yZWYsXG4gICAgICBfcmVmMiRnZXREaXNwbGF5TmFtZSA9IF9yZWYyLmdldERpc3BsYXlOYW1lLFxuICAgICAgZ2V0RGlzcGxheU5hbWUgPSBfcmVmMiRnZXREaXNwbGF5TmFtZSA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gXCJDb25uZWN0QWR2YW5jZWQoXCIgKyBuYW1lICsgXCIpXCI7XG4gIH0gOiBfcmVmMiRnZXREaXNwbGF5TmFtZSxcbiAgICAgIF9yZWYyJG1ldGhvZE5hbWUgPSBfcmVmMi5tZXRob2ROYW1lLFxuICAgICAgbWV0aG9kTmFtZSA9IF9yZWYyJG1ldGhvZE5hbWUgPT09IHZvaWQgMCA/ICdjb25uZWN0QWR2YW5jZWQnIDogX3JlZjIkbWV0aG9kTmFtZSxcbiAgICAgIF9yZWYyJHJlbmRlckNvdW50UHJvcCA9IF9yZWYyLnJlbmRlckNvdW50UHJvcCxcbiAgICAgIHJlbmRlckNvdW50UHJvcCA9IF9yZWYyJHJlbmRlckNvdW50UHJvcCA9PT0gdm9pZCAwID8gdW5kZWZpbmVkIDogX3JlZjIkcmVuZGVyQ291bnRQcm9wLFxuICAgICAgX3JlZjIkc2hvdWxkSGFuZGxlU3RhID0gX3JlZjIuc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzLFxuICAgICAgc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzID0gX3JlZjIkc2hvdWxkSGFuZGxlU3RhID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZjIkc2hvdWxkSGFuZGxlU3RhLFxuICAgICAgX3JlZjIkc3RvcmVLZXkgPSBfcmVmMi5zdG9yZUtleSxcbiAgICAgIHN0b3JlS2V5ID0gX3JlZjIkc3RvcmVLZXkgPT09IHZvaWQgMCA/ICdzdG9yZScgOiBfcmVmMiRzdG9yZUtleSxcbiAgICAgIF9yZWYyJHdpdGhSZWYgPSBfcmVmMi53aXRoUmVmLFxuICAgICAgd2l0aFJlZiA9IF9yZWYyJHdpdGhSZWYgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjIkd2l0aFJlZixcbiAgICAgIGNvbm5lY3RPcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZjIsIFtcImdldERpc3BsYXlOYW1lXCIsIFwibWV0aG9kTmFtZVwiLCBcInJlbmRlckNvdW50UHJvcFwiLCBcInNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlc1wiLCBcInN0b3JlS2V5XCIsIFwid2l0aFJlZlwiXSk7XG5cbiAgdmFyIHN1YnNjcmlwdGlvbktleSA9IHN0b3JlS2V5ICsgJ1N1YnNjcmlwdGlvbic7XG4gIHZhciB2ZXJzaW9uID0gaG90UmVsb2FkaW5nVmVyc2lvbisrO1xuICB2YXIgY29udGV4dFR5cGVzID0gKF9jb250ZXh0VHlwZXMgPSB7fSwgX2NvbnRleHRUeXBlc1tzdG9yZUtleV0gPSBzdG9yZVNoYXBlLCBfY29udGV4dFR5cGVzW3N1YnNjcmlwdGlvbktleV0gPSBzdWJzY3JpcHRpb25TaGFwZSwgX2NvbnRleHRUeXBlcyk7XG4gIHZhciBjaGlsZENvbnRleHRUeXBlcyA9IChfY2hpbGRDb250ZXh0VHlwZXMgPSB7fSwgX2NoaWxkQ29udGV4dFR5cGVzW3N1YnNjcmlwdGlvbktleV0gPSBzdWJzY3JpcHRpb25TaGFwZSwgX2NoaWxkQ29udGV4dFR5cGVzKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXBXaXRoQ29ubmVjdChXcmFwcGVkQ29tcG9uZW50KSB7XG4gICAgaW52YXJpYW50KGlzVmFsaWRFbGVtZW50VHlwZShXcmFwcGVkQ29tcG9uZW50KSwgXCJZb3UgbXVzdCBwYXNzIGEgY29tcG9uZW50IHRvIHRoZSBmdW5jdGlvbiByZXR1cm5lZCBieSBcIiArIChtZXRob2ROYW1lICsgXCIuIEluc3RlYWQgcmVjZWl2ZWQgXCIgKyBKU09OLnN0cmluZ2lmeShXcmFwcGVkQ29tcG9uZW50KSkpO1xuICAgIHZhciB3cmFwcGVkQ29tcG9uZW50TmFtZSA9IFdyYXBwZWRDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgV3JhcHBlZENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnO1xuICAgIHZhciBkaXNwbGF5TmFtZSA9IGdldERpc3BsYXlOYW1lKHdyYXBwZWRDb21wb25lbnROYW1lKTtcblxuICAgIHZhciBzZWxlY3RvckZhY3RvcnlPcHRpb25zID0gX2V4dGVuZHMoe30sIGNvbm5lY3RPcHRpb25zLCB7XG4gICAgICBnZXREaXNwbGF5TmFtZTogZ2V0RGlzcGxheU5hbWUsXG4gICAgICBtZXRob2ROYW1lOiBtZXRob2ROYW1lLFxuICAgICAgcmVuZGVyQ291bnRQcm9wOiByZW5kZXJDb3VudFByb3AsXG4gICAgICBzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXM6IHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcyxcbiAgICAgIHN0b3JlS2V5OiBzdG9yZUtleSxcbiAgICAgIHdpdGhSZWY6IHdpdGhSZWYsXG4gICAgICBkaXNwbGF5TmFtZTogZGlzcGxheU5hbWUsXG4gICAgICB3cmFwcGVkQ29tcG9uZW50TmFtZTogd3JhcHBlZENvbXBvbmVudE5hbWUsXG4gICAgICBXcmFwcGVkQ29tcG9uZW50OiBXcmFwcGVkQ29tcG9uZW50IC8vIFRPRE8gQWN0dWFsbHkgZml4IG91ciB1c2Ugb2YgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1xuXG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9uby1kZXByZWNhdGVkICovXG5cbiAgICB9KTtcblxuICAgIHZhciBDb25uZWN0ID1cbiAgICAvKiNfX1BVUkVfXyovXG4gICAgZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgICAgIF9pbmhlcml0c0xvb3NlKENvbm5lY3QsIF9Db21wb25lbnQpO1xuXG4gICAgICBmdW5jdGlvbiBDb25uZWN0KHByb3BzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcztcblxuICAgICAgICBfdGhpcyA9IF9Db21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIF90aGlzLnN0YXRlID0ge307XG4gICAgICAgIF90aGlzLnJlbmRlckNvdW50ID0gMDtcbiAgICAgICAgX3RoaXMuc3RvcmUgPSBwcm9wc1tzdG9yZUtleV0gfHwgY29udGV4dFtzdG9yZUtleV07XG4gICAgICAgIF90aGlzLnByb3BzTW9kZSA9IEJvb2xlYW4ocHJvcHNbc3RvcmVLZXldKTtcbiAgICAgICAgX3RoaXMuc2V0V3JhcHBlZEluc3RhbmNlID0gX3RoaXMuc2V0V3JhcHBlZEluc3RhbmNlLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkpO1xuICAgICAgICBpbnZhcmlhbnQoX3RoaXMuc3RvcmUsIFwiQ291bGQgbm90IGZpbmQgXFxcIlwiICsgc3RvcmVLZXkgKyBcIlxcXCIgaW4gZWl0aGVyIHRoZSBjb250ZXh0IG9yIHByb3BzIG9mIFwiICsgKFwiXFxcIlwiICsgZGlzcGxheU5hbWUgKyBcIlxcXCIuIEVpdGhlciB3cmFwIHRoZSByb290IGNvbXBvbmVudCBpbiBhIDxQcm92aWRlcj4sIFwiKSArIChcIm9yIGV4cGxpY2l0bHkgcGFzcyBcXFwiXCIgKyBzdG9yZUtleSArIFwiXFxcIiBhcyBhIHByb3AgdG8gXFxcIlwiICsgZGlzcGxheU5hbWUgKyBcIlxcXCIuXCIpKTtcblxuICAgICAgICBfdGhpcy5pbml0U2VsZWN0b3IoKTtcblxuICAgICAgICBfdGhpcy5pbml0U3Vic2NyaXB0aW9uKCk7XG5cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3Byb3RvID0gQ29ubmVjdC5wcm90b3R5cGU7XG5cbiAgICAgIF9wcm90by5nZXRDaGlsZENvbnRleHQgPSBmdW5jdGlvbiBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgICAgIHZhciBfcmVmMztcblxuICAgICAgICAvLyBJZiB0aGlzIGNvbXBvbmVudCByZWNlaXZlZCBzdG9yZSBmcm9tIHByb3BzLCBpdHMgc3Vic2NyaXB0aW9uIHNob3VsZCBiZSB0cmFuc3BhcmVudFxuICAgICAgICAvLyB0byBhbnkgZGVzY2VuZGFudHMgcmVjZWl2aW5nIHN0b3JlK3N1YnNjcmlwdGlvbiBmcm9tIGNvbnRleHQ7IGl0IHBhc3NlcyBhbG9uZ1xuICAgICAgICAvLyBzdWJzY3JpcHRpb24gcGFzc2VkIHRvIGl0LiBPdGhlcndpc2UsIGl0IHNoYWRvd3MgdGhlIHBhcmVudCBzdWJzY3JpcHRpb24sIHdoaWNoIGFsbG93c1xuICAgICAgICAvLyBDb25uZWN0IHRvIGNvbnRyb2wgb3JkZXJpbmcgb2Ygbm90aWZpY2F0aW9ucyB0byBmbG93IHRvcC1kb3duLlxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5wcm9wc01vZGUgPyBudWxsIDogdGhpcy5zdWJzY3JpcHRpb247XG4gICAgICAgIHJldHVybiBfcmVmMyA9IHt9LCBfcmVmM1tzdWJzY3JpcHRpb25LZXldID0gc3Vic2NyaXB0aW9uIHx8IHRoaXMuY29udGV4dFtzdWJzY3JpcHRpb25LZXldLCBfcmVmMztcbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBpZiAoIXNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcykgcmV0dXJuOyAvLyBjb21wb25lbnRXaWxsTW91bnQgZmlyZXMgZHVyaW5nIHNlcnZlciBzaWRlIHJlbmRlcmluZywgYnV0IGNvbXBvbmVudERpZE1vdW50IGFuZFxuICAgICAgICAvLyBjb21wb25lbnRXaWxsVW5tb3VudCBkbyBub3QuIEJlY2F1c2Ugb2YgdGhpcywgdHJ5U3Vic2NyaWJlIGhhcHBlbnMgZHVyaW5nIC4uLmRpZE1vdW50LlxuICAgICAgICAvLyBPdGhlcndpc2UsIHVuc3Vic2NyaXB0aW9uIHdvdWxkIG5ldmVyIHRha2UgcGxhY2UgZHVyaW5nIFNTUiwgY2F1c2luZyBhIG1lbW9yeSBsZWFrLlxuICAgICAgICAvLyBUbyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgYSBjaGlsZCBjb21wb25lbnQgbWF5IGhhdmUgdHJpZ2dlcmVkIGEgc3RhdGUgY2hhbmdlIGJ5XG4gICAgICAgIC8vIGRpc3BhdGNoaW5nIGFuIGFjdGlvbiBpbiBpdHMgY29tcG9uZW50V2lsbE1vdW50LCB3ZSBoYXZlIHRvIHJlLXJ1biB0aGUgc2VsZWN0IGFuZCBtYXliZVxuICAgICAgICAvLyByZS1yZW5kZXIuXG5cbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24udHJ5U3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IucnVuKHRoaXMucHJvcHMpO1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rvci5zaG91bGRDb21wb25lbnRVcGRhdGUpIHRoaXMuZm9yY2VVcGRhdGUoKTtcbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rvci5ydW4obmV4dFByb3BzKTtcbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdG9yLnNob3VsZENvbXBvbmVudFVwZGF0ZTtcbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb24pIHRoaXMuc3Vic2NyaXB0aW9uLnRyeVVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5ub3RpZnlOZXN0ZWRTdWJzID0gbm9vcDtcbiAgICAgICAgdGhpcy5zdG9yZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IucnVuID0gbm9vcDtcbiAgICAgICAgdGhpcy5zZWxlY3Rvci5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5nZXRXcmFwcGVkSW5zdGFuY2UgPSBmdW5jdGlvbiBnZXRXcmFwcGVkSW5zdGFuY2UoKSB7XG4gICAgICAgIGludmFyaWFudCh3aXRoUmVmLCBcIlRvIGFjY2VzcyB0aGUgd3JhcHBlZCBpbnN0YW5jZSwgeW91IG5lZWQgdG8gc3BlY2lmeSBcIiArIChcInsgd2l0aFJlZjogdHJ1ZSB9IGluIHRoZSBvcHRpb25zIGFyZ3VtZW50IG9mIHRoZSBcIiArIG1ldGhvZE5hbWUgKyBcIigpIGNhbGwuXCIpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZEluc3RhbmNlO1xuICAgICAgfTtcblxuICAgICAgX3Byb3RvLnNldFdyYXBwZWRJbnN0YW5jZSA9IGZ1bmN0aW9uIHNldFdyYXBwZWRJbnN0YW5jZShyZWYpIHtcbiAgICAgICAgdGhpcy53cmFwcGVkSW5zdGFuY2UgPSByZWY7XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8uaW5pdFNlbGVjdG9yID0gZnVuY3Rpb24gaW5pdFNlbGVjdG9yKCkge1xuICAgICAgICB2YXIgc291cmNlU2VsZWN0b3IgPSBzZWxlY3RvckZhY3RvcnkodGhpcy5zdG9yZS5kaXNwYXRjaCwgc2VsZWN0b3JGYWN0b3J5T3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBtYWtlU2VsZWN0b3JTdGF0ZWZ1bChzb3VyY2VTZWxlY3RvciwgdGhpcy5zdG9yZSk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IucnVuKHRoaXMucHJvcHMpO1xuICAgICAgfTtcblxuICAgICAgX3Byb3RvLmluaXRTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiBpbml0U3Vic2NyaXB0aW9uKCkge1xuICAgICAgICBpZiAoIXNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcykgcmV0dXJuOyAvLyBwYXJlbnRTdWIncyBzb3VyY2Ugc2hvdWxkIG1hdGNoIHdoZXJlIHN0b3JlIGNhbWUgZnJvbTogcHJvcHMgdnMuIGNvbnRleHQuIEEgY29tcG9uZW50XG4gICAgICAgIC8vIGNvbm5lY3RlZCB0byB0aGUgc3RvcmUgdmlhIHByb3BzIHNob3VsZG4ndCB1c2Ugc3Vic2NyaXB0aW9uIGZyb20gY29udGV4dCwgb3IgdmljZSB2ZXJzYS5cblxuICAgICAgICB2YXIgcGFyZW50U3ViID0gKHRoaXMucHJvcHNNb2RlID8gdGhpcy5wcm9wcyA6IHRoaXMuY29udGV4dClbc3Vic2NyaXB0aW9uS2V5XTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKHRoaXMuc3RvcmUsIHBhcmVudFN1YiwgdGhpcy5vblN0YXRlQ2hhbmdlLmJpbmQodGhpcykpOyAvLyBgbm90aWZ5TmVzdGVkU3Vic2AgaXMgZHVwbGljYXRlZCB0byBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhlIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgaW5cbiAgICAgICAgLy8gdGhlIG1pZGRsZSBvZiB0aGUgbm90aWZpY2F0aW9uIGxvb3AsIHdoZXJlIGB0aGlzLnN1YnNjcmlwdGlvbmAgd2lsbCB0aGVuIGJlIG51bGwuIEFuXG4gICAgICAgIC8vIGV4dHJhIG51bGwgY2hlY2sgZXZlcnkgY2hhbmdlIGNhbiBiZSBhdm9pZGVkIGJ5IGNvcHlpbmcgdGhlIG1ldGhvZCBvbnRvIGB0aGlzYCBhbmQgdGhlblxuICAgICAgICAvLyByZXBsYWNpbmcgaXQgd2l0aCBhIG5vLW9wIG9uIHVubW91bnQuIFRoaXMgY2FuIHByb2JhYmx5IGJlIGF2b2lkZWQgaWYgU3Vic2NyaXB0aW9uJ3NcbiAgICAgICAgLy8gbGlzdGVuZXJzIGxvZ2ljIGlzIGNoYW5nZWQgdG8gbm90IGNhbGwgbGlzdGVuZXJzIHRoYXQgaGF2ZSBiZWVuIHVuc3Vic2NyaWJlZCBpbiB0aGVcbiAgICAgICAgLy8gbWlkZGxlIG9mIHRoZSBub3RpZmljYXRpb24gbG9vcC5cblxuICAgICAgICB0aGlzLm5vdGlmeU5lc3RlZFN1YnMgPSB0aGlzLnN1YnNjcmlwdGlvbi5ub3RpZnlOZXN0ZWRTdWJzLmJpbmQodGhpcy5zdWJzY3JpcHRpb24pO1xuICAgICAgfTtcblxuICAgICAgX3Byb3RvLm9uU3RhdGVDaGFuZ2UgPSBmdW5jdGlvbiBvblN0YXRlQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLnNlbGVjdG9yLnJ1bih0aGlzLnByb3BzKTtcblxuICAgICAgICBpZiAoIXRoaXMuc2VsZWN0b3Iuc2hvdWxkQ29tcG9uZW50VXBkYXRlKSB7XG4gICAgICAgICAgdGhpcy5ub3RpZnlOZXN0ZWRTdWJzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jb21wb25lbnREaWRVcGRhdGUgPSB0aGlzLm5vdGlmeU5lc3RlZFN1YnNPbkNvbXBvbmVudERpZFVwZGF0ZTtcbiAgICAgICAgICB0aGlzLnNldFN0YXRlKGR1bW15U3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8ubm90aWZ5TmVzdGVkU3Vic09uQ29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gbm90aWZ5TmVzdGVkU3Vic09uQ29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICAvLyBgY29tcG9uZW50RGlkVXBkYXRlYCBpcyBjb25kaXRpb25hbGx5IGltcGxlbWVudGVkIHdoZW4gYG9uU3RhdGVDaGFuZ2VgIGRldGVybWluZXMgaXRcbiAgICAgICAgLy8gbmVlZHMgdG8gbm90aWZ5IG5lc3RlZCBzdWJzLiBPbmNlIGNhbGxlZCwgaXQgdW5pbXBsZW1lbnRzIGl0c2VsZiB1bnRpbCBmdXJ0aGVyIHN0YXRlXG4gICAgICAgIC8vIGNoYW5nZXMgb2NjdXIuIERvaW5nIGl0IHRoaXMgd2F5IHZzIGhhdmluZyBhIHBlcm1hbmVudCBgY29tcG9uZW50RGlkVXBkYXRlYCB0aGF0IGRvZXNcbiAgICAgICAgLy8gYSBib29sZWFuIGNoZWNrIGV2ZXJ5IHRpbWUgYXZvaWRzIGFuIGV4dHJhIG1ldGhvZCBjYWxsIG1vc3Qgb2YgdGhlIHRpbWUsIHJlc3VsdGluZ1xuICAgICAgICAvLyBpbiBzb21lIHBlcmYgYm9vc3QuXG4gICAgICAgIHRoaXMuY29tcG9uZW50RGlkVXBkYXRlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm5vdGlmeU5lc3RlZFN1YnMoKTtcbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5pc1N1YnNjcmliZWQgPSBmdW5jdGlvbiBpc1N1YnNjcmliZWQoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuc3Vic2NyaXB0aW9uKSAmJiB0aGlzLnN1YnNjcmlwdGlvbi5pc1N1YnNjcmliZWQoKTtcbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5hZGRFeHRyYVByb3BzID0gZnVuY3Rpb24gYWRkRXh0cmFQcm9wcyhwcm9wcykge1xuICAgICAgICBpZiAoIXdpdGhSZWYgJiYgIXJlbmRlckNvdW50UHJvcCAmJiAhKHRoaXMucHJvcHNNb2RlICYmIHRoaXMuc3Vic2NyaXB0aW9uKSkgcmV0dXJuIHByb3BzOyAvLyBtYWtlIGEgc2hhbGxvdyBjb3B5IHNvIHRoYXQgZmllbGRzIGFkZGVkIGRvbid0IGxlYWsgdG8gdGhlIG9yaWdpbmFsIHNlbGVjdG9yLlxuICAgICAgICAvLyB0aGlzIGlzIGVzcGVjaWFsbHkgaW1wb3J0YW50IGZvciAncmVmJyBzaW5jZSB0aGF0J3MgYSByZWZlcmVuY2UgYmFjayB0byB0aGUgY29tcG9uZW50XG4gICAgICAgIC8vIGluc3RhbmNlLiBhIHNpbmdsZXRvbiBtZW1vaXplZCBzZWxlY3RvciB3b3VsZCB0aGVuIGJlIGhvbGRpbmcgYSByZWZlcmVuY2UgdG8gdGhlXG4gICAgICAgIC8vIGluc3RhbmNlLCBwcmV2ZW50aW5nIHRoZSBpbnN0YW5jZSBmcm9tIGJlaW5nIGdhcmJhZ2UgY29sbGVjdGVkLCBhbmQgdGhhdCB3b3VsZCBiZSBiYWRcblxuICAgICAgICB2YXIgd2l0aEV4dHJhcyA9IF9leHRlbmRzKHt9LCBwcm9wcyk7XG5cbiAgICAgICAgaWYgKHdpdGhSZWYpIHdpdGhFeHRyYXMucmVmID0gdGhpcy5zZXRXcmFwcGVkSW5zdGFuY2U7XG4gICAgICAgIGlmIChyZW5kZXJDb3VudFByb3ApIHdpdGhFeHRyYXNbcmVuZGVyQ291bnRQcm9wXSA9IHRoaXMucmVuZGVyQ291bnQrKztcbiAgICAgICAgaWYgKHRoaXMucHJvcHNNb2RlICYmIHRoaXMuc3Vic2NyaXB0aW9uKSB3aXRoRXh0cmFzW3N1YnNjcmlwdGlvbktleV0gPSB0aGlzLnN1YnNjcmlwdGlvbjtcbiAgICAgICAgcmV0dXJuIHdpdGhFeHRyYXM7XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yO1xuICAgICAgICBzZWxlY3Rvci5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICBpZiAoc2VsZWN0b3IuZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBzZWxlY3Rvci5lcnJvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChXcmFwcGVkQ29tcG9uZW50LCB0aGlzLmFkZEV4dHJhUHJvcHMoc2VsZWN0b3IucHJvcHMpKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIENvbm5lY3Q7XG4gICAgfShDb21wb25lbnQpO1xuICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3Qvbm8tZGVwcmVjYXRlZCAqL1xuXG5cbiAgICBDb25uZWN0LldyYXBwZWRDb21wb25lbnQgPSBXcmFwcGVkQ29tcG9uZW50O1xuICAgIENvbm5lY3QuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgICBDb25uZWN0LmNoaWxkQ29udGV4dFR5cGVzID0gY2hpbGRDb250ZXh0VHlwZXM7XG4gICAgQ29ubmVjdC5jb250ZXh0VHlwZXMgPSBjb250ZXh0VHlwZXM7XG4gICAgQ29ubmVjdC5wcm9wVHlwZXMgPSBjb250ZXh0VHlwZXM7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVcGRhdGUoKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIC8vIFdlIGFyZSBob3QgcmVsb2FkaW5nIVxuICAgICAgICBpZiAodGhpcy52ZXJzaW9uICE9PSB2ZXJzaW9uKSB7XG4gICAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgICB0aGlzLmluaXRTZWxlY3RvcigpOyAvLyBJZiBhbnkgY29ubmVjdGVkIGRlc2NlbmRhbnRzIGRvbid0IGhvdCByZWxvYWQgKGFuZCByZXN1YnNjcmliZSBpbiB0aGUgcHJvY2VzcyksIHRoZWlyXG4gICAgICAgICAgLy8gbGlzdGVuZXJzIHdpbGwgYmUgbG9zdCB3aGVuIHdlIHVuc3Vic2NyaWJlLiBVbmZvcnR1bmF0ZWx5LCBieSBjb3B5aW5nIG92ZXIgYWxsXG4gICAgICAgICAgLy8gbGlzdGVuZXJzLCB0aGlzIGRvZXMgbWVhbiB0aGF0IHRoZSBvbGQgdmVyc2lvbnMgb2YgY29ubmVjdGVkIGRlc2NlbmRhbnRzIHdpbGwgc3RpbGwgYmVcbiAgICAgICAgICAvLyBub3RpZmllZCBvZiBzdGF0ZSBjaGFuZ2VzOyBob3dldmVyLCB0aGVpciBvblN0YXRlQ2hhbmdlIGZ1bmN0aW9uIGlzIGEgbm8tb3Agc28gdGhpc1xuICAgICAgICAgIC8vIGlzbid0IGEgaHVnZSBkZWFsLlxuXG4gICAgICAgICAgdmFyIG9sZExpc3RlbmVycyA9IFtdO1xuXG4gICAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBvbGRMaXN0ZW5lcnMgPSB0aGlzLnN1YnNjcmlwdGlvbi5saXN0ZW5lcnMuZ2V0KCk7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi50cnlVbnN1YnNjcmliZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuaW5pdFN1YnNjcmlwdGlvbigpO1xuXG4gICAgICAgICAgaWYgKHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcykge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24udHJ5U3Vic2NyaWJlKCk7XG4gICAgICAgICAgICBvbGRMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5zdWJzY3JpcHRpb24ubGlzdGVuZXJzLnN1YnNjcmliZShsaXN0ZW5lcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGhvaXN0U3RhdGljcyhDb25uZWN0LCBXcmFwcGVkQ29tcG9uZW50KTtcbiAgfTtcbn0iLCJ2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gaXMoeCwgeSkge1xuICBpZiAoeCA9PT0geSkge1xuICAgIHJldHVybiB4ICE9PSAwIHx8IHkgIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgaWYgKGlzKG9iakEsIG9iakIpKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAodHlwZW9mIG9iakEgIT09ICdvYmplY3QnIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09ICdvYmplY3QnIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWhhc093bi5jYWxsKG9iakIsIGtleXNBW2ldKSB8fCAhaXMob2JqQVtrZXlzQVtpXV0sIG9iakJba2V5c0FbaV1dKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufSIsIi8qKlxyXG4gKiBAcGFyYW0ge2FueX0gb2JqIFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGFyZ3VtZW50IGFwcGVhcnMgdG8gYmUgYSBwbGFpbiBvYmplY3QuXHJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgdmFyIGJhc2VQcm90byA9IHByb3RvO1xuXG4gIHdoaWxlIChPYmplY3QuZ2V0UHJvdG90eXBlT2YoYmFzZVByb3RvKSAhPT0gbnVsbCkge1xuICAgIGJhc2VQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihiYXNlUHJvdG8pO1xuICB9XG5cbiAgcmV0dXJuIHByb3RvID09PSBiYXNlUHJvdG87XG59IiwiaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnLi9pc1BsYWluT2JqZWN0JztcbmltcG9ydCB3YXJuaW5nIGZyb20gJy4vd2FybmluZyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB2ZXJpZnlQbGFpbk9iamVjdCh2YWx1ZSwgZGlzcGxheU5hbWUsIG1ldGhvZE5hbWUpIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIHdhcm5pbmcobWV0aG9kTmFtZSArIFwiKCkgaW4gXCIgKyBkaXNwbGF5TmFtZSArIFwiIG11c3QgcmV0dXJuIGEgcGxhaW4gb2JqZWN0LiBJbnN0ZWFkIHJlY2VpdmVkIFwiICsgdmFsdWUgKyBcIi5cIik7XG4gIH1cbn0iLCJpbXBvcnQgdmVyaWZ5UGxhaW5PYmplY3QgZnJvbSAnLi4vdXRpbHMvdmVyaWZ5UGxhaW5PYmplY3QnO1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQoZ2V0Q29uc3RhbnQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGluaXRDb25zdGFudFNlbGVjdG9yKGRpc3BhdGNoLCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbnN0YW50ID0gZ2V0Q29uc3RhbnQoZGlzcGF0Y2gsIG9wdGlvbnMpO1xuXG4gICAgZnVuY3Rpb24gY29uc3RhbnRTZWxlY3RvcigpIHtcbiAgICAgIHJldHVybiBjb25zdGFudDtcbiAgICB9XG5cbiAgICBjb25zdGFudFNlbGVjdG9yLmRlcGVuZHNPbk93blByb3BzID0gZmFsc2U7XG4gICAgcmV0dXJuIGNvbnN0YW50U2VsZWN0b3I7XG4gIH07XG59IC8vIGRlcGVuZHNPbk93blByb3BzIGlzIHVzZWQgYnkgY3JlYXRlTWFwVG9Qcm9wc1Byb3h5IHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHBhc3MgcHJvcHMgYXMgYXJnc1xuLy8gdG8gdGhlIG1hcFRvUHJvcHMgZnVuY3Rpb24gYmVpbmcgd3JhcHBlZC4gSXQgaXMgYWxzbyB1c2VkIGJ5IG1ha2VQdXJlUHJvcHNTZWxlY3RvciB0byBkZXRlcm1pbmVcbi8vIHdoZXRoZXIgbWFwVG9Qcm9wcyBuZWVkcyB0byBiZSBpbnZva2VkIHdoZW4gcHJvcHMgaGF2ZSBjaGFuZ2VkLlxuLy8gXG4vLyBBIGxlbmd0aCBvZiBvbmUgc2lnbmFscyB0aGF0IG1hcFRvUHJvcHMgZG9lcyBub3QgZGVwZW5kIG9uIHByb3BzIGZyb20gdGhlIHBhcmVudCBjb21wb25lbnQuXG4vLyBBIGxlbmd0aCBvZiB6ZXJvIGlzIGFzc3VtZWQgdG8gbWVhbiBtYXBUb1Byb3BzIGlzIGdldHRpbmcgYXJncyB2aWEgYXJndW1lbnRzIG9yIC4uLmFyZ3MgYW5kXG4vLyB0aGVyZWZvcmUgbm90IHJlcG9ydGluZyBpdHMgbGVuZ3RoIGFjY3VyYXRlbHkuLlxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVwZW5kc09uT3duUHJvcHMobWFwVG9Qcm9wcykge1xuICByZXR1cm4gbWFwVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcyAhPT0gbnVsbCAmJiBtYXBUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzICE9PSB1bmRlZmluZWQgPyBCb29sZWFuKG1hcFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpIDogbWFwVG9Qcm9wcy5sZW5ndGggIT09IDE7XG59IC8vIFVzZWQgYnkgd2hlbk1hcFN0YXRlVG9Qcm9wc0lzRnVuY3Rpb24gYW5kIHdoZW5NYXBEaXNwYXRjaFRvUHJvcHNJc0Z1bmN0aW9uLFxuLy8gdGhpcyBmdW5jdGlvbiB3cmFwcyBtYXBUb1Byb3BzIGluIGEgcHJveHkgZnVuY3Rpb24gd2hpY2ggZG9lcyBzZXZlcmFsIHRoaW5nczpcbi8vIFxuLy8gICogRGV0ZWN0cyB3aGV0aGVyIHRoZSBtYXBUb1Byb3BzIGZ1bmN0aW9uIGJlaW5nIGNhbGxlZCBkZXBlbmRzIG9uIHByb3BzLCB3aGljaFxuLy8gICAgaXMgdXNlZCBieSBzZWxlY3RvckZhY3RvcnkgdG8gZGVjaWRlIGlmIGl0IHNob3VsZCByZWludm9rZSBvbiBwcm9wcyBjaGFuZ2VzLlxuLy8gICAgXG4vLyAgKiBPbiBmaXJzdCBjYWxsLCBoYW5kbGVzIG1hcFRvUHJvcHMgaWYgcmV0dXJucyBhbm90aGVyIGZ1bmN0aW9uLCBhbmQgdHJlYXRzIHRoYXRcbi8vICAgIG5ldyBmdW5jdGlvbiBhcyB0aGUgdHJ1ZSBtYXBUb1Byb3BzIGZvciBzdWJzZXF1ZW50IGNhbGxzLlxuLy8gICAgXG4vLyAgKiBPbiBmaXJzdCBjYWxsLCB2ZXJpZmllcyB0aGUgZmlyc3QgcmVzdWx0IGlzIGEgcGxhaW4gb2JqZWN0LCBpbiBvcmRlciB0byB3YXJuXG4vLyAgICB0aGUgZGV2ZWxvcGVyIHRoYXQgdGhlaXIgbWFwVG9Qcm9wcyBmdW5jdGlvbiBpcyBub3QgcmV0dXJuaW5nIGEgdmFsaWQgcmVzdWx0LlxuLy8gICAgXG5cbmV4cG9ydCBmdW5jdGlvbiB3cmFwTWFwVG9Qcm9wc0Z1bmMobWFwVG9Qcm9wcywgbWV0aG9kTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gaW5pdFByb3h5U2VsZWN0b3IoZGlzcGF0Y2gsIF9yZWYpIHtcbiAgICB2YXIgZGlzcGxheU5hbWUgPSBfcmVmLmRpc3BsYXlOYW1lO1xuXG4gICAgdmFyIHByb3h5ID0gZnVuY3Rpb24gbWFwVG9Qcm9wc1Byb3h5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpIHtcbiAgICAgIHJldHVybiBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA/IHByb3h5Lm1hcFRvUHJvcHMoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcykgOiBwcm94eS5tYXBUb1Byb3BzKHN0YXRlT3JEaXNwYXRjaCk7XG4gICAgfTsgLy8gYWxsb3cgZGV0ZWN0RmFjdG9yeUFuZFZlcmlmeSB0byBnZXQgb3duUHJvcHNcblxuXG4gICAgcHJveHkuZGVwZW5kc09uT3duUHJvcHMgPSB0cnVlO1xuXG4gICAgcHJveHkubWFwVG9Qcm9wcyA9IGZ1bmN0aW9uIGRldGVjdEZhY3RvcnlBbmRWZXJpZnkoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcykge1xuICAgICAgcHJveHkubWFwVG9Qcm9wcyA9IG1hcFRvUHJvcHM7XG4gICAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IGdldERlcGVuZHNPbk93blByb3BzKG1hcFRvUHJvcHMpO1xuICAgICAgdmFyIHByb3BzID0gcHJveHkoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcyk7XG5cbiAgICAgIGlmICh0eXBlb2YgcHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJveHkubWFwVG9Qcm9wcyA9IHByb3BzO1xuICAgICAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IGdldERlcGVuZHNPbk93blByb3BzKHByb3BzKTtcbiAgICAgICAgcHJvcHMgPSBwcm94eShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHZlcmlmeVBsYWluT2JqZWN0KHByb3BzLCBkaXNwbGF5TmFtZSwgbWV0aG9kTmFtZSk7XG4gICAgICByZXR1cm4gcHJvcHM7XG4gICAgfTtcblxuICAgIHJldHVybiBwcm94eTtcbiAgfTtcbn0iLCJpbXBvcnQgeyBiaW5kQWN0aW9uQ3JlYXRvcnMgfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgeyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50LCB3cmFwTWFwVG9Qcm9wc0Z1bmMgfSBmcm9tICcuL3dyYXBNYXBUb1Byb3BzJztcbmV4cG9ydCBmdW5jdGlvbiB3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNGdW5jdGlvbihtYXBEaXNwYXRjaFRvUHJvcHMpIHtcbiAgcmV0dXJuIHR5cGVvZiBtYXBEaXNwYXRjaFRvUHJvcHMgPT09ICdmdW5jdGlvbicgPyB3cmFwTWFwVG9Qcm9wc0Z1bmMobWFwRGlzcGF0Y2hUb1Byb3BzLCAnbWFwRGlzcGF0Y2hUb1Byb3BzJykgOiB1bmRlZmluZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gd2hlbk1hcERpc3BhdGNoVG9Qcm9wc0lzTWlzc2luZyhtYXBEaXNwYXRjaFRvUHJvcHMpIHtcbiAgcmV0dXJuICFtYXBEaXNwYXRjaFRvUHJvcHMgPyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KGZ1bmN0aW9uIChkaXNwYXRjaCkge1xuICAgIHJldHVybiB7XG4gICAgICBkaXNwYXRjaDogZGlzcGF0Y2hcbiAgICB9O1xuICB9KSA6IHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNPYmplY3QobWFwRGlzcGF0Y2hUb1Byb3BzKSB7XG4gIHJldHVybiBtYXBEaXNwYXRjaFRvUHJvcHMgJiYgdHlwZW9mIG1hcERpc3BhdGNoVG9Qcm9wcyA9PT0gJ29iamVjdCcgPyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KGZ1bmN0aW9uIChkaXNwYXRjaCkge1xuICAgIHJldHVybiBiaW5kQWN0aW9uQ3JlYXRvcnMobWFwRGlzcGF0Y2hUb1Byb3BzLCBkaXNwYXRjaCk7XG4gIH0pIDogdW5kZWZpbmVkO1xufVxuZXhwb3J0IGRlZmF1bHQgW3doZW5NYXBEaXNwYXRjaFRvUHJvcHNJc0Z1bmN0aW9uLCB3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNNaXNzaW5nLCB3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNPYmplY3RdOyIsImltcG9ydCB7IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQsIHdyYXBNYXBUb1Byb3BzRnVuYyB9IGZyb20gJy4vd3JhcE1hcFRvUHJvcHMnO1xuZXhwb3J0IGZ1bmN0aW9uIHdoZW5NYXBTdGF0ZVRvUHJvcHNJc0Z1bmN0aW9uKG1hcFN0YXRlVG9Qcm9wcykge1xuICByZXR1cm4gdHlwZW9mIG1hcFN0YXRlVG9Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyA/IHdyYXBNYXBUb1Byb3BzRnVuYyhtYXBTdGF0ZVRvUHJvcHMsICdtYXBTdGF0ZVRvUHJvcHMnKSA6IHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3aGVuTWFwU3RhdGVUb1Byb3BzSXNNaXNzaW5nKG1hcFN0YXRlVG9Qcm9wcykge1xuICByZXR1cm4gIW1hcFN0YXRlVG9Qcm9wcyA/IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7fTtcbiAgfSkgOiB1bmRlZmluZWQ7XG59XG5leHBvcnQgZGVmYXVsdCBbd2hlbk1hcFN0YXRlVG9Qcm9wc0lzRnVuY3Rpb24sIHdoZW5NYXBTdGF0ZVRvUHJvcHNJc01pc3NpbmddOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IHZlcmlmeVBsYWluT2JqZWN0IGZyb20gJy4uL3V0aWxzL3ZlcmlmeVBsYWluT2JqZWN0JztcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0TWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcykge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIG93blByb3BzLCBzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwTWVyZ2VQcm9wc0Z1bmMobWVyZ2VQcm9wcykge1xuICByZXR1cm4gZnVuY3Rpb24gaW5pdE1lcmdlUHJvcHNQcm94eShkaXNwYXRjaCwgX3JlZikge1xuICAgIHZhciBkaXNwbGF5TmFtZSA9IF9yZWYuZGlzcGxheU5hbWUsXG4gICAgICAgIHB1cmUgPSBfcmVmLnB1cmUsXG4gICAgICAgIGFyZU1lcmdlZFByb3BzRXF1YWwgPSBfcmVmLmFyZU1lcmdlZFByb3BzRXF1YWw7XG4gICAgdmFyIGhhc1J1bk9uY2UgPSBmYWxzZTtcbiAgICB2YXIgbWVyZ2VkUHJvcHM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlUHJvcHNQcm94eShzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcykge1xuICAgICAgdmFyIG5leHRNZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuXG4gICAgICBpZiAoaGFzUnVuT25jZSkge1xuICAgICAgICBpZiAoIXB1cmUgfHwgIWFyZU1lcmdlZFByb3BzRXF1YWwobmV4dE1lcmdlZFByb3BzLCBtZXJnZWRQcm9wcykpIG1lcmdlZFByb3BzID0gbmV4dE1lcmdlZFByb3BzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFzUnVuT25jZSA9IHRydWU7XG4gICAgICAgIG1lcmdlZFByb3BzID0gbmV4dE1lcmdlZFByb3BzO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgdmVyaWZ5UGxhaW5PYmplY3QobWVyZ2VkUHJvcHMsIGRpc3BsYXlOYW1lLCAnbWVyZ2VQcm9wcycpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gICAgfTtcbiAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3aGVuTWVyZ2VQcm9wc0lzRnVuY3Rpb24obWVyZ2VQcm9wcykge1xuICByZXR1cm4gdHlwZW9mIG1lcmdlUHJvcHMgPT09ICdmdW5jdGlvbicgPyB3cmFwTWVyZ2VQcm9wc0Z1bmMobWVyZ2VQcm9wcykgOiB1bmRlZmluZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gd2hlbk1lcmdlUHJvcHNJc09taXR0ZWQobWVyZ2VQcm9wcykge1xuICByZXR1cm4gIW1lcmdlUHJvcHMgPyBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNZXJnZVByb3BzO1xuICB9IDogdW5kZWZpbmVkO1xufVxuZXhwb3J0IGRlZmF1bHQgW3doZW5NZXJnZVByb3BzSXNGdW5jdGlvbiwgd2hlbk1lcmdlUHJvcHNJc09taXR0ZWRdOyIsImltcG9ydCB3YXJuaW5nIGZyb20gJy4uL3V0aWxzL3dhcm5pbmcnO1xuXG5mdW5jdGlvbiB2ZXJpZnkoc2VsZWN0b3IsIG1ldGhvZE5hbWUsIGRpc3BsYXlOYW1lKSB7XG4gIGlmICghc2VsZWN0b3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHZhbHVlIGZvciBcIiArIG1ldGhvZE5hbWUgKyBcIiBpbiBcIiArIGRpc3BsYXlOYW1lICsgXCIuXCIpO1xuICB9IGVsc2UgaWYgKG1ldGhvZE5hbWUgPT09ICdtYXBTdGF0ZVRvUHJvcHMnIHx8IG1ldGhvZE5hbWUgPT09ICdtYXBEaXNwYXRjaFRvUHJvcHMnKSB7XG4gICAgaWYgKCFzZWxlY3Rvci5oYXNPd25Qcm9wZXJ0eSgnZGVwZW5kc09uT3duUHJvcHMnKSkge1xuICAgICAgd2FybmluZyhcIlRoZSBzZWxlY3RvciBmb3IgXCIgKyBtZXRob2ROYW1lICsgXCIgb2YgXCIgKyBkaXNwbGF5TmFtZSArIFwiIGRpZCBub3Qgc3BlY2lmeSBhIHZhbHVlIGZvciBkZXBlbmRzT25Pd25Qcm9wcy5cIik7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHZlcmlmeVN1YnNlbGVjdG9ycyhtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmVyaWZ5KG1hcFN0YXRlVG9Qcm9wcywgJ21hcFN0YXRlVG9Qcm9wcycsIGRpc3BsYXlOYW1lKTtcbiAgdmVyaWZ5KG1hcERpc3BhdGNoVG9Qcm9wcywgJ21hcERpc3BhdGNoVG9Qcm9wcycsIGRpc3BsYXlOYW1lKTtcbiAgdmVyaWZ5KG1lcmdlUHJvcHMsICdtZXJnZVByb3BzJywgZGlzcGxheU5hbWUpO1xufSIsImltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZVwiO1xuaW1wb3J0IHZlcmlmeVN1YnNlbGVjdG9ycyBmcm9tICcuL3ZlcmlmeVN1YnNlbGVjdG9ycyc7XG5leHBvcnQgZnVuY3Rpb24gaW1wdXJlRmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywgZGlzcGF0Y2gpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGltcHVyZUZpbmFsUHJvcHNTZWxlY3RvcihzdGF0ZSwgb3duUHJvcHMpIHtcbiAgICByZXR1cm4gbWVyZ2VQcm9wcyhtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKSwgbWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoLCBvd25Qcm9wcyksIG93blByb3BzKTtcbiAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwdXJlRmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywgZGlzcGF0Y2gsIF9yZWYpIHtcbiAgdmFyIGFyZVN0YXRlc0VxdWFsID0gX3JlZi5hcmVTdGF0ZXNFcXVhbCxcbiAgICAgIGFyZU93blByb3BzRXF1YWwgPSBfcmVmLmFyZU93blByb3BzRXF1YWwsXG4gICAgICBhcmVTdGF0ZVByb3BzRXF1YWwgPSBfcmVmLmFyZVN0YXRlUHJvcHNFcXVhbDtcbiAgdmFyIGhhc1J1bkF0TGVhc3RPbmNlID0gZmFsc2U7XG4gIHZhciBzdGF0ZTtcbiAgdmFyIG93blByb3BzO1xuICB2YXIgc3RhdGVQcm9wcztcbiAgdmFyIGRpc3BhdGNoUHJvcHM7XG4gIHZhciBtZXJnZWRQcm9wcztcblxuICBmdW5jdGlvbiBoYW5kbGVGaXJzdENhbGwoZmlyc3RTdGF0ZSwgZmlyc3RPd25Qcm9wcykge1xuICAgIHN0YXRlID0gZmlyc3RTdGF0ZTtcbiAgICBvd25Qcm9wcyA9IGZpcnN0T3duUHJvcHM7XG4gICAgc3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIGhhc1J1bkF0TGVhc3RPbmNlID0gdHJ1ZTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVOZXdQcm9wc0FuZE5ld1N0YXRlKCkge1xuICAgIHN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcbiAgICBpZiAobWFwRGlzcGF0Y2hUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzKSBkaXNwYXRjaFByb3BzID0gbWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoLCBvd25Qcm9wcyk7XG4gICAgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVOZXdQcm9wcygpIHtcbiAgICBpZiAobWFwU3RhdGVUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzKSBzdGF0ZVByb3BzID0gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyk7XG4gICAgaWYgKG1hcERpc3BhdGNoVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcykgZGlzcGF0Y2hQcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTmV3U3RhdGUoKSB7XG4gICAgdmFyIG5leHRTdGF0ZVByb3BzID0gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyk7XG4gICAgdmFyIHN0YXRlUHJvcHNDaGFuZ2VkID0gIWFyZVN0YXRlUHJvcHNFcXVhbChuZXh0U3RhdGVQcm9wcywgc3RhdGVQcm9wcyk7XG4gICAgc3RhdGVQcm9wcyA9IG5leHRTdGF0ZVByb3BzO1xuICAgIGlmIChzdGF0ZVByb3BzQ2hhbmdlZCkgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVTdWJzZXF1ZW50Q2FsbHMobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpIHtcbiAgICB2YXIgcHJvcHNDaGFuZ2VkID0gIWFyZU93blByb3BzRXF1YWwobmV4dE93blByb3BzLCBvd25Qcm9wcyk7XG4gICAgdmFyIHN0YXRlQ2hhbmdlZCA9ICFhcmVTdGF0ZXNFcXVhbChuZXh0U3RhdGUsIHN0YXRlKTtcbiAgICBzdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICBvd25Qcm9wcyA9IG5leHRPd25Qcm9wcztcbiAgICBpZiAocHJvcHNDaGFuZ2VkICYmIHN0YXRlQ2hhbmdlZCkgcmV0dXJuIGhhbmRsZU5ld1Byb3BzQW5kTmV3U3RhdGUoKTtcbiAgICBpZiAocHJvcHNDaGFuZ2VkKSByZXR1cm4gaGFuZGxlTmV3UHJvcHMoKTtcbiAgICBpZiAoc3RhdGVDaGFuZ2VkKSByZXR1cm4gaGFuZGxlTmV3U3RhdGUoKTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcHVyZUZpbmFsUHJvcHNTZWxlY3RvcihuZXh0U3RhdGUsIG5leHRPd25Qcm9wcykge1xuICAgIHJldHVybiBoYXNSdW5BdExlYXN0T25jZSA/IGhhbmRsZVN1YnNlcXVlbnRDYWxscyhuZXh0U3RhdGUsIG5leHRPd25Qcm9wcykgOiBoYW5kbGVGaXJzdENhbGwobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpO1xuICB9O1xufSAvLyBUT0RPOiBBZGQgbW9yZSBjb21tZW50c1xuLy8gSWYgcHVyZSBpcyB0cnVlLCB0aGUgc2VsZWN0b3IgcmV0dXJuZWQgYnkgc2VsZWN0b3JGYWN0b3J5IHdpbGwgbWVtb2l6ZSBpdHMgcmVzdWx0cyxcbi8vIGFsbG93aW5nIGNvbm5lY3RBZHZhbmNlZCdzIHNob3VsZENvbXBvbmVudFVwZGF0ZSB0byByZXR1cm4gZmFsc2UgaWYgZmluYWxcbi8vIHByb3BzIGhhdmUgbm90IGNoYW5nZWQuIElmIGZhbHNlLCB0aGUgc2VsZWN0b3Igd2lsbCBhbHdheXMgcmV0dXJuIGEgbmV3XG4vLyBvYmplY3QgYW5kIHNob3VsZENvbXBvbmVudFVwZGF0ZSB3aWxsIGFsd2F5cyByZXR1cm4gdHJ1ZS5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeShkaXNwYXRjaCwgX3JlZjIpIHtcbiAgdmFyIGluaXRNYXBTdGF0ZVRvUHJvcHMgPSBfcmVmMi5pbml0TWFwU3RhdGVUb1Byb3BzLFxuICAgICAgaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyA9IF9yZWYyLmluaXRNYXBEaXNwYXRjaFRvUHJvcHMsXG4gICAgICBpbml0TWVyZ2VQcm9wcyA9IF9yZWYyLmluaXRNZXJnZVByb3BzLFxuICAgICAgb3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYyLCBbXCJpbml0TWFwU3RhdGVUb1Byb3BzXCIsIFwiaW5pdE1hcERpc3BhdGNoVG9Qcm9wc1wiLCBcImluaXRNZXJnZVByb3BzXCJdKTtcblxuICB2YXIgbWFwU3RhdGVUb1Byb3BzID0gaW5pdE1hcFN0YXRlVG9Qcm9wcyhkaXNwYXRjaCwgb3B0aW9ucyk7XG4gIHZhciBtYXBEaXNwYXRjaFRvUHJvcHMgPSBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoLCBvcHRpb25zKTtcbiAgdmFyIG1lcmdlUHJvcHMgPSBpbml0TWVyZ2VQcm9wcyhkaXNwYXRjaCwgb3B0aW9ucyk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2ZXJpZnlTdWJzZWxlY3RvcnMobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIG9wdGlvbnMuZGlzcGxheU5hbWUpO1xuICB9XG5cbiAgdmFyIHNlbGVjdG9yRmFjdG9yeSA9IG9wdGlvbnMucHVyZSA/IHB1cmVGaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5IDogaW1wdXJlRmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeTtcbiAgcmV0dXJuIHNlbGVjdG9yRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywgZGlzcGF0Y2gsIG9wdGlvbnMpO1xufSIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlXCI7XG5pbXBvcnQgY29ubmVjdEFkdmFuY2VkIGZyb20gJy4uL2NvbXBvbmVudHMvY29ubmVjdEFkdmFuY2VkJztcbmltcG9ydCBzaGFsbG93RXF1YWwgZnJvbSAnLi4vdXRpbHMvc2hhbGxvd0VxdWFsJztcbmltcG9ydCBkZWZhdWx0TWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yaWVzIGZyb20gJy4vbWFwRGlzcGF0Y2hUb1Byb3BzJztcbmltcG9ydCBkZWZhdWx0TWFwU3RhdGVUb1Byb3BzRmFjdG9yaWVzIGZyb20gJy4vbWFwU3RhdGVUb1Byb3BzJztcbmltcG9ydCBkZWZhdWx0TWVyZ2VQcm9wc0ZhY3RvcmllcyBmcm9tICcuL21lcmdlUHJvcHMnO1xuaW1wb3J0IGRlZmF1bHRTZWxlY3RvckZhY3RvcnkgZnJvbSAnLi9zZWxlY3RvckZhY3RvcnknO1xuLypcbiAgY29ubmVjdCBpcyBhIGZhY2FkZSBvdmVyIGNvbm5lY3RBZHZhbmNlZC4gSXQgdHVybnMgaXRzIGFyZ3MgaW50byBhIGNvbXBhdGlibGVcbiAgc2VsZWN0b3JGYWN0b3J5LCB3aGljaCBoYXMgdGhlIHNpZ25hdHVyZTpcblxuICAgIChkaXNwYXRjaCwgb3B0aW9ucykgPT4gKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKSA9PiBuZXh0RmluYWxQcm9wc1xuICBcbiAgY29ubmVjdCBwYXNzZXMgaXRzIGFyZ3MgdG8gY29ubmVjdEFkdmFuY2VkIGFzIG9wdGlvbnMsIHdoaWNoIHdpbGwgaW4gdHVybiBwYXNzIHRoZW0gdG9cbiAgc2VsZWN0b3JGYWN0b3J5IGVhY2ggdGltZSBhIENvbm5lY3QgY29tcG9uZW50IGluc3RhbmNlIGlzIGluc3RhbnRpYXRlZCBvciBob3QgcmVsb2FkZWQuXG5cbiAgc2VsZWN0b3JGYWN0b3J5IHJldHVybnMgYSBmaW5hbCBwcm9wcyBzZWxlY3RvciBmcm9tIGl0cyBtYXBTdGF0ZVRvUHJvcHMsXG4gIG1hcFN0YXRlVG9Qcm9wc0ZhY3RvcmllcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3JpZXMsIG1lcmdlUHJvcHMsXG4gIG1lcmdlUHJvcHNGYWN0b3JpZXMsIGFuZCBwdXJlIGFyZ3MuXG5cbiAgVGhlIHJlc3VsdGluZyBmaW5hbCBwcm9wcyBzZWxlY3RvciBpcyBjYWxsZWQgYnkgdGhlIENvbm5lY3QgY29tcG9uZW50IGluc3RhbmNlIHdoZW5ldmVyXG4gIGl0IHJlY2VpdmVzIG5ldyBwcm9wcyBvciBzdG9yZSBzdGF0ZS5cbiAqL1xuXG5mdW5jdGlvbiBtYXRjaChhcmcsIGZhY3RvcmllcywgbmFtZSkge1xuICBmb3IgKHZhciBpID0gZmFjdG9yaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHJlc3VsdCA9IGZhY3Rvcmllc1tpXShhcmcpO1xuICAgIGlmIChyZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoLCBvcHRpb25zKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZSBvZiB0eXBlIFwiICsgdHlwZW9mIGFyZyArIFwiIGZvciBcIiArIG5hbWUgKyBcIiBhcmd1bWVudCB3aGVuIGNvbm5lY3RpbmcgY29tcG9uZW50IFwiICsgb3B0aW9ucy53cmFwcGVkQ29tcG9uZW50TmFtZSArIFwiLlwiKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3RyaWN0RXF1YWwoYSwgYikge1xuICByZXR1cm4gYSA9PT0gYjtcbn0gLy8gY3JlYXRlQ29ubmVjdCB3aXRoIGRlZmF1bHQgYXJncyBidWlsZHMgdGhlICdvZmZpY2lhbCcgY29ubmVjdCBiZWhhdmlvci4gQ2FsbGluZyBpdCB3aXRoXG4vLyBkaWZmZXJlbnQgb3B0aW9ucyBvcGVucyB1cCBzb21lIHRlc3RpbmcgYW5kIGV4dGVuc2liaWxpdHkgc2NlbmFyaW9zXG5cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbm5lY3QoX3RlbXApIHtcbiAgdmFyIF9yZWYgPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcCxcbiAgICAgIF9yZWYkY29ubmVjdEhPQyA9IF9yZWYuY29ubmVjdEhPQyxcbiAgICAgIGNvbm5lY3RIT0MgPSBfcmVmJGNvbm5lY3RIT0MgPT09IHZvaWQgMCA/IGNvbm5lY3RBZHZhbmNlZCA6IF9yZWYkY29ubmVjdEhPQyxcbiAgICAgIF9yZWYkbWFwU3RhdGVUb1Byb3BzRiA9IF9yZWYubWFwU3RhdGVUb1Byb3BzRmFjdG9yaWVzLFxuICAgICAgbWFwU3RhdGVUb1Byb3BzRmFjdG9yaWVzID0gX3JlZiRtYXBTdGF0ZVRvUHJvcHNGID09PSB2b2lkIDAgPyBkZWZhdWx0TWFwU3RhdGVUb1Byb3BzRmFjdG9yaWVzIDogX3JlZiRtYXBTdGF0ZVRvUHJvcHNGLFxuICAgICAgX3JlZiRtYXBEaXNwYXRjaFRvUHJvID0gX3JlZi5tYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3JpZXMsXG4gICAgICBtYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3JpZXMgPSBfcmVmJG1hcERpc3BhdGNoVG9Qcm8gPT09IHZvaWQgMCA/IGRlZmF1bHRNYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3JpZXMgOiBfcmVmJG1hcERpc3BhdGNoVG9Qcm8sXG4gICAgICBfcmVmJG1lcmdlUHJvcHNGYWN0b3IgPSBfcmVmLm1lcmdlUHJvcHNGYWN0b3JpZXMsXG4gICAgICBtZXJnZVByb3BzRmFjdG9yaWVzID0gX3JlZiRtZXJnZVByb3BzRmFjdG9yID09PSB2b2lkIDAgPyBkZWZhdWx0TWVyZ2VQcm9wc0ZhY3RvcmllcyA6IF9yZWYkbWVyZ2VQcm9wc0ZhY3RvcixcbiAgICAgIF9yZWYkc2VsZWN0b3JGYWN0b3J5ID0gX3JlZi5zZWxlY3RvckZhY3RvcnksXG4gICAgICBzZWxlY3RvckZhY3RvcnkgPSBfcmVmJHNlbGVjdG9yRmFjdG9yeSA9PT0gdm9pZCAwID8gZGVmYXVsdFNlbGVjdG9yRmFjdG9yeSA6IF9yZWYkc2VsZWN0b3JGYWN0b3J5O1xuXG4gIHJldHVybiBmdW5jdGlvbiBjb25uZWN0KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzLCBfcmVmMikge1xuICAgIGlmIChfcmVmMiA9PT0gdm9pZCAwKSB7XG4gICAgICBfcmVmMiA9IHt9O1xuICAgIH1cblxuICAgIHZhciBfcmVmMyA9IF9yZWYyLFxuICAgICAgICBfcmVmMyRwdXJlID0gX3JlZjMucHVyZSxcbiAgICAgICAgcHVyZSA9IF9yZWYzJHB1cmUgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmMyRwdXJlLFxuICAgICAgICBfcmVmMyRhcmVTdGF0ZXNFcXVhbCA9IF9yZWYzLmFyZVN0YXRlc0VxdWFsLFxuICAgICAgICBhcmVTdGF0ZXNFcXVhbCA9IF9yZWYzJGFyZVN0YXRlc0VxdWFsID09PSB2b2lkIDAgPyBzdHJpY3RFcXVhbCA6IF9yZWYzJGFyZVN0YXRlc0VxdWFsLFxuICAgICAgICBfcmVmMyRhcmVPd25Qcm9wc0VxdWEgPSBfcmVmMy5hcmVPd25Qcm9wc0VxdWFsLFxuICAgICAgICBhcmVPd25Qcm9wc0VxdWFsID0gX3JlZjMkYXJlT3duUHJvcHNFcXVhID09PSB2b2lkIDAgPyBzaGFsbG93RXF1YWwgOiBfcmVmMyRhcmVPd25Qcm9wc0VxdWEsXG4gICAgICAgIF9yZWYzJGFyZVN0YXRlUHJvcHNFcSA9IF9yZWYzLmFyZVN0YXRlUHJvcHNFcXVhbCxcbiAgICAgICAgYXJlU3RhdGVQcm9wc0VxdWFsID0gX3JlZjMkYXJlU3RhdGVQcm9wc0VxID09PSB2b2lkIDAgPyBzaGFsbG93RXF1YWwgOiBfcmVmMyRhcmVTdGF0ZVByb3BzRXEsXG4gICAgICAgIF9yZWYzJGFyZU1lcmdlZFByb3BzRSA9IF9yZWYzLmFyZU1lcmdlZFByb3BzRXF1YWwsXG4gICAgICAgIGFyZU1lcmdlZFByb3BzRXF1YWwgPSBfcmVmMyRhcmVNZXJnZWRQcm9wc0UgPT09IHZvaWQgMCA/IHNoYWxsb3dFcXVhbCA6IF9yZWYzJGFyZU1lcmdlZFByb3BzRSxcbiAgICAgICAgZXh0cmFPcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZjMsIFtcInB1cmVcIiwgXCJhcmVTdGF0ZXNFcXVhbFwiLCBcImFyZU93blByb3BzRXF1YWxcIiwgXCJhcmVTdGF0ZVByb3BzRXF1YWxcIiwgXCJhcmVNZXJnZWRQcm9wc0VxdWFsXCJdKTtcblxuICAgIHZhciBpbml0TWFwU3RhdGVUb1Byb3BzID0gbWF0Y2gobWFwU3RhdGVUb1Byb3BzLCBtYXBTdGF0ZVRvUHJvcHNGYWN0b3JpZXMsICdtYXBTdGF0ZVRvUHJvcHMnKTtcbiAgICB2YXIgaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyA9IG1hdGNoKG1hcERpc3BhdGNoVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yaWVzLCAnbWFwRGlzcGF0Y2hUb1Byb3BzJyk7XG4gICAgdmFyIGluaXRNZXJnZVByb3BzID0gbWF0Y2gobWVyZ2VQcm9wcywgbWVyZ2VQcm9wc0ZhY3RvcmllcywgJ21lcmdlUHJvcHMnKTtcbiAgICByZXR1cm4gY29ubmVjdEhPQyhzZWxlY3RvckZhY3RvcnksIF9leHRlbmRzKHtcbiAgICAgIC8vIHVzZWQgaW4gZXJyb3IgbWVzc2FnZXNcbiAgICAgIG1ldGhvZE5hbWU6ICdjb25uZWN0JyxcbiAgICAgIC8vIHVzZWQgdG8gY29tcHV0ZSBDb25uZWN0J3MgZGlzcGxheU5hbWUgZnJvbSB0aGUgd3JhcHBlZCBjb21wb25lbnQncyBkaXNwbGF5TmFtZS5cbiAgICAgIGdldERpc3BsYXlOYW1lOiBmdW5jdGlvbiBnZXREaXNwbGF5TmFtZShuYW1lKSB7XG4gICAgICAgIHJldHVybiBcIkNvbm5lY3QoXCIgKyBuYW1lICsgXCIpXCI7XG4gICAgICB9LFxuICAgICAgLy8gaWYgbWFwU3RhdGVUb1Byb3BzIGlzIGZhbHN5LCB0aGUgQ29ubmVjdCBjb21wb25lbnQgZG9lc24ndCBzdWJzY3JpYmUgdG8gc3RvcmUgc3RhdGUgY2hhbmdlc1xuICAgICAgc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzOiBCb29sZWFuKG1hcFN0YXRlVG9Qcm9wcyksXG4gICAgICAvLyBwYXNzZWQgdGhyb3VnaCB0byBzZWxlY3RvckZhY3RvcnlcbiAgICAgIGluaXRNYXBTdGF0ZVRvUHJvcHM6IGluaXRNYXBTdGF0ZVRvUHJvcHMsXG4gICAgICBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzOiBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzLFxuICAgICAgaW5pdE1lcmdlUHJvcHM6IGluaXRNZXJnZVByb3BzLFxuICAgICAgcHVyZTogcHVyZSxcbiAgICAgIGFyZVN0YXRlc0VxdWFsOiBhcmVTdGF0ZXNFcXVhbCxcbiAgICAgIGFyZU93blByb3BzRXF1YWw6IGFyZU93blByb3BzRXF1YWwsXG4gICAgICBhcmVTdGF0ZVByb3BzRXF1YWw6IGFyZVN0YXRlUHJvcHNFcXVhbCxcbiAgICAgIGFyZU1lcmdlZFByb3BzRXF1YWw6IGFyZU1lcmdlZFByb3BzRXF1YWxcbiAgICB9LCBleHRyYU9wdGlvbnMpKTtcbiAgfTtcbn1cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUNvbm5lY3QoKTsiLCJpbXBvcnQgUHJvdmlkZXIsIHsgY3JlYXRlUHJvdmlkZXIgfSBmcm9tICcuL2NvbXBvbmVudHMvUHJvdmlkZXInO1xuaW1wb3J0IGNvbm5lY3RBZHZhbmNlZCBmcm9tICcuL2NvbXBvbmVudHMvY29ubmVjdEFkdmFuY2VkJztcbmltcG9ydCBjb25uZWN0IGZyb20gJy4vY29ubmVjdC9jb25uZWN0JztcbmV4cG9ydCB7IFByb3ZpZGVyLCBjcmVhdGVQcm92aWRlciwgY29ubmVjdEFkdmFuY2VkLCBjb25uZWN0IH07IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2V4dGVuZHNcIjtcbmltcG9ydCB7IEFSUkFZX0lOU0VSVCwgQVJSQVlfTU9WRSwgQVJSQVlfUE9QLCBBUlJBWV9QVVNILCBBUlJBWV9SRU1PVkUsIEFSUkFZX1JFTU9WRV9BTEwsIEFSUkFZX1NISUZULCBBUlJBWV9TUExJQ0UsIEFSUkFZX1NXQVAsIEFSUkFZX1VOU0hJRlQsIEFVVE9GSUxMLCBCTFVSLCBDSEFOR0UsIENMRUFSX1NVQk1JVCwgQ0xFQVJfU1VCTUlUX0VSUk9SUywgQ0xFQVJfQVNZTkNfRVJST1IsIERFU1RST1ksIEZPQ1VTLCBJTklUSUFMSVpFLCBSRUdJU1RFUl9GSUVMRCwgUkVTRVQsIFJFU0VUX1NFQ1RJT04sIENMRUFSX0ZJRUxEUywgU0VUX1NVQk1JVF9GQUlMRUQsIFNFVF9TVUJNSVRfU1VDQ0VFREVELCBTVEFSVF9BU1lOQ19WQUxJREFUSU9OLCBTVEFSVF9TVUJNSVQsIFNUT1BfQVNZTkNfVkFMSURBVElPTiwgU1RPUF9TVUJNSVQsIFNVQk1JVCwgVE9VQ0gsIFVOUkVHSVNURVJfRklFTEQsIFVOVE9VQ0gsIFVQREFURV9TWU5DX0VSUk9SUywgVVBEQVRFX1NZTkNfV0FSTklOR1MgfSBmcm9tICcuL2FjdGlvblR5cGVzJztcblxudmFyIGFycmF5SW5zZXJ0ID0gZnVuY3Rpb24gYXJyYXlJbnNlcnQoZm9ybSwgZmllbGQsIGluZGV4LCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFSUkFZX0lOU0VSVCxcbiAgICBtZXRhOiB7XG4gICAgICBmb3JtOiBmb3JtLFxuICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgaW5kZXg6IGluZGV4XG4gICAgfSxcbiAgICBwYXlsb2FkOiB2YWx1ZVxuICB9O1xufTtcblxudmFyIGFycmF5TW92ZSA9IGZ1bmN0aW9uIGFycmF5TW92ZShmb3JtLCBmaWVsZCwgZnJvbSwgdG8pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBBUlJBWV9NT1ZFLFxuICAgIG1ldGE6IHtcbiAgICAgIGZvcm06IGZvcm0sXG4gICAgICBmaWVsZDogZmllbGQsXG4gICAgICBmcm9tOiBmcm9tLFxuICAgICAgdG86IHRvXG4gICAgfVxuICB9O1xufTtcblxudmFyIGFycmF5UG9wID0gZnVuY3Rpb24gYXJyYXlQb3AoZm9ybSwgZmllbGQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBBUlJBWV9QT1AsXG4gICAgbWV0YToge1xuICAgICAgZm9ybTogZm9ybSxcbiAgICAgIGZpZWxkOiBmaWVsZFxuICAgIH1cbiAgfTtcbn07XG5cbnZhciBhcnJheVB1c2ggPSBmdW5jdGlvbiBhcnJheVB1c2goZm9ybSwgZmllbGQsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQVJSQVlfUFVTSCxcbiAgICBtZXRhOiB7XG4gICAgICBmb3JtOiBmb3JtLFxuICAgICAgZmllbGQ6IGZpZWxkXG4gICAgfSxcbiAgICBwYXlsb2FkOiB2YWx1ZVxuICB9O1xufTtcblxudmFyIGFycmF5UmVtb3ZlID0gZnVuY3Rpb24gYXJyYXlSZW1vdmUoZm9ybSwgZmllbGQsIGluZGV4KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQVJSQVlfUkVNT1ZFLFxuICAgIG1ldGE6IHtcbiAgICAgIGZvcm06IGZvcm0sXG4gICAgICBmaWVsZDogZmllbGQsXG4gICAgICBpbmRleDogaW5kZXhcbiAgICB9XG4gIH07XG59O1xuXG52YXIgYXJyYXlSZW1vdmVBbGwgPSBmdW5jdGlvbiBhcnJheVJlbW92ZUFsbChmb3JtLCBmaWVsZCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFSUkFZX1JFTU9WRV9BTEwsXG4gICAgbWV0YToge1xuICAgICAgZm9ybTogZm9ybSxcbiAgICAgIGZpZWxkOiBmaWVsZFxuICAgIH1cbiAgfTtcbn07XG5cbnZhciBhcnJheVNoaWZ0ID0gZnVuY3Rpb24gYXJyYXlTaGlmdChmb3JtLCBmaWVsZCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFSUkFZX1NISUZULFxuICAgIG1ldGE6IHtcbiAgICAgIGZvcm06IGZvcm0sXG4gICAgICBmaWVsZDogZmllbGRcbiAgICB9XG4gIH07XG59O1xuXG52YXIgYXJyYXlTcGxpY2UgPSBmdW5jdGlvbiBhcnJheVNwbGljZShmb3JtLCBmaWVsZCwgaW5kZXgsIHJlbW92ZU51bSwgdmFsdWUpIHtcbiAgdmFyIGFjdGlvbiA9IHtcbiAgICB0eXBlOiBBUlJBWV9TUExJQ0UsXG4gICAgbWV0YToge1xuICAgICAgZm9ybTogZm9ybSxcbiAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgIHJlbW92ZU51bTogcmVtb3ZlTnVtXG4gICAgfVxuICB9O1xuXG4gIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYWN0aW9uLnBheWxvYWQgPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBhY3Rpb247XG59O1xuXG52YXIgYXJyYXlTd2FwID0gZnVuY3Rpb24gYXJyYXlTd2FwKGZvcm0sIGZpZWxkLCBpbmRleEEsIGluZGV4Qikge1xuICBpZiAoaW5kZXhBID09PSBpbmRleEIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1N3YXAgaW5kaWNlcyBjYW5ub3QgYmUgZXF1YWwnKTtcbiAgfVxuXG4gIGlmIChpbmRleEEgPCAwIHx8IGluZGV4QiA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1N3YXAgaW5kaWNlcyBjYW5ub3QgYmUgbmVnYXRpdmUnKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogQVJSQVlfU1dBUCxcbiAgICBtZXRhOiB7XG4gICAgICBmb3JtOiBmb3JtLFxuICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgaW5kZXhBOiBpbmRleEEsXG4gICAgICBpbmRleEI6IGluZGV4QlxuICAgIH1cbiAgfTtcbn07XG5cbnZhciBhcnJheVVuc2hpZnQgPSBmdW5jdGlvbiBhcnJheVVuc2hpZnQoZm9ybSwgZmllbGQsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQVJSQVlfVU5TSElGVCxcbiAgICBtZXRhOiB7XG4gICAgICBmb3JtOiBmb3JtLFxuICAgICAgZmllbGQ6IGZpZWxkXG4gICAgfSxcbiAgICBwYXlsb2FkOiB2YWx1ZVxuICB9O1xufTtcblxudmFyIGF1dG9maWxsID0gZnVuY3Rpb24gYXV0b2ZpbGwoZm9ybSwgZmllbGQsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQVVUT0ZJTEwsXG4gICAgbWV0YToge1xuICAgICAgZm9ybTogZm9ybSxcbiAgICAgIGZpZWxkOiBmaWVsZFxuICAgIH0sXG4gICAgcGF5bG9hZDogdmFsdWVcbiAgfTtcbn07XG5cbnZhciBibHVyID0gZnVuY3Rpb24gYmx1cihmb3JtLCBmaWVsZCwgdmFsdWUsIHRvdWNoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQkxVUixcbiAgICBtZXRhOiB7XG4gICAgICBmb3JtOiBmb3JtLFxuICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgdG91Y2g6IHRvdWNoXG4gICAgfSxcbiAgICBwYXlsb2FkOiB2YWx1ZVxuICB9O1xufTtcblxudmFyIGNoYW5nZSA9IGZ1bmN0aW9uIGNoYW5nZShmb3JtLCBmaWVsZCwgdmFsdWUsIHRvdWNoLCBwZXJzaXN0ZW50U3VibWl0RXJyb3JzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQ0hBTkdFLFxuICAgIG1ldGE6IHtcbiAgICAgIGZvcm06IGZvcm0sXG4gICAgICBmaWVsZDogZmllbGQsXG4gICAgICB0b3VjaDogdG91Y2gsXG4gICAgICBwZXJzaXN0ZW50U3VibWl0RXJyb3JzOiBwZXJzaXN0ZW50U3VibWl0RXJyb3JzXG4gICAgfSxcbiAgICBwYXlsb2FkOiB2YWx1ZVxuICB9O1xufTtcblxudmFyIGNsZWFyU3VibWl0ID0gZnVuY3Rpb24gY2xlYXJTdWJtaXQoZm9ybSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IENMRUFSX1NVQk1JVCxcbiAgICBtZXRhOiB7XG4gICAgICBmb3JtOiBmb3JtXG4gICAgfVxuICB9O1xufTtcblxudmFyIGNsZWFyU3VibWl0RXJyb3JzID0gZnVuY3Rpb24gY2xlYXJTdWJtaXRFcnJvcnMoZm9ybSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IENMRUFSX1NVQk1JVF9FUlJPUlMsXG4gICAgbWV0YToge1xuICAgICAgZm9ybTogZm9ybVxuICAgIH1cbiAgfTtcbn07XG5cbnZhciBjbGVhckFzeW5jRXJyb3IgPSBmdW5jdGlvbiBjbGVhckFzeW5jRXJyb3IoZm9ybSwgZmllbGQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBDTEVBUl9BU1lOQ19FUlJPUixcbiAgICBtZXRhOiB7XG4gICAgICBmb3JtOiBmb3JtLFxuICAgICAgZmllbGQ6IGZpZWxkXG4gICAgfVxuICB9O1xufTtcblxudmFyIGNsZWFyRmllbGRzID0gZnVuY3Rpb24gY2xlYXJGaWVsZHMoZm9ybSwga2VlcFRvdWNoZWQsIHBlcnNpc3RlbnRTdWJtaXRFcnJvcnMpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZpZWxkcyA9IG5ldyBBcnJheShfbGVuID4gMyA/IF9sZW4gLSAzIDogMCksIF9rZXkgPSAzOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgZmllbGRzW19rZXkgLSAzXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogQ0xFQVJfRklFTERTLFxuICAgIG1ldGE6IHtcbiAgICAgIGZvcm06IGZvcm0sXG4gICAgICBrZWVwVG91Y2hlZDoga2VlcFRvdWNoZWQsXG4gICAgICBwZXJzaXN0ZW50U3VibWl0RXJyb3JzOiBwZXJzaXN0ZW50U3VibWl0RXJyb3JzLFxuICAgICAgZmllbGRzOiBmaWVsZHNcbiAgICB9XG4gIH07XG59O1xuXG52YXIgZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgZm9ybSA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgIGZvcm1bX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogREVTVFJPWSxcbiAgICBtZXRhOiB7XG4gICAgICBmb3JtOiBmb3JtXG4gICAgfVxuICB9O1xufTtcblxudmFyIGZvY3VzID0gZnVuY3Rpb24gZm9jdXMoZm9ybSwgZmllbGQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBGT0NVUyxcbiAgICBtZXRhOiB7XG4gICAgICBmb3JtOiBmb3JtLFxuICAgICAgZmllbGQ6IGZpZWxkXG4gICAgfVxuICB9O1xufTtcblxudmFyIGluaXRpYWxpemUgPSBmdW5jdGlvbiBpbml0aWFsaXplKGZvcm0sIHZhbHVlcywga2VlcERpcnR5LCBvdGhlck1ldGEpIHtcbiAgaWYgKG90aGVyTWV0YSA9PT0gdm9pZCAwKSB7XG4gICAgb3RoZXJNZXRhID0ge307XG4gIH1cblxuICBpZiAoa2VlcERpcnR5IGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgb3RoZXJNZXRhID0ga2VlcERpcnR5O1xuICAgIGtlZXBEaXJ0eSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBJTklUSUFMSVpFLFxuICAgIG1ldGE6IF9leHRlbmRzKHtcbiAgICAgIGZvcm06IGZvcm0sXG4gICAgICBrZWVwRGlydHk6IGtlZXBEaXJ0eVxuICAgIH0sIG90aGVyTWV0YSksXG4gICAgcGF5bG9hZDogdmFsdWVzXG4gIH07XG59O1xuXG52YXIgcmVnaXN0ZXJGaWVsZCA9IGZ1bmN0aW9uIHJlZ2lzdGVyRmllbGQoZm9ybSwgbmFtZSwgdHlwZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFJFR0lTVEVSX0ZJRUxELFxuICAgIG1ldGE6IHtcbiAgICAgIGZvcm06IGZvcm1cbiAgICB9LFxuICAgIHBheWxvYWQ6IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB0eXBlOiB0eXBlXG4gICAgfVxuICB9O1xufTtcblxudmFyIHJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoZm9ybSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFJFU0VULFxuICAgIG1ldGE6IHtcbiAgICAgIGZvcm06IGZvcm1cbiAgICB9XG4gIH07XG59O1xuXG52YXIgcmVzZXRTZWN0aW9uID0gZnVuY3Rpb24gcmVzZXRTZWN0aW9uKGZvcm0pIHtcbiAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBzZWN0aW9ucyA9IG5ldyBBcnJheShfbGVuMyA+IDEgPyBfbGVuMyAtIDEgOiAwKSwgX2tleTMgPSAxOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgc2VjdGlvbnNbX2tleTMgLSAxXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6IFJFU0VUX1NFQ1RJT04sXG4gICAgbWV0YToge1xuICAgICAgZm9ybTogZm9ybSxcbiAgICAgIHNlY3Rpb25zOiBzZWN0aW9uc1xuICAgIH1cbiAgfTtcbn07XG5cbnZhciBzdGFydEFzeW5jVmFsaWRhdGlvbiA9IGZ1bmN0aW9uIHN0YXJ0QXN5bmNWYWxpZGF0aW9uKGZvcm0sIGZpZWxkKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogU1RBUlRfQVNZTkNfVkFMSURBVElPTixcbiAgICBtZXRhOiB7XG4gICAgICBmb3JtOiBmb3JtLFxuICAgICAgZmllbGQ6IGZpZWxkXG4gICAgfVxuICB9O1xufTtcblxudmFyIHN0YXJ0U3VibWl0ID0gZnVuY3Rpb24gc3RhcnRTdWJtaXQoZm9ybSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFNUQVJUX1NVQk1JVCxcbiAgICBtZXRhOiB7XG4gICAgICBmb3JtOiBmb3JtXG4gICAgfVxuICB9O1xufTtcblxudmFyIHN0b3BBc3luY1ZhbGlkYXRpb24gPSBmdW5jdGlvbiBzdG9wQXN5bmNWYWxpZGF0aW9uKGZvcm0sIGVycm9ycykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFNUT1BfQVNZTkNfVkFMSURBVElPTixcbiAgICBtZXRhOiB7XG4gICAgICBmb3JtOiBmb3JtXG4gICAgfSxcbiAgICBwYXlsb2FkOiBlcnJvcnMsXG4gICAgZXJyb3I6ICEhKGVycm9ycyAmJiBPYmplY3Qua2V5cyhlcnJvcnMpLmxlbmd0aClcbiAgfTtcbn07XG5cbnZhciBzdG9wU3VibWl0ID0gZnVuY3Rpb24gc3RvcFN1Ym1pdChmb3JtLCBlcnJvcnMpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBTVE9QX1NVQk1JVCxcbiAgICBtZXRhOiB7XG4gICAgICBmb3JtOiBmb3JtXG4gICAgfSxcbiAgICBwYXlsb2FkOiBlcnJvcnMsXG4gICAgZXJyb3I6ICEhKGVycm9ycyAmJiBPYmplY3Qua2V5cyhlcnJvcnMpLmxlbmd0aClcbiAgfTtcbn07XG5cbnZhciBzdWJtaXQgPSBmdW5jdGlvbiBzdWJtaXQoZm9ybSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFNVQk1JVCxcbiAgICBtZXRhOiB7XG4gICAgICBmb3JtOiBmb3JtXG4gICAgfVxuICB9O1xufTtcblxudmFyIHNldFN1Ym1pdEZhaWxlZCA9IGZ1bmN0aW9uIHNldFN1Ym1pdEZhaWxlZChmb3JtKSB7XG4gIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgZmllbGRzID0gbmV3IEFycmF5KF9sZW40ID4gMSA/IF9sZW40IC0gMSA6IDApLCBfa2V5NCA9IDE7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICBmaWVsZHNbX2tleTQgLSAxXSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6IFNFVF9TVUJNSVRfRkFJTEVELFxuICAgIG1ldGE6IHtcbiAgICAgIGZvcm06IGZvcm0sXG4gICAgICBmaWVsZHM6IGZpZWxkc1xuICAgIH0sXG4gICAgZXJyb3I6IHRydWVcbiAgfTtcbn07XG5cbnZhciBzZXRTdWJtaXRTdWNjZWVkZWQgPSBmdW5jdGlvbiBzZXRTdWJtaXRTdWNjZWVkZWQoZm9ybSkge1xuICBmb3IgKHZhciBfbGVuNSA9IGFyZ3VtZW50cy5sZW5ndGgsIGZpZWxkcyA9IG5ldyBBcnJheShfbGVuNSA+IDEgPyBfbGVuNSAtIDEgOiAwKSwgX2tleTUgPSAxOyBfa2V5NSA8IF9sZW41OyBfa2V5NSsrKSB7XG4gICAgZmllbGRzW19rZXk1IC0gMV0gPSBhcmd1bWVudHNbX2tleTVdO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBTRVRfU1VCTUlUX1NVQ0NFRURFRCxcbiAgICBtZXRhOiB7XG4gICAgICBmb3JtOiBmb3JtLFxuICAgICAgZmllbGRzOiBmaWVsZHNcbiAgICB9LFxuICAgIGVycm9yOiBmYWxzZVxuICB9O1xufTtcblxudmFyIHRvdWNoID0gZnVuY3Rpb24gdG91Y2goZm9ybSkge1xuICBmb3IgKHZhciBfbGVuNiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZpZWxkcyA9IG5ldyBBcnJheShfbGVuNiA+IDEgPyBfbGVuNiAtIDEgOiAwKSwgX2tleTYgPSAxOyBfa2V5NiA8IF9sZW42OyBfa2V5NisrKSB7XG4gICAgZmllbGRzW19rZXk2IC0gMV0gPSBhcmd1bWVudHNbX2tleTZdO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBUT1VDSCxcbiAgICBtZXRhOiB7XG4gICAgICBmb3JtOiBmb3JtLFxuICAgICAgZmllbGRzOiBmaWVsZHNcbiAgICB9XG4gIH07XG59O1xuXG52YXIgdW5yZWdpc3RlckZpZWxkID0gZnVuY3Rpb24gdW5yZWdpc3RlckZpZWxkKGZvcm0sIG5hbWUsIGRlc3Ryb3lPblVubW91bnQpIHtcbiAgaWYgKGRlc3Ryb3lPblVubW91bnQgPT09IHZvaWQgMCkge1xuICAgIGRlc3Ryb3lPblVubW91bnQgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBVTlJFR0lTVEVSX0ZJRUxELFxuICAgIG1ldGE6IHtcbiAgICAgIGZvcm06IGZvcm1cbiAgICB9LFxuICAgIHBheWxvYWQ6IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBkZXN0cm95T25Vbm1vdW50OiBkZXN0cm95T25Vbm1vdW50XG4gICAgfVxuICB9O1xufTtcblxudmFyIHVudG91Y2ggPSBmdW5jdGlvbiB1bnRvdWNoKGZvcm0pIHtcbiAgZm9yICh2YXIgX2xlbjcgPSBhcmd1bWVudHMubGVuZ3RoLCBmaWVsZHMgPSBuZXcgQXJyYXkoX2xlbjcgPiAxID8gX2xlbjcgLSAxIDogMCksIF9rZXk3ID0gMTsgX2tleTcgPCBfbGVuNzsgX2tleTcrKykge1xuICAgIGZpZWxkc1tfa2V5NyAtIDFdID0gYXJndW1lbnRzW19rZXk3XTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogVU5UT1VDSCxcbiAgICBtZXRhOiB7XG4gICAgICBmb3JtOiBmb3JtLFxuICAgICAgZmllbGRzOiBmaWVsZHNcbiAgICB9XG4gIH07XG59O1xuXG52YXIgdXBkYXRlU3luY0Vycm9ycyA9IGZ1bmN0aW9uIHVwZGF0ZVN5bmNFcnJvcnMoZm9ybSwgc3luY0Vycm9ycywgZXJyb3IpIHtcbiAgaWYgKHN5bmNFcnJvcnMgPT09IHZvaWQgMCkge1xuICAgIHN5bmNFcnJvcnMgPSB7fTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogVVBEQVRFX1NZTkNfRVJST1JTLFxuICAgIG1ldGE6IHtcbiAgICAgIGZvcm06IGZvcm1cbiAgICB9LFxuICAgIHBheWxvYWQ6IHtcbiAgICAgIHN5bmNFcnJvcnM6IHN5bmNFcnJvcnMsXG4gICAgICBlcnJvcjogZXJyb3JcbiAgICB9XG4gIH07XG59O1xuXG52YXIgdXBkYXRlU3luY1dhcm5pbmdzID0gZnVuY3Rpb24gdXBkYXRlU3luY1dhcm5pbmdzKGZvcm0sIHN5bmNXYXJuaW5ncywgd2FybmluZykge1xuICBpZiAoc3luY1dhcm5pbmdzID09PSB2b2lkIDApIHtcbiAgICBzeW5jV2FybmluZ3MgPSB7fTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogVVBEQVRFX1NZTkNfV0FSTklOR1MsXG4gICAgbWV0YToge1xuICAgICAgZm9ybTogZm9ybVxuICAgIH0sXG4gICAgcGF5bG9hZDoge1xuICAgICAgc3luY1dhcm5pbmdzOiBzeW5jV2FybmluZ3MsXG4gICAgICB3YXJuaW5nOiB3YXJuaW5nXG4gICAgfVxuICB9O1xufTtcblxudmFyIGFjdGlvbnMgPSB7XG4gIGFycmF5SW5zZXJ0OiBhcnJheUluc2VydCxcbiAgYXJyYXlNb3ZlOiBhcnJheU1vdmUsXG4gIGFycmF5UG9wOiBhcnJheVBvcCxcbiAgYXJyYXlQdXNoOiBhcnJheVB1c2gsXG4gIGFycmF5UmVtb3ZlOiBhcnJheVJlbW92ZSxcbiAgYXJyYXlSZW1vdmVBbGw6IGFycmF5UmVtb3ZlQWxsLFxuICBhcnJheVNoaWZ0OiBhcnJheVNoaWZ0LFxuICBhcnJheVNwbGljZTogYXJyYXlTcGxpY2UsXG4gIGFycmF5U3dhcDogYXJyYXlTd2FwLFxuICBhcnJheVVuc2hpZnQ6IGFycmF5VW5zaGlmdCxcbiAgYXV0b2ZpbGw6IGF1dG9maWxsLFxuICBibHVyOiBibHVyLFxuICBjaGFuZ2U6IGNoYW5nZSxcbiAgY2xlYXJGaWVsZHM6IGNsZWFyRmllbGRzLFxuICBjbGVhclN1Ym1pdDogY2xlYXJTdWJtaXQsXG4gIGNsZWFyU3VibWl0RXJyb3JzOiBjbGVhclN1Ym1pdEVycm9ycyxcbiAgY2xlYXJBc3luY0Vycm9yOiBjbGVhckFzeW5jRXJyb3IsXG4gIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gIGZvY3VzOiBmb2N1cyxcbiAgaW5pdGlhbGl6ZTogaW5pdGlhbGl6ZSxcbiAgcmVnaXN0ZXJGaWVsZDogcmVnaXN0ZXJGaWVsZCxcbiAgcmVzZXQ6IHJlc2V0LFxuICByZXNldFNlY3Rpb246IHJlc2V0U2VjdGlvbixcbiAgc3RhcnRBc3luY1ZhbGlkYXRpb246IHN0YXJ0QXN5bmNWYWxpZGF0aW9uLFxuICBzdGFydFN1Ym1pdDogc3RhcnRTdWJtaXQsXG4gIHN0b3BBc3luY1ZhbGlkYXRpb246IHN0b3BBc3luY1ZhbGlkYXRpb24sXG4gIHN0b3BTdWJtaXQ6IHN0b3BTdWJtaXQsXG4gIHN1Ym1pdDogc3VibWl0LFxuICBzZXRTdWJtaXRGYWlsZWQ6IHNldFN1Ym1pdEZhaWxlZCxcbiAgc2V0U3VibWl0U3VjY2VlZGVkOiBzZXRTdWJtaXRTdWNjZWVkZWQsXG4gIHRvdWNoOiB0b3VjaCxcbiAgdW5yZWdpc3RlckZpZWxkOiB1bnJlZ2lzdGVyRmllbGQsXG4gIHVudG91Y2g6IHVudG91Y2gsXG4gIHVwZGF0ZVN5bmNFcnJvcnM6IHVwZGF0ZVN5bmNFcnJvcnMsXG4gIHVwZGF0ZVN5bmNXYXJuaW5nczogdXBkYXRlU3luY1dhcm5pbmdzXG59O1xuZXhwb3J0IGRlZmF1bHQgYWN0aW9uczsiLCJpbXBvcnQgaXNQcm9taXNlIGZyb20gJ2lzLXByb21pc2UnO1xuXG52YXIgYXN5bmNWYWxpZGF0aW9uID0gZnVuY3Rpb24gYXN5bmNWYWxpZGF0aW9uKGZuLCBzdGFydCwgc3RvcCwgZmllbGQpIHtcbiAgc3RhcnQoZmllbGQpO1xuICB2YXIgcHJvbWlzZSA9IGZuKCk7XG5cbiAgaWYgKCFpc1Byb21pc2UocHJvbWlzZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2FzeW5jVmFsaWRhdGUgZnVuY3Rpb24gcGFzc2VkIHRvIHJlZHV4Rm9ybSBtdXN0IHJldHVybiBhIHByb21pc2UnKTtcbiAgfVxuXG4gIHZhciBoYW5kbGVFcnJvcnMgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcnMocmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVycm9ycykge1xuICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgIGlmIChlcnJvcnMgJiYgT2JqZWN0LmtleXMoZXJyb3JzKS5sZW5ndGgpIHtcbiAgICAgICAgICBzdG9wKGVycm9ycyk7XG4gICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdG9wKCk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBc3luY2hyb25vdXMgdmFsaWRhdGlvbiBwcm9taXNlIHdhcyByZWplY3RlZCB3aXRob3V0IGVycm9ycy4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdG9wKCk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfTtcbiAgfTtcblxuICByZXR1cm4gcHJvbWlzZS50aGVuKGhhbmRsZUVycm9ycyhmYWxzZSksIGhhbmRsZUVycm9ycyh0cnVlKSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBhc3luY1ZhbGlkYXRpb247IiwidmFyIGRlZmF1bHRTaG91bGRBc3luY1ZhbGlkYXRlID0gZnVuY3Rpb24gZGVmYXVsdFNob3VsZEFzeW5jVmFsaWRhdGUoX3JlZikge1xuICB2YXIgaW5pdGlhbGl6ZWQgPSBfcmVmLmluaXRpYWxpemVkLFxuICAgICAgdHJpZ2dlciA9IF9yZWYudHJpZ2dlcixcbiAgICAgIHByaXN0aW5lID0gX3JlZi5wcmlzdGluZSxcbiAgICAgIHN5bmNWYWxpZGF0aW9uUGFzc2VzID0gX3JlZi5zeW5jVmFsaWRhdGlvblBhc3NlcztcblxuICBpZiAoIXN5bmNWYWxpZGF0aW9uUGFzc2VzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3dpdGNoICh0cmlnZ2VyKSB7XG4gICAgY2FzZSAnYmx1cic6XG4gICAgY2FzZSAnY2hhbmdlJzpcbiAgICAgIC8vIGJsdXJyaW5nXG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgJ3N1Ym1pdCc6XG4gICAgICAvLyBzdWJtaXR0aW5nLCBzbyBvbmx5IGFzeW5jIHZhbGlkYXRlIGlmIGZvcm0gaXMgZGlydHkgb3Igd2FzIG5ldmVyIGluaXRpYWxpemVkXG4gICAgICAvLyBjb252ZXJzZWx5LCBET04nVCBhc3luYyB2YWxpZGF0ZSBpZiB0aGUgZm9ybSBpcyBwcmlzdGluZSBqdXN0IGFzIGl0IHdhcyBpbml0aWFsaXplZFxuICAgICAgcmV0dXJuICFwcmlzdGluZSB8fCAhaW5pdGlhbGl6ZWQ7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBkZWZhdWx0U2hvdWxkQXN5bmNWYWxpZGF0ZTsiLCJ2YXIgZGVmYXVsdFNob3VsZFZhbGlkYXRlID0gZnVuY3Rpb24gZGVmYXVsdFNob3VsZFZhbGlkYXRlKF9yZWYpIHtcbiAgdmFyIHZhbHVlcyA9IF9yZWYudmFsdWVzLFxuICAgICAgbmV4dFByb3BzID0gX3JlZi5uZXh0UHJvcHMsXG4gICAgICBpbml0aWFsUmVuZGVyID0gX3JlZi5pbml0aWFsUmVuZGVyLFxuICAgICAgbGFzdEZpZWxkVmFsaWRhdG9yS2V5cyA9IF9yZWYubGFzdEZpZWxkVmFsaWRhdG9yS2V5cyxcbiAgICAgIGZpZWxkVmFsaWRhdG9yS2V5cyA9IF9yZWYuZmllbGRWYWxpZGF0b3JLZXlzLFxuICAgICAgc3RydWN0dXJlID0gX3JlZi5zdHJ1Y3R1cmU7XG5cbiAgaWYgKGluaXRpYWxSZW5kZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiAhc3RydWN0dXJlLmRlZXBFcXVhbCh2YWx1ZXMsIG5leHRQcm9wcyAmJiBuZXh0UHJvcHMudmFsdWVzKSB8fCAhc3RydWN0dXJlLmRlZXBFcXVhbChsYXN0RmllbGRWYWxpZGF0b3JLZXlzLCBmaWVsZFZhbGlkYXRvcktleXMpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZGVmYXVsdFNob3VsZFZhbGlkYXRlOyIsInZhciBkZWZhdWx0U2hvdWxkRXJyb3IgPSBmdW5jdGlvbiBkZWZhdWx0U2hvdWxkRXJyb3IoX3JlZikge1xuICB2YXIgdmFsdWVzID0gX3JlZi52YWx1ZXMsXG4gICAgICBuZXh0UHJvcHMgPSBfcmVmLm5leHRQcm9wcyxcbiAgICAgIGluaXRpYWxSZW5kZXIgPSBfcmVmLmluaXRpYWxSZW5kZXIsXG4gICAgICBsYXN0RmllbGRWYWxpZGF0b3JLZXlzID0gX3JlZi5sYXN0RmllbGRWYWxpZGF0b3JLZXlzLFxuICAgICAgZmllbGRWYWxpZGF0b3JLZXlzID0gX3JlZi5maWVsZFZhbGlkYXRvcktleXMsXG4gICAgICBzdHJ1Y3R1cmUgPSBfcmVmLnN0cnVjdHVyZTtcblxuICBpZiAoaW5pdGlhbFJlbmRlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuICFzdHJ1Y3R1cmUuZGVlcEVxdWFsKHZhbHVlcywgbmV4dFByb3BzICYmIG5leHRQcm9wcy52YWx1ZXMpIHx8ICFzdHJ1Y3R1cmUuZGVlcEVxdWFsKGxhc3RGaWVsZFZhbGlkYXRvcktleXMsIGZpZWxkVmFsaWRhdG9yS2V5cyk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBkZWZhdWx0U2hvdWxkRXJyb3I7IiwidmFyIGRlZmF1bHRTaG91bGRXYXJuID0gZnVuY3Rpb24gZGVmYXVsdFNob3VsZFdhcm4oX3JlZikge1xuICB2YXIgdmFsdWVzID0gX3JlZi52YWx1ZXMsXG4gICAgICBuZXh0UHJvcHMgPSBfcmVmLm5leHRQcm9wcyxcbiAgICAgIGluaXRpYWxSZW5kZXIgPSBfcmVmLmluaXRpYWxSZW5kZXIsXG4gICAgICBsYXN0RmllbGRWYWxpZGF0b3JLZXlzID0gX3JlZi5sYXN0RmllbGRWYWxpZGF0b3JLZXlzLFxuICAgICAgZmllbGRWYWxpZGF0b3JLZXlzID0gX3JlZi5maWVsZFZhbGlkYXRvcktleXMsXG4gICAgICBzdHJ1Y3R1cmUgPSBfcmVmLnN0cnVjdHVyZTtcblxuICBpZiAoaW5pdGlhbFJlbmRlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuICFzdHJ1Y3R1cmUuZGVlcEVxdWFsKHZhbHVlcywgbmV4dFByb3BzICYmIG5leHRQcm9wcy52YWx1ZXMpIHx8ICFzdHJ1Y3R1cmUuZGVlcEVxdWFsKGxhc3RGaWVsZFZhbGlkYXRvcktleXMsIGZpZWxkVmFsaWRhdG9yS2V5cyk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBkZWZhdWx0U2hvdWxkV2FybjsiLCJ2YXIgaXNFdmVudCA9IGZ1bmN0aW9uIGlzRXZlbnQoY2FuZGlkYXRlKSB7XG4gIHJldHVybiAhIShjYW5kaWRhdGUgJiYgY2FuZGlkYXRlLnN0b3BQcm9wYWdhdGlvbiAmJiBjYW5kaWRhdGUucHJldmVudERlZmF1bHQpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgaXNFdmVudDsiLCJpbXBvcnQgaXNFdmVudCBmcm9tICcuL2lzRXZlbnQnO1xuXG52YXIgc2lsZW5jZUV2ZW50ID0gZnVuY3Rpb24gc2lsZW5jZUV2ZW50KGV2ZW50KSB7XG4gIHZhciBpcyA9IGlzRXZlbnQoZXZlbnQpO1xuXG4gIGlmIChpcykge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuICByZXR1cm4gaXM7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBzaWxlbmNlRXZlbnQ7IiwiaW1wb3J0IHNpbGVuY2VFdmVudCBmcm9tICcuL3NpbGVuY2VFdmVudCc7XG5cbnZhciBzaWxlbmNlRXZlbnRzID0gZnVuY3Rpb24gc2lsZW5jZUV2ZW50cyhmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHNpbGVuY2VFdmVudChldmVudCkgPyBmbi5hcHBseSh2b2lkIDAsIGFyZ3MpIDogZm4uYXBwbHkodm9pZCAwLCBbZXZlbnRdLmNvbmNhdChhcmdzKSk7XG4gIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBzaWxlbmNlRXZlbnRzOyIsImltcG9ydCBwbGFpbiBmcm9tICcuL3N0cnVjdHVyZS9wbGFpbic7XG5cbnZhciB0b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG59O1xuXG52YXIgZ2V0RXJyb3IgPSBmdW5jdGlvbiBnZXRFcnJvcih2YWx1ZSwgdmFsdWVzLCBwcm9wcywgdmFsaWRhdG9ycywgbmFtZSkge1xuICB2YXIgYXJyYXkgPSB0b0FycmF5KHZhbGlkYXRvcnMpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZXJyb3IgPSBhcnJheVtpXSh2YWx1ZSwgdmFsdWVzLCBwcm9wcywgbmFtZSk7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBnZW5lcmF0ZVZhbGlkYXRvciA9IGZ1bmN0aW9uIGdlbmVyYXRlVmFsaWRhdG9yKHZhbGlkYXRvcnMsIF9yZWYpIHtcbiAgdmFyIGdldEluID0gX3JlZi5nZXRJbjtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZXMsIHByb3BzKSB7XG4gICAgdmFyIGVycm9ycyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKHZhbGlkYXRvcnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldEluKHZhbHVlcywgbmFtZSk7XG4gICAgICB2YXIgZXJyb3IgPSBnZXRFcnJvcih2YWx1ZSwgdmFsdWVzLCBwcm9wcywgdmFsaWRhdG9yc1tuYW1lXSwgbmFtZSk7XG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBlcnJvcnMgPSBwbGFpbi5zZXRJbihlcnJvcnMsIG5hbWUsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3JzO1xuICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZ2VuZXJhdGVWYWxpZGF0b3I7IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5mdW5jdGlvbiBfZXh0ZW5kYWJsZUJ1aWx0aW4oY2xzKSB7XG4gIGZ1bmN0aW9uIEV4dGVuZGFibGVCdWlsdGluKCkge1xuICAgIGNscy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgRXh0ZW5kYWJsZUJ1aWx0aW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjbHMucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBjbHMsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcblxuICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKEV4dGVuZGFibGVCdWlsdGluLCBjbHMpO1xuICB9IGVsc2Uge1xuICAgIEV4dGVuZGFibGVCdWlsdGluLl9fcHJvdG9fXyA9IGNscztcbiAgfVxuXG4gIHJldHVybiBFeHRlbmRhYmxlQnVpbHRpbjtcbn1cblxudmFyIEV4dGVuZGFibGVFcnJvciA9IGZ1bmN0aW9uIChfZXh0ZW5kYWJsZUJ1aWx0aW4yKSB7XG4gIF9pbmhlcml0cyhFeHRlbmRhYmxlRXJyb3IsIF9leHRlbmRhYmxlQnVpbHRpbjIpO1xuXG4gIGZ1bmN0aW9uIEV4dGVuZGFibGVFcnJvcigpIHtcbiAgICB2YXIgbWVzc2FnZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJyc7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXh0ZW5kYWJsZUVycm9yKTtcblxuICAgIC8vIGV4dGVuZGluZyBFcnJvciBpcyB3ZWlyZCBhbmQgZG9lcyBub3QgcHJvcGFnYXRlIGBtZXNzYWdlYFxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChFeHRlbmRhYmxlRXJyb3IuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihFeHRlbmRhYmxlRXJyb3IpKS5jYWxsKHRoaXMsIG1lc3NhZ2UpKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgJ21lc3NhZ2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBtZXNzYWdlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgJ25hbWUnLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBfdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcblxuICAgIGlmIChFcnJvci5oYXNPd25Qcm9wZXJ0eSgnY2FwdHVyZVN0YWNrVHJhY2UnKSkge1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoX3RoaXMsIF90aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcyk7XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCAnc3RhY2snLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBuZXcgRXJyb3IobWVzc2FnZSkuc3RhY2ssXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBFeHRlbmRhYmxlRXJyb3I7XG59KF9leHRlbmRhYmxlQnVpbHRpbihFcnJvcikpO1xuXG5leHBvcnQgZGVmYXVsdCBFeHRlbmRhYmxlRXJyb3I7XG4iLCJpbXBvcnQgX2luaGVyaXRzTG9vc2UgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNMb29zZVwiO1xuaW1wb3J0IEV4dGVuZGFibGVFcnJvciBmcm9tICdlczYtZXJyb3InO1xuXG52YXIgU3VibWlzc2lvbkVycm9yID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfRXh0ZW5kYWJsZUVycm9yKSB7XG4gIF9pbmhlcml0c0xvb3NlKFN1Ym1pc3Npb25FcnJvciwgX0V4dGVuZGFibGVFcnJvcik7XG5cbiAgZnVuY3Rpb24gU3VibWlzc2lvbkVycm9yKGVycm9ycykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0V4dGVuZGFibGVFcnJvci5jYWxsKHRoaXMsICdTdWJtaXQgVmFsaWRhdGlvbiBGYWlsZWQnKSB8fCB0aGlzO1xuICAgIF90aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gU3VibWlzc2lvbkVycm9yO1xufShFeHRlbmRhYmxlRXJyb3IpO1xuXG5leHBvcnQgZGVmYXVsdCBTdWJtaXNzaW9uRXJyb3I7IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2V4dGVuZHNcIjtcbmltcG9ydCBpc1Byb21pc2UgZnJvbSAnaXMtcHJvbWlzZSc7XG5pbXBvcnQgU3VibWlzc2lvbkVycm9yIGZyb20gJy4vU3VibWlzc2lvbkVycm9yJztcblxudmFyIGlzU3VibWlzc2lvbkVycm9yID0gZnVuY3Rpb24gaXNTdWJtaXNzaW9uRXJyb3IoZXJyb3IpIHtcbiAgcmV0dXJuIGVycm9yICYmIGVycm9yLm5hbWUgPT09IFN1Ym1pc3Npb25FcnJvci5uYW1lO1xufTtcblxudmFyIG1lcmdlRXJyb3JzID0gZnVuY3Rpb24gbWVyZ2VFcnJvcnMoX3JlZikge1xuICB2YXIgYXN5bmNFcnJvcnMgPSBfcmVmLmFzeW5jRXJyb3JzLFxuICAgICAgc3luY0Vycm9ycyA9IF9yZWYuc3luY0Vycm9ycztcbiAgcmV0dXJuIGFzeW5jRXJyb3JzICYmIHR5cGVvZiBhc3luY0Vycm9ycy5tZXJnZSA9PT0gJ2Z1bmN0aW9uJyA/IGFzeW5jRXJyb3JzLm1lcmdlKHN5bmNFcnJvcnMpLnRvSlMoKSA6IF9leHRlbmRzKHt9LCBhc3luY0Vycm9ycywgc3luY0Vycm9ycyk7XG59O1xuXG52YXIgaGFuZGxlU3VibWl0ID0gZnVuY3Rpb24gaGFuZGxlU3VibWl0KHN1Ym1pdCwgcHJvcHMsIHZhbGlkLCBhc3luY1ZhbGlkYXRlLCBmaWVsZHMpIHtcbiAgdmFyIGRpc3BhdGNoID0gcHJvcHMuZGlzcGF0Y2gsXG4gICAgICBvblN1Ym1pdEZhaWwgPSBwcm9wcy5vblN1Ym1pdEZhaWwsXG4gICAgICBvblN1Ym1pdFN1Y2Nlc3MgPSBwcm9wcy5vblN1Ym1pdFN1Y2Nlc3MsXG4gICAgICBzdGFydFN1Ym1pdCA9IHByb3BzLnN0YXJ0U3VibWl0LFxuICAgICAgc3RvcFN1Ym1pdCA9IHByb3BzLnN0b3BTdWJtaXQsXG4gICAgICBzZXRTdWJtaXRGYWlsZWQgPSBwcm9wcy5zZXRTdWJtaXRGYWlsZWQsXG4gICAgICBzZXRTdWJtaXRTdWNjZWVkZWQgPSBwcm9wcy5zZXRTdWJtaXRTdWNjZWVkZWQsXG4gICAgICBzeW5jRXJyb3JzID0gcHJvcHMuc3luY0Vycm9ycyxcbiAgICAgIGFzeW5jRXJyb3JzID0gcHJvcHMuYXN5bmNFcnJvcnMsXG4gICAgICB0b3VjaCA9IHByb3BzLnRvdWNoLFxuICAgICAgdmFsdWVzID0gcHJvcHMudmFsdWVzLFxuICAgICAgcGVyc2lzdGVudFN1Ym1pdEVycm9ycyA9IHByb3BzLnBlcnNpc3RlbnRTdWJtaXRFcnJvcnM7XG4gIHRvdWNoLmFwcGx5KHZvaWQgMCwgQXJyYXkuZnJvbShmaWVsZHMpKTsgLy8gbWFyayBhbGwgZmllbGRzIGFzIHRvdWNoZWRcblxuICBpZiAodmFsaWQgfHwgcGVyc2lzdGVudFN1Ym1pdEVycm9ycykge1xuICAgIHZhciBkb1N1Ym1pdCA9IGZ1bmN0aW9uIGRvU3VibWl0KCkge1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gc3VibWl0KHZhbHVlcywgZGlzcGF0Y2gsIHByb3BzKTtcbiAgICAgIH0gY2F0Y2ggKHN1Ym1pdEVycm9yKSB7XG4gICAgICAgIHZhciBlcnJvciA9IGlzU3VibWlzc2lvbkVycm9yKHN1Ym1pdEVycm9yKSA/IHN1Ym1pdEVycm9yLmVycm9ycyA6IHVuZGVmaW5lZDtcbiAgICAgICAgc3RvcFN1Ym1pdChlcnJvcik7XG4gICAgICAgIHNldFN1Ym1pdEZhaWxlZC5hcHBseSh2b2lkIDAsIGZpZWxkcyk7XG5cbiAgICAgICAgaWYgKG9uU3VibWl0RmFpbCkge1xuICAgICAgICAgIG9uU3VibWl0RmFpbChlcnJvciwgZGlzcGF0Y2gsIHN1Ym1pdEVycm9yLCBwcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IgfHwgb25TdWJtaXRGYWlsKSB7XG4gICAgICAgICAgLy8gaWYgeW91J3ZlIHByb3ZpZGVkIGFuIG9uU3VibWl0RmFpbCBjYWxsYmFjaywgZG9uJ3QgcmUtdGhyb3cgdGhlIGVycm9yXG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IHN1Ym1pdEVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1Byb21pc2UocmVzdWx0KSkge1xuICAgICAgICBzdGFydFN1Ym1pdCgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4oZnVuY3Rpb24gKHN1Ym1pdFJlc3VsdCkge1xuICAgICAgICAgIHN0b3BTdWJtaXQoKTtcbiAgICAgICAgICBzZXRTdWJtaXRTdWNjZWVkZWQoKTtcblxuICAgICAgICAgIGlmIChvblN1Ym1pdFN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIG9uU3VibWl0U3VjY2VzcyhzdWJtaXRSZXN1bHQsIGRpc3BhdGNoLCBwcm9wcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN1Ym1pdFJlc3VsdDtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHN1Ym1pdEVycm9yKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gaXNTdWJtaXNzaW9uRXJyb3Ioc3VibWl0RXJyb3IpID8gc3VibWl0RXJyb3IuZXJyb3JzIDogdW5kZWZpbmVkO1xuICAgICAgICAgIHN0b3BTdWJtaXQoZXJyb3IpO1xuICAgICAgICAgIHNldFN1Ym1pdEZhaWxlZC5hcHBseSh2b2lkIDAsIGZpZWxkcyk7XG5cbiAgICAgICAgICBpZiAob25TdWJtaXRGYWlsKSB7XG4gICAgICAgICAgICBvblN1Ym1pdEZhaWwoZXJyb3IsIGRpc3BhdGNoLCBzdWJtaXRFcnJvciwgcHJvcHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChlcnJvciB8fCBvblN1Ym1pdEZhaWwpIHtcbiAgICAgICAgICAgIC8vIGlmIHlvdSd2ZSBwcm92aWRlZCBhbiBvblN1Ym1pdEZhaWwgY2FsbGJhY2ssIGRvbid0IHJlLXRocm93IHRoZSBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBzdWJtaXRFcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0U3VibWl0U3VjY2VlZGVkKCk7XG5cbiAgICAgICAgaWYgKG9uU3VibWl0U3VjY2Vzcykge1xuICAgICAgICAgIG9uU3VibWl0U3VjY2VzcyhyZXN1bHQsIGRpc3BhdGNoLCBwcm9wcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgdmFyIGFzeW5jVmFsaWRhdGVSZXN1bHQgPSBhc3luY1ZhbGlkYXRlICYmIGFzeW5jVmFsaWRhdGUoKTtcblxuICAgIGlmIChhc3luY1ZhbGlkYXRlUmVzdWx0KSB7XG4gICAgICByZXR1cm4gYXN5bmNWYWxpZGF0ZVJlc3VsdC50aGVuKGZ1bmN0aW9uIChhc3luY0Vycm9ycykge1xuICAgICAgICBpZiAoYXN5bmNFcnJvcnMpIHtcbiAgICAgICAgICB0aHJvdyBhc3luY0Vycm9ycztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkb1N1Ym1pdCgpO1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGFzeW5jRXJyb3JzKSB7XG4gICAgICAgIHNldFN1Ym1pdEZhaWxlZC5hcHBseSh2b2lkIDAsIGZpZWxkcyk7XG5cbiAgICAgICAgaWYgKG9uU3VibWl0RmFpbCkge1xuICAgICAgICAgIG9uU3VibWl0RmFpbChhc3luY0Vycm9ycywgZGlzcGF0Y2gsIG51bGwsIHByb3BzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChhc3luY0Vycm9ycyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRvU3VibWl0KCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNldFN1Ym1pdEZhaWxlZC5hcHBseSh2b2lkIDAsIGZpZWxkcyk7XG4gICAgdmFyIGVycm9ycyA9IG1lcmdlRXJyb3JzKHtcbiAgICAgIGFzeW5jRXJyb3JzOiBhc3luY0Vycm9ycyxcbiAgICAgIHN5bmNFcnJvcnM6IHN5bmNFcnJvcnNcbiAgICB9KTtcblxuICAgIGlmIChvblN1Ym1pdEZhaWwpIHtcbiAgICAgIG9uU3VibWl0RmFpbChlcnJvcnMsIGRpc3BhdGNoLCBudWxsLCBwcm9wcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVycm9ycztcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgaGFuZGxlU3VibWl0OyIsInZhciBnZXRFcnJvcktleXMgPSBmdW5jdGlvbiBnZXRFcnJvcktleXMobmFtZSwgdHlwZSkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdGaWVsZCc6XG4gICAgICByZXR1cm4gW25hbWUsIG5hbWUgKyBcIi5fZXJyb3JcIl07XG5cbiAgICBjYXNlICdGaWVsZEFycmF5JzpcbiAgICAgIHJldHVybiBbbmFtZSArIFwiLl9lcnJvclwiXTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZmllbGQgdHlwZScpO1xuICB9XG59O1xuXG52YXIgY3JlYXRlSGFzRXJyb3IgPSBmdW5jdGlvbiBjcmVhdGVIYXNFcnJvcihfcmVmKSB7XG4gIHZhciBnZXRJbiA9IF9yZWYuZ2V0SW47XG5cbiAgdmFyIGhhc0Vycm9yID0gZnVuY3Rpb24gaGFzRXJyb3IoZmllbGQsIHN5bmNFcnJvcnMsIGFzeW5jRXJyb3JzLCBzdWJtaXRFcnJvcnMpIHtcbiAgICBpZiAoIXN5bmNFcnJvcnMgJiYgIWFzeW5jRXJyb3JzICYmICFzdWJtaXRFcnJvcnMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IGdldEluKGZpZWxkLCAnbmFtZScpO1xuICAgIHZhciB0eXBlID0gZ2V0SW4oZmllbGQsICd0eXBlJyk7XG4gICAgcmV0dXJuIGdldEVycm9yS2V5cyhuYW1lLCB0eXBlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBnZXRJbihzeW5jRXJyb3JzLCBrZXkpIHx8IGdldEluKGFzeW5jRXJyb3JzLCBrZXkpIHx8IGdldEluKHN1Ym1pdEVycm9ycywga2V5KTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gaGFzRXJyb3I7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVIYXNFcnJvcjsiLCJpbXBvcnQgY3JlYXRlSGFzRXJyb3IgZnJvbSAnLi4vaGFzRXJyb3InO1xuXG52YXIgY3JlYXRlSXNWYWxpZCA9IGZ1bmN0aW9uIGNyZWF0ZUlzVmFsaWQoc3RydWN0dXJlKSB7XG4gIHZhciBnZXRJbiA9IHN0cnVjdHVyZS5nZXRJbixcbiAgICAgIGtleXMgPSBzdHJ1Y3R1cmUua2V5cztcbiAgdmFyIGhhc0Vycm9yID0gY3JlYXRlSGFzRXJyb3Ioc3RydWN0dXJlKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChmb3JtLCBnZXRGb3JtU3RhdGUsIGlnbm9yZVN1Ym1pdEVycm9ycykge1xuICAgIGlmIChpZ25vcmVTdWJtaXRFcnJvcnMgPT09IHZvaWQgMCkge1xuICAgICAgaWdub3JlU3VibWl0RXJyb3JzID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgdmFyIG5vbk51bGxHZXRGb3JtU3RhdGUgPSBnZXRGb3JtU3RhdGUgfHwgZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBnZXRJbihzdGF0ZSwgJ2Zvcm0nKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBmb3JtU3RhdGUgPSBub25OdWxsR2V0Rm9ybVN0YXRlKHN0YXRlKTtcbiAgICAgIHZhciBzeW5jRXJyb3IgPSBnZXRJbihmb3JtU3RhdGUsIGZvcm0gKyBcIi5zeW5jRXJyb3JcIik7XG5cbiAgICAgIGlmIChzeW5jRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlnbm9yZVN1Ym1pdEVycm9ycykge1xuICAgICAgICB2YXIgZXJyb3IgPSBnZXRJbihmb3JtU3RhdGUsIGZvcm0gKyBcIi5lcnJvclwiKTtcblxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHN5bmNFcnJvcnMgPSBnZXRJbihmb3JtU3RhdGUsIGZvcm0gKyBcIi5zeW5jRXJyb3JzXCIpO1xuICAgICAgdmFyIGFzeW5jRXJyb3JzID0gZ2V0SW4oZm9ybVN0YXRlLCBmb3JtICsgXCIuYXN5bmNFcnJvcnNcIik7XG4gICAgICB2YXIgc3VibWl0RXJyb3JzID0gaWdub3JlU3VibWl0RXJyb3JzID8gdW5kZWZpbmVkIDogZ2V0SW4oZm9ybVN0YXRlLCBmb3JtICsgXCIuc3VibWl0RXJyb3JzXCIpO1xuXG4gICAgICBpZiAoIXN5bmNFcnJvcnMgJiYgIWFzeW5jRXJyb3JzICYmICFzdWJtaXRFcnJvcnMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWdpc3RlcmVkRmllbGRzID0gZ2V0SW4oZm9ybVN0YXRlLCBmb3JtICsgXCIucmVnaXN0ZXJlZEZpZWxkc1wiKTtcblxuICAgICAgaWYgKCFyZWdpc3RlcmVkRmllbGRzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gIWtleXMocmVnaXN0ZXJlZEZpZWxkcykuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBnZXRJbihyZWdpc3RlcmVkRmllbGRzLCBcIlsnXCIgKyBuYW1lICsgXCInXS5jb3VudFwiKSA+IDA7XG4gICAgICB9KS5zb21lKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBoYXNFcnJvcihnZXRJbihyZWdpc3RlcmVkRmllbGRzLCBcIlsnXCIgKyBuYW1lICsgXCInXVwiKSwgc3luY0Vycm9ycywgYXN5bmNFcnJvcnMsIHN1Ym1pdEVycm9ycyk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlSXNWYWxpZDsiLCJ2YXIgZ2V0RGlzcGxheU5hbWUgPSBmdW5jdGlvbiBnZXREaXNwbGF5TmFtZShDb21wKSB7XG4gIHJldHVybiBDb21wLmRpc3BsYXlOYW1lIHx8IENvbXAubmFtZSB8fCAnQ29tcG9uZW50Jztcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGdldERpc3BsYXlOYW1lOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZVwiO1xuaW1wb3J0IF9pbmhlcml0c0xvb3NlIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzTG9vc2VcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmV4cG9ydCB2YXIgUmVkdXhGb3JtQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5leHBvcnQgdmFyIHdpdGhSZWR1eEZvcm0gPSBmdW5jdGlvbiB3aXRoUmVkdXhGb3JtKENvbXBvbmVudCkge1xuICB2YXIgSG9jID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICAgIF9pbmhlcml0c0xvb3NlKEhvYywgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBIb2MoKSB7XG4gICAgICByZXR1cm4gX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIF9wcm90byA9IEhvYy5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBmb3J3YXJkZWRSZWYgPSBfdGhpcyRwcm9wcy5mb3J3YXJkZWRSZWYsXG4gICAgICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF90aGlzJHByb3BzLCBbXCJmb3J3YXJkZWRSZWZcIl0pO1xuXG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSZWR1eEZvcm1Db250ZXh0LkNvbnN1bWVyLCB7XG4gICAgICAgIGNoaWxkcmVuOiBmdW5jdGlvbiBjaGlsZHJlbihfcmVkdXhGb3JtKSB7XG4gICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBfZXh0ZW5kcyh7XG4gICAgICAgICAgICBfcmVkdXhGb3JtOiBfcmVkdXhGb3JtLFxuICAgICAgICAgICAgcmVmOiBmb3J3YXJkZWRSZWZcbiAgICAgICAgICB9LCByZXN0KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gSG9jO1xuICB9KFJlYWN0LkNvbXBvbmVudCk7XG5cbiAgdmFyIHJlZiA9IFJlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gKHByb3BzLCByZWYpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChIb2MsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgZm9yd2FyZGVkUmVmOiByZWZcbiAgICB9KSk7XG4gIH0pO1xuICByZWYuZGlzcGxheU5hbWUgPSBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCc7XG4gIHJldHVybiByZWY7XG59OyIsImltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIjtcbmltcG9ydCBfaW5oZXJpdHNMb29zZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c0xvb3NlXCI7XG5pbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2VcIjtcbmltcG9ydCBfbWVyZ2UgZnJvbSBcImxvZGFzaC9tZXJnZVwiO1xuaW1wb3J0IF9tYXBWYWx1ZXMgZnJvbSBcImxvZGFzaC9tYXBWYWx1ZXNcIjtcbmltcG9ydCB7IHBvbHlmaWxsIH0gZnJvbSAncmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQnO1xuaW1wb3J0IGhvaXN0U3RhdGljcyBmcm9tICdob2lzdC1ub24tcmVhY3Qtc3RhdGljcyc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2ludmFyaWFudCc7XG5pbXBvcnQgaXNQcm9taXNlIGZyb20gJ2lzLXByb21pc2UnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCwgeyBjcmVhdGVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY29ubmVjdCB9IGZyb20gJ3JlYWN0LXJlZHV4JztcbmltcG9ydCB7IGJpbmRBY3Rpb25DcmVhdG9ycyB9IGZyb20gJ3JlZHV4JztcbmltcG9ydCBpbXBvcnRlZEFjdGlvbnMgZnJvbSAnLi9hY3Rpb25zJztcbmltcG9ydCBhc3luY1ZhbGlkYXRpb24gZnJvbSAnLi9hc3luY1ZhbGlkYXRpb24nO1xuaW1wb3J0IGRlZmF1bHRTaG91bGRBc3luY1ZhbGlkYXRlIGZyb20gJy4vZGVmYXVsdFNob3VsZEFzeW5jVmFsaWRhdGUnO1xuaW1wb3J0IGRlZmF1bHRTaG91bGRWYWxpZGF0ZSBmcm9tICcuL2RlZmF1bHRTaG91bGRWYWxpZGF0ZSc7XG5pbXBvcnQgZGVmYXVsdFNob3VsZEVycm9yIGZyb20gJy4vZGVmYXVsdFNob3VsZEVycm9yJztcbmltcG9ydCBkZWZhdWx0U2hvdWxkV2FybiBmcm9tICcuL2RlZmF1bHRTaG91bGRXYXJuJztcbmltcG9ydCBzaWxlbmNlRXZlbnQgZnJvbSAnLi9ldmVudHMvc2lsZW5jZUV2ZW50JztcbmltcG9ydCBzaWxlbmNlRXZlbnRzIGZyb20gJy4vZXZlbnRzL3NpbGVuY2VFdmVudHMnO1xuaW1wb3J0IGdlbmVyYXRlVmFsaWRhdG9yIGZyb20gJy4vZ2VuZXJhdGVWYWxpZGF0b3InO1xuaW1wb3J0IGhhbmRsZVN1Ym1pdCBmcm9tICcuL2hhbmRsZVN1Ym1pdCc7XG5pbXBvcnQgY3JlYXRlSXNWYWxpZCBmcm9tICcuL3NlbGVjdG9ycy9pc1ZhbGlkJztcbmltcG9ydCBwbGFpbiBmcm9tICcuL3N0cnVjdHVyZS9wbGFpbic7XG5pbXBvcnQgZ2V0RGlzcGxheU5hbWUgZnJvbSAnLi91dGlsL2dldERpc3BsYXlOYW1lJztcbmltcG9ydCBpc0hvdFJlbG9hZGluZyBmcm9tICcuL3V0aWwvaXNIb3RSZWxvYWRpbmcnO1xuaW1wb3J0IHsgd2l0aFJlZHV4Rm9ybSwgUmVkdXhGb3JtQ29udGV4dCB9IGZyb20gJy4vUmVkdXhGb3JtQ29udGV4dCc7XG5cbnZhciBpc0NsYXNzQ29tcG9uZW50ID0gZnVuY3Rpb24gaXNDbGFzc0NvbXBvbmVudChDb21wb25lbnQpIHtcbiAgcmV0dXJuIEJvb2xlYW4oQ29tcG9uZW50ICYmIENvbXBvbmVudC5wcm90b3R5cGUgJiYgdHlwZW9mIENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9PT0gJ29iamVjdCcpO1xufTsgLy8gZXh0cmFjdCBmaWVsZC1zcGVjaWZpYyBhY3Rpb25zXG5cblxudmFyIGFycmF5SW5zZXJ0ID0gaW1wb3J0ZWRBY3Rpb25zLmFycmF5SW5zZXJ0LFxuICAgIGFycmF5TW92ZSA9IGltcG9ydGVkQWN0aW9ucy5hcnJheU1vdmUsXG4gICAgYXJyYXlQb3AgPSBpbXBvcnRlZEFjdGlvbnMuYXJyYXlQb3AsXG4gICAgYXJyYXlQdXNoID0gaW1wb3J0ZWRBY3Rpb25zLmFycmF5UHVzaCxcbiAgICBhcnJheVJlbW92ZSA9IGltcG9ydGVkQWN0aW9ucy5hcnJheVJlbW92ZSxcbiAgICBhcnJheVJlbW92ZUFsbCA9IGltcG9ydGVkQWN0aW9ucy5hcnJheVJlbW92ZUFsbCxcbiAgICBhcnJheVNoaWZ0ID0gaW1wb3J0ZWRBY3Rpb25zLmFycmF5U2hpZnQsXG4gICAgYXJyYXlTcGxpY2UgPSBpbXBvcnRlZEFjdGlvbnMuYXJyYXlTcGxpY2UsXG4gICAgYXJyYXlTd2FwID0gaW1wb3J0ZWRBY3Rpb25zLmFycmF5U3dhcCxcbiAgICBhcnJheVVuc2hpZnQgPSBpbXBvcnRlZEFjdGlvbnMuYXJyYXlVbnNoaWZ0LFxuICAgIGJsdXIgPSBpbXBvcnRlZEFjdGlvbnMuYmx1cixcbiAgICBjaGFuZ2UgPSBpbXBvcnRlZEFjdGlvbnMuY2hhbmdlLFxuICAgIGZvY3VzID0gaW1wb3J0ZWRBY3Rpb25zLmZvY3VzLFxuICAgIGZvcm1BY3Rpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoaW1wb3J0ZWRBY3Rpb25zLCBbXCJhcnJheUluc2VydFwiLCBcImFycmF5TW92ZVwiLCBcImFycmF5UG9wXCIsIFwiYXJyYXlQdXNoXCIsIFwiYXJyYXlSZW1vdmVcIiwgXCJhcnJheVJlbW92ZUFsbFwiLCBcImFycmF5U2hpZnRcIiwgXCJhcnJheVNwbGljZVwiLCBcImFycmF5U3dhcFwiLCBcImFycmF5VW5zaGlmdFwiLCBcImJsdXJcIiwgXCJjaGFuZ2VcIiwgXCJmb2N1c1wiXSk7XG5cbnZhciBhcnJheUFjdGlvbnMgPSB7XG4gIGFycmF5SW5zZXJ0OiBhcnJheUluc2VydCxcbiAgYXJyYXlNb3ZlOiBhcnJheU1vdmUsXG4gIGFycmF5UG9wOiBhcnJheVBvcCxcbiAgYXJyYXlQdXNoOiBhcnJheVB1c2gsXG4gIGFycmF5UmVtb3ZlOiBhcnJheVJlbW92ZSxcbiAgYXJyYXlSZW1vdmVBbGw6IGFycmF5UmVtb3ZlQWxsLFxuICBhcnJheVNoaWZ0OiBhcnJheVNoaWZ0LFxuICBhcnJheVNwbGljZTogYXJyYXlTcGxpY2UsXG4gIGFycmF5U3dhcDogYXJyYXlTd2FwLFxuICBhcnJheVVuc2hpZnQ6IGFycmF5VW5zaGlmdFxufTtcbnZhciBwcm9wc1RvTm90VXBkYXRlRm9yID0gW10uY29uY2F0KE9iamVjdC5rZXlzKGltcG9ydGVkQWN0aW9ucyksIFsnYXJyYXknLCAnYXN5bmNFcnJvcnMnLCAnaW5pdGlhbFZhbHVlcycsICdzeW5jRXJyb3JzJywgJ3N5bmNXYXJuaW5ncycsICd2YWx1ZXMnLCAncmVnaXN0ZXJlZEZpZWxkcyddKTtcblxudmFyIGNoZWNrU3VibWl0ID0gZnVuY3Rpb24gY2hlY2tTdWJtaXQoc3VibWl0KSB7XG4gIGlmICghc3VibWl0IHx8IHR5cGVvZiBzdWJtaXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IGVpdGhlciBwYXNzIGhhbmRsZVN1Ym1pdCgpIGFuIG9uU3VibWl0IGZ1bmN0aW9uIG9yIHBhc3Mgb25TdWJtaXQgYXMgYSBwcm9wJyk7XG4gIH1cblxuICByZXR1cm4gc3VibWl0O1xufTtcblxuLyoqXG4gKiBUaGUgZGVjb3JhdG9yIHRoYXQgaXMgdGhlIG1haW4gQVBJIHRvIHJlZHV4LWZvcm1cbiAqL1xudmFyIGNyZWF0ZVJlZHV4Rm9ybSA9IGZ1bmN0aW9uIGNyZWF0ZVJlZHV4Rm9ybShzdHJ1Y3R1cmUpIHtcbiAgdmFyIGRlZXBFcXVhbCA9IHN0cnVjdHVyZS5kZWVwRXF1YWwsXG4gICAgICBlbXB0eSA9IHN0cnVjdHVyZS5lbXB0eSxcbiAgICAgIGdldEluID0gc3RydWN0dXJlLmdldEluLFxuICAgICAgc2V0SW4gPSBzdHJ1Y3R1cmUuc2V0SW4sXG4gICAgICBrZXlzID0gc3RydWN0dXJlLmtleXMsXG4gICAgICBmcm9tSlMgPSBzdHJ1Y3R1cmUuZnJvbUpTO1xuICB2YXIgaXNWYWxpZCA9IGNyZWF0ZUlzVmFsaWQoc3RydWN0dXJlKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpbml0aWFsQ29uZmlnKSB7XG4gICAgdmFyIGNvbmZpZyA9IF9leHRlbmRzKHtcbiAgICAgIHRvdWNoT25CbHVyOiB0cnVlLFxuICAgICAgdG91Y2hPbkNoYW5nZTogZmFsc2UsXG4gICAgICBwZXJzaXN0ZW50U3VibWl0RXJyb3JzOiBmYWxzZSxcbiAgICAgIGRlc3Ryb3lPblVubW91bnQ6IHRydWUsXG4gICAgICBzaG91bGRBc3luY1ZhbGlkYXRlOiBkZWZhdWx0U2hvdWxkQXN5bmNWYWxpZGF0ZSxcbiAgICAgIHNob3VsZFZhbGlkYXRlOiBkZWZhdWx0U2hvdWxkVmFsaWRhdGUsXG4gICAgICBzaG91bGRFcnJvcjogZGVmYXVsdFNob3VsZEVycm9yLFxuICAgICAgc2hvdWxkV2FybjogZGVmYXVsdFNob3VsZFdhcm4sXG4gICAgICBlbmFibGVSZWluaXRpYWxpemU6IGZhbHNlLFxuICAgICAga2VlcERpcnR5T25SZWluaXRpYWxpemU6IGZhbHNlLFxuICAgICAgdXBkYXRlVW5yZWdpc3RlcmVkRmllbGRzOiBmYWxzZSxcbiAgICAgIGdldEZvcm1TdGF0ZTogZnVuY3Rpb24gZ2V0Rm9ybVN0YXRlKHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBnZXRJbihzdGF0ZSwgJ2Zvcm0nKTtcbiAgICAgIH0sXG4gICAgICBwdXJlOiB0cnVlLFxuICAgICAgZm9yY2VVbnJlZ2lzdGVyT25Vbm1vdW50OiBmYWxzZVxuICAgIH0sIGluaXRpYWxDb25maWcpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChXcmFwcGVkQ29tcG9uZW50KSB7XG4gICAgICB2YXIgRm9ybSA9XG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICAgICAgICBfaW5oZXJpdHNMb29zZShGb3JtLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICAgICAgICBmdW5jdGlvbiBGb3JtKCkge1xuICAgICAgICAgIHZhciBfdGhpcztcblxuICAgICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSB8fCB0aGlzO1xuICAgICAgICAgIF90aGlzLndyYXBwZWQgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgICBfdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgICBfdGhpcy5maWVsZENvdW50cyA9IHt9O1xuICAgICAgICAgIF90aGlzLmZpZWxkVmFsaWRhdG9ycyA9IHt9O1xuICAgICAgICAgIF90aGlzLmxhc3RGaWVsZFZhbGlkYXRvcktleXMgPSBbXTtcbiAgICAgICAgICBfdGhpcy5maWVsZFdhcm5lcnMgPSB7fTtcbiAgICAgICAgICBfdGhpcy5sYXN0RmllbGRXYXJuZXJLZXlzID0gW107XG4gICAgICAgICAgX3RoaXMuaW5uZXJPblN1Ym1pdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBfdGhpcy5zdWJtaXRQcm9taXNlID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgX3RoaXMuZ2V0VmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnByb3BzLnZhbHVlcztcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgX3RoaXMuaXNWYWxpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5wcm9wcy52YWxpZDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgX3RoaXMuaXNQcmlzdGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5wcm9wcy5wcmlzdGluZTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgX3RoaXMucmVnaXN0ZXIgPSBmdW5jdGlvbiAobmFtZSwgdHlwZSwgZ2V0VmFsaWRhdG9yLCBnZXRXYXJuZXIpIHtcbiAgICAgICAgICAgIHZhciBsYXN0Q291bnQgPSBfdGhpcy5maWVsZENvdW50c1tuYW1lXTtcbiAgICAgICAgICAgIHZhciBuZXh0Q291bnQgPSAobGFzdENvdW50IHx8IDApICsgMTtcbiAgICAgICAgICAgIF90aGlzLmZpZWxkQ291bnRzW25hbWVdID0gbmV4dENvdW50O1xuXG4gICAgICAgICAgICBfdGhpcy5wcm9wcy5yZWdpc3RlckZpZWxkKG5hbWUsIHR5cGUpO1xuXG4gICAgICAgICAgICBpZiAoZ2V0VmFsaWRhdG9yKSB7XG4gICAgICAgICAgICAgIF90aGlzLmZpZWxkVmFsaWRhdG9yc1tuYW1lXSA9IGdldFZhbGlkYXRvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGdldFdhcm5lcikge1xuICAgICAgICAgICAgICBfdGhpcy5maWVsZFdhcm5lcnNbbmFtZV0gPSBnZXRXYXJuZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIF90aGlzLnVucmVnaXN0ZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIGxhc3RDb3VudCA9IF90aGlzLmZpZWxkQ291bnRzW25hbWVdO1xuICAgICAgICAgICAgaWYgKGxhc3RDb3VudCA9PT0gMSkgZGVsZXRlIF90aGlzLmZpZWxkQ291bnRzW25hbWVdO2Vsc2UgaWYgKGxhc3RDb3VudCAhPSBudWxsKSBfdGhpcy5maWVsZENvdW50c1tuYW1lXSA9IGxhc3RDb3VudCAtIDE7XG5cbiAgICAgICAgICAgIGlmICghX3RoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpcyRwcm9wcyA9IF90aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgICAgX2Rlc3Ryb3lPblVubW91bnQgPSBfdGhpcyRwcm9wcy5kZXN0cm95T25Vbm1vdW50LFxuICAgICAgICAgICAgICAgICAgZm9yY2VVbnJlZ2lzdGVyT25Vbm1vdW50ID0gX3RoaXMkcHJvcHMuZm9yY2VVbnJlZ2lzdGVyT25Vbm1vdW50LFxuICAgICAgICAgICAgICAgICAgdW5yZWdpc3RlckZpZWxkID0gX3RoaXMkcHJvcHMudW5yZWdpc3RlckZpZWxkO1xuXG4gICAgICAgICAgICAgIGlmIChfZGVzdHJveU9uVW5tb3VudCB8fCBmb3JjZVVucmVnaXN0ZXJPblVubW91bnQpIHtcbiAgICAgICAgICAgICAgICB1bnJlZ2lzdGVyRmllbGQobmFtZSwgX2Rlc3Ryb3lPblVubW91bnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5maWVsZENvdW50c1tuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzLmZpZWxkVmFsaWRhdG9yc1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5maWVsZFdhcm5lcnNbbmFtZV07XG4gICAgICAgICAgICAgICAgICBfdGhpcy5sYXN0RmllbGRWYWxpZGF0b3JLZXlzID0gX3RoaXMubGFzdEZpZWxkVmFsaWRhdG9yS2V5cy5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5ICE9PSBuYW1lO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVucmVnaXN0ZXJGaWVsZChuYW1lLCBmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgX3RoaXMuZ2V0RmllbGRMaXN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciByZWdpc3RlcmVkRmllbGRzID0gX3RoaXMucHJvcHMucmVnaXN0ZXJlZEZpZWxkcztcbiAgICAgICAgICAgIHZhciBsaXN0ID0gW107XG5cbiAgICAgICAgICAgIGlmICghcmVnaXN0ZXJlZEZpZWxkcykge1xuICAgICAgICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGtleVNlcSA9IGtleXMocmVnaXN0ZXJlZEZpZWxkcyk7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZXhjbHVkZUZpZWxkQXJyYXkpIHtcbiAgICAgICAgICAgICAga2V5U2VxID0ga2V5U2VxLmZpbHRlcihmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRJbihyZWdpc3RlcmVkRmllbGRzLCBcIlsnXCIgKyBuYW1lICsgXCInXS50eXBlXCIpICE9PSAnRmllbGRBcnJheSc7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZnJvbUpTKGtleVNlcS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgICAgICAgICAgIGFjYy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LCBsaXN0KSk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIF90aGlzLmdldFZhbGlkYXRvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRhdG9ycyA9IHt9O1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoX3RoaXMuZmllbGRWYWxpZGF0b3JzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgIHZhciB2YWxpZGF0b3IgPSBfdGhpcy5maWVsZFZhbGlkYXRvcnNbbmFtZV0oKTtcblxuICAgICAgICAgICAgICBpZiAodmFsaWRhdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdG9yc1tuYW1lXSA9IHZhbGlkYXRvcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdG9ycztcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgX3RoaXMuZ2VuZXJhdGVWYWxpZGF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRhdG9ycyA9IF90aGlzLmdldFZhbGlkYXRvcnMoKTtcblxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbGlkYXRvcnMpLmxlbmd0aCA/IGdlbmVyYXRlVmFsaWRhdG9yKHZhbGlkYXRvcnMsIHN0cnVjdHVyZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIF90aGlzLmdldFdhcm5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgd2FybmVycyA9IHt9O1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoX3RoaXMuZmllbGRXYXJuZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgIHZhciB3YXJuZXIgPSBfdGhpcy5maWVsZFdhcm5lcnNbbmFtZV0oKTtcblxuICAgICAgICAgICAgICBpZiAod2FybmVyKSB7XG4gICAgICAgICAgICAgICAgd2FybmVyc1tuYW1lXSA9IHdhcm5lcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gd2FybmVycztcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgX3RoaXMuZ2VuZXJhdGVXYXJuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgd2FybmVycyA9IF90aGlzLmdldFdhcm5lcnMoKTtcblxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHdhcm5lcnMpLmxlbmd0aCA/IGdlbmVyYXRlVmFsaWRhdG9yKHdhcm5lcnMsIHN0cnVjdHVyZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIF90aGlzLmFzeW5jVmFsaWRhdGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIHRyaWdnZXIpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyRwcm9wczIgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgICBhc3luY0JsdXJGaWVsZHMgPSBfdGhpcyRwcm9wczIuYXN5bmNCbHVyRmllbGRzLFxuICAgICAgICAgICAgICAgIGFzeW5jQ2hhbmdlRmllbGRzID0gX3RoaXMkcHJvcHMyLmFzeW5jQ2hhbmdlRmllbGRzLFxuICAgICAgICAgICAgICAgIGFzeW5jRXJyb3JzID0gX3RoaXMkcHJvcHMyLmFzeW5jRXJyb3JzLFxuICAgICAgICAgICAgICAgIGFzeW5jVmFsaWRhdGUgPSBfdGhpcyRwcm9wczIuYXN5bmNWYWxpZGF0ZSxcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCA9IF90aGlzJHByb3BzMi5kaXNwYXRjaCxcbiAgICAgICAgICAgICAgICBpbml0aWFsaXplZCA9IF90aGlzJHByb3BzMi5pbml0aWFsaXplZCxcbiAgICAgICAgICAgICAgICBwcmlzdGluZSA9IF90aGlzJHByb3BzMi5wcmlzdGluZSxcbiAgICAgICAgICAgICAgICBzaG91bGRBc3luY1ZhbGlkYXRlID0gX3RoaXMkcHJvcHMyLnNob3VsZEFzeW5jVmFsaWRhdGUsXG4gICAgICAgICAgICAgICAgc3RhcnRBc3luY1ZhbGlkYXRpb24gPSBfdGhpcyRwcm9wczIuc3RhcnRBc3luY1ZhbGlkYXRpb24sXG4gICAgICAgICAgICAgICAgc3RvcEFzeW5jVmFsaWRhdGlvbiA9IF90aGlzJHByb3BzMi5zdG9wQXN5bmNWYWxpZGF0aW9uLFxuICAgICAgICAgICAgICAgIHN5bmNFcnJvcnMgPSBfdGhpcyRwcm9wczIuc3luY0Vycm9ycyxcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSBfdGhpcyRwcm9wczIudmFsdWVzO1xuICAgICAgICAgICAgdmFyIHN1Ym1pdHRpbmcgPSAhbmFtZTtcblxuICAgICAgICAgICAgdmFyIGZpZWxkTmVlZHNWYWxpZGF0aW9uID0gZnVuY3Rpb24gZmllbGROZWVkc1ZhbGlkYXRpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBmaWVsZE5lZWRzVmFsaWRhdGlvbkZvckJsdXIgPSBhc3luY0JsdXJGaWVsZHMgJiYgbmFtZSAmJiB+YXN5bmNCbHVyRmllbGRzLmluZGV4T2YobmFtZS5yZXBsYWNlKC9cXFtbMC05XStcXF0vZywgJ1tdJykpO1xuICAgICAgICAgICAgICB2YXIgZmllbGROZWVkc1ZhbGlkYXRpb25Gb3JDaGFuZ2UgPSBhc3luY0NoYW5nZUZpZWxkcyAmJiBuYW1lICYmIH5hc3luY0NoYW5nZUZpZWxkcy5pbmRleE9mKG5hbWUucmVwbGFjZSgvXFxbWzAtOV0rXFxdL2csICdbXScpKTtcbiAgICAgICAgICAgICAgdmFyIGFzeW5jVmFsaWRhdGVCeURlZmF1bHQgPSAhKGFzeW5jQmx1ckZpZWxkcyB8fCBhc3luY0NoYW5nZUZpZWxkcyk7XG4gICAgICAgICAgICAgIHJldHVybiBzdWJtaXR0aW5nIHx8IGFzeW5jVmFsaWRhdGVCeURlZmF1bHQgfHwgKHRyaWdnZXIgPT09ICdibHVyJyA/IGZpZWxkTmVlZHNWYWxpZGF0aW9uRm9yQmx1ciA6IGZpZWxkTmVlZHNWYWxpZGF0aW9uRm9yQ2hhbmdlKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChhc3luY1ZhbGlkYXRlKSB7XG4gICAgICAgICAgICAgIHZhciB2YWx1ZXNUb1ZhbGlkYXRlID0gc3VibWl0dGluZyA/IHZhbHVlcyA6IHNldEluKHZhbHVlcywgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgICB2YXIgc3luY1ZhbGlkYXRpb25QYXNzZXMgPSBzdWJtaXR0aW5nIHx8ICFnZXRJbihzeW5jRXJyb3JzLCBuYW1lKTtcblxuICAgICAgICAgICAgICBpZiAoZmllbGROZWVkc1ZhbGlkYXRpb24oKSAmJiBzaG91bGRBc3luY1ZhbGlkYXRlKHtcbiAgICAgICAgICAgICAgICBhc3luY0Vycm9yczogYXN5bmNFcnJvcnMsXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZWQ6IGluaXRpYWxpemVkLFxuICAgICAgICAgICAgICAgIHRyaWdnZXI6IHN1Ym1pdHRpbmcgPyAnc3VibWl0JyA6IHRyaWdnZXIsXG4gICAgICAgICAgICAgICAgYmx1cnJlZEZpZWxkOiBuYW1lLFxuICAgICAgICAgICAgICAgIHByaXN0aW5lOiBwcmlzdGluZSxcbiAgICAgICAgICAgICAgICBzeW5jVmFsaWRhdGlvblBhc3Nlczogc3luY1ZhbGlkYXRpb25QYXNzZXNcbiAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXN5bmNWYWxpZGF0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBhc3luY1ZhbGlkYXRlKHZhbHVlc1RvVmFsaWRhdGUsIGRpc3BhdGNoLCBfdGhpcy5wcm9wcywgbmFtZSk7XG4gICAgICAgICAgICAgICAgfSwgc3RhcnRBc3luY1ZhbGlkYXRpb24sIHN0b3BBc3luY1ZhbGlkYXRpb24sIG5hbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIF90aGlzLnN1Ym1pdENvbXBsZXRlZCA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5zdWJtaXRQcm9taXNlO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgX3RoaXMuc3VibWl0RmFpbGVkID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBkZWxldGUgX3RoaXMuc3VibWl0UHJvbWlzZTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBfdGhpcy5saXN0ZW5Ub1N1Ym1pdCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgICAgICBpZiAoIWlzUHJvbWlzZShwcm9taXNlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX3RoaXMuc3VibWl0UHJvbWlzZSA9IHByb21pc2U7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKF90aGlzLnN1Ym1pdENvbXBsZXRlZCwgX3RoaXMuc3VibWl0RmFpbGVkKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgX3RoaXMuc3VibWl0ID0gZnVuY3Rpb24gKHN1Ym1pdE9yRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyRwcm9wczMgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgICBvblN1Ym1pdCA9IF90aGlzJHByb3BzMy5vblN1Ym1pdCxcbiAgICAgICAgICAgICAgICBibHVyID0gX3RoaXMkcHJvcHMzLmJsdXIsXG4gICAgICAgICAgICAgICAgY2hhbmdlID0gX3RoaXMkcHJvcHMzLmNoYW5nZSxcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCA9IF90aGlzJHByb3BzMy5kaXNwYXRjaDtcblxuICAgICAgICAgICAgaWYgKCFzdWJtaXRPckV2ZW50IHx8IHNpbGVuY2VFdmVudChzdWJtaXRPckV2ZW50KSkge1xuICAgICAgICAgICAgICAvLyBzdWJtaXRPckV2ZW50IGlzIGFuIGV2ZW50OiBmaXJlIHN1Ym1pdCBpZiBub3QgYWxyZWFkeSBzdWJtaXR0aW5nXG4gICAgICAgICAgICAgIGlmICghX3RoaXMuc3VibWl0UHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIC8vIGF2b2lkIHJlY3Vyc2l2ZSBzdGFjayB0cmFjZSBpZiB1c2UgRm9ybSB3aXRoIG9uU3VibWl0IGFzIGhhbmRsZVN1Ym1pdFxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5pbm5lck9uU3VibWl0ICYmIF90aGlzLmlubmVyT25TdWJtaXQgIT09IF90aGlzLnN1Ym1pdCkge1xuICAgICAgICAgICAgICAgICAgLy8gd2lsbCBjYWxsIFwic3VibWl0T3JFdmVudCBpcyB0aGUgc3VibWl0IGZ1bmN0aW9uXCIgYmxvY2sgYmVsb3dcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5pbm5lck9uU3VibWl0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5saXN0ZW5Ub1N1Ym1pdChoYW5kbGVTdWJtaXQoY2hlY2tTdWJtaXQob25TdWJtaXQpLCBfZXh0ZW5kcyh7fSwgX3RoaXMucHJvcHMsIGJpbmRBY3Rpb25DcmVhdG9ycyh7XG4gICAgICAgICAgICAgICAgICAgIGJsdXI6IGJsdXIsXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZTogY2hhbmdlXG4gICAgICAgICAgICAgICAgICB9LCBkaXNwYXRjaCkpLCBfdGhpcy5wcm9wcy52YWxpZEV4Y2VwdFN1Ym1pdCwgX3RoaXMuYXN5bmNWYWxpZGF0ZSwgX3RoaXMuZ2V0RmllbGRMaXN0KHtcbiAgICAgICAgICAgICAgICAgICAgZXhjbHVkZUZpZWxkQXJyYXk6IHRydWVcbiAgICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBzdWJtaXRPckV2ZW50IGlzIHRoZSBzdWJtaXQgZnVuY3Rpb246IHJldHVybiBkZWZlcnJlZCBzdWJtaXQgdGh1bmtcbiAgICAgICAgICAgICAgcmV0dXJuIHNpbGVuY2VFdmVudHMoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhX3RoaXMuc3VibWl0UHJvbWlzZSAmJiBfdGhpcy5saXN0ZW5Ub1N1Ym1pdChoYW5kbGVTdWJtaXQoY2hlY2tTdWJtaXQoc3VibWl0T3JFdmVudCksIF9leHRlbmRzKHt9LCBfdGhpcy5wcm9wcywgYmluZEFjdGlvbkNyZWF0b3JzKHtcbiAgICAgICAgICAgICAgICAgIGJsdXI6IGJsdXIsXG4gICAgICAgICAgICAgICAgICBjaGFuZ2U6IGNoYW5nZVxuICAgICAgICAgICAgICAgIH0sIGRpc3BhdGNoKSksIF90aGlzLnByb3BzLnZhbGlkRXhjZXB0U3VibWl0LCBfdGhpcy5hc3luY1ZhbGlkYXRlLCBfdGhpcy5nZXRGaWVsZExpc3Qoe1xuICAgICAgICAgICAgICAgICAgZXhjbHVkZUZpZWxkQXJyYXk6IHRydWVcbiAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgX3RoaXMucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMucHJvcHMucmVzZXQoKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9wcm90byA9IEZvcm0ucHJvdG90eXBlO1xuXG4gICAgICAgIF9wcm90by5pbml0SWZOZWVkZWQgPSBmdW5jdGlvbiBpbml0SWZOZWVkZWQobmV4dFByb3BzKSB7XG4gICAgICAgICAgdmFyIGVuYWJsZVJlaW5pdGlhbGl6ZSA9IHRoaXMucHJvcHMuZW5hYmxlUmVpbml0aWFsaXplO1xuXG4gICAgICAgICAgaWYgKG5leHRQcm9wcykge1xuICAgICAgICAgICAgaWYgKChlbmFibGVSZWluaXRpYWxpemUgfHwgIW5leHRQcm9wcy5pbml0aWFsaXplZCkgJiYgIWRlZXBFcXVhbCh0aGlzLnByb3BzLmluaXRpYWxWYWx1ZXMsIG5leHRQcm9wcy5pbml0aWFsVmFsdWVzKSkge1xuICAgICAgICAgICAgICB2YXIgX2tlZXBEaXJ0eSA9IG5leHRQcm9wcy5pbml0aWFsaXplZCAmJiB0aGlzLnByb3BzLmtlZXBEaXJ0eU9uUmVpbml0aWFsaXplO1xuXG4gICAgICAgICAgICAgIHRoaXMucHJvcHMuaW5pdGlhbGl6ZShuZXh0UHJvcHMuaW5pdGlhbFZhbHVlcywgX2tlZXBEaXJ0eSwge1xuICAgICAgICAgICAgICAgIGtlZXBWYWx1ZXM6IG5leHRQcm9wcy5rZWVwVmFsdWVzLFxuICAgICAgICAgICAgICAgIGxhc3RJbml0aWFsVmFsdWVzOiB0aGlzLnByb3BzLmluaXRpYWxWYWx1ZXMsXG4gICAgICAgICAgICAgICAgdXBkYXRlVW5yZWdpc3RlcmVkRmllbGRzOiBuZXh0UHJvcHMudXBkYXRlVW5yZWdpc3RlcmVkRmllbGRzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcm9wcy5pbml0aWFsVmFsdWVzICYmICghdGhpcy5wcm9wcy5pbml0aWFsaXplZCB8fCBlbmFibGVSZWluaXRpYWxpemUpKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLmluaXRpYWxpemUodGhpcy5wcm9wcy5pbml0aWFsVmFsdWVzLCB0aGlzLnByb3BzLmtlZXBEaXJ0eU9uUmVpbml0aWFsaXplLCB7XG4gICAgICAgICAgICAgIGtlZXBWYWx1ZXM6IHRoaXMucHJvcHMua2VlcFZhbHVlcyxcbiAgICAgICAgICAgICAgdXBkYXRlVW5yZWdpc3RlcmVkRmllbGRzOiB0aGlzLnByb3BzLnVwZGF0ZVVucmVnaXN0ZXJlZEZpZWxkc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIF9wcm90by51cGRhdGVTeW5jRXJyb3JzSWZOZWVkZWQgPSBmdW5jdGlvbiB1cGRhdGVTeW5jRXJyb3JzSWZOZWVkZWQobmV4dFN5bmNFcnJvcnMsIG5leHRFcnJvciwgbGFzdFN5bmNFcnJvcnMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMkcHJvcHM0ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgZXJyb3IgPSBfdGhpcyRwcm9wczQuZXJyb3IsXG4gICAgICAgICAgICAgIHVwZGF0ZVN5bmNFcnJvcnMgPSBfdGhpcyRwcm9wczQudXBkYXRlU3luY0Vycm9ycztcbiAgICAgICAgICB2YXIgbm9FcnJvcnMgPSAoIWxhc3RTeW5jRXJyb3JzIHx8ICFPYmplY3Qua2V5cyhsYXN0U3luY0Vycm9ycykubGVuZ3RoKSAmJiAhZXJyb3I7XG4gICAgICAgICAgdmFyIG5leHROb0Vycm9ycyA9ICghbmV4dFN5bmNFcnJvcnMgfHwgIU9iamVjdC5rZXlzKG5leHRTeW5jRXJyb3JzKS5sZW5ndGgpICYmICFuZXh0RXJyb3I7XG5cbiAgICAgICAgICBpZiAoIShub0Vycm9ycyAmJiBuZXh0Tm9FcnJvcnMpICYmICghcGxhaW4uZGVlcEVxdWFsKGxhc3RTeW5jRXJyb3JzLCBuZXh0U3luY0Vycm9ycykgfHwgIXBsYWluLmRlZXBFcXVhbChlcnJvciwgbmV4dEVycm9yKSkpIHtcbiAgICAgICAgICAgIHVwZGF0ZVN5bmNFcnJvcnMobmV4dFN5bmNFcnJvcnMsIG5leHRFcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIF9wcm90by5jbGVhclN1Ym1pdFByb21pc2VJZk5lZWRlZCA9IGZ1bmN0aW9uIGNsZWFyU3VibWl0UHJvbWlzZUlmTmVlZGVkKG5leHRQcm9wcykge1xuICAgICAgICAgIHZhciBzdWJtaXR0aW5nID0gdGhpcy5wcm9wcy5zdWJtaXR0aW5nO1xuXG4gICAgICAgICAgaWYgKHRoaXMuc3VibWl0UHJvbWlzZSAmJiBzdWJtaXR0aW5nICYmICFuZXh0UHJvcHMuc3VibWl0dGluZykge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc3VibWl0UHJvbWlzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgX3Byb3RvLnN1Ym1pdElmTmVlZGVkID0gZnVuY3Rpb24gc3VibWl0SWZOZWVkZWQobmV4dFByb3BzKSB7XG4gICAgICAgICAgdmFyIF90aGlzJHByb3BzNSA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgIGNsZWFyU3VibWl0ID0gX3RoaXMkcHJvcHM1LmNsZWFyU3VibWl0LFxuICAgICAgICAgICAgICB0cmlnZ2VyU3VibWl0ID0gX3RoaXMkcHJvcHM1LnRyaWdnZXJTdWJtaXQ7XG5cbiAgICAgICAgICBpZiAoIXRyaWdnZXJTdWJtaXQgJiYgbmV4dFByb3BzLnRyaWdnZXJTdWJtaXQpIHtcbiAgICAgICAgICAgIGNsZWFyU3VibWl0KCk7XG4gICAgICAgICAgICB0aGlzLnN1Ym1pdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBfcHJvdG8uc2hvdWxkRXJyb3JGdW5jdGlvbiA9IGZ1bmN0aW9uIHNob3VsZEVycm9yRnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIF90aGlzJHByb3BzNiA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgIHNob3VsZFZhbGlkYXRlID0gX3RoaXMkcHJvcHM2LnNob3VsZFZhbGlkYXRlLFxuICAgICAgICAgICAgICBzaG91bGRFcnJvciA9IF90aGlzJHByb3BzNi5zaG91bGRFcnJvcjtcbiAgICAgICAgICB2YXIgc2hvdWxkVmFsaWRhdGVPdmVycmlkZGVuID0gc2hvdWxkVmFsaWRhdGUgIT09IGRlZmF1bHRTaG91bGRWYWxpZGF0ZTtcbiAgICAgICAgICB2YXIgc2hvdWxkRXJyb3JPdmVycmlkZGVuID0gc2hvdWxkRXJyb3IgIT09IGRlZmF1bHRTaG91bGRFcnJvcjtcbiAgICAgICAgICByZXR1cm4gc2hvdWxkVmFsaWRhdGVPdmVycmlkZGVuICYmICFzaG91bGRFcnJvck92ZXJyaWRkZW4gPyBzaG91bGRWYWxpZGF0ZSA6IHNob3VsZEVycm9yO1xuICAgICAgICB9O1xuXG4gICAgICAgIF9wcm90by52YWxpZGF0ZUlmTmVlZGVkID0gZnVuY3Rpb24gdmFsaWRhdGVJZk5lZWRlZChuZXh0UHJvcHMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMkcHJvcHM3ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgdmFsaWRhdGUgPSBfdGhpcyRwcm9wczcudmFsaWRhdGUsXG4gICAgICAgICAgICAgIHZhbHVlcyA9IF90aGlzJHByb3BzNy52YWx1ZXM7XG4gICAgICAgICAgdmFyIHNob3VsZEVycm9yID0gdGhpcy5zaG91bGRFcnJvckZ1bmN0aW9uKCk7XG4gICAgICAgICAgdmFyIGZpZWxkTGV2ZWxWYWxpZGF0ZSA9IHRoaXMuZ2VuZXJhdGVWYWxpZGF0b3IoKTtcblxuICAgICAgICAgIGlmICh2YWxpZGF0ZSB8fCBmaWVsZExldmVsVmFsaWRhdGUpIHtcbiAgICAgICAgICAgIHZhciBpbml0aWFsUmVuZGVyID0gbmV4dFByb3BzID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2YXIgZmllbGRWYWxpZGF0b3JLZXlzID0gT2JqZWN0LmtleXModGhpcy5nZXRWYWxpZGF0b3JzKCkpO1xuICAgICAgICAgICAgdmFyIHZhbGlkYXRlUGFyYW1zID0ge1xuICAgICAgICAgICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICAgICAgICAgICAgbmV4dFByb3BzOiBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgIHByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICBpbml0aWFsUmVuZGVyOiBpbml0aWFsUmVuZGVyLFxuICAgICAgICAgICAgICBsYXN0RmllbGRWYWxpZGF0b3JLZXlzOiB0aGlzLmxhc3RGaWVsZFZhbGlkYXRvcktleXMsXG4gICAgICAgICAgICAgIGZpZWxkVmFsaWRhdG9yS2V5czogZmllbGRWYWxpZGF0b3JLZXlzLFxuICAgICAgICAgICAgICBzdHJ1Y3R1cmU6IHN0cnVjdHVyZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHNob3VsZEVycm9yKHZhbGlkYXRlUGFyYW1zKSkge1xuICAgICAgICAgICAgICB2YXIgcHJvcHNUb1ZhbGlkYXRlID0gaW5pdGlhbFJlbmRlciB8fCAhbmV4dFByb3BzID8gdGhpcy5wcm9wcyA6IG5leHRQcm9wcztcblxuICAgICAgICAgICAgICB2YXIgX21lcmdlMiA9IF9tZXJnZSh2YWxpZGF0ZSA/IHZhbGlkYXRlKHByb3BzVG9WYWxpZGF0ZS52YWx1ZXMsIHByb3BzVG9WYWxpZGF0ZSkgfHwge30gOiB7fSwgZmllbGRMZXZlbFZhbGlkYXRlID8gZmllbGRMZXZlbFZhbGlkYXRlKHByb3BzVG9WYWxpZGF0ZS52YWx1ZXMsIHByb3BzVG9WYWxpZGF0ZSkgfHwge30gOiB7fSksXG4gICAgICAgICAgICAgICAgICBfZXJyb3IgPSBfbWVyZ2UyLl9lcnJvcixcbiAgICAgICAgICAgICAgICAgIG5leHRTeW5jRXJyb3JzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX21lcmdlMiwgW1wiX2Vycm9yXCJdKTtcblxuICAgICAgICAgICAgICB0aGlzLmxhc3RGaWVsZFZhbGlkYXRvcktleXMgPSBmaWVsZFZhbGlkYXRvcktleXM7XG4gICAgICAgICAgICAgIHRoaXMudXBkYXRlU3luY0Vycm9yc0lmTmVlZGVkKG5leHRTeW5jRXJyb3JzLCBfZXJyb3IsIHByb3BzVG9WYWxpZGF0ZS5zeW5jRXJyb3JzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sYXN0RmllbGRWYWxpZGF0b3JLZXlzID0gW107XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIF9wcm90by51cGRhdGVTeW5jV2FybmluZ3NJZk5lZWRlZCA9IGZ1bmN0aW9uIHVwZGF0ZVN5bmNXYXJuaW5nc0lmTmVlZGVkKG5leHRTeW5jV2FybmluZ3MsIG5leHRXYXJuaW5nLCBsYXN0U3luY1dhcm5pbmdzKSB7XG4gICAgICAgICAgdmFyIF90aGlzJHByb3BzOCA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgIHdhcm5pbmcgPSBfdGhpcyRwcm9wczgud2FybmluZyxcbiAgICAgICAgICAgICAgc3luY1dhcm5pbmdzID0gX3RoaXMkcHJvcHM4LnN5bmNXYXJuaW5ncyxcbiAgICAgICAgICAgICAgdXBkYXRlU3luY1dhcm5pbmdzID0gX3RoaXMkcHJvcHM4LnVwZGF0ZVN5bmNXYXJuaW5ncztcbiAgICAgICAgICB2YXIgbm9XYXJuaW5ncyA9ICghc3luY1dhcm5pbmdzIHx8ICFPYmplY3Qua2V5cyhzeW5jV2FybmluZ3MpLmxlbmd0aCkgJiYgIXdhcm5pbmc7XG4gICAgICAgICAgdmFyIG5leHROb1dhcm5pbmdzID0gKCFuZXh0U3luY1dhcm5pbmdzIHx8ICFPYmplY3Qua2V5cyhuZXh0U3luY1dhcm5pbmdzKS5sZW5ndGgpICYmICFuZXh0V2FybmluZztcblxuICAgICAgICAgIGlmICghKG5vV2FybmluZ3MgJiYgbmV4dE5vV2FybmluZ3MpICYmICghcGxhaW4uZGVlcEVxdWFsKGxhc3RTeW5jV2FybmluZ3MsIG5leHRTeW5jV2FybmluZ3MpIHx8ICFwbGFpbi5kZWVwRXF1YWwod2FybmluZywgbmV4dFdhcm5pbmcpKSkge1xuICAgICAgICAgICAgdXBkYXRlU3luY1dhcm5pbmdzKG5leHRTeW5jV2FybmluZ3MsIG5leHRXYXJuaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgX3Byb3RvLnNob3VsZFdhcm5GdW5jdGlvbiA9IGZ1bmN0aW9uIHNob3VsZFdhcm5GdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgX3RoaXMkcHJvcHM5ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgc2hvdWxkVmFsaWRhdGUgPSBfdGhpcyRwcm9wczkuc2hvdWxkVmFsaWRhdGUsXG4gICAgICAgICAgICAgIHNob3VsZFdhcm4gPSBfdGhpcyRwcm9wczkuc2hvdWxkV2FybjtcbiAgICAgICAgICB2YXIgc2hvdWxkVmFsaWRhdGVPdmVycmlkZGVuID0gc2hvdWxkVmFsaWRhdGUgIT09IGRlZmF1bHRTaG91bGRWYWxpZGF0ZTtcbiAgICAgICAgICB2YXIgc2hvdWxkV2Fybk92ZXJyaWRkZW4gPSBzaG91bGRXYXJuICE9PSBkZWZhdWx0U2hvdWxkV2FybjtcbiAgICAgICAgICByZXR1cm4gc2hvdWxkVmFsaWRhdGVPdmVycmlkZGVuICYmICFzaG91bGRXYXJuT3ZlcnJpZGRlbiA/IHNob3VsZFZhbGlkYXRlIDogc2hvdWxkV2FybjtcbiAgICAgICAgfTtcblxuICAgICAgICBfcHJvdG8ud2FybklmTmVlZGVkID0gZnVuY3Rpb24gd2FybklmTmVlZGVkKG5leHRQcm9wcykge1xuICAgICAgICAgIHZhciBfdGhpcyRwcm9wczEwID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgd2FybiA9IF90aGlzJHByb3BzMTAud2FybixcbiAgICAgICAgICAgICAgdmFsdWVzID0gX3RoaXMkcHJvcHMxMC52YWx1ZXM7XG4gICAgICAgICAgdmFyIHNob3VsZFdhcm4gPSB0aGlzLnNob3VsZFdhcm5GdW5jdGlvbigpO1xuICAgICAgICAgIHZhciBmaWVsZExldmVsV2FybiA9IHRoaXMuZ2VuZXJhdGVXYXJuZXIoKTtcblxuICAgICAgICAgIGlmICh3YXJuIHx8IGZpZWxkTGV2ZWxXYXJuKSB7XG4gICAgICAgICAgICB2YXIgaW5pdGlhbFJlbmRlciA9IG5leHRQcm9wcyA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdmFyIGZpZWxkV2FybmVyS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuZ2V0V2FybmVycygpKTtcbiAgICAgICAgICAgIHZhciB2YWxpZGF0ZVBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICAgICAgICAgIG5leHRQcm9wczogbmV4dFByb3BzLFxuICAgICAgICAgICAgICBwcm9wczogdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgaW5pdGlhbFJlbmRlcjogaW5pdGlhbFJlbmRlcixcbiAgICAgICAgICAgICAgbGFzdEZpZWxkVmFsaWRhdG9yS2V5czogdGhpcy5sYXN0RmllbGRXYXJuZXJLZXlzLFxuICAgICAgICAgICAgICBmaWVsZFZhbGlkYXRvcktleXM6IGZpZWxkV2FybmVyS2V5cyxcbiAgICAgICAgICAgICAgc3RydWN0dXJlOiBzdHJ1Y3R1cmVcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChzaG91bGRXYXJuKHZhbGlkYXRlUGFyYW1zKSkge1xuICAgICAgICAgICAgICB2YXIgcHJvcHNUb1dhcm4gPSBpbml0aWFsUmVuZGVyIHx8ICFuZXh0UHJvcHMgPyB0aGlzLnByb3BzIDogbmV4dFByb3BzO1xuXG4gICAgICAgICAgICAgIHZhciBfbWVyZ2UzID0gX21lcmdlKHdhcm4gPyB3YXJuKHByb3BzVG9XYXJuLnZhbHVlcywgcHJvcHNUb1dhcm4pIDoge30sIGZpZWxkTGV2ZWxXYXJuID8gZmllbGRMZXZlbFdhcm4ocHJvcHNUb1dhcm4udmFsdWVzLCBwcm9wc1RvV2FybikgOiB7fSksXG4gICAgICAgICAgICAgICAgICBfd2FybmluZyA9IF9tZXJnZTMuX3dhcm5pbmcsXG4gICAgICAgICAgICAgICAgICBuZXh0U3luY1dhcm5pbmdzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX21lcmdlMywgW1wiX3dhcm5pbmdcIl0pO1xuXG4gICAgICAgICAgICAgIHRoaXMubGFzdEZpZWxkV2FybmVyS2V5cyA9IGZpZWxkV2FybmVyS2V5cztcbiAgICAgICAgICAgICAgdGhpcy51cGRhdGVTeW5jV2FybmluZ3NJZk5lZWRlZChuZXh0U3luY1dhcm5pbmdzLCBfd2FybmluZywgcHJvcHNUb1dhcm4uc3luY1dhcm5pbmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgX3Byb3RvLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgICAgICBpZiAoIWlzSG90UmVsb2FkaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdElmTmVlZGVkKCk7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlSWZOZWVkZWQoKTtcbiAgICAgICAgICAgIHRoaXMud2FybklmTmVlZGVkKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW52YXJpYW50KHRoaXMucHJvcHMuc2hvdWxkVmFsaWRhdGUsICdzaG91bGRWYWxpZGF0ZSgpIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2OS4wLjAuIFVzZSBzaG91bGRXYXJuKCkgb3Igc2hvdWxkRXJyb3IoKSBpbnN0ZWFkLicpO1xuICAgICAgICB9O1xuXG4gICAgICAgIF9wcm90by5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgICB0aGlzLmluaXRJZk5lZWRlZChuZXh0UHJvcHMpO1xuICAgICAgICAgIHRoaXMudmFsaWRhdGVJZk5lZWRlZChuZXh0UHJvcHMpO1xuICAgICAgICAgIHRoaXMud2FybklmTmVlZGVkKG5leHRQcm9wcyk7XG4gICAgICAgICAgdGhpcy5jbGVhclN1Ym1pdFByb21pc2VJZk5lZWRlZChuZXh0UHJvcHMpO1xuICAgICAgICAgIHRoaXMuc3VibWl0SWZOZWVkZWQobmV4dFByb3BzKTtcbiAgICAgICAgICB2YXIgb25DaGFuZ2UgPSBuZXh0UHJvcHMub25DaGFuZ2UsXG4gICAgICAgICAgICAgIHZhbHVlcyA9IG5leHRQcm9wcy52YWx1ZXMsXG4gICAgICAgICAgICAgIGRpc3BhdGNoID0gbmV4dFByb3BzLmRpc3BhdGNoO1xuXG4gICAgICAgICAgaWYgKG9uQ2hhbmdlICYmICFkZWVwRXF1YWwodmFsdWVzLCB0aGlzLnByb3BzLnZhbHVlcykpIHtcbiAgICAgICAgICAgIG9uQ2hhbmdlKHZhbHVlcywgZGlzcGF0Y2gsIG5leHRQcm9wcywgdGhpcy5wcm9wcy52YWx1ZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBfcHJvdG8uc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24gc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcykge1xuICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLnByb3BzLnB1cmUpIHJldHVybiB0cnVlO1xuICAgICAgICAgIHZhciBfY29uZmlnJGltbXV0YWJsZVByb3AgPSBjb25maWcuaW1tdXRhYmxlUHJvcHMsXG4gICAgICAgICAgICAgIGltbXV0YWJsZVByb3BzID0gX2NvbmZpZyRpbW11dGFibGVQcm9wID09PSB2b2lkIDAgPyBbXSA6IF9jb25maWckaW1tdXRhYmxlUHJvcDsgLy8gaWYgd2UgaGF2ZSBjaGlsZHJlbiwgd2UgTVVTVCB1cGRhdGUgaW4gUmVhY3QgMTZcbiAgICAgICAgICAvLyBodHRwczovL3R3aXR0ZXIuY29tL2VyaWtyYXMvc3RhdHVzLzkxNTg2NjU0NDU1ODc4ODYwOFxuXG4gICAgICAgICAgcmV0dXJuICEhKHRoaXMucHJvcHMuY2hpbGRyZW4gfHwgbmV4dFByb3BzLmNoaWxkcmVuIHx8IE9iamVjdC5rZXlzKG5leHRQcm9wcykuc29tZShmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgLy8gdXNlZnVsIHRvIGRlYnVnIHJlcmVuZGVyc1xuICAgICAgICAgICAgLy8gaWYgKCFwbGFpbi5kZWVwRXF1YWwodGhpcy5wcm9wc1sgcHJvcCBdLCBuZXh0UHJvcHNbIHByb3AgXSkpIHtcbiAgICAgICAgICAgIC8vICAgY29uc29sZS5pbmZvKHByb3AsICdjaGFuZ2VkJywgdGhpcy5wcm9wc1sgcHJvcCBdLCAnPT0+JywgbmV4dFByb3BzWyBwcm9wIF0pXG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICBpZiAofmltbXV0YWJsZVByb3BzLmluZGV4T2YocHJvcCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5wcm9wc1twcm9wXSAhPT0gbmV4dFByb3BzW3Byb3BdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gIX5wcm9wc1RvTm90VXBkYXRlRm9yLmluZGV4T2YocHJvcCkgJiYgIWRlZXBFcXVhbChfdGhpczIucHJvcHNbcHJvcF0sIG5leHRQcm9wc1twcm9wXSk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIF9wcm90by5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICAgIGlmICghaXNIb3RSZWxvYWRpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5pbml0SWZOZWVkZWQodGhpcy5wcm9wcyk7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlSWZOZWVkZWQoKTtcbiAgICAgICAgICAgIHRoaXMud2FybklmTmVlZGVkKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW52YXJpYW50KHRoaXMucHJvcHMuc2hvdWxkVmFsaWRhdGUsICdzaG91bGRWYWxpZGF0ZSgpIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2OS4wLjAuIFVzZSBzaG91bGRXYXJuKCkgb3Igc2hvdWxkRXJyb3IoKSBpbnN0ZWFkLicpO1xuICAgICAgICB9O1xuXG4gICAgICAgIF9wcm90by5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICAgIHZhciBfdGhpcyRwcm9wczExID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgZGVzdHJveU9uVW5tb3VudCA9IF90aGlzJHByb3BzMTEuZGVzdHJveU9uVW5tb3VudCxcbiAgICAgICAgICAgICAgZGVzdHJveSA9IF90aGlzJHByb3BzMTEuZGVzdHJveTtcblxuICAgICAgICAgIGlmIChkZXN0cm95T25Vbm1vdW50ICYmICFpc0hvdFJlbG9hZGluZygpKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgICAgICBkZXN0cm95KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgICAgdmFyIF9yZWYsXG4gICAgICAgICAgICAgIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgICAvLyByZW1vdmUgc29tZSByZWR1eC1mb3JtIGNvbmZpZy1vbmx5IHByb3BzXG5cbiAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICAgICAgICAgIHZhciBfdGhpcyRwcm9wczEyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgYW55VG91Y2hlZCA9IF90aGlzJHByb3BzMTIuYW55VG91Y2hlZCxcbiAgICAgICAgICAgICAgYXJyYXkgPSBfdGhpcyRwcm9wczEyLmFycmF5LFxuICAgICAgICAgICAgICBhcnJheUluc2VydCA9IF90aGlzJHByb3BzMTIuYXJyYXlJbnNlcnQsXG4gICAgICAgICAgICAgIGFycmF5TW92ZSA9IF90aGlzJHByb3BzMTIuYXJyYXlNb3ZlLFxuICAgICAgICAgICAgICBhcnJheVBvcCA9IF90aGlzJHByb3BzMTIuYXJyYXlQb3AsXG4gICAgICAgICAgICAgIGFycmF5UHVzaCA9IF90aGlzJHByb3BzMTIuYXJyYXlQdXNoLFxuICAgICAgICAgICAgICBhcnJheVJlbW92ZSA9IF90aGlzJHByb3BzMTIuYXJyYXlSZW1vdmUsXG4gICAgICAgICAgICAgIGFycmF5UmVtb3ZlQWxsID0gX3RoaXMkcHJvcHMxMi5hcnJheVJlbW92ZUFsbCxcbiAgICAgICAgICAgICAgYXJyYXlTaGlmdCA9IF90aGlzJHByb3BzMTIuYXJyYXlTaGlmdCxcbiAgICAgICAgICAgICAgYXJyYXlTcGxpY2UgPSBfdGhpcyRwcm9wczEyLmFycmF5U3BsaWNlLFxuICAgICAgICAgICAgICBhcnJheVN3YXAgPSBfdGhpcyRwcm9wczEyLmFycmF5U3dhcCxcbiAgICAgICAgICAgICAgYXJyYXlVbnNoaWZ0ID0gX3RoaXMkcHJvcHMxMi5hcnJheVVuc2hpZnQsXG4gICAgICAgICAgICAgIGFzeW5jRXJyb3JzID0gX3RoaXMkcHJvcHMxMi5hc3luY0Vycm9ycyxcbiAgICAgICAgICAgICAgYXN5bmNWYWxpZGF0ZSA9IF90aGlzJHByb3BzMTIuYXN5bmNWYWxpZGF0ZSxcbiAgICAgICAgICAgICAgYXN5bmNWYWxpZGF0aW5nID0gX3RoaXMkcHJvcHMxMi5hc3luY1ZhbGlkYXRpbmcsXG4gICAgICAgICAgICAgIGJsdXIgPSBfdGhpcyRwcm9wczEyLmJsdXIsXG4gICAgICAgICAgICAgIGNoYW5nZSA9IF90aGlzJHByb3BzMTIuY2hhbmdlLFxuICAgICAgICAgICAgICBjbGVhclN1Ym1pdCA9IF90aGlzJHByb3BzMTIuY2xlYXJTdWJtaXQsXG4gICAgICAgICAgICAgIGRlc3Ryb3kgPSBfdGhpcyRwcm9wczEyLmRlc3Ryb3ksXG4gICAgICAgICAgICAgIGRlc3Ryb3lPblVubW91bnQgPSBfdGhpcyRwcm9wczEyLmRlc3Ryb3lPblVubW91bnQsXG4gICAgICAgICAgICAgIGZvcmNlVW5yZWdpc3Rlck9uVW5tb3VudCA9IF90aGlzJHByb3BzMTIuZm9yY2VVbnJlZ2lzdGVyT25Vbm1vdW50LFxuICAgICAgICAgICAgICBkaXJ0eSA9IF90aGlzJHByb3BzMTIuZGlydHksXG4gICAgICAgICAgICAgIGRpc3BhdGNoID0gX3RoaXMkcHJvcHMxMi5kaXNwYXRjaCxcbiAgICAgICAgICAgICAgZW5hYmxlUmVpbml0aWFsaXplID0gX3RoaXMkcHJvcHMxMi5lbmFibGVSZWluaXRpYWxpemUsXG4gICAgICAgICAgICAgIGVycm9yID0gX3RoaXMkcHJvcHMxMi5lcnJvcixcbiAgICAgICAgICAgICAgZm9jdXMgPSBfdGhpcyRwcm9wczEyLmZvY3VzLFxuICAgICAgICAgICAgICBmb3JtID0gX3RoaXMkcHJvcHMxMi5mb3JtLFxuICAgICAgICAgICAgICBnZXRGb3JtU3RhdGUgPSBfdGhpcyRwcm9wczEyLmdldEZvcm1TdGF0ZSxcbiAgICAgICAgICAgICAgaW1tdXRhYmxlUHJvcHMgPSBfdGhpcyRwcm9wczEyLmltbXV0YWJsZVByb3BzLFxuICAgICAgICAgICAgICBpbml0aWFsaXplID0gX3RoaXMkcHJvcHMxMi5pbml0aWFsaXplLFxuICAgICAgICAgICAgICBpbml0aWFsaXplZCA9IF90aGlzJHByb3BzMTIuaW5pdGlhbGl6ZWQsXG4gICAgICAgICAgICAgIGluaXRpYWxWYWx1ZXMgPSBfdGhpcyRwcm9wczEyLmluaXRpYWxWYWx1ZXMsXG4gICAgICAgICAgICAgIGludmFsaWQgPSBfdGhpcyRwcm9wczEyLmludmFsaWQsXG4gICAgICAgICAgICAgIGtlZXBEaXJ0eU9uUmVpbml0aWFsaXplID0gX3RoaXMkcHJvcHMxMi5rZWVwRGlydHlPblJlaW5pdGlhbGl6ZSxcbiAgICAgICAgICAgICAga2VlcFZhbHVlcyA9IF90aGlzJHByb3BzMTIua2VlcFZhbHVlcyxcbiAgICAgICAgICAgICAgdXBkYXRlVW5yZWdpc3RlcmVkRmllbGRzID0gX3RoaXMkcHJvcHMxMi51cGRhdGVVbnJlZ2lzdGVyZWRGaWVsZHMsXG4gICAgICAgICAgICAgIHByaXN0aW5lID0gX3RoaXMkcHJvcHMxMi5wcmlzdGluZSxcbiAgICAgICAgICAgICAgcHJvcE5hbWVzcGFjZSA9IF90aGlzJHByb3BzMTIucHJvcE5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgcmVnaXN0ZXJlZEZpZWxkcyA9IF90aGlzJHByb3BzMTIucmVnaXN0ZXJlZEZpZWxkcyxcbiAgICAgICAgICAgICAgcmVnaXN0ZXJGaWVsZCA9IF90aGlzJHByb3BzMTIucmVnaXN0ZXJGaWVsZCxcbiAgICAgICAgICAgICAgcmVzZXQgPSBfdGhpcyRwcm9wczEyLnJlc2V0LFxuICAgICAgICAgICAgICByZXNldFNlY3Rpb24gPSBfdGhpcyRwcm9wczEyLnJlc2V0U2VjdGlvbixcbiAgICAgICAgICAgICAgc2V0U3VibWl0RmFpbGVkID0gX3RoaXMkcHJvcHMxMi5zZXRTdWJtaXRGYWlsZWQsXG4gICAgICAgICAgICAgIHNldFN1Ym1pdFN1Y2NlZWRlZCA9IF90aGlzJHByb3BzMTIuc2V0U3VibWl0U3VjY2VlZGVkLFxuICAgICAgICAgICAgICBzaG91bGRBc3luY1ZhbGlkYXRlID0gX3RoaXMkcHJvcHMxMi5zaG91bGRBc3luY1ZhbGlkYXRlLFxuICAgICAgICAgICAgICBzaG91bGRWYWxpZGF0ZSA9IF90aGlzJHByb3BzMTIuc2hvdWxkVmFsaWRhdGUsXG4gICAgICAgICAgICAgIHNob3VsZEVycm9yID0gX3RoaXMkcHJvcHMxMi5zaG91bGRFcnJvcixcbiAgICAgICAgICAgICAgc2hvdWxkV2FybiA9IF90aGlzJHByb3BzMTIuc2hvdWxkV2FybixcbiAgICAgICAgICAgICAgc3RhcnRBc3luY1ZhbGlkYXRpb24gPSBfdGhpcyRwcm9wczEyLnN0YXJ0QXN5bmNWYWxpZGF0aW9uLFxuICAgICAgICAgICAgICBzdGFydFN1Ym1pdCA9IF90aGlzJHByb3BzMTIuc3RhcnRTdWJtaXQsXG4gICAgICAgICAgICAgIHN0b3BBc3luY1ZhbGlkYXRpb24gPSBfdGhpcyRwcm9wczEyLnN0b3BBc3luY1ZhbGlkYXRpb24sXG4gICAgICAgICAgICAgIHN0b3BTdWJtaXQgPSBfdGhpcyRwcm9wczEyLnN0b3BTdWJtaXQsXG4gICAgICAgICAgICAgIHN1Ym1pdHRpbmcgPSBfdGhpcyRwcm9wczEyLnN1Ym1pdHRpbmcsXG4gICAgICAgICAgICAgIHN1Ym1pdEZhaWxlZCA9IF90aGlzJHByb3BzMTIuc3VibWl0RmFpbGVkLFxuICAgICAgICAgICAgICBzdWJtaXRTdWNjZWVkZWQgPSBfdGhpcyRwcm9wczEyLnN1Ym1pdFN1Y2NlZWRlZCxcbiAgICAgICAgICAgICAgdG91Y2ggPSBfdGhpcyRwcm9wczEyLnRvdWNoLFxuICAgICAgICAgICAgICB0b3VjaE9uQmx1ciA9IF90aGlzJHByb3BzMTIudG91Y2hPbkJsdXIsXG4gICAgICAgICAgICAgIHRvdWNoT25DaGFuZ2UgPSBfdGhpcyRwcm9wczEyLnRvdWNoT25DaGFuZ2UsXG4gICAgICAgICAgICAgIHBlcnNpc3RlbnRTdWJtaXRFcnJvcnMgPSBfdGhpcyRwcm9wczEyLnBlcnNpc3RlbnRTdWJtaXRFcnJvcnMsXG4gICAgICAgICAgICAgIHN5bmNFcnJvcnMgPSBfdGhpcyRwcm9wczEyLnN5bmNFcnJvcnMsXG4gICAgICAgICAgICAgIHN5bmNXYXJuaW5ncyA9IF90aGlzJHByb3BzMTIuc3luY1dhcm5pbmdzLFxuICAgICAgICAgICAgICB1bnJlZ2lzdGVyRmllbGQgPSBfdGhpcyRwcm9wczEyLnVucmVnaXN0ZXJGaWVsZCxcbiAgICAgICAgICAgICAgdW50b3VjaCA9IF90aGlzJHByb3BzMTIudW50b3VjaCxcbiAgICAgICAgICAgICAgdXBkYXRlU3luY0Vycm9ycyA9IF90aGlzJHByb3BzMTIudXBkYXRlU3luY0Vycm9ycyxcbiAgICAgICAgICAgICAgdXBkYXRlU3luY1dhcm5pbmdzID0gX3RoaXMkcHJvcHMxMi51cGRhdGVTeW5jV2FybmluZ3MsXG4gICAgICAgICAgICAgIHZhbGlkID0gX3RoaXMkcHJvcHMxMi52YWxpZCxcbiAgICAgICAgICAgICAgdmFsaWRFeGNlcHRTdWJtaXQgPSBfdGhpcyRwcm9wczEyLnZhbGlkRXhjZXB0U3VibWl0LFxuICAgICAgICAgICAgICB2YWx1ZXMgPSBfdGhpcyRwcm9wczEyLnZhbHVlcyxcbiAgICAgICAgICAgICAgd2FybmluZyA9IF90aGlzJHByb3BzMTIud2FybmluZyxcbiAgICAgICAgICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF90aGlzJHByb3BzMTIsIFtcImFueVRvdWNoZWRcIiwgXCJhcnJheVwiLCBcImFycmF5SW5zZXJ0XCIsIFwiYXJyYXlNb3ZlXCIsIFwiYXJyYXlQb3BcIiwgXCJhcnJheVB1c2hcIiwgXCJhcnJheVJlbW92ZVwiLCBcImFycmF5UmVtb3ZlQWxsXCIsIFwiYXJyYXlTaGlmdFwiLCBcImFycmF5U3BsaWNlXCIsIFwiYXJyYXlTd2FwXCIsIFwiYXJyYXlVbnNoaWZ0XCIsIFwiYXN5bmNFcnJvcnNcIiwgXCJhc3luY1ZhbGlkYXRlXCIsIFwiYXN5bmNWYWxpZGF0aW5nXCIsIFwiYmx1clwiLCBcImNoYW5nZVwiLCBcImNsZWFyU3VibWl0XCIsIFwiZGVzdHJveVwiLCBcImRlc3Ryb3lPblVubW91bnRcIiwgXCJmb3JjZVVucmVnaXN0ZXJPblVubW91bnRcIiwgXCJkaXJ0eVwiLCBcImRpc3BhdGNoXCIsIFwiZW5hYmxlUmVpbml0aWFsaXplXCIsIFwiZXJyb3JcIiwgXCJmb2N1c1wiLCBcImZvcm1cIiwgXCJnZXRGb3JtU3RhdGVcIiwgXCJpbW11dGFibGVQcm9wc1wiLCBcImluaXRpYWxpemVcIiwgXCJpbml0aWFsaXplZFwiLCBcImluaXRpYWxWYWx1ZXNcIiwgXCJpbnZhbGlkXCIsIFwia2VlcERpcnR5T25SZWluaXRpYWxpemVcIiwgXCJrZWVwVmFsdWVzXCIsIFwidXBkYXRlVW5yZWdpc3RlcmVkRmllbGRzXCIsIFwicHJpc3RpbmVcIiwgXCJwcm9wTmFtZXNwYWNlXCIsIFwicmVnaXN0ZXJlZEZpZWxkc1wiLCBcInJlZ2lzdGVyRmllbGRcIiwgXCJyZXNldFwiLCBcInJlc2V0U2VjdGlvblwiLCBcInNldFN1Ym1pdEZhaWxlZFwiLCBcInNldFN1Ym1pdFN1Y2NlZWRlZFwiLCBcInNob3VsZEFzeW5jVmFsaWRhdGVcIiwgXCJzaG91bGRWYWxpZGF0ZVwiLCBcInNob3VsZEVycm9yXCIsIFwic2hvdWxkV2FyblwiLCBcInN0YXJ0QXN5bmNWYWxpZGF0aW9uXCIsIFwic3RhcnRTdWJtaXRcIiwgXCJzdG9wQXN5bmNWYWxpZGF0aW9uXCIsIFwic3RvcFN1Ym1pdFwiLCBcInN1Ym1pdHRpbmdcIiwgXCJzdWJtaXRGYWlsZWRcIiwgXCJzdWJtaXRTdWNjZWVkZWRcIiwgXCJ0b3VjaFwiLCBcInRvdWNoT25CbHVyXCIsIFwidG91Y2hPbkNoYW5nZVwiLCBcInBlcnNpc3RlbnRTdWJtaXRFcnJvcnNcIiwgXCJzeW5jRXJyb3JzXCIsIFwic3luY1dhcm5pbmdzXCIsIFwidW5yZWdpc3RlckZpZWxkXCIsIFwidW50b3VjaFwiLCBcInVwZGF0ZVN5bmNFcnJvcnNcIiwgXCJ1cGRhdGVTeW5jV2FybmluZ3NcIiwgXCJ2YWxpZFwiLCBcInZhbGlkRXhjZXB0U3VibWl0XCIsIFwidmFsdWVzXCIsIFwid2FybmluZ1wiXSk7XG4gICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG5cbiAgICAgICAgICB2YXIgcmVkdXhGb3JtUHJvcHMgPSBfZXh0ZW5kcyh7XG4gICAgICAgICAgICBhcnJheTogYXJyYXksXG4gICAgICAgICAgICBhbnlUb3VjaGVkOiBhbnlUb3VjaGVkLFxuICAgICAgICAgICAgYXN5bmNWYWxpZGF0ZTogdGhpcy5hc3luY1ZhbGlkYXRlLFxuICAgICAgICAgICAgYXN5bmNWYWxpZGF0aW5nOiBhc3luY1ZhbGlkYXRpbmdcbiAgICAgICAgICB9LCBiaW5kQWN0aW9uQ3JlYXRvcnMoe1xuICAgICAgICAgICAgYmx1cjogYmx1cixcbiAgICAgICAgICAgIGNoYW5nZTogY2hhbmdlXG4gICAgICAgICAgfSwgZGlzcGF0Y2gpLCB7XG4gICAgICAgICAgICBjbGVhclN1Ym1pdDogY2xlYXJTdWJtaXQsXG4gICAgICAgICAgICBkZXN0cm95OiBkZXN0cm95LFxuICAgICAgICAgICAgZGlydHk6IGRpcnR5LFxuICAgICAgICAgICAgZGlzcGF0Y2g6IGRpc3BhdGNoLFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgZm9ybTogZm9ybSxcbiAgICAgICAgICAgIGhhbmRsZVN1Ym1pdDogdGhpcy5zdWJtaXQsXG4gICAgICAgICAgICBpbml0aWFsaXplOiBpbml0aWFsaXplLFxuICAgICAgICAgICAgaW5pdGlhbGl6ZWQ6IGluaXRpYWxpemVkLFxuICAgICAgICAgICAgaW5pdGlhbFZhbHVlczogaW5pdGlhbFZhbHVlcyxcbiAgICAgICAgICAgIGludmFsaWQ6IGludmFsaWQsXG4gICAgICAgICAgICBwcmlzdGluZTogcHJpc3RpbmUsXG4gICAgICAgICAgICByZXNldDogcmVzZXQsXG4gICAgICAgICAgICByZXNldFNlY3Rpb246IHJlc2V0U2VjdGlvbixcbiAgICAgICAgICAgIHN1Ym1pdHRpbmc6IHN1Ym1pdHRpbmcsXG4gICAgICAgICAgICBzdWJtaXRGYWlsZWQ6IHN1Ym1pdEZhaWxlZCxcbiAgICAgICAgICAgIHN1Ym1pdFN1Y2NlZWRlZDogc3VibWl0U3VjY2VlZGVkLFxuICAgICAgICAgICAgdG91Y2g6IHRvdWNoLFxuICAgICAgICAgICAgdW50b3VjaDogdW50b3VjaCxcbiAgICAgICAgICAgIHZhbGlkOiB2YWxpZCxcbiAgICAgICAgICAgIHdhcm5pbmc6IHdhcm5pbmdcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBwcm9wc1RvUGFzcyA9IF9leHRlbmRzKHt9LCBwcm9wTmFtZXNwYWNlID8gKF9yZWYgPSB7fSwgX3JlZltwcm9wTmFtZXNwYWNlXSA9IHJlZHV4Rm9ybVByb3BzLCBfcmVmKSA6IHJlZHV4Rm9ybVByb3BzLCByZXN0KTtcblxuICAgICAgICAgIGlmIChpc0NsYXNzQ29tcG9uZW50KFdyYXBwZWRDb21wb25lbnQpKSB7XG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBwcm9wc1RvUGFzcy5yZWYgPSB0aGlzLndyYXBwZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9yZWR1eEZvcm0gPSBfZXh0ZW5kcyh7fSwgdGhpcy5wcm9wcywge1xuICAgICAgICAgICAgZ2V0Rm9ybVN0YXRlOiBmdW5jdGlvbiBnZXRGb3JtU3RhdGUoc3RhdGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldEluKF90aGlzMy5wcm9wcy5nZXRGb3JtU3RhdGUoc3RhdGUpLCBfdGhpczMucHJvcHMuZm9ybSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXN5bmNWYWxpZGF0ZTogdGhpcy5hc3luY1ZhbGlkYXRlLFxuICAgICAgICAgICAgZ2V0VmFsdWVzOiB0aGlzLmdldFZhbHVlcyxcbiAgICAgICAgICAgIHNlY3Rpb25QcmVmaXg6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHJlZ2lzdGVyOiB0aGlzLnJlZ2lzdGVyLFxuICAgICAgICAgICAgdW5yZWdpc3RlcjogdGhpcy51bnJlZ2lzdGVyLFxuICAgICAgICAgICAgcmVnaXN0ZXJJbm5lck9uU3VibWl0OiBmdW5jdGlvbiByZWdpc3RlcklubmVyT25TdWJtaXQoaW5uZXJPblN1Ym1pdCkge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMzLmlubmVyT25TdWJtaXQgPSBpbm5lck9uU3VibWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoUmVkdXhGb3JtQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICAgICAgdmFsdWU6IF9yZWR1eEZvcm0sXG4gICAgICAgICAgICBjaGlsZHJlbjogY3JlYXRlRWxlbWVudChXcmFwcGVkQ29tcG9uZW50LCBwcm9wc1RvUGFzcylcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gRm9ybTtcbiAgICAgIH0oUmVhY3QuQ29tcG9uZW50KTtcblxuICAgICAgRm9ybS5kaXNwbGF5TmFtZSA9IFwiRm9ybShcIiArIGdldERpc3BsYXlOYW1lKFdyYXBwZWRDb21wb25lbnQpICsgXCIpXCI7XG4gICAgICBGb3JtLldyYXBwZWRDb21wb25lbnQgPSBXcmFwcGVkQ29tcG9uZW50O1xuICAgICAgRm9ybS5wcm9wVHlwZXMgPSB7XG4gICAgICAgIGRlc3Ryb3lPblVubW91bnQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBmb3JjZVVucmVnaXN0ZXJPblVubW91bnQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBmb3JtOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgICAgIGltbXV0YWJsZVByb3BzOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc3RyaW5nKSxcbiAgICAgICAgaW5pdGlhbFZhbHVlczogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmFycmF5LCBQcm9wVHlwZXMub2JqZWN0XSksXG4gICAgICAgIGdldEZvcm1TdGF0ZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG9uU3VibWl0RmFpbDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG9uU3VibWl0U3VjY2VzczogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIHByb3BOYW1lc3BhY2U6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHZhbGlkYXRlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgd2FybjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIHRvdWNoT25CbHVyOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgdG91Y2hPbkNoYW5nZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIHRyaWdnZXJTdWJtaXQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBwZXJzaXN0ZW50U3VibWl0RXJyb3JzOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgcmVnaXN0ZXJlZEZpZWxkczogUHJvcFR5cGVzLmFueVxuICAgICAgfTtcbiAgICAgIHZhciBjb25uZWN0b3IgPSBjb25uZWN0KGZ1bmN0aW9uIChzdGF0ZSwgcHJvcHMpIHtcbiAgICAgICAgdmFyIGZvcm0gPSBwcm9wcy5mb3JtLFxuICAgICAgICAgICAgZ2V0Rm9ybVN0YXRlID0gcHJvcHMuZ2V0Rm9ybVN0YXRlLFxuICAgICAgICAgICAgaW5pdGlhbFZhbHVlcyA9IHByb3BzLmluaXRpYWxWYWx1ZXMsXG4gICAgICAgICAgICBlbmFibGVSZWluaXRpYWxpemUgPSBwcm9wcy5lbmFibGVSZWluaXRpYWxpemUsXG4gICAgICAgICAgICBrZWVwRGlydHlPblJlaW5pdGlhbGl6ZSA9IHByb3BzLmtlZXBEaXJ0eU9uUmVpbml0aWFsaXplO1xuICAgICAgICB2YXIgZm9ybVN0YXRlID0gZ2V0SW4oZ2V0Rm9ybVN0YXRlKHN0YXRlKSB8fCBlbXB0eSwgZm9ybSkgfHwgZW1wdHk7XG4gICAgICAgIHZhciBzdGF0ZUluaXRpYWwgPSBnZXRJbihmb3JtU3RhdGUsICdpbml0aWFsJyk7XG4gICAgICAgIHZhciBpbml0aWFsaXplZCA9ICEhc3RhdGVJbml0aWFsO1xuICAgICAgICB2YXIgc2hvdWxkVXBkYXRlSW5pdGlhbFZhbHVlcyA9IGVuYWJsZVJlaW5pdGlhbGl6ZSAmJiBpbml0aWFsaXplZCAmJiAhZGVlcEVxdWFsKGluaXRpYWxWYWx1ZXMsIHN0YXRlSW5pdGlhbCk7XG4gICAgICAgIHZhciBzaG91bGRSZXNldFZhbHVlcyA9IHNob3VsZFVwZGF0ZUluaXRpYWxWYWx1ZXMgJiYgIWtlZXBEaXJ0eU9uUmVpbml0aWFsaXplO1xuICAgICAgICB2YXIgaW5pdGlhbCA9IGluaXRpYWxWYWx1ZXMgfHwgc3RhdGVJbml0aWFsIHx8IGVtcHR5O1xuXG4gICAgICAgIGlmICghc2hvdWxkVXBkYXRlSW5pdGlhbFZhbHVlcykge1xuICAgICAgICAgIGluaXRpYWwgPSBzdGF0ZUluaXRpYWwgfHwgZW1wdHk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsdWVzID0gZ2V0SW4oZm9ybVN0YXRlLCAndmFsdWVzJykgfHwgaW5pdGlhbDtcblxuICAgICAgICBpZiAoc2hvdWxkUmVzZXRWYWx1ZXMpIHtcbiAgICAgICAgICB2YWx1ZXMgPSBpbml0aWFsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByaXN0aW5lID0gc2hvdWxkUmVzZXRWYWx1ZXMgfHwgZGVlcEVxdWFsKGluaXRpYWwsIHZhbHVlcyk7XG4gICAgICAgIHZhciBhc3luY0Vycm9ycyA9IGdldEluKGZvcm1TdGF0ZSwgJ2FzeW5jRXJyb3JzJyk7XG4gICAgICAgIHZhciBzeW5jRXJyb3JzID0gZ2V0SW4oZm9ybVN0YXRlLCAnc3luY0Vycm9ycycpIHx8IHBsYWluLmVtcHR5O1xuICAgICAgICB2YXIgc3luY1dhcm5pbmdzID0gZ2V0SW4oZm9ybVN0YXRlLCAnc3luY1dhcm5pbmdzJykgfHwgcGxhaW4uZW1wdHk7XG4gICAgICAgIHZhciByZWdpc3RlcmVkRmllbGRzID0gZ2V0SW4oZm9ybVN0YXRlLCAncmVnaXN0ZXJlZEZpZWxkcycpO1xuICAgICAgICB2YXIgdmFsaWQgPSBpc1ZhbGlkKGZvcm0sIGdldEZvcm1TdGF0ZSwgZmFsc2UpKHN0YXRlKTtcbiAgICAgICAgdmFyIHZhbGlkRXhjZXB0U3VibWl0ID0gaXNWYWxpZChmb3JtLCBnZXRGb3JtU3RhdGUsIHRydWUpKHN0YXRlKTtcbiAgICAgICAgdmFyIGFueVRvdWNoZWQgPSAhIWdldEluKGZvcm1TdGF0ZSwgJ2FueVRvdWNoZWQnKTtcbiAgICAgICAgdmFyIHN1Ym1pdHRpbmcgPSAhIWdldEluKGZvcm1TdGF0ZSwgJ3N1Ym1pdHRpbmcnKTtcbiAgICAgICAgdmFyIHN1Ym1pdEZhaWxlZCA9ICEhZ2V0SW4oZm9ybVN0YXRlLCAnc3VibWl0RmFpbGVkJyk7XG4gICAgICAgIHZhciBzdWJtaXRTdWNjZWVkZWQgPSAhIWdldEluKGZvcm1TdGF0ZSwgJ3N1Ym1pdFN1Y2NlZWRlZCcpO1xuICAgICAgICB2YXIgZXJyb3IgPSBnZXRJbihmb3JtU3RhdGUsICdlcnJvcicpO1xuICAgICAgICB2YXIgd2FybmluZyA9IGdldEluKGZvcm1TdGF0ZSwgJ3dhcm5pbmcnKTtcbiAgICAgICAgdmFyIHRyaWdnZXJTdWJtaXQgPSBnZXRJbihmb3JtU3RhdGUsICd0cmlnZ2VyU3VibWl0Jyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYW55VG91Y2hlZDogYW55VG91Y2hlZCxcbiAgICAgICAgICBhc3luY0Vycm9yczogYXN5bmNFcnJvcnMsXG4gICAgICAgICAgYXN5bmNWYWxpZGF0aW5nOiBnZXRJbihmb3JtU3RhdGUsICdhc3luY1ZhbGlkYXRpbmcnKSB8fCBmYWxzZSxcbiAgICAgICAgICBkaXJ0eTogIXByaXN0aW5lLFxuICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICBpbml0aWFsaXplZDogaW5pdGlhbGl6ZWQsXG4gICAgICAgICAgaW52YWxpZDogIXZhbGlkLFxuICAgICAgICAgIHByaXN0aW5lOiBwcmlzdGluZSxcbiAgICAgICAgICByZWdpc3RlcmVkRmllbGRzOiByZWdpc3RlcmVkRmllbGRzLFxuICAgICAgICAgIHN1Ym1pdHRpbmc6IHN1Ym1pdHRpbmcsXG4gICAgICAgICAgc3VibWl0RmFpbGVkOiBzdWJtaXRGYWlsZWQsXG4gICAgICAgICAgc3VibWl0U3VjY2VlZGVkOiBzdWJtaXRTdWNjZWVkZWQsXG4gICAgICAgICAgc3luY0Vycm9yczogc3luY0Vycm9ycyxcbiAgICAgICAgICBzeW5jV2FybmluZ3M6IHN5bmNXYXJuaW5ncyxcbiAgICAgICAgICB0cmlnZ2VyU3VibWl0OiB0cmlnZ2VyU3VibWl0LFxuICAgICAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgICAgIHZhbGlkOiB2YWxpZCxcbiAgICAgICAgICB2YWxpZEV4Y2VwdFN1Ym1pdDogdmFsaWRFeGNlcHRTdWJtaXQsXG4gICAgICAgICAgd2FybmluZzogd2FybmluZ1xuICAgICAgICB9O1xuICAgICAgfSwgZnVuY3Rpb24gKGRpc3BhdGNoLCBpbml0aWFsUHJvcHMpIHtcbiAgICAgICAgdmFyIGJpbmRGb3JtID0gZnVuY3Rpb24gYmluZEZvcm0oYWN0aW9uQ3JlYXRvcikge1xuICAgICAgICAgIHJldHVybiBhY3Rpb25DcmVhdG9yLmJpbmQobnVsbCwgaW5pdGlhbFByb3BzLmZvcm0pO1xuICAgICAgICB9OyAvLyBCaW5kIHRoZSBmaXJzdCBwYXJhbWV0ZXIgb24gYHByb3BzLmZvcm1gXG5cblxuICAgICAgICB2YXIgYm91bmRGb3JtQUNzID0gX21hcFZhbHVlcyhmb3JtQWN0aW9ucywgYmluZEZvcm0pO1xuXG4gICAgICAgIHZhciBib3VuZEFycmF5QUNzID0gX21hcFZhbHVlcyhhcnJheUFjdGlvbnMsIGJpbmRGb3JtKTtcblxuICAgICAgICB2YXIgYm91bmRCbHVyID0gZnVuY3Rpb24gYm91bmRCbHVyKGZpZWxkLCB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBibHVyKGluaXRpYWxQcm9wcy5mb3JtLCBmaWVsZCwgdmFsdWUsICEhaW5pdGlhbFByb3BzLnRvdWNoT25CbHVyKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYm91bmRDaGFuZ2UgPSBmdW5jdGlvbiBib3VuZENoYW5nZShmaWVsZCwgdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gY2hhbmdlKGluaXRpYWxQcm9wcy5mb3JtLCBmaWVsZCwgdmFsdWUsICEhaW5pdGlhbFByb3BzLnRvdWNoT25DaGFuZ2UsICEhaW5pdGlhbFByb3BzLnBlcnNpc3RlbnRTdWJtaXRFcnJvcnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBib3VuZEZvY3VzID0gYmluZEZvcm0oZm9jdXMpOyAvLyBXcmFwIGFjdGlvbiBjcmVhdG9ycyB3aXRoIGBkaXNwYXRjaGBcblxuICAgICAgICB2YXIgY29ubmVjdGVkRm9ybUFDcyA9IGJpbmRBY3Rpb25DcmVhdG9ycyhib3VuZEZvcm1BQ3MsIGRpc3BhdGNoKTtcbiAgICAgICAgdmFyIGNvbm5lY3RlZEFycmF5QUNzID0ge1xuICAgICAgICAgIGluc2VydDogYmluZEFjdGlvbkNyZWF0b3JzKGJvdW5kQXJyYXlBQ3MuYXJyYXlJbnNlcnQsIGRpc3BhdGNoKSxcbiAgICAgICAgICBtb3ZlOiBiaW5kQWN0aW9uQ3JlYXRvcnMoYm91bmRBcnJheUFDcy5hcnJheU1vdmUsIGRpc3BhdGNoKSxcbiAgICAgICAgICBwb3A6IGJpbmRBY3Rpb25DcmVhdG9ycyhib3VuZEFycmF5QUNzLmFycmF5UG9wLCBkaXNwYXRjaCksXG4gICAgICAgICAgcHVzaDogYmluZEFjdGlvbkNyZWF0b3JzKGJvdW5kQXJyYXlBQ3MuYXJyYXlQdXNoLCBkaXNwYXRjaCksXG4gICAgICAgICAgcmVtb3ZlOiBiaW5kQWN0aW9uQ3JlYXRvcnMoYm91bmRBcnJheUFDcy5hcnJheVJlbW92ZSwgZGlzcGF0Y2gpLFxuICAgICAgICAgIHJlbW92ZUFsbDogYmluZEFjdGlvbkNyZWF0b3JzKGJvdW5kQXJyYXlBQ3MuYXJyYXlSZW1vdmVBbGwsIGRpc3BhdGNoKSxcbiAgICAgICAgICBzaGlmdDogYmluZEFjdGlvbkNyZWF0b3JzKGJvdW5kQXJyYXlBQ3MuYXJyYXlTaGlmdCwgZGlzcGF0Y2gpLFxuICAgICAgICAgIHNwbGljZTogYmluZEFjdGlvbkNyZWF0b3JzKGJvdW5kQXJyYXlBQ3MuYXJyYXlTcGxpY2UsIGRpc3BhdGNoKSxcbiAgICAgICAgICBzd2FwOiBiaW5kQWN0aW9uQ3JlYXRvcnMoYm91bmRBcnJheUFDcy5hcnJheVN3YXAsIGRpc3BhdGNoKSxcbiAgICAgICAgICB1bnNoaWZ0OiBiaW5kQWN0aW9uQ3JlYXRvcnMoYm91bmRBcnJheUFDcy5hcnJheVVuc2hpZnQsIGRpc3BhdGNoKVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjb21wdXRlZEFjdGlvbnMgPSBfZXh0ZW5kcyh7fSwgY29ubmVjdGVkRm9ybUFDcywgYm91bmRBcnJheUFDcywge1xuICAgICAgICAgIGJsdXI6IGJvdW5kQmx1cixcbiAgICAgICAgICBjaGFuZ2U6IGJvdW5kQ2hhbmdlLFxuICAgICAgICAgIGFycmF5OiBjb25uZWN0ZWRBcnJheUFDcyxcbiAgICAgICAgICBmb2N1czogYm91bmRGb2N1cyxcbiAgICAgICAgICBkaXNwYXRjaDogZGlzcGF0Y2hcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29tcHV0ZWRBY3Rpb25zO1xuICAgICAgICB9O1xuICAgICAgfSwgdW5kZWZpbmVkLCB7XG4gICAgICAgIGZvcndhcmRSZWY6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdmFyIENvbm5lY3RlZEZvcm0gPSBob2lzdFN0YXRpY3MoY29ubmVjdG9yKEZvcm0pLCBXcmFwcGVkQ29tcG9uZW50KTtcbiAgICAgIENvbm5lY3RlZEZvcm0uZGVmYXVsdFByb3BzID0gY29uZmlnOyAvLyBidWlsZCBvdXRlciBjb21wb25lbnQgdG8gZXhwb3NlIGluc3RhbmNlIGFwaVxuXG4gICAgICB2YXIgUmVkdXhGb3JtID1cbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50Mikge1xuICAgICAgICBfaW5oZXJpdHNMb29zZShSZWR1eEZvcm0sIF9SZWFjdCRDb21wb25lbnQyKTtcblxuICAgICAgICBmdW5jdGlvbiBSZWR1eEZvcm0oKSB7XG4gICAgICAgICAgdmFyIF90aGlzNDtcblxuICAgICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzNCA9IF9SZWFjdCRDb21wb25lbnQyLmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudDIsIFt0aGlzXS5jb25jYXQoYXJncykpIHx8IHRoaXM7XG4gICAgICAgICAgX3RoaXM0LnJlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICAgIHJldHVybiBfdGhpczQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3Byb3RvMiA9IFJlZHV4Rm9ybS5wcm90b3R5cGU7XG5cbiAgICAgICAgX3Byb3RvMi5zdWJtaXQgPSBmdW5jdGlvbiBzdWJtaXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVmLmN1cnJlbnQgJiYgdGhpcy5yZWYuY3VycmVudC5zdWJtaXQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBfcHJvdG8yLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgICAgaWYgKHRoaXMucmVmKSB7XG4gICAgICAgICAgICB0aGlzLnJlZi5jdXJyZW50LnJlc2V0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIF9wcm90bzIucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICAgIHZhciBfdGhpcyRwcm9wczEzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgaW5pdGlhbFZhbHVlcyA9IF90aGlzJHByb3BzMTMuaW5pdGlhbFZhbHVlcyxcbiAgICAgICAgICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF90aGlzJHByb3BzMTMsIFtcImluaXRpYWxWYWx1ZXNcIl0pO1xuXG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoQ29ubmVjdGVkRm9ybSwgX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICAgICAgICAgIHJlZjogdGhpcy5yZWYsXG4gICAgICAgICAgICAvLyBjb252ZXJ0IGluaXRpYWxWYWx1ZXMgaWYgbmVlZCB0b1xuICAgICAgICAgICAgaW5pdGlhbFZhbHVlczogZnJvbUpTKGluaXRpYWxWYWx1ZXMpXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIF9jcmVhdGVDbGFzcyhSZWR1eEZvcm0sIFt7XG4gICAgICAgICAga2V5OiBcInZhbGlkXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gISEodGhpcy5yZWYuY3VycmVudCAmJiB0aGlzLnJlZi5jdXJyZW50LmlzVmFsaWQoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImludmFsaWRcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy52YWxpZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwicHJpc3RpbmVcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiAhISh0aGlzLnJlZi5jdXJyZW50ICYmIHRoaXMucmVmLmN1cnJlbnQuaXNQcmlzdGluZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiZGlydHlcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5wcmlzdGluZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwidmFsdWVzXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWYuY3VycmVudCA/IHRoaXMucmVmLmN1cnJlbnQuZ2V0VmFsdWVzKCkgOiBlbXB0eTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiZmllbGRMaXN0XCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAvLyBtYWlubHkgcHJvdmlkZWQgZm9yIHRlc3RpbmdcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZi5jdXJyZW50ID8gdGhpcy5yZWYuY3VycmVudC5nZXRGaWVsZExpc3QoKSA6IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJ3cmFwcGVkSW5zdGFuY2VcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIC8vIGZvciB0ZXN0aW5nXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWYuY3VycmVudCAmJiB0aGlzLnJlZi5jdXJyZW50LndyYXBwZWQuY3VycmVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1dKTtcblxuICAgICAgICByZXR1cm4gUmVkdXhGb3JtO1xuICAgICAgfShSZWFjdC5Db21wb25lbnQpO1xuXG4gICAgICBwb2x5ZmlsbChSZWR1eEZvcm0pO1xuICAgICAgdmFyIFdpdGhDb250ZXh0ID0gaG9pc3RTdGF0aWNzKHdpdGhSZWR1eEZvcm0oUmVkdXhGb3JtKSwgV3JhcHBlZENvbXBvbmVudCk7XG4gICAgICBXaXRoQ29udGV4dC5kZWZhdWx0UHJvcHMgPSBjb25maWc7XG4gICAgICByZXR1cm4gV2l0aENvbnRleHQ7XG4gICAgfTtcbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVJlZHV4Rm9ybTsiLCJpbXBvcnQgY3JlYXRlUmVkdXhGb3JtIGZyb20gJy4vY3JlYXRlUmVkdXhGb3JtJztcbmltcG9ydCBwbGFpbiBmcm9tICcuL3N0cnVjdHVyZS9wbGFpbic7XG5leHBvcnQgZGVmYXVsdCBjcmVhdGVSZWR1eEZvcm0ocGxhaW4pOyIsImltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlXCI7XG5pbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXh0ZW5kc1wiO1xuXG52YXIgcHJvY2Vzc1Byb3BzID0gZnVuY3Rpb24gcHJvY2Vzc1Byb3BzKHR5cGUsIHByb3BzLCBfdmFsdWUsIGRlZXBFcXVhbCkge1xuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcblxuICBpZiAodHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgIGNoZWNrZWQ6ICEhdmFsdWVcbiAgICB9KTtcbiAgfVxuXG4gIGlmICh0eXBlID09PSAncmFkaW8nKSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgY2hlY2tlZDogZGVlcEVxdWFsKHZhbHVlLCBfdmFsdWUpLFxuICAgICAgdmFsdWU6IF92YWx1ZVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHR5cGUgPT09ICdzZWxlY3QtbXVsdGlwbGUnKSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgdmFsdWU6IHZhbHVlIHx8IFtdXG4gICAgfSk7XG4gIH1cblxuICBpZiAodHlwZSA9PT0gJ2ZpbGUnKSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgdmFsdWU6IHZhbHVlIHx8IHVuZGVmaW5lZFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHByb3BzO1xufTtcblxudmFyIGNyZWF0ZUZpZWxkUHJvcHMgPSBmdW5jdGlvbiBjcmVhdGVGaWVsZFByb3BzKF9yZWYsIG5hbWUsIF9yZWYyKSB7XG4gIHZhciBnZXRJbiA9IF9yZWYuZ2V0SW4sXG4gICAgICB0b0pTID0gX3JlZi50b0pTLFxuICAgICAgZGVlcEVxdWFsID0gX3JlZi5kZWVwRXF1YWw7XG5cbiAgdmFyIGFzeW5jRXJyb3IgPSBfcmVmMi5hc3luY0Vycm9yLFxuICAgICAgYXN5bmNWYWxpZGF0aW5nID0gX3JlZjIuYXN5bmNWYWxpZGF0aW5nLFxuICAgICAgb25CbHVyID0gX3JlZjIub25CbHVyLFxuICAgICAgb25DaGFuZ2UgPSBfcmVmMi5vbkNoYW5nZSxcbiAgICAgIG9uRHJvcCA9IF9yZWYyLm9uRHJvcCxcbiAgICAgIG9uRHJhZ1N0YXJ0ID0gX3JlZjIub25EcmFnU3RhcnQsXG4gICAgICBkaXJ0eSA9IF9yZWYyLmRpcnR5LFxuICAgICAgZGlzcGF0Y2ggPSBfcmVmMi5kaXNwYXRjaCxcbiAgICAgIG9uRm9jdXMgPSBfcmVmMi5vbkZvY3VzLFxuICAgICAgZm9ybSA9IF9yZWYyLmZvcm0sXG4gICAgICBmb3JtYXQgPSBfcmVmMi5mb3JtYXQsXG4gICAgICBpbml0aWFsID0gX3JlZjIuaW5pdGlhbCxcbiAgICAgIHBhcnNlID0gX3JlZjIucGFyc2UsXG4gICAgICBwcmlzdGluZSA9IF9yZWYyLnByaXN0aW5lLFxuICAgICAgcHJvcHMgPSBfcmVmMi5wcm9wcyxcbiAgICAgIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICBzdWJtaXRFcnJvciA9IF9yZWYyLnN1Ym1pdEVycm9yLFxuICAgICAgc3VibWl0RmFpbGVkID0gX3JlZjIuc3VibWl0RmFpbGVkLFxuICAgICAgc3VibWl0dGluZyA9IF9yZWYyLnN1Ym1pdHRpbmcsXG4gICAgICBzeW5jRXJyb3IgPSBfcmVmMi5zeW5jRXJyb3IsXG4gICAgICBzeW5jV2FybmluZyA9IF9yZWYyLnN5bmNXYXJuaW5nLFxuICAgICAgdmFsaWRhdGUgPSBfcmVmMi52YWxpZGF0ZSxcbiAgICAgIHZhbHVlID0gX3JlZjIudmFsdWUsXG4gICAgICBfdmFsdWUgPSBfcmVmMi5fdmFsdWUsXG4gICAgICB3YXJuID0gX3JlZjIud2FybixcbiAgICAgIGN1c3RvbSA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYyLCBbXCJhc3luY0Vycm9yXCIsIFwiYXN5bmNWYWxpZGF0aW5nXCIsIFwib25CbHVyXCIsIFwib25DaGFuZ2VcIiwgXCJvbkRyb3BcIiwgXCJvbkRyYWdTdGFydFwiLCBcImRpcnR5XCIsIFwiZGlzcGF0Y2hcIiwgXCJvbkZvY3VzXCIsIFwiZm9ybVwiLCBcImZvcm1hdFwiLCBcImluaXRpYWxcIiwgXCJwYXJzZVwiLCBcInByaXN0aW5lXCIsIFwicHJvcHNcIiwgXCJzdGF0ZVwiLCBcInN1Ym1pdEVycm9yXCIsIFwic3VibWl0RmFpbGVkXCIsIFwic3VibWl0dGluZ1wiLCBcInN5bmNFcnJvclwiLCBcInN5bmNXYXJuaW5nXCIsIFwidmFsaWRhdGVcIiwgXCJ2YWx1ZVwiLCBcIl92YWx1ZVwiLCBcIndhcm5cIl0pO1xuXG4gIHZhciBlcnJvciA9IHN5bmNFcnJvciB8fCBhc3luY0Vycm9yIHx8IHN1Ym1pdEVycm9yO1xuICB2YXIgd2FybmluZyA9IHN5bmNXYXJuaW5nO1xuXG4gIHZhciBmb3JtYXRGaWVsZFZhbHVlID0gZnVuY3Rpb24gZm9ybWF0RmllbGRWYWx1ZSh2YWx1ZSwgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0Rm9ybWF0dGVkVmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcbiAgICByZXR1cm4gZm9ybWF0ID8gZm9ybWF0KHZhbHVlLCBuYW1lKSA6IGRlZmF1bHRGb3JtYXR0ZWRWYWx1ZTtcbiAgfTtcblxuICB2YXIgZm9ybWF0dGVkRmllbGRWYWx1ZSA9IGZvcm1hdEZpZWxkVmFsdWUodmFsdWUsIGZvcm1hdCk7XG4gIHJldHVybiB7XG4gICAgaW5wdXQ6IHByb2Nlc3NQcm9wcyhjdXN0b20udHlwZSwge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIG9uQmx1cjogb25CbHVyLFxuICAgICAgb25DaGFuZ2U6IG9uQ2hhbmdlLFxuICAgICAgb25EcmFnU3RhcnQ6IG9uRHJhZ1N0YXJ0LFxuICAgICAgb25Ecm9wOiBvbkRyb3AsXG4gICAgICBvbkZvY3VzOiBvbkZvY3VzLFxuICAgICAgdmFsdWU6IGZvcm1hdHRlZEZpZWxkVmFsdWVcbiAgICB9LCBfdmFsdWUsIGRlZXBFcXVhbCksXG4gICAgbWV0YTogX2V4dGVuZHMoe30sIHRvSlMoc3RhdGUpLCB7XG4gICAgICBhY3RpdmU6ICEhKHN0YXRlICYmIGdldEluKHN0YXRlLCAnYWN0aXZlJykpLFxuICAgICAgYXN5bmNWYWxpZGF0aW5nOiBhc3luY1ZhbGlkYXRpbmcsXG4gICAgICBhdXRvZmlsbGVkOiAhIShzdGF0ZSAmJiBnZXRJbihzdGF0ZSwgJ2F1dG9maWxsZWQnKSksXG4gICAgICBkaXJ0eTogZGlydHksXG4gICAgICBkaXNwYXRjaDogZGlzcGF0Y2gsXG4gICAgICBlcnJvcjogZXJyb3IsXG4gICAgICBmb3JtOiBmb3JtLFxuICAgICAgaW5pdGlhbDogaW5pdGlhbCxcbiAgICAgIHdhcm5pbmc6IHdhcm5pbmcsXG4gICAgICBpbnZhbGlkOiAhIWVycm9yLFxuICAgICAgcHJpc3RpbmU6IHByaXN0aW5lLFxuICAgICAgc3VibWl0dGluZzogISFzdWJtaXR0aW5nLFxuICAgICAgc3VibWl0RmFpbGVkOiAhIXN1Ym1pdEZhaWxlZCxcbiAgICAgIHRvdWNoZWQ6ICEhKHN0YXRlICYmIGdldEluKHN0YXRlLCAndG91Y2hlZCcpKSxcbiAgICAgIHZhbGlkOiAhZXJyb3IsXG4gICAgICB2aXNpdGVkOiAhIShzdGF0ZSAmJiBnZXRJbihzdGF0ZSwgJ3Zpc2l0ZWQnKSlcbiAgICB9KSxcbiAgICBjdXN0b206IF9leHRlbmRzKHt9LCBjdXN0b20sIHByb3BzKVxuICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlRmllbGRQcm9wczsiLCJpbXBvcnQgaXNFdmVudCBmcm9tICcuL2lzRXZlbnQnO1xuXG52YXIgZ2V0U2VsZWN0ZWRWYWx1ZXMgPSBmdW5jdGlvbiBnZXRTZWxlY3RlZFZhbHVlcyhvcHRpb25zKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBvcHRpb25zLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIG9wdGlvbiA9IG9wdGlvbnNbaW5kZXhdO1xuXG4gICAgICBpZiAob3B0aW9uLnNlbGVjdGVkKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG9wdGlvbi52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBnZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlKGV2ZW50LCBpc1JlYWN0TmF0aXZlKSB7XG4gIGlmIChpc0V2ZW50KGV2ZW50KSkge1xuICAgIGlmICghaXNSZWFjdE5hdGl2ZSAmJiBldmVudC5uYXRpdmVFdmVudCAmJiBldmVudC5uYXRpdmVFdmVudC50ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmVudC5uYXRpdmVFdmVudC50ZXh0O1xuICAgIH1cblxuICAgIGlmIChpc1JlYWN0TmF0aXZlICYmIGV2ZW50Lm5hdGl2ZUV2ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmVudC5uYXRpdmVFdmVudC50ZXh0O1xuICAgIH1cblxuICAgIHZhciBkZXR5cGVkRXZlbnQgPSBldmVudDtcbiAgICB2YXIgX2RldHlwZWRFdmVudCR0YXJnZXQgPSBkZXR5cGVkRXZlbnQudGFyZ2V0LFxuICAgICAgICB0eXBlID0gX2RldHlwZWRFdmVudCR0YXJnZXQudHlwZSxcbiAgICAgICAgdmFsdWUgPSBfZGV0eXBlZEV2ZW50JHRhcmdldC52YWx1ZSxcbiAgICAgICAgY2hlY2tlZCA9IF9kZXR5cGVkRXZlbnQkdGFyZ2V0LmNoZWNrZWQsXG4gICAgICAgIGZpbGVzID0gX2RldHlwZWRFdmVudCR0YXJnZXQuZmlsZXMsXG4gICAgICAgIGRhdGFUcmFuc2ZlciA9IGRldHlwZWRFdmVudC5kYXRhVHJhbnNmZXI7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuICAgICAgcmV0dXJuICEhY2hlY2tlZDtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICByZXR1cm4gZmlsZXMgfHwgZGF0YVRyYW5zZmVyICYmIGRhdGFUcmFuc2Zlci5maWxlcztcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ3NlbGVjdC1tdWx0aXBsZScpIHtcbiAgICAgIHJldHVybiBnZXRTZWxlY3RlZFZhbHVlcyhldmVudC50YXJnZXQub3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIGV2ZW50O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZ2V0VmFsdWU7IiwidmFyIGlzUmVhY3ROYXRpdmUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubmF2aWdhdG9yICYmIHdpbmRvdy5uYXZpZ2F0b3IucHJvZHVjdCAmJiB3aW5kb3cubmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZSc7XG5leHBvcnQgZGVmYXVsdCBpc1JlYWN0TmF0aXZlOyIsImltcG9ydCBnZXRWYWx1ZSBmcm9tICcuL2dldFZhbHVlJztcbmltcG9ydCBpc1JlYWN0TmF0aXZlIGZyb20gJy4uL2lzUmVhY3ROYXRpdmUnO1xuXG52YXIgb25DaGFuZ2VWYWx1ZSA9IGZ1bmN0aW9uIG9uQ2hhbmdlVmFsdWUoZXZlbnQsIF9yZWYpIHtcbiAgdmFyIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICBwYXJzZSA9IF9yZWYucGFyc2UsXG4gICAgICBub3JtYWxpemUgPSBfcmVmLm5vcm1hbGl6ZTtcbiAgLy8gcmVhZCB2YWx1ZSBmcm9tIGlucHV0XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKGV2ZW50LCBpc1JlYWN0TmF0aXZlKTsgLy8gcGFyc2UgdmFsdWUgaWYgd2UgaGF2ZSBhIHBhcnNlclxuXG4gIGlmIChwYXJzZSkge1xuICAgIHZhbHVlID0gcGFyc2UodmFsdWUsIG5hbWUpO1xuICB9IC8vIG5vcm1hbGl6ZSB2YWx1ZVxuXG5cbiAgaWYgKG5vcm1hbGl6ZSkge1xuICAgIHZhbHVlID0gbm9ybWFsaXplKG5hbWUsIHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG9uQ2hhbmdlVmFsdWU7IiwiZXhwb3J0IHZhciBkYXRhS2V5ID0gJ3RleHQnOyIsImltcG9ydCB7IGlzVmFsaWRFbGVtZW50VHlwZSB9IGZyb20gJ3JlYWN0LWlzJztcblxudmFyIHZhbGlkYXRlQ29tcG9uZW50UHJvcCA9IGZ1bmN0aW9uIHZhbGlkYXRlQ29tcG9uZW50UHJvcChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgcHJvcCBgJyArIHByb3BOYW1lICsgJ2Agc3VwcGxpZWQgdG8nICsgJyBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdmFsaWRhdGVDb21wb25lbnRQcm9wOyIsImltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlXCI7XG5pbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXh0ZW5kc1wiO1xuaW1wb3J0IF9pbmhlcml0c0xvb3NlIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzTG9vc2VcIjtcbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIGNyZWF0ZUVsZW1lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgY29ubmVjdCB9IGZyb20gJ3JlYWN0LXJlZHV4JztcbmltcG9ydCBjcmVhdGVGaWVsZFByb3BzIGZyb20gJy4vY3JlYXRlRmllbGRQcm9wcyc7XG5pbXBvcnQgb25DaGFuZ2VWYWx1ZSBmcm9tICcuL2V2ZW50cy9vbkNoYW5nZVZhbHVlJztcbmltcG9ydCB7IGRhdGFLZXkgfSBmcm9tICcuL3V0aWwvZXZlbnRDb25zdHMnO1xuaW1wb3J0IHBsYWluIGZyb20gJy4vc3RydWN0dXJlL3BsYWluJztcbmltcG9ydCBpc1JlYWN0TmF0aXZlIGZyb20gJy4vaXNSZWFjdE5hdGl2ZSc7XG5pbXBvcnQgdmFsaWRhdGVDb21wb25lbnRQcm9wIGZyb20gJy4vdXRpbC92YWxpZGF0ZUNvbXBvbmVudFByb3AnO1xuaW1wb3J0IGlzRXZlbnQgZnJvbSAnLi9ldmVudHMvaXNFdmVudCc7XG52YXIgcHJvcHNUb05vdFVwZGF0ZUZvciA9IFsnX3JlZHV4Rm9ybSddO1xuXG52YXIgaXNPYmplY3QgPSBmdW5jdGlvbiBpc09iamVjdChlbnRpdHkpIHtcbiAgcmV0dXJuIGVudGl0eSAmJiB0eXBlb2YgZW50aXR5ID09PSAnb2JqZWN0Jztcbn07XG5cbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbihlbnRpdHkpIHtcbiAgcmV0dXJuIGVudGl0eSAmJiB0eXBlb2YgZW50aXR5ID09PSAnZnVuY3Rpb24nO1xufTtcblxudmFyIGV2ZW50UHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiBldmVudFByZXZlbnREZWZhdWx0KGV2ZW50KSB7XG4gIGlmIChpc09iamVjdChldmVudCkgJiYgaXNGdW5jdGlvbihldmVudC5wcmV2ZW50RGVmYXVsdCkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG59O1xuXG52YXIgZXZlbnREYXRhVHJhbnNmZXJHZXREYXRhID0gZnVuY3Rpb24gZXZlbnREYXRhVHJhbnNmZXJHZXREYXRhKGV2ZW50LCBrZXkpIHtcbiAgaWYgKGlzT2JqZWN0KGV2ZW50KSAmJiBpc09iamVjdChldmVudC5kYXRhVHJhbnNmZXIpICYmIGlzRnVuY3Rpb24oZXZlbnQuZGF0YVRyYW5zZmVyLmdldERhdGEpKSB7XG4gICAgcmV0dXJuIGV2ZW50LmRhdGFUcmFuc2Zlci5nZXREYXRhKGtleSk7XG4gIH1cbn07XG5cbnZhciBldmVudERhdGFUcmFuc2ZlclNldERhdGEgPSBmdW5jdGlvbiBldmVudERhdGFUcmFuc2ZlclNldERhdGEoZXZlbnQsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGlzT2JqZWN0KGV2ZW50KSAmJiBpc09iamVjdChldmVudC5kYXRhVHJhbnNmZXIpICYmIGlzRnVuY3Rpb24oZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEpKSB7XG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoa2V5LCB2YWx1ZSk7XG4gIH1cbn07XG5cbnZhciBjcmVhdGVDb25uZWN0ZWRGaWVsZCA9IGZ1bmN0aW9uIGNyZWF0ZUNvbm5lY3RlZEZpZWxkKHN0cnVjdHVyZSkge1xuICB2YXIgZGVlcEVxdWFsID0gc3RydWN0dXJlLmRlZXBFcXVhbCxcbiAgICAgIGdldEluID0gc3RydWN0dXJlLmdldEluO1xuXG4gIHZhciBnZXRTeW5jRXJyb3IgPSBmdW5jdGlvbiBnZXRTeW5jRXJyb3Ioc3luY0Vycm9ycywgbmFtZSkge1xuICAgIHZhciBlcnJvciA9IHBsYWluLmdldEluKHN5bmNFcnJvcnMsIG5hbWUpOyAvLyBCZWNhdXNlIHRoZSBlcnJvciBmb3IgdGhpcyBmaWVsZCBtaWdodCBub3QgYmUgYXQgYSBsZXZlbCBpbiB0aGUgZXJyb3Igc3RydWN0dXJlIHdoZXJlXG4gICAgLy8gaXQgY2FuIGJlIHNldCBkaXJlY3RseSwgaXQgbWlnaHQgbmVlZCB0byBiZSB1bndyYXBwZWQgZnJvbSB0aGUgX2Vycm9yIHByb3BlcnR5XG5cbiAgICByZXR1cm4gZXJyb3IgJiYgZXJyb3IuX2Vycm9yID8gZXJyb3IuX2Vycm9yIDogZXJyb3I7XG4gIH07XG5cbiAgdmFyIGdldFN5bmNXYXJuaW5nID0gZnVuY3Rpb24gZ2V0U3luY1dhcm5pbmcoc3luY1dhcm5pbmdzLCBuYW1lKSB7XG4gICAgdmFyIHdhcm5pbmcgPSBnZXRJbihzeW5jV2FybmluZ3MsIG5hbWUpOyAvLyBCZWNhdXNlIHRoZSB3YXJuaW5nIGZvciB0aGlzIGZpZWxkIG1pZ2h0IG5vdCBiZSBhdCBhIGxldmVsIGluIHRoZSB3YXJuaW5nIHN0cnVjdHVyZSB3aGVyZVxuICAgIC8vIGl0IGNhbiBiZSBzZXQgZGlyZWN0bHksIGl0IG1pZ2h0IG5lZWQgdG8gYmUgdW53cmFwcGVkIGZyb20gdGhlIF93YXJuaW5nIHByb3BlcnR5XG5cbiAgICByZXR1cm4gd2FybmluZyAmJiB3YXJuaW5nLl93YXJuaW5nID8gd2FybmluZy5fd2FybmluZyA6IHdhcm5pbmc7XG4gIH07XG5cbiAgdmFyIENvbm5lY3RlZEZpZWxkID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICAgIF9pbmhlcml0c0xvb3NlKENvbm5lY3RlZEZpZWxkLCBfQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIENvbm5lY3RlZEZpZWxkKCkge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMgPSBfQ29tcG9uZW50LmNhbGwuYXBwbHkoX0NvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkgfHwgdGhpcztcbiAgICAgIF90aGlzLnJlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuXG4gICAgICBfdGhpcy5pc1ByaXN0aW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMucHJvcHMucHJpc3RpbmU7XG4gICAgICB9O1xuXG4gICAgICBfdGhpcy5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnByb3BzLnZhbHVlO1xuICAgICAgfTtcblxuICAgICAgX3RoaXMuaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyRwcm9wcyA9IF90aGlzLnByb3BzLFxuICAgICAgICAgICAgbmFtZSA9IF90aGlzJHByb3BzLm5hbWUsXG4gICAgICAgICAgICBkaXNwYXRjaCA9IF90aGlzJHByb3BzLmRpc3BhdGNoLFxuICAgICAgICAgICAgcGFyc2UgPSBfdGhpcyRwcm9wcy5wYXJzZSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZSA9IF90aGlzJHByb3BzLm5vcm1hbGl6ZSxcbiAgICAgICAgICAgIG9uQ2hhbmdlID0gX3RoaXMkcHJvcHMub25DaGFuZ2UsXG4gICAgICAgICAgICBfcmVkdXhGb3JtID0gX3RoaXMkcHJvcHMuX3JlZHV4Rm9ybSxcbiAgICAgICAgICAgIHByZXZpb3VzVmFsdWUgPSBfdGhpcyRwcm9wcy52YWx1ZTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gb25DaGFuZ2VWYWx1ZShldmVudCwge1xuICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgcGFyc2U6IHBhcnNlLFxuICAgICAgICAgIG5vcm1hbGl6ZTogbm9ybWFsaXplXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChvbkNoYW5nZSkge1xuICAgICAgICAgIC8vIENhbid0IHNlZW0gdG8gZmluZCBhIHdheSB0byBleHRlbmQgRXZlbnQgaW4gUmVhY3QgTmF0aXZlLFxuICAgICAgICAgIC8vIHRodXMgSSBzaW1wbHkgYXZvaWQgYWRkaW5nIHByZXZlbnREZWZhdWx0KCkgaW4gYSBSTiBlbnZpcm9ubWVudFxuICAgICAgICAgIC8vIHRvIHByZXZlbnQgdGhlIGZvbGxvd2luZyBlcnJvcjpcbiAgICAgICAgICAvLyBgT25lIG9mIHRoZSBzb3VyY2VzIGZvciBhc3NpZ24gaGFzIGFuIGVudW1lcmFibGUga2V5IG9uIHRoZSBwcm90b3R5cGUgY2hhaW5gXG4gICAgICAgICAgLy8gUmVmZXJlbmNlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL2lzc3Vlcy81NTA3XG4gICAgICAgICAgaWYgKCFpc1JlYWN0TmF0aXZlICYmIGlzRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgICAgICBvbkNoYW5nZShfZXh0ZW5kcyh7fSwgZXZlbnQsIHtcbiAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBldmVudFByZXZlbnREZWZhdWx0KGV2ZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksIG5ld1ZhbHVlLCBwcmV2aW91c1ZhbHVlLCBuYW1lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVmYXVsdFByZXZlbnRlZCA9IG9uQ2hhbmdlKGV2ZW50LCBuZXdWYWx1ZSwgcHJldmlvdXNWYWx1ZSwgbmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgLy8gZGlzcGF0Y2ggY2hhbmdlIGFjdGlvblxuICAgICAgICAgIGRpc3BhdGNoKF9yZWR1eEZvcm0uY2hhbmdlKG5hbWUsIG5ld1ZhbHVlKSk7IC8vIGNhbGwgcG9zdC1jaGFuZ2UgY2FsbGJhY2tcblxuICAgICAgICAgIGlmIChfcmVkdXhGb3JtLmFzeW5jVmFsaWRhdGUpIHtcbiAgICAgICAgICAgIF9yZWR1eEZvcm0uYXN5bmNWYWxpZGF0ZShuYW1lLCBuZXdWYWx1ZSwgJ2NoYW5nZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgX3RoaXMuaGFuZGxlRm9jdXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzJHByb3BzMiA9IF90aGlzLnByb3BzLFxuICAgICAgICAgICAgbmFtZSA9IF90aGlzJHByb3BzMi5uYW1lLFxuICAgICAgICAgICAgZGlzcGF0Y2ggPSBfdGhpcyRwcm9wczIuZGlzcGF0Y2gsXG4gICAgICAgICAgICBvbkZvY3VzID0gX3RoaXMkcHJvcHMyLm9uRm9jdXMsXG4gICAgICAgICAgICBfcmVkdXhGb3JtID0gX3RoaXMkcHJvcHMyLl9yZWR1eEZvcm07XG4gICAgICAgIHZhciBkZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKG9uRm9jdXMpIHtcbiAgICAgICAgICBpZiAoIWlzUmVhY3ROYXRpdmUpIHtcbiAgICAgICAgICAgIG9uRm9jdXMoX2V4dGVuZHMoe30sIGV2ZW50LCB7XG4gICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnRQcmV2ZW50RGVmYXVsdChldmVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLCBuYW1lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVmYXVsdFByZXZlbnRlZCA9IG9uRm9jdXMoZXZlbnQsIG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgIGRpc3BhdGNoKF9yZWR1eEZvcm0uZm9jdXMobmFtZSkpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBfdGhpcy5oYW5kbGVCbHVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyRwcm9wczMgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIG5hbWUgPSBfdGhpcyRwcm9wczMubmFtZSxcbiAgICAgICAgICAgIGRpc3BhdGNoID0gX3RoaXMkcHJvcHMzLmRpc3BhdGNoLFxuICAgICAgICAgICAgcGFyc2UgPSBfdGhpcyRwcm9wczMucGFyc2UsXG4gICAgICAgICAgICBub3JtYWxpemUgPSBfdGhpcyRwcm9wczMubm9ybWFsaXplLFxuICAgICAgICAgICAgb25CbHVyID0gX3RoaXMkcHJvcHMzLm9uQmx1cixcbiAgICAgICAgICAgIF9yZWR1eEZvcm0gPSBfdGhpcyRwcm9wczMuX3JlZHV4Rm9ybSxcbiAgICAgICAgICAgIF92YWx1ZSA9IF90aGlzJHByb3BzMy5fdmFsdWUsXG4gICAgICAgICAgICBwcmV2aW91c1ZhbHVlID0gX3RoaXMkcHJvcHMzLnZhbHVlO1xuICAgICAgICB2YXIgbmV3VmFsdWUgPSBvbkNoYW5nZVZhbHVlKGV2ZW50LCB7XG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICBwYXJzZTogcGFyc2UsXG4gICAgICAgICAgbm9ybWFsaXplOiBub3JtYWxpemVcbiAgICAgICAgfSk7IC8vIGZvciBjaGVja2JveCBhbmQgcmFkaW8sIGlmIHRoZSB2YWx1ZSBwcm9wZXJ0eSBvZiBjaGVja2JveCBvciByYWRpbyBlcXVhbHNcbiAgICAgICAgLy8gdGhlIHZhbHVlIHBhc3NlZCBieSBibHVyIGV2ZW50LCB0aGVuIGZpcmUgYmx1ciBhY3Rpb24gd2l0aCBwcmV2aW91c1ZhbHVlLlxuXG4gICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gX3ZhbHVlICYmIF92YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbmV3VmFsdWUgPSBwcmV2aW91c1ZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAob25CbHVyKSB7XG4gICAgICAgICAgaWYgKCFpc1JlYWN0TmF0aXZlKSB7XG4gICAgICAgICAgICBvbkJsdXIoX2V4dGVuZHMoe30sIGV2ZW50LCB7XG4gICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnRQcmV2ZW50RGVmYXVsdChldmVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLCBuZXdWYWx1ZSwgcHJldmlvdXNWYWx1ZSwgbmFtZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlZmF1bHRQcmV2ZW50ZWQgPSBvbkJsdXIoZXZlbnQsIG5ld1ZhbHVlLCBwcmV2aW91c1ZhbHVlLCBuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAvLyBkaXNwYXRjaCBibHVyIGFjdGlvblxuICAgICAgICAgIGRpc3BhdGNoKF9yZWR1eEZvcm0uYmx1cihuYW1lLCBuZXdWYWx1ZSkpOyAvLyBjYWxsIHBvc3QtYmx1ciBjYWxsYmFja1xuXG4gICAgICAgICAgaWYgKF9yZWR1eEZvcm0uYXN5bmNWYWxpZGF0ZSkge1xuICAgICAgICAgICAgX3JlZHV4Rm9ybS5hc3luY1ZhbGlkYXRlKG5hbWUsIG5ld1ZhbHVlLCAnYmx1cicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgX3RoaXMuaGFuZGxlRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyRwcm9wczQgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIG5hbWUgPSBfdGhpcyRwcm9wczQubmFtZSxcbiAgICAgICAgICAgIG9uRHJhZ1N0YXJ0ID0gX3RoaXMkcHJvcHM0Lm9uRHJhZ1N0YXJ0LFxuICAgICAgICAgICAgdmFsdWUgPSBfdGhpcyRwcm9wczQudmFsdWU7XG4gICAgICAgIGV2ZW50RGF0YVRyYW5zZmVyU2V0RGF0YShldmVudCwgZGF0YUtleSwgdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWUpO1xuXG4gICAgICAgIGlmIChvbkRyYWdTdGFydCkge1xuICAgICAgICAgIG9uRHJhZ1N0YXJ0KGV2ZW50LCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgX3RoaXMuaGFuZGxlRHJvcCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgX3RoaXMkcHJvcHM1ID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgICBuYW1lID0gX3RoaXMkcHJvcHM1Lm5hbWUsXG4gICAgICAgICAgICBkaXNwYXRjaCA9IF90aGlzJHByb3BzNS5kaXNwYXRjaCxcbiAgICAgICAgICAgIG9uRHJvcCA9IF90aGlzJHByb3BzNS5vbkRyb3AsXG4gICAgICAgICAgICBfcmVkdXhGb3JtID0gX3RoaXMkcHJvcHM1Ll9yZWR1eEZvcm0sXG4gICAgICAgICAgICBwcmV2aW91c1ZhbHVlID0gX3RoaXMkcHJvcHM1LnZhbHVlO1xuICAgICAgICB2YXIgbmV3VmFsdWUgPSBldmVudERhdGFUcmFuc2ZlckdldERhdGEoZXZlbnQsIGRhdGFLZXkpO1xuICAgICAgICB2YXIgZGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChvbkRyb3ApIHtcbiAgICAgICAgICBvbkRyb3AoX2V4dGVuZHMoe30sIGV2ZW50LCB7XG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gcHJldmVudERlZmF1bHQoKSB7XG4gICAgICAgICAgICAgIGRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICByZXR1cm4gZXZlbnRQcmV2ZW50RGVmYXVsdChldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIG5ld1ZhbHVlLCBwcmV2aW91c1ZhbHVlLCBuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgIC8vIGRpc3BhdGNoIGNoYW5nZSBhY3Rpb25cbiAgICAgICAgICBkaXNwYXRjaChfcmVkdXhGb3JtLmNoYW5nZShuYW1lLCBuZXdWYWx1ZSkpO1xuICAgICAgICAgIGV2ZW50UHJldmVudERlZmF1bHQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgdmFyIF9wcm90byA9IENvbm5lY3RlZEZpZWxkLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbiBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIG5leHRQcm9wc0tleXMgPSBPYmplY3Qua2V5cyhuZXh0UHJvcHMpO1xuICAgICAgdmFyIHRoaXNQcm9wc0tleXMgPSBPYmplY3Qua2V5cyh0aGlzLnByb3BzKTsgLy8gaWYgd2UgaGF2ZSBjaGlsZHJlbiwgd2UgTVVTVCB1cGRhdGUgaW4gUmVhY3QgMTZcbiAgICAgIC8vIGh0dHBzOi8vdHdpdHRlci5jb20vZXJpa3Jhcy9zdGF0dXMvOTE1ODY2NTQ0NTU4Nzg4NjA4XG5cbiAgICAgIHJldHVybiAhISh0aGlzLnByb3BzLmNoaWxkcmVuIHx8IG5leHRQcm9wcy5jaGlsZHJlbiB8fCBuZXh0UHJvcHNLZXlzLmxlbmd0aCAhPT0gdGhpc1Byb3BzS2V5cy5sZW5ndGggfHwgbmV4dFByb3BzS2V5cy5zb21lKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIGlmICh+KG5leHRQcm9wcy5pbW11dGFibGVQcm9wcyB8fCBbXSkuaW5kZXhPZihwcm9wKSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczIucHJvcHNbcHJvcF0gIT09IG5leHRQcm9wc1twcm9wXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhfnByb3BzVG9Ob3RVcGRhdGVGb3IuaW5kZXhPZihwcm9wKSAmJiAhZGVlcEVxdWFsKF90aGlzMi5wcm9wc1twcm9wXSwgbmV4dFByb3BzW3Byb3BdKTtcbiAgICAgIH0pKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmdldFJlbmRlcmVkQ29tcG9uZW50ID0gZnVuY3Rpb24gZ2V0UmVuZGVyZWRDb21wb25lbnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWYuY3VycmVudDtcbiAgICB9O1xuXG4gICAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczYgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGNvbXBvbmVudCA9IF90aGlzJHByb3BzNi5jb21wb25lbnQsXG4gICAgICAgICAgZm9yd2FyZFJlZiA9IF90aGlzJHByb3BzNi5mb3J3YXJkUmVmLFxuICAgICAgICAgIG5hbWUgPSBfdGhpcyRwcm9wczYubmFtZSxcbiAgICAgICAgICBfcmVkdXhGb3JtID0gX3RoaXMkcHJvcHM2Ll9yZWR1eEZvcm0sXG4gICAgICAgICAgbm9ybWFsaXplID0gX3RoaXMkcHJvcHM2Lm5vcm1hbGl6ZSxcbiAgICAgICAgICBvbkJsdXIgPSBfdGhpcyRwcm9wczYub25CbHVyLFxuICAgICAgICAgIG9uQ2hhbmdlID0gX3RoaXMkcHJvcHM2Lm9uQ2hhbmdlLFxuICAgICAgICAgIG9uRm9jdXMgPSBfdGhpcyRwcm9wczYub25Gb2N1cyxcbiAgICAgICAgICBvbkRyYWdTdGFydCA9IF90aGlzJHByb3BzNi5vbkRyYWdTdGFydCxcbiAgICAgICAgICBvbkRyb3AgPSBfdGhpcyRwcm9wczYub25Ecm9wLFxuICAgICAgICAgIGltbXV0YWJsZVByb3BzID0gX3RoaXMkcHJvcHM2LmltbXV0YWJsZVByb3BzLFxuICAgICAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdGhpcyRwcm9wczYsIFtcImNvbXBvbmVudFwiLCBcImZvcndhcmRSZWZcIiwgXCJuYW1lXCIsIFwiX3JlZHV4Rm9ybVwiLCBcIm5vcm1hbGl6ZVwiLCBcIm9uQmx1clwiLCBcIm9uQ2hhbmdlXCIsIFwib25Gb2N1c1wiLCBcIm9uRHJhZ1N0YXJ0XCIsIFwib25Ecm9wXCIsIFwiaW1tdXRhYmxlUHJvcHNcIl0pO1xuXG4gICAgICB2YXIgX2NyZWF0ZUZpZWxkUHJvcHMgPSBjcmVhdGVGaWVsZFByb3BzKHN0cnVjdHVyZSwgbmFtZSwgX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICAgICAgZm9ybTogX3JlZHV4Rm9ybS5mb3JtLFxuICAgICAgICBvbkJsdXI6IHRoaXMuaGFuZGxlQmx1cixcbiAgICAgICAgb25DaGFuZ2U6IHRoaXMuaGFuZGxlQ2hhbmdlLFxuICAgICAgICBvbkRyb3A6IHRoaXMuaGFuZGxlRHJvcCxcbiAgICAgICAgb25EcmFnU3RhcnQ6IHRoaXMuaGFuZGxlRHJhZ1N0YXJ0LFxuICAgICAgICBvbkZvY3VzOiB0aGlzLmhhbmRsZUZvY3VzXG4gICAgICB9KSksXG4gICAgICAgICAgY3VzdG9tID0gX2NyZWF0ZUZpZWxkUHJvcHMuY3VzdG9tLFxuICAgICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX2NyZWF0ZUZpZWxkUHJvcHMsIFtcImN1c3RvbVwiXSk7XG5cbiAgICAgIGlmIChmb3J3YXJkUmVmKSB7XG4gICAgICAgIGN1c3RvbS5yZWYgPSB0aGlzLnJlZjtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBjb21wb25lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IHByb3BzLmlucHV0LFxuICAgICAgICAgICAgbWV0YSA9IHByb3BzLm1ldGE7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgICAgLy8gZmxhdHRlbiBpbnB1dCBpbnRvIG90aGVyIHByb3BzXG5cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBfZXh0ZW5kcyh7fSwgaW5wdXQsIGN1c3RvbSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBfZXh0ZW5kcyh7fSwgcHJvcHMsIGN1c3RvbSkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gQ29ubmVjdGVkRmllbGQ7XG4gIH0oQ29tcG9uZW50KTtcblxuICBDb25uZWN0ZWRGaWVsZC5wcm9wVHlwZXMgPSB7XG4gICAgY29tcG9uZW50OiB2YWxpZGF0ZUNvbXBvbmVudFByb3AsXG4gICAgcHJvcHM6IFByb3BUeXBlcy5vYmplY3RcbiAgfTtcbiAgdmFyIGNvbm5lY3RvciA9IGNvbm5lY3QoZnVuY3Rpb24gKHN0YXRlLCBvd25Qcm9wcykge1xuICAgIHZhciBuYW1lID0gb3duUHJvcHMubmFtZSxcbiAgICAgICAgX293blByb3BzJF9yZWR1eEZvcm0gPSBvd25Qcm9wcy5fcmVkdXhGb3JtLFxuICAgICAgICBpbml0aWFsVmFsdWVzID0gX293blByb3BzJF9yZWR1eEZvcm0uaW5pdGlhbFZhbHVlcyxcbiAgICAgICAgZ2V0Rm9ybVN0YXRlID0gX293blByb3BzJF9yZWR1eEZvcm0uZ2V0Rm9ybVN0YXRlO1xuICAgIHZhciBmb3JtU3RhdGUgPSBnZXRGb3JtU3RhdGUoc3RhdGUpO1xuICAgIHZhciBpbml0aWFsU3RhdGUgPSBnZXRJbihmb3JtU3RhdGUsIFwiaW5pdGlhbC5cIiArIG5hbWUpO1xuICAgIHZhciBpbml0aWFsID0gaW5pdGlhbFN0YXRlICE9PSB1bmRlZmluZWQgPyBpbml0aWFsU3RhdGUgOiBpbml0aWFsVmFsdWVzICYmIGdldEluKGluaXRpYWxWYWx1ZXMsIG5hbWUpO1xuICAgIHZhciB2YWx1ZSA9IGdldEluKGZvcm1TdGF0ZSwgXCJ2YWx1ZXMuXCIgKyBuYW1lKTtcbiAgICB2YXIgc3VibWl0dGluZyA9IGdldEluKGZvcm1TdGF0ZSwgJ3N1Ym1pdHRpbmcnKTtcbiAgICB2YXIgc3luY0Vycm9yID0gZ2V0U3luY0Vycm9yKGdldEluKGZvcm1TdGF0ZSwgJ3N5bmNFcnJvcnMnKSwgbmFtZSk7XG4gICAgdmFyIHN5bmNXYXJuaW5nID0gZ2V0U3luY1dhcm5pbmcoZ2V0SW4oZm9ybVN0YXRlLCAnc3luY1dhcm5pbmdzJyksIG5hbWUpO1xuICAgIHZhciBwcmlzdGluZSA9IGRlZXBFcXVhbCh2YWx1ZSwgaW5pdGlhbCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFzeW5jRXJyb3I6IGdldEluKGZvcm1TdGF0ZSwgXCJhc3luY0Vycm9ycy5cIiArIG5hbWUpLFxuICAgICAgYXN5bmNWYWxpZGF0aW5nOiBnZXRJbihmb3JtU3RhdGUsICdhc3luY1ZhbGlkYXRpbmcnKSA9PT0gbmFtZSxcbiAgICAgIGRpcnR5OiAhcHJpc3RpbmUsXG4gICAgICBwcmlzdGluZTogcHJpc3RpbmUsXG4gICAgICBzdGF0ZTogZ2V0SW4oZm9ybVN0YXRlLCBcImZpZWxkcy5cIiArIG5hbWUpLFxuICAgICAgc3VibWl0RXJyb3I6IGdldEluKGZvcm1TdGF0ZSwgXCJzdWJtaXRFcnJvcnMuXCIgKyBuYW1lKSxcbiAgICAgIHN1Ym1pdEZhaWxlZDogZ2V0SW4oZm9ybVN0YXRlLCAnc3VibWl0RmFpbGVkJyksXG4gICAgICBzdWJtaXR0aW5nOiBzdWJtaXR0aW5nLFxuICAgICAgc3luY0Vycm9yOiBzeW5jRXJyb3IsXG4gICAgICBzeW5jV2FybmluZzogc3luY1dhcm5pbmcsXG4gICAgICBpbml0aWFsOiBpbml0aWFsLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgX3ZhbHVlOiBvd25Qcm9wcy52YWx1ZSAvLyBzYXZlIHZhbHVlIHBhc3NlZCBpbiAoZm9yIHJhZGlvcylcblxuICAgIH07XG4gIH0sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7XG4gICAgZm9yd2FyZFJlZjogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIGNvbm5lY3RvcihDb25uZWN0ZWRGaWVsZCk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVDb25uZWN0ZWRGaWVsZDsiLCJpbXBvcnQgX2lzRXF1YWxXaXRoIGZyb20gXCJsb2Rhc2gvaXNFcXVhbFdpdGhcIjtcblxudmFyIGN1c3RvbWl6ZXIgPSBmdW5jdGlvbiBjdXN0b21pemVyKG9iamVjdFZhbHVlLCBvdGhlclZhbHVlLCBpbmRleE9ya2V5LCBvYmplY3QsIG90aGVyLCBzdGFjaykge1xuICAvLyBodHRwczovL2xvZGFzaC5jb20vZG9jcy80LjE3LjQjaXNFcXVhbFdpdGhcbiAgaWYgKHN0YWNrKSB7XG4gICAgLy8gU2hhbGxvdyBjb21wYXJlc1xuICAgIC8vIEZvciAxc3QgbGV2ZWwsIHN0YWNrID09PSB1bmRlZmluZWQuXG4gICAgLy8gICAtPiBEbyBub3RoaW5nIChhbmQgaW1wbGljaXRseSByZXR1cm4gdW5kZWZpbmVkIHNvIHRoYXQgaXQgZ29lcyB0byBjb21wYXJlIDJuZCBsZXZlbClcbiAgICAvLyBGb3IgMm5kIGxldmVsIGFuZCB1cCwgc3RhY2sgIT09IHVuZGVmaW5lZC5cbiAgICAvLyAgIC0+IENvbXBhcmUgYnkgPT09IG9wZXJhdG9yXG4gICAgcmV0dXJuIG9iamVjdFZhbHVlID09PSBvdGhlclZhbHVlO1xuICB9XG59O1xuXG52YXIgc2hhbGxvd0NvbXBhcmUgPSBmdW5jdGlvbiBzaGFsbG93Q29tcGFyZShpbnN0YW5jZSwgbmV4dFByb3BzLCBuZXh0U3RhdGUpIHtcbiAgdmFyIHByb3BzRXF1YWwgPSBfaXNFcXVhbFdpdGgoaW5zdGFuY2UucHJvcHMsIG5leHRQcm9wcywgY3VzdG9taXplcik7XG5cbiAgdmFyIHN0YXRlRXF1YWwgPSBfaXNFcXVhbFdpdGgoaW5zdGFuY2Uuc3RhdGUsIG5leHRTdGF0ZSwgY3VzdG9taXplcik7XG5cbiAgcmV0dXJuICFwcm9wc0VxdWFsIHx8ICFzdGF0ZUVxdWFsO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgc2hhbGxvd0NvbXBhcmU7IiwidmFyIGZvcm1hdE5hbWUgPSBmdW5jdGlvbiBmb3JtYXROYW1lKF9yZWYsIG5hbWUpIHtcbiAgdmFyIHNlY3Rpb25QcmVmaXggPSBfcmVmLl9yZWR1eEZvcm0uc2VjdGlvblByZWZpeDtcbiAgcmV0dXJuIHNlY3Rpb25QcmVmaXggPyBzZWN0aW9uUHJlZml4ICsgXCIuXCIgKyBuYW1lIDogbmFtZTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZvcm1hdE5hbWU7IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2V4dGVuZHNcIjtcbmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIjtcbmltcG9ydCBfaW5oZXJpdHNMb29zZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c0xvb3NlXCI7XG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCBjcmVhdGVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgcG9seWZpbGwgfSBmcm9tICdyZWFjdC1saWZlY3ljbGVzLWNvbXBhdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdpbnZhcmlhbnQnO1xuaW1wb3J0IGNyZWF0ZUNvbm5lY3RlZEZpZWxkIGZyb20gJy4vQ29ubmVjdGVkRmllbGQnO1xuaW1wb3J0IHNoYWxsb3dDb21wYXJlIGZyb20gJy4vdXRpbC9zaGFsbG93Q29tcGFyZSc7XG5pbXBvcnQgcHJlZml4TmFtZSBmcm9tICcuL3V0aWwvcHJlZml4TmFtZSc7XG5pbXBvcnQgcGxhaW4gZnJvbSAnLi9zdHJ1Y3R1cmUvcGxhaW4nO1xuaW1wb3J0IHsgd2l0aFJlZHV4Rm9ybSB9IGZyb20gJy4vUmVkdXhGb3JtQ29udGV4dCc7XG5pbXBvcnQgdmFsaWRhdGVDb21wb25lbnRQcm9wIGZyb20gJy4vdXRpbC92YWxpZGF0ZUNvbXBvbmVudFByb3AnO1xuXG52YXIgY3JlYXRlRmllbGQgPSBmdW5jdGlvbiBjcmVhdGVGaWVsZChzdHJ1Y3R1cmUpIHtcbiAgdmFyIENvbm5lY3RlZEZpZWxkID0gY3JlYXRlQ29ubmVjdGVkRmllbGQoc3RydWN0dXJlKTtcbiAgdmFyIHNldEluID0gc3RydWN0dXJlLnNldEluO1xuXG4gIHZhciBGaWVsZCA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHNMb29zZShGaWVsZCwgX0NvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBGaWVsZChwcm9wcykge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfdGhpcyA9IF9Db21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICAgIF90aGlzLnJlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgX3RoaXMucmVmID0gUmVhY3QuY3JlYXRlUmVmKCk7XG5cbiAgICAgIF90aGlzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YXIgbm9ybWFsaXplID0gX3RoaXMucHJvcHMubm9ybWFsaXplO1xuXG4gICAgICAgIGlmICghbm9ybWFsaXplKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByZXZpb3VzVmFsdWVzID0gX3RoaXMucHJvcHMuX3JlZHV4Rm9ybS5nZXRWYWx1ZXMoKTtcblxuICAgICAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IF90aGlzLnZhbHVlO1xuICAgICAgICB2YXIgbmV4dFZhbHVlcyA9IHNldEluKHByZXZpb3VzVmFsdWVzLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBub3JtYWxpemUodmFsdWUsIHByZXZpb3VzVmFsdWUsIG5leHRWYWx1ZXMsIHByZXZpb3VzVmFsdWVzLCBuYW1lKTtcbiAgICAgIH07XG5cbiAgICAgIGlmICghcHJvcHMuX3JlZHV4Rm9ybSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpZWxkIG11c3QgYmUgaW5zaWRlIGEgY29tcG9uZW50IGRlY29yYXRlZCB3aXRoIHJlZHV4Rm9ybSgpJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICB2YXIgX3Byb3RvID0gRmllbGQucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5wcm9wcy5fcmVkdXhGb3JtLnJlZ2lzdGVyKHRoaXMubmFtZSwgJ0ZpZWxkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLnByb3BzLnZhbGlkYXRlO1xuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLnByb3BzLndhcm47XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSkge1xuICAgICAgcmV0dXJuIHNoYWxsb3dDb21wYXJlKHRoaXMsIG5leHRQcm9wcywgbmV4dFN0YXRlKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgdmFyIG9sZE5hbWUgPSBwcmVmaXhOYW1lKHRoaXMucHJvcHMsIHRoaXMucHJvcHMubmFtZSk7XG4gICAgICB2YXIgbmV3TmFtZSA9IHByZWZpeE5hbWUobmV4dFByb3BzLCBuZXh0UHJvcHMubmFtZSk7XG5cbiAgICAgIGlmIChvbGROYW1lICE9PSBuZXdOYW1lIHx8IC8vIHVzZSBkZWVwRXF1YWwgaGVyZSBiZWNhdXNlIHRoZXkgY291bGQgYmUgYSBmdW5jdGlvbiBvciBhbiBhcnJheSBvZiBmdW5jdGlvbnNcbiAgICAgICFwbGFpbi5kZWVwRXF1YWwodGhpcy5wcm9wcy52YWxpZGF0ZSwgbmV4dFByb3BzLnZhbGlkYXRlKSB8fCAhcGxhaW4uZGVlcEVxdWFsKHRoaXMucHJvcHMud2FybiwgbmV4dFByb3BzLndhcm4pKSB7XG4gICAgICAgIC8vIHVucmVnaXN0ZXIgb2xkIG5hbWVcbiAgICAgICAgdGhpcy5wcm9wcy5fcmVkdXhGb3JtLnVucmVnaXN0ZXIob2xkTmFtZSk7IC8vIHJlZ2lzdGVyIG5ldyBuYW1lXG5cblxuICAgICAgICB0aGlzLnByb3BzLl9yZWR1eEZvcm0ucmVnaXN0ZXIobmV3TmFtZSwgJ0ZpZWxkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBuZXh0UHJvcHMudmFsaWRhdGU7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gbmV4dFByb3BzLndhcm47XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIHRoaXMucHJvcHMuX3JlZHV4Rm9ybS51bnJlZ2lzdGVyKHRoaXMubmFtZSk7XG4gICAgfTtcblxuICAgIF9wcm90by5nZXRSZW5kZXJlZENvbXBvbmVudCA9IGZ1bmN0aW9uIGdldFJlbmRlcmVkQ29tcG9uZW50KCkge1xuICAgICAgaW52YXJpYW50KHRoaXMucHJvcHMuZm9yd2FyZFJlZiwgJ0lmIHlvdSB3YW50IHRvIGFjY2VzcyBnZXRSZW5kZXJlZENvbXBvbmVudCgpLCAnICsgJ3lvdSBtdXN0IHNwZWNpZnkgYSBmb3J3YXJkUmVmIHByb3AgdG8gRmllbGQnKTtcbiAgICAgIHJldHVybiB0aGlzLnJlZi5jdXJyZW50ID8gdGhpcy5yZWYuY3VycmVudC5nZXRSZW5kZXJlZENvbXBvbmVudCgpIDogdW5kZWZpbmVkO1xuICAgIH07XG5cbiAgICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoQ29ubmVjdGVkRmllbGQsIF9leHRlbmRzKHt9LCB0aGlzLnByb3BzLCB7XG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgbm9ybWFsaXplOiB0aGlzLm5vcm1hbGl6ZSxcbiAgICAgICAgcmVmOiB0aGlzLnJlZlxuICAgICAgfSkpO1xuICAgIH07XG5cbiAgICBfY3JlYXRlQ2xhc3MoRmllbGQsIFt7XG4gICAgICBrZXk6IFwibmFtZVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBwcmVmaXhOYW1lKHRoaXMucHJvcHMsIHRoaXMucHJvcHMubmFtZSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRpcnR5XCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnByaXN0aW5lO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwcmlzdGluZVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiAhISh0aGlzLnJlZi5jdXJyZW50ICYmIHRoaXMucmVmLmN1cnJlbnQuaXNQcmlzdGluZSgpKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidmFsdWVcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWYuY3VycmVudCAmJiB0aGlzLnJlZi5jdXJyZW50LmdldFZhbHVlKCk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEZpZWxkO1xuICB9KENvbXBvbmVudCk7XG5cbiAgRmllbGQucHJvcFR5cGVzID0ge1xuICAgIG5hbWU6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBjb21wb25lbnQ6IHZhbGlkYXRlQ29tcG9uZW50UHJvcCxcbiAgICBmb3JtYXQ6IFByb3BUeXBlcy5mdW5jLFxuICAgIG5vcm1hbGl6ZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25CbHVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Gb2N1czogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25EcmFnU3RhcnQ6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uRHJvcDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgcGFyc2U6IFByb3BUeXBlcy5mdW5jLFxuICAgIHByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIHZhbGlkYXRlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLmZ1bmMpXSksXG4gICAgd2FybjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5mdW5jKV0pLFxuICAgIGZvcndhcmRSZWY6IFByb3BUeXBlcy5ib29sLFxuICAgIGltbXV0YWJsZVByb3BzOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc3RyaW5nKSxcbiAgICBfcmVkdXhGb3JtOiBQcm9wVHlwZXMub2JqZWN0XG4gIH07XG4gIHBvbHlmaWxsKEZpZWxkKTtcbiAgcmV0dXJuIHdpdGhSZWR1eEZvcm0oRmllbGQpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlRmllbGQ7IiwiaW1wb3J0IGNyZWF0ZUZpZWxkIGZyb20gJy4vY3JlYXRlRmllbGQnO1xuaW1wb3J0IHBsYWluIGZyb20gJy4vc3RydWN0dXJlL3BsYWluJztcbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUZpZWxkKHBsYWluKTsiLCIvKiogQGxpY2Vuc2UgTWF0ZXJpYWwtVUkgdjMuOC4zXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbmltcG9ydCAqIGFzIGNvbG9ycyBmcm9tICcuL2NvbG9ycyc7XG5leHBvcnQgeyBjb2xvcnMgfTtcbmV4cG9ydCB7IGNyZWF0ZUdlbmVyYXRlQ2xhc3NOYW1lLCBjcmVhdGVNdWlUaGVtZSwgY3JlYXRlU3R5bGVzLCBqc3NQcmVzZXQsIE11aVRoZW1lUHJvdmlkZXIsIHdpdGhTdHlsZXMsIHdpdGhUaGVtZSB9IGZyb20gJy4vc3R5bGVzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQXBwQmFyIH0gZnJvbSAnLi9BcHBCYXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBBdmF0YXIgfSBmcm9tICcuL0F2YXRhcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEJhY2tkcm9wIH0gZnJvbSAnLi9CYWNrZHJvcCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEJhZGdlIH0gZnJvbSAnLi9CYWRnZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEJvdHRvbU5hdmlnYXRpb24gfSBmcm9tICcuL0JvdHRvbU5hdmlnYXRpb24nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBCb3R0b21OYXZpZ2F0aW9uQWN0aW9uIH0gZnJvbSAnLi9Cb3R0b21OYXZpZ2F0aW9uQWN0aW9uJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQnV0dG9uIH0gZnJvbSAnLi9CdXR0b24nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBCdXR0b25CYXNlIH0gZnJvbSAnLi9CdXR0b25CYXNlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ2FyZCB9IGZyb20gJy4vQ2FyZCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENhcmRBY3Rpb25BcmVhIH0gZnJvbSAnLi9DYXJkQWN0aW9uQXJlYSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENhcmRBY3Rpb25zIH0gZnJvbSAnLi9DYXJkQWN0aW9ucyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENhcmRDb250ZW50IH0gZnJvbSAnLi9DYXJkQ29udGVudCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENhcmRIZWFkZXIgfSBmcm9tICcuL0NhcmRIZWFkZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDYXJkTWVkaWEgfSBmcm9tICcuL0NhcmRNZWRpYSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENoZWNrYm94IH0gZnJvbSAnLi9DaGVja2JveCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENoaXAgfSBmcm9tICcuL0NoaXAnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDaXJjdWxhclByb2dyZXNzIH0gZnJvbSAnLi9DaXJjdWxhclByb2dyZXNzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ2xpY2tBd2F5TGlzdGVuZXIgfSBmcm9tICcuL0NsaWNrQXdheUxpc3RlbmVyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ29sbGFwc2UgfSBmcm9tICcuL0NvbGxhcHNlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ3NzQmFzZWxpbmUgfSBmcm9tICcuL0Nzc0Jhc2VsaW5lJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRGlhbG9nIH0gZnJvbSAnLi9EaWFsb2cnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBEaWFsb2dBY3Rpb25zIH0gZnJvbSAnLi9EaWFsb2dBY3Rpb25zJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRGlhbG9nQ29udGVudCB9IGZyb20gJy4vRGlhbG9nQ29udGVudCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIERpYWxvZ0NvbnRlbnRUZXh0IH0gZnJvbSAnLi9EaWFsb2dDb250ZW50VGV4dCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIERpYWxvZ1RpdGxlIH0gZnJvbSAnLi9EaWFsb2dUaXRsZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIERpdmlkZXIgfSBmcm9tICcuL0RpdmlkZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBEcmF3ZXIgfSBmcm9tICcuL0RyYXdlcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEV4cGFuc2lvblBhbmVsIH0gZnJvbSAnLi9FeHBhbnNpb25QYW5lbCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEV4cGFuc2lvblBhbmVsQWN0aW9ucyB9IGZyb20gJy4vRXhwYW5zaW9uUGFuZWxBY3Rpb25zJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRXhwYW5zaW9uUGFuZWxEZXRhaWxzIH0gZnJvbSAnLi9FeHBhbnNpb25QYW5lbERldGFpbHMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBFeHBhbnNpb25QYW5lbFN1bW1hcnkgfSBmcm9tICcuL0V4cGFuc2lvblBhbmVsU3VtbWFyeSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEZhYiB9IGZyb20gJy4vRmFiJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRmFkZSB9IGZyb20gJy4vRmFkZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEZpbGxlZElucHV0IH0gZnJvbSAnLi9GaWxsZWRJbnB1dCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEZvcm1Db250cm9sIH0gZnJvbSAnLi9Gb3JtQ29udHJvbCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEZvcm1Db250cm9sTGFiZWwgfSBmcm9tICcuL0Zvcm1Db250cm9sTGFiZWwnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBGb3JtR3JvdXAgfSBmcm9tICcuL0Zvcm1Hcm91cCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEZvcm1IZWxwZXJUZXh0IH0gZnJvbSAnLi9Gb3JtSGVscGVyVGV4dCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEZvcm1MYWJlbCB9IGZyb20gJy4vRm9ybUxhYmVsJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgR3JpZCB9IGZyb20gJy4vR3JpZCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEdyaWRMaXN0IH0gZnJvbSAnLi9HcmlkTGlzdCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEdyaWRMaXN0VGlsZSB9IGZyb20gJy4vR3JpZExpc3RUaWxlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgR3JpZExpc3RUaWxlQmFyIH0gZnJvbSAnLi9HcmlkTGlzdFRpbGVCYXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBHcm93IH0gZnJvbSAnLi9Hcm93JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgSGlkZGVuIH0gZnJvbSAnLi9IaWRkZW4nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBJY29uIH0gZnJvbSAnLi9JY29uJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgSWNvbkJ1dHRvbiB9IGZyb20gJy4vSWNvbkJ1dHRvbic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIElucHV0IH0gZnJvbSAnLi9JbnB1dCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIElucHV0QWRvcm5tZW50IH0gZnJvbSAnLi9JbnB1dEFkb3JubWVudCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIElucHV0QmFzZSB9IGZyb20gJy4vSW5wdXRCYXNlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgSW5wdXRMYWJlbCB9IGZyb20gJy4vSW5wdXRMYWJlbCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIExpbmVhclByb2dyZXNzIH0gZnJvbSAnLi9MaW5lYXJQcm9ncmVzcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIExpbmsgfSBmcm9tICcuL0xpbmsnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBMaXN0IH0gZnJvbSAnLi9MaXN0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTGlzdEl0ZW0gfSBmcm9tICcuL0xpc3RJdGVtJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTGlzdEl0ZW1BdmF0YXIgfSBmcm9tICcuL0xpc3RJdGVtQXZhdGFyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTGlzdEl0ZW1JY29uIH0gZnJvbSAnLi9MaXN0SXRlbUljb24nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBMaXN0SXRlbVNlY29uZGFyeUFjdGlvbiB9IGZyb20gJy4vTGlzdEl0ZW1TZWNvbmRhcnlBY3Rpb24nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBMaXN0SXRlbVRleHQgfSBmcm9tICcuL0xpc3RJdGVtVGV4dCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIExpc3RTdWJoZWFkZXIgfSBmcm9tICcuL0xpc3RTdWJoZWFkZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNZW51IH0gZnJvbSAnLi9NZW51JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTWVudUl0ZW0gfSBmcm9tICcuL01lbnVJdGVtJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTWVudUxpc3QgfSBmcm9tICcuL01lbnVMaXN0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTW9iaWxlU3RlcHBlciB9IGZyb20gJy4vTW9iaWxlU3RlcHBlcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE1vZGFsLCBNb2RhbE1hbmFnZXIgfSBmcm9tICcuL01vZGFsJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTmF0aXZlU2VsZWN0IH0gZnJvbSAnLi9OYXRpdmVTZWxlY3QnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBOb1NzciB9IGZyb20gJy4vTm9Tc3InO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBPdXRsaW5lZElucHV0IH0gZnJvbSAnLi9PdXRsaW5lZElucHV0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUGFwZXIgfSBmcm9tICcuL1BhcGVyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUG9wb3ZlciB9IGZyb20gJy4vUG9wb3Zlcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFBvcHBlciB9IGZyb20gJy4vUG9wcGVyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUG9ydGFsIH0gZnJvbSAnLi9Qb3J0YWwnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBSYWRpbyB9IGZyb20gJy4vUmFkaW8nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBSYWRpb0dyb3VwIH0gZnJvbSAnLi9SYWRpb0dyb3VwJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUm9vdFJlZiB9IGZyb20gJy4vUm9vdFJlZic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNlbGVjdCB9IGZyb20gJy4vU2VsZWN0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2xpZGUgfSBmcm9tICcuL1NsaWRlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU25hY2tiYXIgfSBmcm9tICcuL1NuYWNrYmFyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU25hY2tiYXJDb250ZW50IH0gZnJvbSAnLi9TbmFja2JhckNvbnRlbnQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTdGVwIH0gZnJvbSAnLi9TdGVwJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU3RlcEJ1dHRvbiB9IGZyb20gJy4vU3RlcEJ1dHRvbic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFN0ZXBDb25uZWN0b3IgfSBmcm9tICcuL1N0ZXBDb25uZWN0b3InO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTdGVwQ29udGVudCB9IGZyb20gJy4vU3RlcENvbnRlbnQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTdGVwSWNvbiB9IGZyb20gJy4vU3RlcEljb24nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTdGVwTGFiZWwgfSBmcm9tICcuL1N0ZXBMYWJlbCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFN0ZXBwZXIgfSBmcm9tICcuL1N0ZXBwZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTdmdJY29uIH0gZnJvbSAnLi9TdmdJY29uJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU3dpcGVhYmxlRHJhd2VyIH0gZnJvbSAnLi9Td2lwZWFibGVEcmF3ZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTd2l0Y2ggfSBmcm9tICcuL1N3aXRjaCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRhYiB9IGZyb20gJy4vVGFiJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGFibGUgfSBmcm9tICcuL1RhYmxlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGFibGVCb2R5IH0gZnJvbSAnLi9UYWJsZUJvZHknO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUYWJsZUNlbGwgfSBmcm9tICcuL1RhYmxlQ2VsbCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRhYmxlRm9vdGVyIH0gZnJvbSAnLi9UYWJsZUZvb3Rlcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRhYmxlSGVhZCB9IGZyb20gJy4vVGFibGVIZWFkJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGFibGVQYWdpbmF0aW9uIH0gZnJvbSAnLi9UYWJsZVBhZ2luYXRpb24nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUYWJsZVJvdyB9IGZyb20gJy4vVGFibGVSb3cnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUYWJsZVNvcnRMYWJlbCB9IGZyb20gJy4vVGFibGVTb3J0TGFiZWwnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUYWJzIH0gZnJvbSAnLi9UYWJzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGV4dEZpZWxkIH0gZnJvbSAnLi9UZXh0RmllbGQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUb29sYmFyIH0gZnJvbSAnLi9Ub29sYmFyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVG9vbHRpcCB9IGZyb20gJy4vVG9vbHRpcCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFR5cG9ncmFwaHkgfSBmcm9tICcuL1R5cG9ncmFwaHknO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB3aXRoTW9iaWxlRGlhbG9nIH0gZnJvbSAnLi93aXRoTW9iaWxlRGlhbG9nJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgd2l0aFdpZHRoIH0gZnJvbSAnLi93aXRoV2lkdGgnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBab29tIH0gZnJvbSAnLi9ab29tJztcbiIsImltcG9ydCB7IFRleHRGaWVsZCB9IGZyb20gXCJAbWF0ZXJpYWwtdWkvY29yZVwiO1xyXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCAoZmllbGQ6IGFueSkgPT4gKFxyXG4gICAgPFRleHRGaWVsZCB7Li4uZmllbGQuaW5wdXR9IGxhYmVsPXtmaWVsZC5sYWJlbH0gcmVxdWlyZWQ9e2ZpZWxkLnJlcXVpcmVkfSBkaXNhYmxlZD17ZmllbGQuZGlzYWJsZWR9Lz5cclxuKTtcclxuIiwiaW1wb3J0IHsgU2VsZWN0LCBGb3JtQ29udHJvbCwgSW5wdXRMYWJlbCB9IGZyb20gXCJAbWF0ZXJpYWwtdWkvY29yZVwiO1xyXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCAoZmllbGQ6IGFueSkgPT4gKFxyXG4gICAgPEZvcm1Db250cm9sIHN0eWxlPXt7bWluV2lkdGg6IDEyMH19PlxyXG4gICAgICAgIDxJbnB1dExhYmVsPntmaWVsZC5sYWJlbH08L0lucHV0TGFiZWw+XHJcbiAgICAgICAgPFNlbGVjdCB7Li4uZmllbGQuaW5wdXR9IHJlcXVpcmVkPXtmaWVsZC5yZXF1aXJlZH0gZGlzYWJsZWQ9e2ZpZWxkLmRpc2FibGVkfT5cclxuICAgICAgICAgICAge2ZpZWxkLmNoaWxkcmVufVxyXG4gICAgICAgIDwvU2VsZWN0PlxyXG4gICAgPC9Gb3JtQ29udHJvbD5cclxuKTtcclxuIiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBTZWxlY3QsIEZvcm1Db250cm9sLCBJbnB1dExhYmVsLCBNZW51SXRlbSB9IGZyb20gJ0BtYXRlcmlhbC11aS9jb3JlJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbW90ZVNlbGVjdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxhbnksIGFueT57XHJcblxyXG4gICAgY29uc3RydWN0b3IocHJvcHMpe1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0ge307XHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50RGlkTW91bnQoKXtcclxuICAgICAgICBzZXRUaW1lb3V0KCgpPT57XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoe3NlbGVjdDogXHJcbiAgICAgICAgICAgICAgICA8U2VsZWN0IHsuLi50aGlzLnByb3BzLmlucHV0fSByZXF1aXJlZD17dGhpcy5wcm9wcy5yZXF1aXJlZH0gZGlzYWJsZWQ9e3RoaXMucHJvcHMuZGlzYWJsZWR9PlxyXG4gICAgICAgICAgICAgICAgICAgIDxNZW51SXRlbSB2YWx1ZT17MTB9PlRlbjwvTWVudUl0ZW0+XHJcbiAgICAgICAgICAgICAgICAgICAgPE1lbnVJdGVtIHZhbHVlPXsyMH0+VHdlbnR5PC9NZW51SXRlbT5cclxuICAgICAgICAgICAgICAgICAgICA8TWVudUl0ZW0gdmFsdWU9ezMwfT5UaGlydHk8L01lbnVJdGVtPiBcclxuICAgICAgICAgICAgICAgIDwvU2VsZWN0PlxyXG4gICAgICAgICAgICB9KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgfSwgMzAwMCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCl7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPEZvcm1Db250cm9sIHN0eWxlPXt7bWluV2lkdGg6IDEyMH19PlxyXG4gICAgICAgICAgICAgICAgPElucHV0TGFiZWw+e3RoaXMucHJvcHMubGFiZWx9PC9JbnB1dExhYmVsPlxyXG4gICAgICAgICAgICAgICAge3RoaXMuc3RhdGUuc2VsZWN0fVxyXG4gICAgICAgICAgICA8L0Zvcm1Db250cm9sPlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IEZpZWxkLCByZWR1eEZvcm0sIEZvcm1Qcm9wcywgRm9ybUVycm9ycywgSW5qZWN0ZWRGb3JtUHJvcHMgfSBmcm9tICdyZWR1eC1mb3JtJztcclxuaW1wb3J0IFRleHRGaWVsZCBmcm9tICcuL2Zvcm0vY29udHJvbC9UZXh0RmllbGQnO1xyXG5pbXBvcnQgeyBjb25uZWN0IH0gZnJvbSAncmVhY3QtcmVkdXgnO1xyXG5pbXBvcnQgeyBHcmlkLCBNZW51SXRlbSB9IGZyb20gJ0BtYXRlcmlhbC11aS9jb3JlJztcclxuaW1wb3J0IFNlbGVjdCBmcm9tICcuL2Zvcm0vY29udHJvbC9TZWxlY3QnO1xyXG5pbXBvcnQgUmVtb3RlU2VsZWN0IGZyb20gJy4vZm9ybS9jb250cm9sL1JlbW90ZVNlbGVjdCc7XHJcblxyXG4vKipcclxuICogU2ltcGxlIEZvcm0gQ29tcG9uZW50IFxyXG4gKi9cclxuQChjb25uZWN0KCBcclxuICAgIC8vIG1hcCBzdGF0ZSB0byBwcm9wc1xyXG4gICAgZnVuY3Rpb24oc3RhdGU6IGFueSl7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coc3RhdGUpO1xyXG4gICAgICAgIHJldHVybiB7c2ltcGxlOiBzdGF0ZSAmJiBzdGF0ZS5mb3JtICYmIHN0YXRlLmZvcm0uc2ltcGxlICYmIHN0YXRlLmZvcm0uc2ltcGxlLnZhbHVlcyA/IHN0YXRlLmZvcm0uc2ltcGxlLnZhbHVlcyA6IHt9IH07XHJcbiAgICB9ICxcclxuICAgIC8vIG1hcCBkaXNwYXRjaCB0byBwcm9wc1xyXG4gICAgZnVuY3Rpb24oZGlzcGF0Y2gpe1xyXG4gICAgICAgIHJldHVybiB7fTtcclxuICAgIH0gICAgXHJcbikgYXMgYW55KVxyXG5AKHJlZHV4Rm9ybSh7Zm9ybSA6ICdzaW1wbGUnfSkgYXMgYW55KVxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaW1wbGVGb3JtQ29tcG9uZW50IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PEluamVjdGVkRm9ybVByb3BzIHwgYW55ICwgYW55ID57XHJcblxyXG4gICAgY29uc3RydWN0b3IocHJvcHM6IGFueSl7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBwcm9wcztcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIoKXtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8Zm9ybT5cclxuICAgICAgICAgICAgICAgIDxHcmlkIGNvbnRhaW5lcj5cclxuICAgICAgICAgICAgICAgICAgICA8R3JpZCBpdGVtPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8RmllbGQgbmFtZT1cInNpbXBsZVRleHRGaWVsZDFcIiBsYWJlbD1cIlNpbXBsZSBUZXh0IEZpZWxkIDFcIiBjb21wb25lbnQ9e1RleHRGaWVsZH0vPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvR3JpZD5cclxuICAgICAgICAgICAgICAgIDwvR3JpZD5cclxuICAgICAgICAgICAgICAgIDxHcmlkIGNvbnRhaW5lcj5cclxuICAgICAgICAgICAgICAgICAgICA8R3JpZCBpdGVtPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8RmllbGQgbmFtZT1cInNpbXBsZVNlbGVjdEZpZWxkXCIgbGFiZWw9XCJTaW1wbGUgU2VsZWN0XCIgY29tcG9uZW50PXtTZWxlY3R9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPE1lbnVJdGVtIHZhbHVlPXsxMH0+VGVuPC9NZW51SXRlbT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxNZW51SXRlbSB2YWx1ZT17MjB9PlR3ZW50eTwvTWVudUl0ZW0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8TWVudUl0ZW0gdmFsdWU9ezMwfT5UaGlydHk8L01lbnVJdGVtPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L0ZpZWxkPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvR3JpZD5cclxuICAgICAgICAgICAgICAgIDwvR3JpZD5cclxuICAgICAgICAgICAgICAgIDxHcmlkIGNvbnRhaW5lcj5cclxuICAgICAgICAgICAgICAgICAgICA8R3JpZCBpdGVtPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8RmllbGQgbmFtZT1cInJlbW90ZVNlbGVjdEZpZWxkXCIgbGFiZWw9XCJSZW1vdGUgU2VsZWN0XCIgY29tcG9uZW50PXtSZW1vdGVTZWxlY3R9Lz5cclxuICAgICAgICAgICAgICAgICAgICA8L0dyaWQ+XHJcbiAgICAgICAgICAgICAgICA8L0dyaWQ+XHJcbiAgICAgICAgICAgIDwvZm9ybT5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbiIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgKiBhcyBSZWFjdERPTSBmcm9tIFwicmVhY3QtZG9tXCI7XHJcbmltcG9ydCB7IGNvbWJpbmVSZWR1Y2VycywgY3JlYXRlU3RvcmUgfSBmcm9tIFwicmVkdXhcIjtcclxuaW1wb3J0IHsgcmVkdWNlciB9IGZyb20gJ3JlZHV4LWZvcm0nO1xyXG5pbXBvcnQgU2ltcGxlRm9ybUNvbXBvbmVudCBmcm9tIFwiLi9TaW1wbGVGb3JtQ29tcG9uZW50XCI7XHJcbmltcG9ydCB7IFByb3ZpZGVyLCBjb25uZWN0IH0gZnJvbSBcInJlYWN0LXJlZHV4XCI7XHJcblxyXG5jb25zdCByb290UmVkdWNlciA9IGNvbWJpbmVSZWR1Y2Vycyh7XHJcbiAgICBmb3JtOiByZWR1Y2VyXHJcbn0pO1xyXG5cclxuY29uc3Qgc3RvcmUgPSBjcmVhdGVTdG9yZShyb290UmVkdWNlcik7XHJcblxyXG5AKGNvbm5lY3QoIFxyXG4gICAgLy8gbWFwIHN0YXRlIHRvIHByb3BzXHJcbiAgICBmdW5jdGlvbihzdGF0ZTogYW55KXtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhzdGF0ZSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2ltcGxlOiBzdGF0ZSAmJiBzdGF0ZS5mb3JtICYmIHN0YXRlLmZvcm0uc2ltcGxlICYmIHN0YXRlLmZvcm0uc2ltcGxlLnZhbHVlcyA/IHN0YXRlLmZvcm0uc2ltcGxlLnZhbHVlcyA6IHt9LFxyXG4gICAgICAgICAgICBmb3JtOiBzdGF0ZSAmJiBzdGF0ZS5mb3JtICYmIHN0YXRlLmZvcm0uc2ltcGxlID8gc3RhdGUuZm9ybS5zaW1wbGUgOiB7fVxyXG4gICAgICAgIH07XHJcbiAgICB9ICxcclxuICAgIC8vIG1hcCBkaXNwYXRjaCB0byBwcm9wc1xyXG4gICAgZnVuY3Rpb24oZGlzcGF0Y2gpe1xyXG4gICAgICAgIHJldHVybiB7fTtcclxuICAgIH0gICAgXHJcbikgYXMgYW55KVxyXG5jbGFzcyBBcHAgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8YW55LCBhbnk+e1xyXG4gICAgXHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcyl7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBwcm9wcztcclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcyl7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnLCBuZXh0UHJvcHMpOyAgICAgICAgXHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCl7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgIDxoMT5IZWxsbyBXb3JsZDwvaDE+XHJcbiAgICAgICAgICAgICAgICAgICAgPFNpbXBsZUZvcm1Db21wb25lbnQvPlxyXG4gICAgICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgICAgICB7dGhpcy5wcm9wcy5zaW1wbGUuc2ltcGxlVGV4dEZpZWxkMX1cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgICAgICB7dGhpcy5wcm9wcy5zaW1wbGUuc2ltcGxlU2VsZWN0RmllbGR9XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICAgICAge3RoaXMucHJvcHMuc2ltcGxlLnJlbW90ZVNlbGVjdEZpZWxkfVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgIFxyXG4gICAgICAgIClcclxuICAgIH1cclxufVxyXG5cclxuXHJcblJlYWN0RE9NLnJlbmRlcihcclxuICAgIDxQcm92aWRlciBzdG9yZT17c3RvcmV9PlxyXG4gICAgICAgIDxBcHAgLz5cclxuICAgIDwvUHJvdmlkZXI+LCBcclxuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FwcCcpKTtcclxuXHJcbiAgICBcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///455\n')}});