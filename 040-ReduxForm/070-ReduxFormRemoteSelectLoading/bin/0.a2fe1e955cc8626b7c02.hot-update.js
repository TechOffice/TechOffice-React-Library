webpackHotUpdate(0,{455:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react/index.js\nvar react = __webpack_require__(0);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-dom/index.js\nvar react_dom = __webpack_require__(19);\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/lodash-es/_freeGlobal.js\nvar _freeGlobal = __webpack_require__(160);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/lodash-es/_root.js\n\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == \'object\' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = _freeGlobal["a" /* default */] || freeSelf || Function(\'return this\')();\n\n/* harmony default export */ var _root = (root);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/lodash-es/_Symbol.js\n\n\n/** Built-in value references. */\nvar _Symbol_Symbol = _root.Symbol;\n\n/* harmony default export */ var _Symbol = (_Symbol_Symbol);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/lodash-es/_getRawTag.js\n\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar _getRawTag_hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = _getRawTag_hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/* harmony default export */ var _getRawTag = (getRawTag);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/lodash-es/_objectToString.js\n/** Used for built-in method references. */\nvar _objectToString_objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar _objectToString_nativeObjectToString = _objectToString_objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return _objectToString_nativeObjectToString.call(value);\n}\n\n/* harmony default export */ var _objectToString = (objectToString);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/lodash-es/_baseGetTag.js\n\n\n\n\n/** `Object#toString` result references. */\nvar nullTag = \'[object Null]\',\n    undefinedTag = \'[object Undefined]\';\n\n/** Built-in value references. */\nvar _baseGetTag_symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (_baseGetTag_symToStringTag && _baseGetTag_symToStringTag in Object(value))\n    ? _getRawTag(value)\n    : _objectToString(value);\n}\n\n/* harmony default export */ var _baseGetTag = (baseGetTag);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/lodash-es/_overArg.js\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/* harmony default export */ var _overArg = (overArg);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/lodash-es/_getPrototype.js\n\n\n/** Built-in value references. */\nvar getPrototype = _overArg(Object.getPrototypeOf, Object);\n\n/* harmony default export */ var _getPrototype = (getPrototype);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/lodash-es/isObjectLike.js\n/**\n * Checks if `value` is object-like. A value is object-like if it\'s not `null`\n * and has a `typeof` result of "object".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == \'object\';\n}\n\n/* harmony default export */ var lodash_es_isObjectLike = (isObjectLike);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/lodash-es/isPlainObject.js\n\n\n\n\n/** `Object#toString` result references. */\nvar objectTag = \'[object Object]\';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    isPlainObject_objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar isPlainObject_hasOwnProperty = isPlainObject_objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ \'x\': 0, \'y\': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!lodash_es_isObjectLike(value) || _baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = _getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = isPlainObject_hasOwnProperty.call(proto, \'constructor\') && proto.constructor;\n  return typeof Ctor == \'function\' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\n/* harmony default export */ var lodash_es_isPlainObject = (isPlainObject);\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/symbol-observable/es/index.js\nvar es = __webpack_require__(60);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux/es/createStore.js\n\n\n\n/**\n * These are private action types reserved by Redux.\n * For any unknown actions, you must return the current state.\n * If the current state is undefined, you must return the initial state.\n * Do not reference these action types directly in your code.\n */\nvar ActionTypes = {\n  INIT: \'@@redux/INIT\'\n\n  /**\n   * Creates a Redux store that holds the state tree.\n   * The only way to change the data in the store is to call `dispatch()` on it.\n   *\n   * There should only be a single store in your app. To specify how different\n   * parts of the state tree respond to actions, you may combine several reducers\n   * into a single reducer function by using `combineReducers`.\n   *\n   * @param {Function} reducer A function that returns the next state tree, given\n   * the current state tree and the action to handle.\n   *\n   * @param {any} [preloadedState] The initial state. You may optionally specify it\n   * to hydrate the state from the server in universal apps, or to restore a\n   * previously serialized user session.\n   * If you use `combineReducers` to produce the root reducer function, this must be\n   * an object with the same shape as `combineReducers` keys.\n   *\n   * @param {Function} [enhancer] The store enhancer. You may optionally specify it\n   * to enhance the store with third-party capabilities such as middleware,\n   * time travel, persistence, etc. The only store enhancer that ships with Redux\n   * is `applyMiddleware()`.\n   *\n   * @returns {Store} A Redux store that lets you read the state, dispatch actions\n   * and subscribe to changes.\n   */\n};function createStore_createStore(reducer, preloadedState, enhancer) {\n  var _ref2;\n\n  if (typeof preloadedState === \'function\' && typeof enhancer === \'undefined\') {\n    enhancer = preloadedState;\n    preloadedState = undefined;\n  }\n\n  if (typeof enhancer !== \'undefined\') {\n    if (typeof enhancer !== \'function\') {\n      throw new Error(\'Expected the enhancer to be a function.\');\n    }\n\n    return enhancer(createStore_createStore)(reducer, preloadedState);\n  }\n\n  if (typeof reducer !== \'function\') {\n    throw new Error(\'Expected the reducer to be a function.\');\n  }\n\n  var currentReducer = reducer;\n  var currentState = preloadedState;\n  var currentListeners = [];\n  var nextListeners = currentListeners;\n  var isDispatching = false;\n\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice();\n    }\n  }\n\n  /**\n   * Reads the state tree managed by the store.\n   *\n   * @returns {any} The current state tree of your application.\n   */\n  function getState() {\n    return currentState;\n  }\n\n  /**\n   * Adds a change listener. It will be called any time an action is dispatched,\n   * and some part of the state tree may potentially have changed. You may then\n   * call `getState()` to read the current state tree inside the callback.\n   *\n   * You may call `dispatch()` from a change listener, with the following\n   * caveats:\n   *\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\n   * will not have any effect on the `dispatch()` that is currently in progress.\n   * However, the next `dispatch()` call, whether nested or not, will use a more\n   * recent snapshot of the subscription list.\n   *\n   * 2. The listener should not expect to see all state changes, as the state\n   * might have been updated multiple times during a nested `dispatch()` before\n   * the listener is called. It is, however, guaranteed that all subscribers\n   * registered before the `dispatch()` started will be called with the latest\n   * state by the time it exits.\n   *\n   * @param {Function} listener A callback to be invoked on every dispatch.\n   * @returns {Function} A function to remove this change listener.\n   */\n  function subscribe(listener) {\n    if (typeof listener !== \'function\') {\n      throw new Error(\'Expected listener to be a function.\');\n    }\n\n    var isSubscribed = true;\n\n    ensureCanMutateNextListeners();\n    nextListeners.push(listener);\n\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return;\n      }\n\n      isSubscribed = false;\n\n      ensureCanMutateNextListeners();\n      var index = nextListeners.indexOf(listener);\n      nextListeners.splice(index, 1);\n    };\n  }\n\n  /**\n   * Dispatches an action. It is the only way to trigger a state change.\n   *\n   * The `reducer` function, used to create the store, will be called with the\n   * current state tree and the given `action`. Its return value will\n   * be considered the **next** state of the tree, and the change listeners\n   * will be notified.\n   *\n   * The base implementation only supports plain object actions. If you want to\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\n   * wrap your store creating function into the corresponding middleware. For\n   * example, see the documentation for the `redux-thunk` package. Even the\n   * middleware will eventually dispatch plain object actions using this method.\n   *\n   * @param {Object} action A plain object representing “what changed”. It is\n   * a good idea to keep actions serializable so you can record and replay user\n   * sessions, or use the time travelling `redux-devtools`. An action must have\n   * a `type` property which may not be `undefined`. It is a good idea to use\n   * string constants for action types.\n   *\n   * @returns {Object} For convenience, the same action object you dispatched.\n   *\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n   * return something else (for example, a Promise you can await).\n   */\n  function dispatch(action) {\n    if (!lodash_es_isPlainObject(action)) {\n      throw new Error(\'Actions must be plain objects. \' + \'Use custom middleware for async actions.\');\n    }\n\n    if (typeof action.type === \'undefined\') {\n      throw new Error(\'Actions may not have an undefined "type" property. \' + \'Have you misspelled a constant?\');\n    }\n\n    if (isDispatching) {\n      throw new Error(\'Reducers may not dispatch actions.\');\n    }\n\n    try {\n      isDispatching = true;\n      currentState = currentReducer(currentState, action);\n    } finally {\n      isDispatching = false;\n    }\n\n    var listeners = currentListeners = nextListeners;\n    for (var i = 0; i < listeners.length; i++) {\n      var listener = listeners[i];\n      listener();\n    }\n\n    return action;\n  }\n\n  /**\n   * Replaces the reducer currently used by the store to calculate the state.\n   *\n   * You might need this if your app implements code splitting and you want to\n   * load some of the reducers dynamically. You might also need this if you\n   * implement a hot reloading mechanism for Redux.\n   *\n   * @param {Function} nextReducer The reducer for the store to use instead.\n   * @returns {void}\n   */\n  function replaceReducer(nextReducer) {\n    if (typeof nextReducer !== \'function\') {\n      throw new Error(\'Expected the nextReducer to be a function.\');\n    }\n\n    currentReducer = nextReducer;\n    dispatch({ type: ActionTypes.INIT });\n  }\n\n  /**\n   * Interoperability point for observable/reactive libraries.\n   * @returns {observable} A minimal observable of state changes.\n   * For more information, see the observable proposal:\n   * https://github.com/tc39/proposal-observable\n   */\n  function observable() {\n    var _ref;\n\n    var outerSubscribe = subscribe;\n    return _ref = {\n      /**\n       * The minimal observable subscription method.\n       * @param {Object} observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns {subscription} An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */\n      subscribe: function subscribe(observer) {\n        if (typeof observer !== \'object\') {\n          throw new TypeError(\'Expected the observer to be an object.\');\n        }\n\n        function observeState() {\n          if (observer.next) {\n            observer.next(getState());\n          }\n        }\n\n        observeState();\n        var unsubscribe = outerSubscribe(observeState);\n        return { unsubscribe: unsubscribe };\n      }\n    }, _ref[es["default"]] = function () {\n      return this;\n    }, _ref;\n  }\n\n  // When a store is created, an "INIT" action is dispatched so that every\n  // reducer returns their initial state. This effectively populates\n  // the initial state tree.\n  dispatch({ type: ActionTypes.INIT });\n\n  return _ref2 = {\n    dispatch: dispatch,\n    subscribe: subscribe,\n    getState: getState,\n    replaceReducer: replaceReducer\n  }, _ref2[es["default"]] = observable, _ref2;\n}\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux/es/utils/warning.js\n/**\n * Prints a warning in the console if it exists.\n *\n * @param {String} message The warning message.\n * @returns {void}\n */\nfunction warning_warning(message) {\n  /* eslint-disable no-console */\n  if (typeof console !== \'undefined\' && typeof console.error === \'function\') {\n    console.error(message);\n  }\n  /* eslint-enable no-console */\n  try {\n    // This error was thrown as a convenience so that if you enable\n    // "break on all exceptions" in your console,\n    // it would pause the execution at this line.\n    throw new Error(message);\n    /* eslint-disable no-empty */\n  } catch (e) {}\n  /* eslint-enable no-empty */\n}\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux/es/combineReducers.js\n\n\n\n\nfunction getUndefinedStateErrorMessage(key, action) {\n  var actionType = action && action.type;\n  var actionName = actionType && \'"\' + actionType.toString() + \'"\' || \'an action\';\n\n  return \'Given action \' + actionName + \', reducer "\' + key + \'" returned undefined. \' + \'To ignore an action, you must explicitly return the previous state. \' + \'If you want this reducer to hold no value, you can return null instead of undefined.\';\n}\n\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\n  var reducerKeys = Object.keys(reducers);\n  var argumentName = action && action.type === ActionTypes.INIT ? \'preloadedState argument passed to createStore\' : \'previous state received by the reducer\';\n\n  if (reducerKeys.length === 0) {\n    return \'Store does not have a valid reducer. Make sure the argument passed \' + \'to combineReducers is an object whose values are reducers.\';\n  }\n\n  if (!lodash_es_isPlainObject(inputState)) {\n    return \'The \' + argumentName + \' has unexpected type of "\' + {}.toString.call(inputState).match(/\\s([a-z|A-Z]+)/)[1] + \'". Expected argument to be an object with the following \' + (\'keys: "\' + reducerKeys.join(\'", "\') + \'"\');\n  }\n\n  var unexpectedKeys = Object.keys(inputState).filter(function (key) {\n    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];\n  });\n\n  unexpectedKeys.forEach(function (key) {\n    unexpectedKeyCache[key] = true;\n  });\n\n  if (unexpectedKeys.length > 0) {\n    return \'Unexpected \' + (unexpectedKeys.length > 1 ? \'keys\' : \'key\') + \' \' + (\'"\' + unexpectedKeys.join(\'", "\') + \'" found in \' + argumentName + \'. \') + \'Expected to find one of the known reducer keys instead: \' + (\'"\' + reducerKeys.join(\'", "\') + \'". Unexpected keys will be ignored.\');\n  }\n}\n\nfunction assertReducerShape(reducers) {\n  Object.keys(reducers).forEach(function (key) {\n    var reducer = reducers[key];\n    var initialState = reducer(undefined, { type: ActionTypes.INIT });\n\n    if (typeof initialState === \'undefined\') {\n      throw new Error(\'Reducer "\' + key + \'" returned undefined during initialization. \' + \'If the state passed to the reducer is undefined, you must \' + \'explicitly return the initial state. The initial state may \' + \'not be undefined. If you don\\\'t want to set a value for this reducer, \' + \'you can use null instead of undefined.\');\n    }\n\n    var type = \'@@redux/PROBE_UNKNOWN_ACTION_\' + Math.random().toString(36).substring(7).split(\'\').join(\'.\');\n    if (typeof reducer(undefined, { type: type }) === \'undefined\') {\n      throw new Error(\'Reducer "\' + key + \'" returned undefined when probed with a random type. \' + (\'Don\\\'t try to handle \' + ActionTypes.INIT + \' or other actions in "redux/*" \') + \'namespace. They are considered private. Instead, you must return the \' + \'current state for any unknown actions, unless it is undefined, \' + \'in which case you must return the initial state, regardless of the \' + \'action type. The initial state may not be undefined, but can be null.\');\n    }\n  });\n}\n\n/**\n * Turns an object whose values are different reducer functions, into a single\n * reducer function. It will call every child reducer, and gather their results\n * into a single state object, whose keys correspond to the keys of the passed\n * reducer functions.\n *\n * @param {Object} reducers An object whose values correspond to different\n * reducer functions that need to be combined into one. One handy way to obtain\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\n * undefined for any action. Instead, they should return their initial state\n * if the state passed to them was undefined, and the current state for any\n * unrecognized action.\n *\n * @returns {Function} A reducer function that invokes every reducer inside the\n * passed object, and builds a state object with the same shape.\n */\nfunction combineReducers(reducers) {\n  var reducerKeys = Object.keys(reducers);\n  var finalReducers = {};\n  for (var i = 0; i < reducerKeys.length; i++) {\n    var key = reducerKeys[i];\n\n    if (false) {}\n\n    if (typeof reducers[key] === \'function\') {\n      finalReducers[key] = reducers[key];\n    }\n  }\n  var finalReducerKeys = Object.keys(finalReducers);\n\n  var unexpectedKeyCache = void 0;\n  if (false) {}\n\n  var shapeAssertionError = void 0;\n  try {\n    assertReducerShape(finalReducers);\n  } catch (e) {\n    shapeAssertionError = e;\n  }\n\n  return function combination() {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var action = arguments[1];\n\n    if (shapeAssertionError) {\n      throw shapeAssertionError;\n    }\n\n    if (false) { var warningMessage; }\n\n    var hasChanged = false;\n    var nextState = {};\n    for (var _i = 0; _i < finalReducerKeys.length; _i++) {\n      var _key = finalReducerKeys[_i];\n      var reducer = finalReducers[_key];\n      var previousStateForKey = state[_key];\n      var nextStateForKey = reducer(previousStateForKey, action);\n      if (typeof nextStateForKey === \'undefined\') {\n        var errorMessage = getUndefinedStateErrorMessage(_key, action);\n        throw new Error(errorMessage);\n      }\n      nextState[_key] = nextStateForKey;\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n    }\n    return hasChanged ? nextState : state;\n  };\n}\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux/es/bindActionCreators.js\nfunction bindActionCreator(actionCreator, dispatch) {\n  return function () {\n    return dispatch(actionCreator.apply(undefined, arguments));\n  };\n}\n\n/**\n * Turns an object whose values are action creators, into an object with the\n * same keys, but with every function wrapped into a `dispatch` call so they\n * may be invoked directly. This is just a convenience method, as you can call\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\n *\n * For convenience, you can also pass a single function as the first argument,\n * and get a function in return.\n *\n * @param {Function|Object} actionCreators An object whose values are action\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\n * syntax. You may also pass a single function.\n *\n * @param {Function} dispatch The `dispatch` function available on your Redux\n * store.\n *\n * @returns {Function|Object} The object mimicking the original object, but with\n * every action creator wrapped into the `dispatch` call. If you passed a\n * function as `actionCreators`, the return value will also be a single\n * function.\n */\nfunction bindActionCreators(actionCreators, dispatch) {\n  if (typeof actionCreators === \'function\') {\n    return bindActionCreator(actionCreators, dispatch);\n  }\n\n  if (typeof actionCreators !== \'object\' || actionCreators === null) {\n    throw new Error(\'bindActionCreators expected an object or a function, instead received \' + (actionCreators === null ? \'null\' : typeof actionCreators) + \'. \' + \'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?\');\n  }\n\n  var keys = Object.keys(actionCreators);\n  var boundActionCreators = {};\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var actionCreator = actionCreators[key];\n    if (typeof actionCreator === \'function\') {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\n    }\n  }\n  return boundActionCreators;\n}\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux/es/compose.js\n/**\n * Composes single-argument functions from right to left. The rightmost\n * function can take multiple arguments as it provides the signature for\n * the resulting composite function.\n *\n * @param {...Function} funcs The functions to compose.\n * @returns {Function} A function obtained by composing the argument functions\n * from right to left. For example, compose(f, g, h) is identical to doing\n * (...args) => f(g(h(...args))).\n */\n\nfunction compose() {\n  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n\n  if (funcs.length === 0) {\n    return function (arg) {\n      return arg;\n    };\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n\n  return funcs.reduce(function (a, b) {\n    return function () {\n      return a(b.apply(undefined, arguments));\n    };\n  });\n}\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux/es/applyMiddleware.js\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\n\n\n/**\n * Creates a store enhancer that applies middleware to the dispatch method\n * of the Redux store. This is handy for a variety of tasks, such as expressing\n * asynchronous actions in a concise manner, or logging every action payload.\n *\n * See `redux-thunk` package as an example of the Redux middleware.\n *\n * Because middleware is potentially asynchronous, this should be the first\n * store enhancer in the composition chain.\n *\n * Note that each middleware will be given the `dispatch` and `getState` functions\n * as named arguments.\n *\n * @param {...Function} middlewares The middleware chain to be applied.\n * @returns {Function} A store enhancer applying the middleware.\n */\nfunction applyMiddleware() {\n  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {\n    middlewares[_key] = arguments[_key];\n  }\n\n  return function (createStore) {\n    return function (reducer, preloadedState, enhancer) {\n      var store = createStore(reducer, preloadedState, enhancer);\n      var _dispatch = store.dispatch;\n      var chain = [];\n\n      var middlewareAPI = {\n        getState: store.getState,\n        dispatch: function dispatch(action) {\n          return _dispatch(action);\n        }\n      };\n      chain = middlewares.map(function (middleware) {\n        return middleware(middlewareAPI);\n      });\n      _dispatch = compose.apply(undefined, chain)(store.dispatch);\n\n      return _extends({}, store, {\n        dispatch: _dispatch\n      });\n    };\n  };\n}\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux/es/index.js\n\n\n\n\n\n\n\n/*\n* This is a dummy function to check if the function name has been altered by minification.\n* If the function has been minified and NODE_ENV !== \'production\', warn the user.\n*/\nfunction isCrushed() {}\n\nif (false) {}\n\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js\nvar objectWithoutPropertiesLoose = __webpack_require__(15);\nvar objectWithoutPropertiesLoose_default = /*#__PURE__*/__webpack_require__.n(objectWithoutPropertiesLoose);\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/lodash/isFunction.js\nvar isFunction = __webpack_require__(44);\nvar isFunction_default = /*#__PURE__*/__webpack_require__.n(isFunction);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/actionTypes.js\nvar prefix = \'@@redux-form/\';\nvar ARRAY_INSERT = prefix + "ARRAY_INSERT";\nvar ARRAY_MOVE = prefix + "ARRAY_MOVE";\nvar ARRAY_POP = prefix + "ARRAY_POP";\nvar ARRAY_PUSH = prefix + "ARRAY_PUSH";\nvar ARRAY_REMOVE = prefix + "ARRAY_REMOVE";\nvar ARRAY_REMOVE_ALL = prefix + "ARRAY_REMOVE_ALL";\nvar ARRAY_SHIFT = prefix + "ARRAY_SHIFT";\nvar ARRAY_SPLICE = prefix + "ARRAY_SPLICE";\nvar ARRAY_UNSHIFT = prefix + "ARRAY_UNSHIFT";\nvar ARRAY_SWAP = prefix + "ARRAY_SWAP";\nvar AUTOFILL = prefix + "AUTOFILL";\nvar BLUR = prefix + "BLUR";\nvar CHANGE = prefix + "CHANGE";\nvar CLEAR_FIELDS = prefix + "CLEAR_FIELDS";\nvar CLEAR_SUBMIT = prefix + "CLEAR_SUBMIT";\nvar CLEAR_SUBMIT_ERRORS = prefix + "CLEAR_SUBMIT_ERRORS";\nvar CLEAR_ASYNC_ERROR = prefix + "CLEAR_ASYNC_ERROR";\nvar DESTROY = prefix + "DESTROY";\nvar FOCUS = prefix + "FOCUS";\nvar INITIALIZE = prefix + "INITIALIZE";\nvar REGISTER_FIELD = prefix + "REGISTER_FIELD";\nvar RESET = prefix + "RESET";\nvar RESET_SECTION = prefix + "RESET_SECTION";\nvar SET_SUBMIT_FAILED = prefix + "SET_SUBMIT_FAILED";\nvar SET_SUBMIT_SUCCEEDED = prefix + "SET_SUBMIT_SUCCEEDED";\nvar START_ASYNC_VALIDATION = prefix + "START_ASYNC_VALIDATION";\nvar START_SUBMIT = prefix + "START_SUBMIT";\nvar STOP_ASYNC_VALIDATION = prefix + "STOP_ASYNC_VALIDATION";\nvar STOP_SUBMIT = prefix + "STOP_SUBMIT";\nvar SUBMIT = prefix + "SUBMIT";\nvar TOUCH = prefix + "TOUCH";\nvar UNREGISTER_FIELD = prefix + "UNREGISTER_FIELD";\nvar UNTOUCH = prefix + "UNTOUCH";\nvar UPDATE_SYNC_ERRORS = prefix + "UPDATE_SYNC_ERRORS";\nvar UPDATE_SYNC_WARNINGS = prefix + "UPDATE_SYNC_WARNINGS";\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/lodash/toPath.js\nvar toPath = __webpack_require__(24);\nvar toPath_default = /*#__PURE__*/__webpack_require__.n(toPath);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/deleteInWithCleanUp.js\n\n\nfunction createDeleteInWithCleanUp(structure) {\n  var shouldDeleteDefault = function shouldDeleteDefault(structure) {\n    return function (state, path) {\n      return structure.getIn(state, path) !== undefined;\n    };\n  };\n\n  var deepEqual = structure.deepEqual,\n      empty = structure.empty,\n      getIn = structure.getIn,\n      deleteIn = structure.deleteIn,\n      setIn = structure.setIn;\n  return function (shouldDelete) {\n    if (shouldDelete === void 0) {\n      shouldDelete = shouldDeleteDefault;\n    }\n\n    var deleteInWithCleanUp = function deleteInWithCleanUp(state, path) {\n      if (path[path.length - 1] === \']\') {\n        // array path\n        var pathTokens = toPath_default()(path);\n\n        pathTokens.pop();\n        var parent = getIn(state, pathTokens.join(\'.\'));\n        return parent ? setIn(state, path) : state;\n      }\n\n      var result = state;\n\n      if (shouldDelete(structure)(state, path)) {\n        result = deleteIn(state, path);\n      }\n\n      var dotIndex = path.lastIndexOf(\'.\');\n\n      if (dotIndex > 0) {\n        var parentPath = path.substring(0, dotIndex);\n\n        if (parentPath[parentPath.length - 1] !== \']\') {\n          var _parent = getIn(result, parentPath);\n\n          if (deepEqual(_parent, empty)) {\n            return deleteInWithCleanUp(result, parentPath);\n          }\n        }\n      }\n\n      return result;\n    };\n\n    return deleteInWithCleanUp;\n  };\n}\n\n/* harmony default export */ var es_deleteInWithCleanUp = (createDeleteInWithCleanUp);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/structure/plain/splice.js\nvar splice_splice = function splice(array, index, removeNum, value) {\n  array = array || [];\n\n  if (index < array.length) {\n    if (value === undefined && !removeNum) {\n      // inserting undefined\n      var _copy2 = [].concat(array);\n\n      _copy2.splice(index, 0, true); // temporary placeholder\n\n\n      _copy2[index] = undefined; // set to undefined\n\n      return _copy2;\n    }\n\n    if (value != null) {\n      var _copy3 = [].concat(array);\n\n      _copy3.splice(index, removeNum, value); // removing and adding\n\n\n      return _copy3;\n    }\n\n    var _copy = [].concat(array);\n\n    _copy.splice(index, removeNum); // removing\n\n\n    return _copy;\n  }\n\n  if (removeNum) {\n    // trying to remove non-existant item: return original array\n    return array;\n  } // trying to add outside of range: just set value\n\n\n  var copy = [].concat(array);\n  copy[index] = value;\n  return copy;\n};\n\n/* harmony default export */ var plain_splice = (splice_splice);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/structure/plain/getIn.js\n\n\nvar getIn_getIn = function getIn(state, field) {\n  if (!state) {\n    return state;\n  }\n\n  var path = toPath_default()(field);\n\n  var length = path.length;\n\n  if (!length) {\n    return undefined;\n  }\n\n  var result = state;\n\n  for (var i = 0; i < length && result; ++i) {\n    result = result[path[i]];\n  }\n\n  return result;\n};\n\n/* harmony default export */ var plain_getIn = (getIn_getIn);\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/@babel/runtime/helpers/extends.js\nvar helpers_extends = __webpack_require__(3);\nvar extends_default = /*#__PURE__*/__webpack_require__.n(helpers_extends);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/structure/plain/setIn.js\n\n\n\nvar setIn_setInWithPath = function setInWithPath(state, value, path, pathIndex) {\n  var _extends2;\n\n  if (pathIndex >= path.length) {\n    return value;\n  }\n\n  var first = path[pathIndex];\n  var firstState = state && (Array.isArray(state) ? state[Number(first)] : state[first]);\n  var next = setInWithPath(firstState, value, path, pathIndex + 1);\n\n  if (!state) {\n    if (isNaN(first)) {\n      var _ref;\n\n      return _ref = {}, _ref[first] = next, _ref;\n    }\n\n    var initialized = [];\n    initialized[parseInt(first, 10)] = next;\n    return initialized;\n  }\n\n  if (Array.isArray(state)) {\n    var copy = [].concat(state);\n    copy[parseInt(first, 10)] = next;\n    return copy;\n  }\n\n  return extends_default()({}, state, (_extends2 = {}, _extends2[first] = next, _extends2));\n};\n\nvar setIn_setIn = function setIn(state, field, value) {\n  return setIn_setInWithPath(state, value, toPath_default()(field), 0);\n};\n\n/* harmony default export */ var plain_setIn = (setIn_setIn);\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/lodash/isEqualWith.js\nvar isEqualWith = __webpack_require__(46);\nvar isEqualWith_default = /*#__PURE__*/__webpack_require__.n(isEqualWith);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/structure/plain/deepEqual.js\n\n\n\nvar deepEqual_customizer = function customizer(obj, other) {\n  if (obj === other) return true;\n\n  if (!obj && !other) {\n    var objIsEmpty = obj === null || obj === undefined || obj === \'\';\n    var otherIsEmpty = other === null || other === undefined || other === \'\';\n    return objIsEmpty === otherIsEmpty;\n  }\n\n  if (obj && other && obj._error !== other._error) return false;\n  if (obj && other && obj._warning !== other._warning) return false;\n  if (react_default.a.isValidElement(obj) || react_default.a.isValidElement(other)) return false;\n};\n\nvar deepEqual_deepEqual = function deepEqual(a, b) {\n  return isEqualWith_default()(a, b, deepEqual_customizer);\n};\n\n/* harmony default export */ var plain_deepEqual = (deepEqual_deepEqual);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/structure/plain/deleteIn.js\n\n\n\nfunction deleteInWithPath(state, first) {\n  if (state === undefined || state === null || first === undefined || first === null) {\n    return state;\n  }\n\n  for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    rest[_key - 2] = arguments[_key];\n  }\n\n  if (rest.length) {\n    if (Array.isArray(state)) {\n      if (isNaN(first)) {\n        throw new Error("Must access array elements with a number, not \\"" + String(first) + "\\".");\n      }\n\n      var firstIndex = Number(first);\n\n      if (firstIndex < state.length) {\n        var result = deleteInWithPath.apply(void 0, [state && state[firstIndex]].concat(rest));\n\n        if (result !== state[firstIndex]) {\n          var copy = [].concat(state);\n          copy[firstIndex] = result;\n          return copy;\n        }\n      }\n\n      return state;\n    }\n\n    if (first in state) {\n      var _extends2;\n\n      var _result = deleteInWithPath.apply(void 0, [state && state[first]].concat(rest));\n\n      return state[first] === _result ? state : extends_default()({}, state, (_extends2 = {}, _extends2[first] = _result, _extends2));\n    }\n\n    return state;\n  }\n\n  if (Array.isArray(state)) {\n    if (isNaN(first)) {\n      throw new Error("Cannot delete non-numerical index from an array. Given: \\"" + String(first));\n    }\n\n    var _firstIndex = Number(first);\n\n    if (_firstIndex < state.length) {\n      var _copy = [].concat(state);\n\n      _copy.splice(_firstIndex, 1);\n\n      return _copy;\n    }\n\n    return state;\n  }\n\n  if (first in state) {\n    var _copy2 = extends_default()({}, state);\n\n    delete _copy2[first];\n    return _copy2;\n  }\n\n  return state;\n}\n\nvar deleteIn_deleteIn = function deleteIn(state, field) {\n  return deleteInWithPath.apply(void 0, [state].concat(toPath_default()(field)));\n};\n\n/* harmony default export */ var plain_deleteIn = (deleteIn_deleteIn);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/structure/plain/keys.js\nfunction keys_keys(value) {\n  if (!value) {\n    return [];\n  }\n\n  if (Array.isArray(value)) {\n    return value.map(function (i) {\n      return i.name;\n    });\n  }\n\n  return Object.keys(value);\n}\n\n/* harmony default export */ var plain_keys = (keys_keys);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/structure/plain/index.js\n\n\n\n\n\n\nvar plain_structure = {\n  allowsArrayErrors: true,\n  empty: {},\n  emptyList: [],\n  getIn: plain_getIn,\n  setIn: plain_setIn,\n  deepEqual: plain_deepEqual,\n  deleteIn: plain_deleteIn,\n  forEach: function forEach(items, callback) {\n    return items.forEach(callback);\n  },\n  fromJS: function fromJS(value) {\n    return value;\n  },\n  keys: plain_keys,\n  size: function size(array) {\n    return array ? array.length : 0;\n  },\n  some: function some(items, callback) {\n    return items.some(callback);\n  },\n  splice: plain_splice,\n  equals: function equals(a, b) {\n    return b.every(function (val) {\n      return ~a.indexOf(val);\n    });\n  },\n  orderChanged: function orderChanged(a, b) {\n    return b.some(function (val, index) {\n      return val !== a[index];\n    });\n  },\n  toJS: function toJS(value) {\n    return value;\n  }\n};\n/* harmony default export */ var plain = (plain_structure);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/createReducer.js\n\n\n\n\n\n\nvar createReducer_shouldDelete = function shouldDelete(_ref) {\n  var getIn = _ref.getIn;\n  return function (state, path) {\n    var initialValuesPath = null;\n\n    if (/^values/.test(path)) {\n      initialValuesPath = path.replace(\'values\', \'initial\');\n    }\n\n    var initialValueComparison = initialValuesPath ? getIn(state, initialValuesPath) === undefined : true;\n    return getIn(state, path) !== undefined && initialValueComparison;\n  };\n};\n\nvar createReducer_isReduxFormAction = function isReduxFormAction(action) {\n  return action && action.type && action.type.length > prefix.length && action.type.substring(0, prefix.length) === prefix;\n};\n\nfunction createReducer(structure) {\n  var _behaviors;\n\n  var deepEqual = structure.deepEqual,\n      empty = structure.empty,\n      forEach = structure.forEach,\n      getIn = structure.getIn,\n      setIn = structure.setIn,\n      deleteIn = structure.deleteIn,\n      fromJS = structure.fromJS,\n      keys = structure.keys,\n      size = structure.size,\n      some = structure.some,\n      splice = structure.splice;\n  var deleteInWithCleanUp = es_deleteInWithCleanUp(structure)(createReducer_shouldDelete);\n  var plainDeleteInWithCleanUp = es_deleteInWithCleanUp(plain)(createReducer_shouldDelete);\n\n  var doSplice = function doSplice(state, key, field, index, removeNum, value, force) {\n    var existing = getIn(state, key + "." + field);\n    return existing || force ? setIn(state, key + "." + field, splice(existing, index, removeNum, value)) : state;\n  };\n\n  var doPlainSplice = function doPlainSplice(state, key, field, index, removeNum, value, force) {\n    var slice = getIn(state, key);\n    var existing = plain.getIn(slice, field);\n    return existing || force ? setIn(state, key, plain.setIn(slice, field, plain.splice(existing, index, removeNum, value))) : state;\n  };\n\n  var rootKeys = [\'values\', \'fields\', \'submitErrors\', \'asyncErrors\'];\n\n  var arraySplice = function arraySplice(state, field, index, removeNum, value) {\n    var result = state;\n    var nonValuesValue = value != null ? empty : undefined;\n    result = doSplice(result, \'values\', field, index, removeNum, value, true);\n    result = doSplice(result, \'fields\', field, index, removeNum, nonValuesValue);\n    result = doPlainSplice(result, \'syncErrors\', field, index, removeNum, undefined);\n    result = doPlainSplice(result, \'syncWarnings\', field, index, removeNum, undefined);\n    result = doSplice(result, \'submitErrors\', field, index, removeNum, undefined);\n    result = doSplice(result, \'asyncErrors\', field, index, removeNum, undefined);\n    return result;\n  };\n\n  var behaviors = (_behaviors = {}, _behaviors[ARRAY_INSERT] = function (state, _ref2) {\n    var _ref2$meta = _ref2.meta,\n        field = _ref2$meta.field,\n        index = _ref2$meta.index,\n        payload = _ref2.payload;\n    return arraySplice(state, field, index, 0, payload);\n  }, _behaviors[ARRAY_MOVE] = function (state, _ref3) {\n    var _ref3$meta = _ref3.meta,\n        field = _ref3$meta.field,\n        from = _ref3$meta.from,\n        to = _ref3$meta.to;\n    var array = getIn(state, "values." + field);\n    var length = array ? size(array) : 0;\n    var result = state;\n\n    if (length) {\n      rootKeys.forEach(function (key) {\n        var path = key + "." + field;\n\n        if (getIn(result, path)) {\n          var value = getIn(result, path + "[" + from + "]");\n          result = setIn(result, path, splice(getIn(result, path), from, 1)); // remove\n\n          result = setIn(result, path, splice(getIn(result, path), to, 0, value)); // insert\n        }\n      });\n    }\n\n    return result;\n  }, _behaviors[ARRAY_POP] = function (state, _ref4) {\n    var field = _ref4.meta.field;\n    var array = getIn(state, "values." + field);\n    var length = array ? size(array) : 0;\n    return length ? arraySplice(state, field, length - 1, 1) : state;\n  }, _behaviors[ARRAY_PUSH] = function (state, _ref5) {\n    var field = _ref5.meta.field,\n        payload = _ref5.payload;\n    var array = getIn(state, "values." + field);\n    var length = array ? size(array) : 0;\n    return arraySplice(state, field, length, 0, payload);\n  }, _behaviors[ARRAY_REMOVE] = function (state, _ref6) {\n    var _ref6$meta = _ref6.meta,\n        field = _ref6$meta.field,\n        index = _ref6$meta.index;\n    return arraySplice(state, field, index, 1);\n  }, _behaviors[ARRAY_REMOVE_ALL] = function (state, _ref7) {\n    var field = _ref7.meta.field;\n    var array = getIn(state, "values." + field);\n    var length = array ? size(array) : 0;\n    return length ? arraySplice(state, field, 0, length) : state;\n  }, _behaviors[ARRAY_SHIFT] = function (state, _ref8) {\n    var field = _ref8.meta.field;\n    return arraySplice(state, field, 0, 1);\n  }, _behaviors[ARRAY_SPLICE] = function (state, _ref9) {\n    var _ref9$meta = _ref9.meta,\n        field = _ref9$meta.field,\n        index = _ref9$meta.index,\n        removeNum = _ref9$meta.removeNum,\n        payload = _ref9.payload;\n    return arraySplice(state, field, index, removeNum, payload);\n  }, _behaviors[ARRAY_SWAP] = function (state, _ref10) {\n    var _ref10$meta = _ref10.meta,\n        field = _ref10$meta.field,\n        indexA = _ref10$meta.indexA,\n        indexB = _ref10$meta.indexB;\n    var result = state;\n    rootKeys.forEach(function (key) {\n      var valueA = getIn(result, key + "." + field + "[" + indexA + "]");\n      var valueB = getIn(result, key + "." + field + "[" + indexB + "]");\n\n      if (valueA !== undefined || valueB !== undefined) {\n        result = setIn(result, key + "." + field + "[" + indexA + "]", valueB);\n        result = setIn(result, key + "." + field + "[" + indexB + "]", valueA);\n      }\n    });\n    return result;\n  }, _behaviors[ARRAY_UNSHIFT] = function (state, _ref11) {\n    var field = _ref11.meta.field,\n        payload = _ref11.payload;\n    return arraySplice(state, field, 0, 0, payload);\n  }, _behaviors[AUTOFILL] = function (state, _ref12) {\n    var field = _ref12.meta.field,\n        payload = _ref12.payload;\n    var result = state;\n    result = deleteInWithCleanUp(result, "asyncErrors." + field);\n    result = deleteInWithCleanUp(result, "submitErrors." + field);\n    result = setIn(result, "fields." + field + ".autofilled", true);\n    result = setIn(result, "values." + field, payload);\n    return result;\n  }, _behaviors[BLUR] = function (state, _ref13) {\n    var _ref13$meta = _ref13.meta,\n        field = _ref13$meta.field,\n        touch = _ref13$meta.touch,\n        payload = _ref13.payload;\n    var result = state;\n    var initial = getIn(result, "initial." + field);\n\n    if (initial === undefined && payload === \'\') {\n      result = deleteInWithCleanUp(result, "values." + field);\n    } else if (payload !== undefined) {\n      result = setIn(result, "values." + field, payload);\n    }\n\n    if (field === getIn(result, \'active\')) {\n      result = deleteIn(result, \'active\');\n    }\n\n    result = deleteIn(result, "fields." + field + ".active");\n\n    if (touch) {\n      result = setIn(result, "fields." + field + ".touched", true);\n      result = setIn(result, \'anyTouched\', true);\n    }\n\n    return result;\n  }, _behaviors[CHANGE] = function (state, _ref14) {\n    var _ref14$meta = _ref14.meta,\n        field = _ref14$meta.field,\n        touch = _ref14$meta.touch,\n        persistentSubmitErrors = _ref14$meta.persistentSubmitErrors,\n        payload = _ref14.payload;\n    var result = state;\n    var initial = getIn(result, "initial." + field);\n\n    if (initial === undefined && payload === \'\') {\n      result = deleteInWithCleanUp(result, "values." + field);\n    } else if (isFunction_default()(payload)) {\n      var fieldCurrentValue = getIn(state, "values." + field);\n      result = setIn(result, "values." + field, payload(fieldCurrentValue, state.values));\n    } else if (payload !== undefined) {\n      result = setIn(result, "values." + field, payload);\n    }\n\n    result = deleteInWithCleanUp(result, "asyncErrors." + field);\n\n    if (!persistentSubmitErrors) {\n      result = deleteInWithCleanUp(result, "submitErrors." + field);\n    }\n\n    result = deleteInWithCleanUp(result, "fields." + field + ".autofilled");\n\n    if (touch) {\n      result = setIn(result, "fields." + field + ".touched", true);\n      result = setIn(result, \'anyTouched\', true);\n    }\n\n    return result;\n  }, _behaviors[CLEAR_SUBMIT] = function (state) {\n    return deleteIn(state, \'triggerSubmit\');\n  }, _behaviors[CLEAR_SUBMIT_ERRORS] = function (state) {\n    var result = state;\n    result = deleteInWithCleanUp(result, \'submitErrors\');\n    result = deleteIn(result, \'error\');\n    return result;\n  }, _behaviors[CLEAR_ASYNC_ERROR] = function (state, _ref15) {\n    var field = _ref15.meta.field;\n    return deleteIn(state, "asyncErrors." + field);\n  }, _behaviors[CLEAR_FIELDS] = function (state, _ref16) {\n    var _ref16$meta = _ref16.meta,\n        keepTouched = _ref16$meta.keepTouched,\n        persistentSubmitErrors = _ref16$meta.persistentSubmitErrors,\n        fields = _ref16$meta.fields;\n    var result = state;\n    fields.forEach(function (field) {\n      result = deleteInWithCleanUp(result, "values." + field);\n      result = deleteInWithCleanUp(result, "asyncErrors." + field);\n\n      if (!persistentSubmitErrors) {\n        result = deleteInWithCleanUp(result, "submitErrors." + field);\n      }\n\n      result = deleteInWithCleanUp(result, "fields." + field + ".autofilled");\n\n      if (!keepTouched) {\n        result = deleteIn(result, "fields." + field + ".touched");\n      }\n    });\n    var anyTouched = some(keys(getIn(result, \'registeredFields\')), function (key) {\n      return getIn(result, "fields." + key + ".touched");\n    });\n    result = anyTouched ? setIn(result, \'anyTouched\', true) : deleteIn(result, \'anyTouched\');\n    return result;\n  }, _behaviors[FOCUS] = function (state, _ref17) {\n    var field = _ref17.meta.field;\n    var result = state;\n    var previouslyActive = getIn(state, \'active\');\n    result = deleteIn(result, "fields." + previouslyActive + ".active");\n    result = setIn(result, "fields." + field + ".visited", true);\n    result = setIn(result, "fields." + field + ".active", true);\n    result = setIn(result, \'active\', field);\n    return result;\n  }, _behaviors[INITIALIZE] = function (state, _ref18) {\n    var payload = _ref18.payload,\n        _ref18$meta = _ref18.meta,\n        keepDirty = _ref18$meta.keepDirty,\n        keepSubmitSucceeded = _ref18$meta.keepSubmitSucceeded,\n        updateUnregisteredFields = _ref18$meta.updateUnregisteredFields,\n        keepValues = _ref18$meta.keepValues;\n    var mapData = fromJS(payload);\n    var result = empty; // clean all field state\n    // persist old warnings, they will get recalculated if the new form values are different from the old values\n\n    var warning = getIn(state, \'warning\');\n\n    if (warning) {\n      result = setIn(result, \'warning\', warning);\n    }\n\n    var syncWarnings = getIn(state, \'syncWarnings\');\n\n    if (syncWarnings) {\n      result = setIn(result, \'syncWarnings\', syncWarnings);\n    } // persist old errors, they will get recalculated if the new form values are different from the old values\n\n\n    var error = getIn(state, \'error\');\n\n    if (error) {\n      result = setIn(result, \'error\', error);\n    }\n\n    var syncErrors = getIn(state, \'syncErrors\');\n\n    if (syncErrors) {\n      result = setIn(result, \'syncErrors\', syncErrors);\n    }\n\n    var registeredFields = getIn(state, \'registeredFields\');\n\n    if (registeredFields) {\n      result = setIn(result, \'registeredFields\', registeredFields);\n    }\n\n    var previousValues = getIn(state, \'values\');\n    var previousInitialValues = getIn(state, \'initial\');\n    var newInitialValues = mapData;\n    var newValues = previousValues;\n\n    if (keepDirty && registeredFields) {\n      if (!deepEqual(newInitialValues, previousInitialValues)) {\n        //\n        // Keep the value of dirty fields while updating the value of\n        // pristine fields. This way, apps can reinitialize forms while\n        // avoiding stomping on user edits.\n        //\n        // Note 1: The initialize action replaces all initial values\n        // regardless of keepDirty.\n        //\n        // Note 2: When a field is dirty, keepDirty is enabled, and the field\n        // value is the same as the new initial value for the field, the\n        // initialize action causes the field to become pristine. That effect\n        // is what we want.\n        //\n        var overwritePristineValue = function overwritePristineValue(name) {\n          var previousInitialValue = getIn(previousInitialValues, name);\n          var previousValue = getIn(previousValues, name);\n\n          if (deepEqual(previousValue, previousInitialValue)) {\n            // Overwrite the old pristine value with the new pristine value\n            var newInitialValue = getIn(newInitialValues, name); // This check prevents any \'setIn\' call that would create useless\n            // nested objects, since the path to the new field value would\n            // evaluate to the same (especially for undefined values)\n\n            if (getIn(newValues, name) !== newInitialValue) {\n              newValues = setIn(newValues, name, newInitialValue);\n            }\n          }\n        };\n\n        if (!updateUnregisteredFields) {\n          forEach(keys(registeredFields), function (name) {\n            return overwritePristineValue(name);\n          });\n        }\n\n        forEach(keys(newInitialValues), function (name) {\n          var previousInitialValue = getIn(previousInitialValues, name);\n\n          if (typeof previousInitialValue === \'undefined\') {\n            // Add new values at the root level.\n            var newInitialValue = getIn(newInitialValues, name);\n            newValues = setIn(newValues, name, newInitialValue);\n          }\n\n          if (updateUnregisteredFields) {\n            overwritePristineValue(name);\n          }\n        });\n      }\n    } else {\n      newValues = newInitialValues;\n    }\n\n    if (keepValues) {\n      forEach(keys(previousValues), function (name) {\n        var previousValue = getIn(previousValues, name);\n        newValues = setIn(newValues, name, previousValue);\n      });\n      forEach(keys(previousInitialValues), function (name) {\n        var previousInitialValue = getIn(previousInitialValues, name);\n        newInitialValues = setIn(newInitialValues, name, previousInitialValue);\n      });\n    }\n\n    if (keepSubmitSucceeded && getIn(state, \'submitSucceeded\')) {\n      result = setIn(result, \'submitSucceeded\', true);\n    }\n\n    result = setIn(result, \'values\', newValues);\n    result = setIn(result, \'initial\', newInitialValues);\n    return result;\n  }, _behaviors[REGISTER_FIELD] = function (state, _ref19) {\n    var _ref19$payload = _ref19.payload,\n        name = _ref19$payload.name,\n        type = _ref19$payload.type;\n    var key = "registeredFields[\'" + name + "\']";\n    var field = getIn(state, key);\n\n    if (field) {\n      var count = getIn(field, \'count\') + 1;\n      field = setIn(field, \'count\', count);\n    } else {\n      field = fromJS({\n        name: name,\n        type: type,\n        count: 1\n      });\n    }\n\n    return setIn(state, key, field);\n  }, _behaviors[RESET] = function (state) {\n    var result = empty;\n    var registeredFields = getIn(state, \'registeredFields\');\n\n    if (registeredFields) {\n      result = setIn(result, \'registeredFields\', registeredFields);\n    }\n\n    var values = getIn(state, \'initial\');\n\n    if (values) {\n      result = setIn(result, \'values\', values);\n      result = setIn(result, \'initial\', values);\n    }\n\n    return result;\n  }, _behaviors[RESET_SECTION] = function (state, _ref20) {\n    var sections = _ref20.meta.sections;\n    var result = state;\n    sections.forEach(function (section) {\n      result = deleteInWithCleanUp(result, "asyncErrors." + section);\n      result = deleteInWithCleanUp(result, "submitErrors." + section);\n      result = deleteInWithCleanUp(result, "fields." + section);\n      var values = getIn(state, "initial." + section);\n      result = values ? setIn(result, "values." + section, values) : deleteInWithCleanUp(result, "values." + section);\n    });\n    var anyTouched = some(keys(getIn(result, \'registeredFields\')), function (key) {\n      return getIn(result, "fields." + key + ".touched");\n    });\n    result = anyTouched ? setIn(result, \'anyTouched\', true) : deleteIn(result, \'anyTouched\');\n    return result;\n  }, _behaviors[SUBMIT] = function (state) {\n    return setIn(state, \'triggerSubmit\', true);\n  }, _behaviors[START_ASYNC_VALIDATION] = function (state, _ref21) {\n    var field = _ref21.meta.field;\n    return setIn(state, \'asyncValidating\', field || true);\n  }, _behaviors[START_SUBMIT] = function (state) {\n    return setIn(state, \'submitting\', true);\n  }, _behaviors[STOP_ASYNC_VALIDATION] = function (state, _ref22) {\n    var payload = _ref22.payload;\n    var result = state;\n    result = deleteIn(result, \'asyncValidating\');\n\n    if (payload && Object.keys(payload).length) {\n      var _error = payload._error,\n          fieldErrors = objectWithoutPropertiesLoose_default()(payload, ["_error"]);\n\n      if (_error) {\n        result = setIn(result, \'error\', _error);\n      }\n\n      if (Object.keys(fieldErrors).length) {\n        result = setIn(result, \'asyncErrors\', fromJS(fieldErrors));\n      }\n    } else {\n      result = deleteIn(result, \'error\');\n      result = deleteIn(result, \'asyncErrors\');\n    }\n\n    return result;\n  }, _behaviors[STOP_SUBMIT] = function (state, _ref23) {\n    var payload = _ref23.payload;\n    var result = state;\n    result = deleteIn(result, \'submitting\');\n    result = deleteIn(result, \'submitFailed\');\n    result = deleteIn(result, \'submitSucceeded\');\n\n    if (payload && Object.keys(payload).length) {\n      var _error = payload._error,\n          fieldErrors = objectWithoutPropertiesLoose_default()(payload, ["_error"]);\n\n      if (_error) {\n        result = setIn(result, \'error\', _error);\n      } else {\n        result = deleteIn(result, \'error\');\n      }\n\n      if (Object.keys(fieldErrors).length) {\n        result = setIn(result, \'submitErrors\', fromJS(fieldErrors));\n      } else {\n        result = deleteIn(result, \'submitErrors\');\n      }\n\n      result = setIn(result, \'submitFailed\', true);\n    } else {\n      result = deleteIn(result, \'error\');\n      result = deleteIn(result, \'submitErrors\');\n    }\n\n    return result;\n  }, _behaviors[SET_SUBMIT_FAILED] = function (state, _ref24) {\n    var fields = _ref24.meta.fields;\n    var result = state;\n    result = setIn(result, \'submitFailed\', true);\n    result = deleteIn(result, \'submitSucceeded\');\n    result = deleteIn(result, \'submitting\');\n    fields.forEach(function (field) {\n      return result = setIn(result, "fields." + field + ".touched", true);\n    });\n\n    if (fields.length) {\n      result = setIn(result, \'anyTouched\', true);\n    }\n\n    return result;\n  }, _behaviors[SET_SUBMIT_SUCCEEDED] = function (state) {\n    var result = state;\n    result = deleteIn(result, \'submitFailed\');\n    result = setIn(result, \'submitSucceeded\', true);\n    return result;\n  }, _behaviors[TOUCH] = function (state, _ref25) {\n    var fields = _ref25.meta.fields;\n    var result = state;\n    fields.forEach(function (field) {\n      return result = setIn(result, "fields." + field + ".touched", true);\n    });\n    result = setIn(result, \'anyTouched\', true);\n    return result;\n  }, _behaviors[UNREGISTER_FIELD] = function (state, _ref26) {\n    var _ref26$payload = _ref26.payload,\n        name = _ref26$payload.name,\n        destroyOnUnmount = _ref26$payload.destroyOnUnmount;\n    var result = state;\n    var key = "registeredFields[\'" + name + "\']";\n    var field = getIn(result, key);\n\n    if (!field) {\n      return result;\n    }\n\n    var count = getIn(field, \'count\') - 1;\n\n    if (count <= 0 && destroyOnUnmount) {\n      // Note: Cannot use deleteWithCleanUp here because of the flat nature of registeredFields\n      result = deleteIn(result, key);\n\n      if (deepEqual(getIn(result, \'registeredFields\'), empty)) {\n        result = deleteIn(result, \'registeredFields\');\n      }\n\n      var syncErrors = getIn(result, \'syncErrors\');\n\n      if (syncErrors) {\n        syncErrors = plainDeleteInWithCleanUp(syncErrors, name);\n\n        if (plain.deepEqual(syncErrors, plain.empty)) {\n          result = deleteIn(result, \'syncErrors\');\n        } else {\n          result = setIn(result, \'syncErrors\', syncErrors);\n        }\n      }\n\n      var syncWarnings = getIn(result, \'syncWarnings\');\n\n      if (syncWarnings) {\n        syncWarnings = plainDeleteInWithCleanUp(syncWarnings, name);\n\n        if (plain.deepEqual(syncWarnings, plain.empty)) {\n          result = deleteIn(result, \'syncWarnings\');\n        } else {\n          result = setIn(result, \'syncWarnings\', syncWarnings);\n        }\n      }\n\n      result = deleteInWithCleanUp(result, "submitErrors." + name);\n      result = deleteInWithCleanUp(result, "asyncErrors." + name);\n    } else {\n      field = setIn(field, \'count\', count);\n      result = setIn(result, key, field);\n    }\n\n    return result;\n  }, _behaviors[UNTOUCH] = function (state, _ref27) {\n    var fields = _ref27.meta.fields;\n    var result = state;\n    fields.forEach(function (field) {\n      return result = deleteIn(result, "fields." + field + ".touched");\n    });\n    var anyTouched = some(keys(getIn(result, \'registeredFields\')), function (key) {\n      return getIn(result, "fields." + key + ".touched");\n    });\n    result = anyTouched ? setIn(result, \'anyTouched\', true) : deleteIn(result, \'anyTouched\');\n    return result;\n  }, _behaviors[UPDATE_SYNC_ERRORS] = function (state, _ref28) {\n    var _ref28$payload = _ref28.payload,\n        syncErrors = _ref28$payload.syncErrors,\n        error = _ref28$payload.error;\n    var result = state;\n\n    if (error) {\n      result = setIn(result, \'error\', error);\n      result = setIn(result, \'syncError\', true);\n    } else {\n      result = deleteIn(result, \'error\');\n      result = deleteIn(result, \'syncError\');\n    }\n\n    if (Object.keys(syncErrors).length) {\n      result = setIn(result, \'syncErrors\', syncErrors);\n    } else {\n      result = deleteIn(result, \'syncErrors\');\n    }\n\n    return result;\n  }, _behaviors[UPDATE_SYNC_WARNINGS] = function (state, _ref29) {\n    var _ref29$payload = _ref29.payload,\n        syncWarnings = _ref29$payload.syncWarnings,\n        warning = _ref29$payload.warning;\n    var result = state;\n\n    if (warning) {\n      result = setIn(result, \'warning\', warning);\n    } else {\n      result = deleteIn(result, \'warning\');\n    }\n\n    if (Object.keys(syncWarnings).length) {\n      result = setIn(result, \'syncWarnings\', syncWarnings);\n    } else {\n      result = deleteIn(result, \'syncWarnings\');\n    }\n\n    return result;\n  }, _behaviors);\n\n  var reducer = function reducer(state, action) {\n    if (state === void 0) {\n      state = empty;\n    }\n\n    var behavior = behaviors[action.type];\n    return behavior ? behavior(state, action) : state;\n  };\n\n  var byForm = function byForm(reducer) {\n    return function (state, action) {\n      if (state === void 0) {\n        state = empty;\n      }\n\n      if (action === void 0) {\n        action = {\n          type: \'NONE\'\n        };\n      }\n\n      var form = action && action.meta && action.meta.form;\n\n      if (!form || !createReducer_isReduxFormAction(action)) {\n        return state;\n      }\n\n      if (action.type === DESTROY && action.meta && action.meta.form) {\n        return action.meta.form.reduce(function (result, form) {\n          return deleteInWithCleanUp(result, form);\n        }, state);\n      }\n\n      var formState = getIn(state, form);\n      var result = reducer(formState, action);\n      return result === formState ? state : setIn(state, form, result);\n    };\n  };\n  /**\n   * Adds additional functionality to the reducer\n   */\n\n\n  function decorate(target) {\n    target.plugin = function (reducers, config) {\n      var _this = this;\n\n      if (config === void 0) {\n        config = {};\n      }\n\n      // use \'function\' keyword to enable \'this\'\n      return decorate(function (state, action) {\n        if (state === void 0) {\n          state = empty;\n        }\n\n        if (action === void 0) {\n          action = {\n            type: \'NONE\'\n          };\n        }\n\n        var callPlugin = function callPlugin(processed, key) {\n          var previousState = getIn(processed, key);\n          var nextState = reducers[key](previousState, action, getIn(state, key));\n          return nextState !== previousState ? setIn(processed, key, nextState) : processed;\n        };\n\n        var processed = _this(state, action); // run through redux-form reducer\n\n\n        var form = action && action.meta && action.meta.form;\n\n        if (form && !config.receiveAllFormActions) {\n          // this is an action aimed at forms, so only give it to the specified form\'s plugin\n          return reducers[form] ? callPlugin(processed, form) : processed;\n        } else {\n          // this is not a form-specific action, so send it to all the plugins\n          return Object.keys(reducers).reduce(callPlugin, processed);\n        }\n      });\n    };\n\n    return target;\n  }\n\n  return decorate(byForm(reducer));\n}\n\n/* harmony default export */ var es_createReducer = (createReducer);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/reducer.js\n\n\n/* harmony default export */ var es_reducer = (es_createReducer(plain));\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/@babel/runtime/helpers/createClass.js\nvar createClass = __webpack_require__(7);\nvar createClass_default = /*#__PURE__*/__webpack_require__.n(createClass);\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/@babel/runtime/helpers/inheritsLoose.js\nvar inheritsLoose = __webpack_require__(16);\nvar inheritsLoose_default = /*#__PURE__*/__webpack_require__.n(inheritsLoose);\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/lodash/merge.js\nvar merge = __webpack_require__(102);\nvar merge_default = /*#__PURE__*/__webpack_require__.n(merge);\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/lodash/mapValues.js\nvar mapValues = __webpack_require__(103);\nvar mapValues_default = /*#__PURE__*/__webpack_require__.n(mapValues);\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-lifecycles-compat/react-lifecycles-compat.es.js\nvar react_lifecycles_compat_es = __webpack_require__(45);\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js\nvar hoist_non_react_statics_cjs = __webpack_require__(23);\nvar hoist_non_react_statics_cjs_default = /*#__PURE__*/__webpack_require__.n(hoist_non_react_statics_cjs);\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/invariant/browser.js\nvar browser = __webpack_require__(21);\nvar browser_default = /*#__PURE__*/__webpack_require__.n(browser);\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/is-promise/index.js\nvar is_promise = __webpack_require__(36);\nvar is_promise_default = /*#__PURE__*/__webpack_require__.n(is_promise);\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(1);\nvar prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/@babel/runtime/helpers/esm/inheritsLoose.js\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-redux/es/utils/PropTypes.js\n\nvar subscriptionShape = prop_types_default.a.shape({\n  trySubscribe: prop_types_default.a.func.isRequired,\n  tryUnsubscribe: prop_types_default.a.func.isRequired,\n  notifyNestedSubs: prop_types_default.a.func.isRequired,\n  isSubscribed: prop_types_default.a.func.isRequired\n});\nvar storeShape = prop_types_default.a.shape({\n  subscribe: prop_types_default.a.func.isRequired,\n  dispatch: prop_types_default.a.func.isRequired,\n  getState: prop_types_default.a.func.isRequired\n});\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-redux/es/utils/warning.js\n/**\n * Prints a warning in the console if it exists.\n *\n * @param {String} message The warning message.\n * @returns {void}\n */\nfunction utils_warning_warning(message) {\n  /* eslint-disable no-console */\n  if (typeof console !== \'undefined\' && typeof console.error === \'function\') {\n    console.error(message);\n  }\n  /* eslint-enable no-console */\n\n\n  try {\n    // This error was thrown as a convenience so that if you enable\n    // "break on all exceptions" in your console,\n    // it would pause the execution at this line.\n    throw new Error(message);\n    /* eslint-disable no-empty */\n  } catch (e) {}\n  /* eslint-enable no-empty */\n\n}\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-redux/es/components/Provider.js\n\n\n\n\n\nvar didWarnAboutReceivingStore = false;\n\nfunction warnAboutReceivingStore() {\n  if (didWarnAboutReceivingStore) {\n    return;\n  }\n\n  didWarnAboutReceivingStore = true;\n  utils_warning_warning(\'<Provider> does not support changing `store` on the fly. \' + \'It is most likely that you see this error because you updated to \' + \'Redux 2.x and React Redux 2.x which no longer hot reload reducers \' + \'automatically. See https://github.com/reduxjs/react-redux/releases/\' + \'tag/v2.0.0 for the migration instructions.\');\n}\n\nfunction createProvider(storeKey) {\n  var _Provider$childContex;\n\n  if (storeKey === void 0) {\n    storeKey = \'store\';\n  }\n\n  var subscriptionKey = storeKey + "Subscription";\n\n  var Provider =\n  /*#__PURE__*/\n  function (_Component) {\n    _inheritsLoose(Provider, _Component);\n\n    var _proto = Provider.prototype;\n\n    _proto.getChildContext = function getChildContext() {\n      var _ref;\n\n      return _ref = {}, _ref[storeKey] = this[storeKey], _ref[subscriptionKey] = null, _ref;\n    };\n\n    function Provider(props, context) {\n      var _this;\n\n      _this = _Component.call(this, props, context) || this;\n      _this[storeKey] = props.store;\n      return _this;\n    }\n\n    _proto.render = function render() {\n      return react["Children"].only(this.props.children);\n    };\n\n    return Provider;\n  }(react["Component"]);\n\n  if (false) {}\n\n  Provider.propTypes = {\n    store: storeShape.isRequired,\n    children: prop_types_default.a.element.isRequired\n  };\n  Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[storeKey] = storeShape.isRequired, _Provider$childContex[subscriptionKey] = subscriptionShape, _Provider$childContex);\n  return Provider;\n}\n/* harmony default export */ var components_Provider = (createProvider());\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");\n  }\n\n  return self;\n}\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/@babel/runtime/helpers/esm/extends.js\nfunction extends_extends() {\n  extends_extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return extends_extends.apply(this, arguments);\n}\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-is/index.js\nvar react_is = __webpack_require__(35);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-redux/es/utils/Subscription.js\n// encapsulates the subscription logic for connecting a component to the redux store, as\n// well as nesting subscriptions of descendant components, so that we can ensure the\n// ancestor components re-render before descendants\nvar CLEARED = null;\nvar nullListeners = {\n  notify: function notify() {}\n};\n\nfunction createListenerCollection() {\n  // the current/next pattern is copied from redux\'s createStore code.\n  // TODO: refactor+expose that code to be reusable here?\n  var current = [];\n  var next = [];\n  return {\n    clear: function clear() {\n      next = CLEARED;\n      current = CLEARED;\n    },\n    notify: function notify() {\n      var listeners = current = next;\n\n      for (var i = 0; i < listeners.length; i++) {\n        listeners[i]();\n      }\n    },\n    get: function get() {\n      return next;\n    },\n    subscribe: function subscribe(listener) {\n      var isSubscribed = true;\n      if (next === current) next = current.slice();\n      next.push(listener);\n      return function unsubscribe() {\n        if (!isSubscribed || current === CLEARED) return;\n        isSubscribed = false;\n        if (next === current) next = current.slice();\n        next.splice(next.indexOf(listener), 1);\n      };\n    }\n  };\n}\n\nvar Subscription =\n/*#__PURE__*/\nfunction () {\n  function Subscription(store, parentSub, onStateChange) {\n    this.store = store;\n    this.parentSub = parentSub;\n    this.onStateChange = onStateChange;\n    this.unsubscribe = null;\n    this.listeners = nullListeners;\n  }\n\n  var _proto = Subscription.prototype;\n\n  _proto.addNestedSub = function addNestedSub(listener) {\n    this.trySubscribe();\n    return this.listeners.subscribe(listener);\n  };\n\n  _proto.notifyNestedSubs = function notifyNestedSubs() {\n    this.listeners.notify();\n  };\n\n  _proto.isSubscribed = function isSubscribed() {\n    return Boolean(this.unsubscribe);\n  };\n\n  _proto.trySubscribe = function trySubscribe() {\n    if (!this.unsubscribe) {\n      this.unsubscribe = this.parentSub ? this.parentSub.addNestedSub(this.onStateChange) : this.store.subscribe(this.onStateChange);\n      this.listeners = createListenerCollection();\n    }\n  };\n\n  _proto.tryUnsubscribe = function tryUnsubscribe() {\n    if (this.unsubscribe) {\n      this.unsubscribe();\n      this.unsubscribe = null;\n      this.listeners.clear();\n      this.listeners = nullListeners;\n    }\n  };\n\n  return Subscription;\n}();\n\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-redux/es/components/connectAdvanced.js\n\n\n\n\n\n\n\n\n\n\nvar hotReloadingVersion = 0;\nvar dummyState = {};\n\nfunction noop() {}\n\nfunction makeSelectorStateful(sourceSelector, store) {\n  // wrap the selector in an object that tracks its results between runs.\n  var selector = {\n    run: function runComponentSelector(props) {\n      try {\n        var nextProps = sourceSelector(store.getState(), props);\n\n        if (nextProps !== selector.props || selector.error) {\n          selector.shouldComponentUpdate = true;\n          selector.props = nextProps;\n          selector.error = null;\n        }\n      } catch (error) {\n        selector.shouldComponentUpdate = true;\n        selector.error = error;\n      }\n    }\n  };\n  return selector;\n}\n\nfunction connectAdvanced(\n/*\n  selectorFactory is a func that is responsible for returning the selector function used to\n  compute new props from state, props, and dispatch. For example:\n     export default connectAdvanced((dispatch, options) => (state, props) => ({\n      thing: state.things[props.thingId],\n      saveThing: fields => dispatch(actionCreators.saveThing(props.thingId, fields)),\n    }))(YourComponent)\n   Access to dispatch is provided to the factory so selectorFactories can bind actionCreators\n  outside of their selector as an optimization. Options passed to connectAdvanced are passed to\n  the selectorFactory, along with displayName and WrappedComponent, as the second argument.\n   Note that selectorFactory is responsible for all caching/memoization of inbound and outbound\n  props. Do not use connectAdvanced directly without memoizing results between calls to your\n  selector, otherwise the Connect component will re-render on every state or props change.\n*/\nselectorFactory, // options object:\n_ref) {\n  var _contextTypes, _childContextTypes;\n\n  if (_ref === void 0) {\n    _ref = {};\n  }\n\n  var _ref2 = _ref,\n      _ref2$getDisplayName = _ref2.getDisplayName,\n      getDisplayName = _ref2$getDisplayName === void 0 ? function (name) {\n    return "ConnectAdvanced(" + name + ")";\n  } : _ref2$getDisplayName,\n      _ref2$methodName = _ref2.methodName,\n      methodName = _ref2$methodName === void 0 ? \'connectAdvanced\' : _ref2$methodName,\n      _ref2$renderCountProp = _ref2.renderCountProp,\n      renderCountProp = _ref2$renderCountProp === void 0 ? undefined : _ref2$renderCountProp,\n      _ref2$shouldHandleSta = _ref2.shouldHandleStateChanges,\n      shouldHandleStateChanges = _ref2$shouldHandleSta === void 0 ? true : _ref2$shouldHandleSta,\n      _ref2$storeKey = _ref2.storeKey,\n      storeKey = _ref2$storeKey === void 0 ? \'store\' : _ref2$storeKey,\n      _ref2$withRef = _ref2.withRef,\n      withRef = _ref2$withRef === void 0 ? false : _ref2$withRef,\n      connectOptions = _objectWithoutPropertiesLoose(_ref2, ["getDisplayName", "methodName", "renderCountProp", "shouldHandleStateChanges", "storeKey", "withRef"]);\n\n  var subscriptionKey = storeKey + \'Subscription\';\n  var version = hotReloadingVersion++;\n  var contextTypes = (_contextTypes = {}, _contextTypes[storeKey] = storeShape, _contextTypes[subscriptionKey] = subscriptionShape, _contextTypes);\n  var childContextTypes = (_childContextTypes = {}, _childContextTypes[subscriptionKey] = subscriptionShape, _childContextTypes);\n  return function wrapWithConnect(WrappedComponent) {\n    browser_default()(Object(react_is["isValidElementType"])(WrappedComponent), "You must pass a component to the function returned by " + (methodName + ". Instead received " + JSON.stringify(WrappedComponent)));\n    var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || \'Component\';\n    var displayName = getDisplayName(wrappedComponentName);\n\n    var selectorFactoryOptions = extends_extends({}, connectOptions, {\n      getDisplayName: getDisplayName,\n      methodName: methodName,\n      renderCountProp: renderCountProp,\n      shouldHandleStateChanges: shouldHandleStateChanges,\n      storeKey: storeKey,\n      withRef: withRef,\n      displayName: displayName,\n      wrappedComponentName: wrappedComponentName,\n      WrappedComponent: WrappedComponent // TODO Actually fix our use of componentWillReceiveProps\n\n      /* eslint-disable react/no-deprecated */\n\n    });\n\n    var Connect =\n    /*#__PURE__*/\n    function (_Component) {\n      _inheritsLoose(Connect, _Component);\n\n      function Connect(props, context) {\n        var _this;\n\n        _this = _Component.call(this, props, context) || this;\n        _this.version = version;\n        _this.state = {};\n        _this.renderCount = 0;\n        _this.store = props[storeKey] || context[storeKey];\n        _this.propsMode = Boolean(props[storeKey]);\n        _this.setWrappedInstance = _this.setWrappedInstance.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n        browser_default()(_this.store, "Could not find \\"" + storeKey + "\\" in either the context or props of " + ("\\"" + displayName + "\\". Either wrap the root component in a <Provider>, ") + ("or explicitly pass \\"" + storeKey + "\\" as a prop to \\"" + displayName + "\\"."));\n\n        _this.initSelector();\n\n        _this.initSubscription();\n\n        return _this;\n      }\n\n      var _proto = Connect.prototype;\n\n      _proto.getChildContext = function getChildContext() {\n        var _ref3;\n\n        // If this component received store from props, its subscription should be transparent\n        // to any descendants receiving store+subscription from context; it passes along\n        // subscription passed to it. Otherwise, it shadows the parent subscription, which allows\n        // Connect to control ordering of notifications to flow top-down.\n        var subscription = this.propsMode ? null : this.subscription;\n        return _ref3 = {}, _ref3[subscriptionKey] = subscription || this.context[subscriptionKey], _ref3;\n      };\n\n      _proto.componentDidMount = function componentDidMount() {\n        if (!shouldHandleStateChanges) return; // componentWillMount fires during server side rendering, but componentDidMount and\n        // componentWillUnmount do not. Because of this, trySubscribe happens during ...didMount.\n        // Otherwise, unsubscription would never take place during SSR, causing a memory leak.\n        // To handle the case where a child component may have triggered a state change by\n        // dispatching an action in its componentWillMount, we have to re-run the select and maybe\n        // re-render.\n\n        this.subscription.trySubscribe();\n        this.selector.run(this.props);\n        if (this.selector.shouldComponentUpdate) this.forceUpdate();\n      };\n\n      _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n        this.selector.run(nextProps);\n      };\n\n      _proto.shouldComponentUpdate = function shouldComponentUpdate() {\n        return this.selector.shouldComponentUpdate;\n      };\n\n      _proto.componentWillUnmount = function componentWillUnmount() {\n        if (this.subscription) this.subscription.tryUnsubscribe();\n        this.subscription = null;\n        this.notifyNestedSubs = noop;\n        this.store = null;\n        this.selector.run = noop;\n        this.selector.shouldComponentUpdate = false;\n      };\n\n      _proto.getWrappedInstance = function getWrappedInstance() {\n        browser_default()(withRef, "To access the wrapped instance, you need to specify " + ("{ withRef: true } in the options argument of the " + methodName + "() call."));\n        return this.wrappedInstance;\n      };\n\n      _proto.setWrappedInstance = function setWrappedInstance(ref) {\n        this.wrappedInstance = ref;\n      };\n\n      _proto.initSelector = function initSelector() {\n        var sourceSelector = selectorFactory(this.store.dispatch, selectorFactoryOptions);\n        this.selector = makeSelectorStateful(sourceSelector, this.store);\n        this.selector.run(this.props);\n      };\n\n      _proto.initSubscription = function initSubscription() {\n        if (!shouldHandleStateChanges) return; // parentSub\'s source should match where store came from: props vs. context. A component\n        // connected to the store via props shouldn\'t use subscription from context, or vice versa.\n\n        var parentSub = (this.propsMode ? this.props : this.context)[subscriptionKey];\n        this.subscription = new Subscription(this.store, parentSub, this.onStateChange.bind(this)); // `notifyNestedSubs` is duplicated to handle the case where the component is unmounted in\n        // the middle of the notification loop, where `this.subscription` will then be null. An\n        // extra null check every change can be avoided by copying the method onto `this` and then\n        // replacing it with a no-op on unmount. This can probably be avoided if Subscription\'s\n        // listeners logic is changed to not call listeners that have been unsubscribed in the\n        // middle of the notification loop.\n\n        this.notifyNestedSubs = this.subscription.notifyNestedSubs.bind(this.subscription);\n      };\n\n      _proto.onStateChange = function onStateChange() {\n        this.selector.run(this.props);\n\n        if (!this.selector.shouldComponentUpdate) {\n          this.notifyNestedSubs();\n        } else {\n          this.componentDidUpdate = this.notifyNestedSubsOnComponentDidUpdate;\n          this.setState(dummyState);\n        }\n      };\n\n      _proto.notifyNestedSubsOnComponentDidUpdate = function notifyNestedSubsOnComponentDidUpdate() {\n        // `componentDidUpdate` is conditionally implemented when `onStateChange` determines it\n        // needs to notify nested subs. Once called, it unimplements itself until further state\n        // changes occur. Doing it this way vs having a permanent `componentDidUpdate` that does\n        // a boolean check every time avoids an extra method call most of the time, resulting\n        // in some perf boost.\n        this.componentDidUpdate = undefined;\n        this.notifyNestedSubs();\n      };\n\n      _proto.isSubscribed = function isSubscribed() {\n        return Boolean(this.subscription) && this.subscription.isSubscribed();\n      };\n\n      _proto.addExtraProps = function addExtraProps(props) {\n        if (!withRef && !renderCountProp && !(this.propsMode && this.subscription)) return props; // make a shallow copy so that fields added don\'t leak to the original selector.\n        // this is especially important for \'ref\' since that\'s a reference back to the component\n        // instance. a singleton memoized selector would then be holding a reference to the\n        // instance, preventing the instance from being garbage collected, and that would be bad\n\n        var withExtras = extends_extends({}, props);\n\n        if (withRef) withExtras.ref = this.setWrappedInstance;\n        if (renderCountProp) withExtras[renderCountProp] = this.renderCount++;\n        if (this.propsMode && this.subscription) withExtras[subscriptionKey] = this.subscription;\n        return withExtras;\n      };\n\n      _proto.render = function render() {\n        var selector = this.selector;\n        selector.shouldComponentUpdate = false;\n\n        if (selector.error) {\n          throw selector.error;\n        } else {\n          return Object(react["createElement"])(WrappedComponent, this.addExtraProps(selector.props));\n        }\n      };\n\n      return Connect;\n    }(react["Component"]);\n    /* eslint-enable react/no-deprecated */\n\n\n    Connect.WrappedComponent = WrappedComponent;\n    Connect.displayName = displayName;\n    Connect.childContextTypes = childContextTypes;\n    Connect.contextTypes = contextTypes;\n    Connect.propTypes = contextTypes;\n\n    if (false) {}\n\n    return hoist_non_react_statics_cjs_default()(Connect, WrappedComponent);\n  };\n}\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-redux/es/utils/shallowEqual.js\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nfunction shallowEqual_is(x, y) {\n  if (x === y) {\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\n\nfunction shallowEqual(objA, objB) {\n  if (shallowEqual_is(objA, objB)) return true;\n\n  if (typeof objA !== \'object\' || objA === null || typeof objB !== \'object\' || objB === null) {\n    return false;\n  }\n\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n  if (keysA.length !== keysB.length) return false;\n\n  for (var i = 0; i < keysA.length; i++) {\n    if (!hasOwn.call(objB, keysA[i]) || !shallowEqual_is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-redux/es/utils/isPlainObject.js\n/**\r\n * @param {any} obj The object to inspect.\r\n * @returns {boolean} True if the argument appears to be a plain object.\r\n */\nfunction isPlainObject_isPlainObject(obj) {\n  if (typeof obj !== \'object\' || obj === null) return false;\n  var proto = Object.getPrototypeOf(obj);\n  if (proto === null) return true;\n  var baseProto = proto;\n\n  while (Object.getPrototypeOf(baseProto) !== null) {\n    baseProto = Object.getPrototypeOf(baseProto);\n  }\n\n  return proto === baseProto;\n}\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-redux/es/utils/verifyPlainObject.js\n\n\nfunction verifyPlainObject(value, displayName, methodName) {\n  if (!isPlainObject_isPlainObject(value)) {\n    utils_warning_warning(methodName + "() in " + displayName + " must return a plain object. Instead received " + value + ".");\n  }\n}\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-redux/es/connect/wrapMapToProps.js\n\nfunction wrapMapToPropsConstant(getConstant) {\n  return function initConstantSelector(dispatch, options) {\n    var constant = getConstant(dispatch, options);\n\n    function constantSelector() {\n      return constant;\n    }\n\n    constantSelector.dependsOnOwnProps = false;\n    return constantSelector;\n  };\n} // dependsOnOwnProps is used by createMapToPropsProxy to determine whether to pass props as args\n// to the mapToProps function being wrapped. It is also used by makePurePropsSelector to determine\n// whether mapToProps needs to be invoked when props have changed.\n// \n// A length of one signals that mapToProps does not depend on props from the parent component.\n// A length of zero is assumed to mean mapToProps is getting args via arguments or ...args and\n// therefore not reporting its length accurately..\n\nfunction getDependsOnOwnProps(mapToProps) {\n  return mapToProps.dependsOnOwnProps !== null && mapToProps.dependsOnOwnProps !== undefined ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;\n} // Used by whenMapStateToPropsIsFunction and whenMapDispatchToPropsIsFunction,\n// this function wraps mapToProps in a proxy function which does several things:\n// \n//  * Detects whether the mapToProps function being called depends on props, which\n//    is used by selectorFactory to decide if it should reinvoke on props changes.\n//    \n//  * On first call, handles mapToProps if returns another function, and treats that\n//    new function as the true mapToProps for subsequent calls.\n//    \n//  * On first call, verifies the first result is a plain object, in order to warn\n//    the developer that their mapToProps function is not returning a valid result.\n//    \n\nfunction wrapMapToPropsFunc(mapToProps, methodName) {\n  return function initProxySelector(dispatch, _ref) {\n    var displayName = _ref.displayName;\n\n    var proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {\n      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch);\n    }; // allow detectFactoryAndVerify to get ownProps\n\n\n    proxy.dependsOnOwnProps = true;\n\n    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {\n      proxy.mapToProps = mapToProps;\n      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);\n      var props = proxy(stateOrDispatch, ownProps);\n\n      if (typeof props === \'function\') {\n        proxy.mapToProps = props;\n        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);\n        props = proxy(stateOrDispatch, ownProps);\n      }\n\n      if (false) {}\n      return props;\n    };\n\n    return proxy;\n  };\n}\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-redux/es/connect/mapDispatchToProps.js\n\n\nfunction whenMapDispatchToPropsIsFunction(mapDispatchToProps) {\n  return typeof mapDispatchToProps === \'function\' ? wrapMapToPropsFunc(mapDispatchToProps, \'mapDispatchToProps\') : undefined;\n}\nfunction whenMapDispatchToPropsIsMissing(mapDispatchToProps) {\n  return !mapDispatchToProps ? wrapMapToPropsConstant(function (dispatch) {\n    return {\n      dispatch: dispatch\n    };\n  }) : undefined;\n}\nfunction whenMapDispatchToPropsIsObject(mapDispatchToProps) {\n  return mapDispatchToProps && typeof mapDispatchToProps === \'object\' ? wrapMapToPropsConstant(function (dispatch) {\n    return bindActionCreators(mapDispatchToProps, dispatch);\n  }) : undefined;\n}\n/* harmony default export */ var connect_mapDispatchToProps = ([whenMapDispatchToPropsIsFunction, whenMapDispatchToPropsIsMissing, whenMapDispatchToPropsIsObject]);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-redux/es/connect/mapStateToProps.js\n\nfunction whenMapStateToPropsIsFunction(mapStateToProps) {\n  return typeof mapStateToProps === \'function\' ? wrapMapToPropsFunc(mapStateToProps, \'mapStateToProps\') : undefined;\n}\nfunction whenMapStateToPropsIsMissing(mapStateToProps) {\n  return !mapStateToProps ? wrapMapToPropsConstant(function () {\n    return {};\n  }) : undefined;\n}\n/* harmony default export */ var connect_mapStateToProps = ([whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing]);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-redux/es/connect/mergeProps.js\n\n\nfunction defaultMergeProps(stateProps, dispatchProps, ownProps) {\n  return extends_extends({}, ownProps, stateProps, dispatchProps);\n}\nfunction wrapMergePropsFunc(mergeProps) {\n  return function initMergePropsProxy(dispatch, _ref) {\n    var displayName = _ref.displayName,\n        pure = _ref.pure,\n        areMergedPropsEqual = _ref.areMergedPropsEqual;\n    var hasRunOnce = false;\n    var mergedProps;\n    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {\n      var nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n\n      if (hasRunOnce) {\n        if (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;\n      } else {\n        hasRunOnce = true;\n        mergedProps = nextMergedProps;\n        if (false) {}\n      }\n\n      return mergedProps;\n    };\n  };\n}\nfunction whenMergePropsIsFunction(mergeProps) {\n  return typeof mergeProps === \'function\' ? wrapMergePropsFunc(mergeProps) : undefined;\n}\nfunction whenMergePropsIsOmitted(mergeProps) {\n  return !mergeProps ? function () {\n    return defaultMergeProps;\n  } : undefined;\n}\n/* harmony default export */ var connect_mergeProps = ([whenMergePropsIsFunction, whenMergePropsIsOmitted]);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-redux/es/connect/verifySubselectors.js\n\n\nfunction verify(selector, methodName, displayName) {\n  if (!selector) {\n    throw new Error("Unexpected value for " + methodName + " in " + displayName + ".");\n  } else if (methodName === \'mapStateToProps\' || methodName === \'mapDispatchToProps\') {\n    if (!selector.hasOwnProperty(\'dependsOnOwnProps\')) {\n      utils_warning_warning("The selector for " + methodName + " of " + displayName + " did not specify a value for dependsOnOwnProps.");\n    }\n  }\n}\n\nfunction verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps, displayName) {\n  verify(mapStateToProps, \'mapStateToProps\', displayName);\n  verify(mapDispatchToProps, \'mapDispatchToProps\', displayName);\n  verify(mergeProps, \'mergeProps\', displayName);\n}\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-redux/es/connect/selectorFactory.js\n\n\nfunction impureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch) {\n  return function impureFinalPropsSelector(state, ownProps) {\n    return mergeProps(mapStateToProps(state, ownProps), mapDispatchToProps(dispatch, ownProps), ownProps);\n  };\n}\nfunction pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, _ref) {\n  var areStatesEqual = _ref.areStatesEqual,\n      areOwnPropsEqual = _ref.areOwnPropsEqual,\n      areStatePropsEqual = _ref.areStatePropsEqual;\n  var hasRunAtLeastOnce = false;\n  var state;\n  var ownProps;\n  var stateProps;\n  var dispatchProps;\n  var mergedProps;\n\n  function handleFirstCall(firstState, firstOwnProps) {\n    state = firstState;\n    ownProps = firstOwnProps;\n    stateProps = mapStateToProps(state, ownProps);\n    dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    hasRunAtLeastOnce = true;\n    return mergedProps;\n  }\n\n  function handleNewPropsAndNewState() {\n    stateProps = mapStateToProps(state, ownProps);\n    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n\n  function handleNewProps() {\n    if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);\n    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n\n  function handleNewState() {\n    var nextStateProps = mapStateToProps(state, ownProps);\n    var statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);\n    stateProps = nextStateProps;\n    if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n\n  function handleSubsequentCalls(nextState, nextOwnProps) {\n    var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);\n    var stateChanged = !areStatesEqual(nextState, state);\n    state = nextState;\n    ownProps = nextOwnProps;\n    if (propsChanged && stateChanged) return handleNewPropsAndNewState();\n    if (propsChanged) return handleNewProps();\n    if (stateChanged) return handleNewState();\n    return mergedProps;\n  }\n\n  return function pureFinalPropsSelector(nextState, nextOwnProps) {\n    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);\n  };\n} // TODO: Add more comments\n// If pure is true, the selector returned by selectorFactory will memoize its results,\n// allowing connectAdvanced\'s shouldComponentUpdate to return false if final\n// props have not changed. If false, the selector will always return a new\n// object and shouldComponentUpdate will always return true.\n\nfunction finalPropsSelectorFactory(dispatch, _ref2) {\n  var initMapStateToProps = _ref2.initMapStateToProps,\n      initMapDispatchToProps = _ref2.initMapDispatchToProps,\n      initMergeProps = _ref2.initMergeProps,\n      options = _objectWithoutPropertiesLoose(_ref2, ["initMapStateToProps", "initMapDispatchToProps", "initMergeProps"]);\n\n  var mapStateToProps = initMapStateToProps(dispatch, options);\n  var mapDispatchToProps = initMapDispatchToProps(dispatch, options);\n  var mergeProps = initMergeProps(dispatch, options);\n\n  if (false) {}\n\n  var selectorFactory = options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory;\n  return selectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);\n}\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-redux/es/connect/connect.js\n\n\n\n\n\n\n\n\n/*\n  connect is a facade over connectAdvanced. It turns its args into a compatible\n  selectorFactory, which has the signature:\n\n    (dispatch, options) => (nextState, nextOwnProps) => nextFinalProps\n  \n  connect passes its args to connectAdvanced as options, which will in turn pass them to\n  selectorFactory each time a Connect component instance is instantiated or hot reloaded.\n\n  selectorFactory returns a final props selector from its mapStateToProps,\n  mapStateToPropsFactories, mapDispatchToProps, mapDispatchToPropsFactories, mergeProps,\n  mergePropsFactories, and pure args.\n\n  The resulting final props selector is called by the Connect component instance whenever\n  it receives new props or store state.\n */\n\nfunction match(arg, factories, name) {\n  for (var i = factories.length - 1; i >= 0; i--) {\n    var result = factories[i](arg);\n    if (result) return result;\n  }\n\n  return function (dispatch, options) {\n    throw new Error("Invalid value of type " + typeof arg + " for " + name + " argument when connecting component " + options.wrappedComponentName + ".");\n  };\n}\n\nfunction strictEqual(a, b) {\n  return a === b;\n} // createConnect with default args builds the \'official\' connect behavior. Calling it with\n// different options opens up some testing and extensibility scenarios\n\n\nfunction createConnect(_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n      _ref$connectHOC = _ref.connectHOC,\n      connectHOC = _ref$connectHOC === void 0 ? connectAdvanced : _ref$connectHOC,\n      _ref$mapStateToPropsF = _ref.mapStateToPropsFactories,\n      mapStateToPropsFactories = _ref$mapStateToPropsF === void 0 ? connect_mapStateToProps : _ref$mapStateToPropsF,\n      _ref$mapDispatchToPro = _ref.mapDispatchToPropsFactories,\n      mapDispatchToPropsFactories = _ref$mapDispatchToPro === void 0 ? connect_mapDispatchToProps : _ref$mapDispatchToPro,\n      _ref$mergePropsFactor = _ref.mergePropsFactories,\n      mergePropsFactories = _ref$mergePropsFactor === void 0 ? connect_mergeProps : _ref$mergePropsFactor,\n      _ref$selectorFactory = _ref.selectorFactory,\n      selectorFactory = _ref$selectorFactory === void 0 ? finalPropsSelectorFactory : _ref$selectorFactory;\n\n  return function connect(mapStateToProps, mapDispatchToProps, mergeProps, _ref2) {\n    if (_ref2 === void 0) {\n      _ref2 = {};\n    }\n\n    var _ref3 = _ref2,\n        _ref3$pure = _ref3.pure,\n        pure = _ref3$pure === void 0 ? true : _ref3$pure,\n        _ref3$areStatesEqual = _ref3.areStatesEqual,\n        areStatesEqual = _ref3$areStatesEqual === void 0 ? strictEqual : _ref3$areStatesEqual,\n        _ref3$areOwnPropsEqua = _ref3.areOwnPropsEqual,\n        areOwnPropsEqual = _ref3$areOwnPropsEqua === void 0 ? shallowEqual : _ref3$areOwnPropsEqua,\n        _ref3$areStatePropsEq = _ref3.areStatePropsEqual,\n        areStatePropsEqual = _ref3$areStatePropsEq === void 0 ? shallowEqual : _ref3$areStatePropsEq,\n        _ref3$areMergedPropsE = _ref3.areMergedPropsEqual,\n        areMergedPropsEqual = _ref3$areMergedPropsE === void 0 ? shallowEqual : _ref3$areMergedPropsE,\n        extraOptions = _objectWithoutPropertiesLoose(_ref3, ["pure", "areStatesEqual", "areOwnPropsEqual", "areStatePropsEqual", "areMergedPropsEqual"]);\n\n    var initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, \'mapStateToProps\');\n    var initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, \'mapDispatchToProps\');\n    var initMergeProps = match(mergeProps, mergePropsFactories, \'mergeProps\');\n    return connectHOC(selectorFactory, extends_extends({\n      // used in error messages\n      methodName: \'connect\',\n      // used to compute Connect\'s displayName from the wrapped component\'s displayName.\n      getDisplayName: function getDisplayName(name) {\n        return "Connect(" + name + ")";\n      },\n      // if mapStateToProps is falsy, the Connect component doesn\'t subscribe to store state changes\n      shouldHandleStateChanges: Boolean(mapStateToProps),\n      // passed through to selectorFactory\n      initMapStateToProps: initMapStateToProps,\n      initMapDispatchToProps: initMapDispatchToProps,\n      initMergeProps: initMergeProps,\n      pure: pure,\n      areStatesEqual: areStatesEqual,\n      areOwnPropsEqual: areOwnPropsEqual,\n      areStatePropsEqual: areStatePropsEqual,\n      areMergedPropsEqual: areMergedPropsEqual\n    }, extraOptions));\n  };\n}\n/* harmony default export */ var connect_connect = (createConnect());\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/react-redux/es/index.js\n\n\n\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/actions.js\n\n\n\nvar actions_arrayInsert = function arrayInsert(form, field, index, value) {\n  return {\n    type: ARRAY_INSERT,\n    meta: {\n      form: form,\n      field: field,\n      index: index\n    },\n    payload: value\n  };\n};\n\nvar actions_arrayMove = function arrayMove(form, field, from, to) {\n  return {\n    type: ARRAY_MOVE,\n    meta: {\n      form: form,\n      field: field,\n      from: from,\n      to: to\n    }\n  };\n};\n\nvar actions_arrayPop = function arrayPop(form, field) {\n  return {\n    type: ARRAY_POP,\n    meta: {\n      form: form,\n      field: field\n    }\n  };\n};\n\nvar actions_arrayPush = function arrayPush(form, field, value) {\n  return {\n    type: ARRAY_PUSH,\n    meta: {\n      form: form,\n      field: field\n    },\n    payload: value\n  };\n};\n\nvar actions_arrayRemove = function arrayRemove(form, field, index) {\n  return {\n    type: ARRAY_REMOVE,\n    meta: {\n      form: form,\n      field: field,\n      index: index\n    }\n  };\n};\n\nvar actions_arrayRemoveAll = function arrayRemoveAll(form, field) {\n  return {\n    type: ARRAY_REMOVE_ALL,\n    meta: {\n      form: form,\n      field: field\n    }\n  };\n};\n\nvar actions_arrayShift = function arrayShift(form, field) {\n  return {\n    type: ARRAY_SHIFT,\n    meta: {\n      form: form,\n      field: field\n    }\n  };\n};\n\nvar actions_arraySplice = function arraySplice(form, field, index, removeNum, value) {\n  var action = {\n    type: ARRAY_SPLICE,\n    meta: {\n      form: form,\n      field: field,\n      index: index,\n      removeNum: removeNum\n    }\n  };\n\n  if (value !== undefined) {\n    action.payload = value;\n  }\n\n  return action;\n};\n\nvar actions_arraySwap = function arraySwap(form, field, indexA, indexB) {\n  if (indexA === indexB) {\n    throw new Error(\'Swap indices cannot be equal\');\n  }\n\n  if (indexA < 0 || indexB < 0) {\n    throw new Error(\'Swap indices cannot be negative\');\n  }\n\n  return {\n    type: ARRAY_SWAP,\n    meta: {\n      form: form,\n      field: field,\n      indexA: indexA,\n      indexB: indexB\n    }\n  };\n};\n\nvar actions_arrayUnshift = function arrayUnshift(form, field, value) {\n  return {\n    type: ARRAY_UNSHIFT,\n    meta: {\n      form: form,\n      field: field\n    },\n    payload: value\n  };\n};\n\nvar actions_autofill = function autofill(form, field, value) {\n  return {\n    type: AUTOFILL,\n    meta: {\n      form: form,\n      field: field\n    },\n    payload: value\n  };\n};\n\nvar actions_blur = function blur(form, field, value, touch) {\n  return {\n    type: BLUR,\n    meta: {\n      form: form,\n      field: field,\n      touch: touch\n    },\n    payload: value\n  };\n};\n\nvar actions_change = function change(form, field, value, touch, persistentSubmitErrors) {\n  return {\n    type: CHANGE,\n    meta: {\n      form: form,\n      field: field,\n      touch: touch,\n      persistentSubmitErrors: persistentSubmitErrors\n    },\n    payload: value\n  };\n};\n\nvar actions_clearSubmit = function clearSubmit(form) {\n  return {\n    type: CLEAR_SUBMIT,\n    meta: {\n      form: form\n    }\n  };\n};\n\nvar actions_clearSubmitErrors = function clearSubmitErrors(form) {\n  return {\n    type: CLEAR_SUBMIT_ERRORS,\n    meta: {\n      form: form\n    }\n  };\n};\n\nvar actions_clearAsyncError = function clearAsyncError(form, field) {\n  return {\n    type: CLEAR_ASYNC_ERROR,\n    meta: {\n      form: form,\n      field: field\n    }\n  };\n};\n\nvar actions_clearFields = function clearFields(form, keepTouched, persistentSubmitErrors) {\n  for (var _len = arguments.length, fields = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n    fields[_key - 3] = arguments[_key];\n  }\n\n  return {\n    type: CLEAR_FIELDS,\n    meta: {\n      form: form,\n      keepTouched: keepTouched,\n      persistentSubmitErrors: persistentSubmitErrors,\n      fields: fields\n    }\n  };\n};\n\nvar actions_destroy = function destroy() {\n  for (var _len2 = arguments.length, form = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    form[_key2] = arguments[_key2];\n  }\n\n  return {\n    type: DESTROY,\n    meta: {\n      form: form\n    }\n  };\n};\n\nvar actions_focus = function focus(form, field) {\n  return {\n    type: FOCUS,\n    meta: {\n      form: form,\n      field: field\n    }\n  };\n};\n\nvar actions_initialize = function initialize(form, values, keepDirty, otherMeta) {\n  if (otherMeta === void 0) {\n    otherMeta = {};\n  }\n\n  if (keepDirty instanceof Object) {\n    otherMeta = keepDirty;\n    keepDirty = false;\n  }\n\n  return {\n    type: INITIALIZE,\n    meta: extends_default()({\n      form: form,\n      keepDirty: keepDirty\n    }, otherMeta),\n    payload: values\n  };\n};\n\nvar actions_registerField = function registerField(form, name, type) {\n  return {\n    type: REGISTER_FIELD,\n    meta: {\n      form: form\n    },\n    payload: {\n      name: name,\n      type: type\n    }\n  };\n};\n\nvar actions_reset = function reset(form) {\n  return {\n    type: RESET,\n    meta: {\n      form: form\n    }\n  };\n};\n\nvar actions_resetSection = function resetSection(form) {\n  for (var _len3 = arguments.length, sections = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    sections[_key3 - 1] = arguments[_key3];\n  }\n\n  return {\n    type: RESET_SECTION,\n    meta: {\n      form: form,\n      sections: sections\n    }\n  };\n};\n\nvar actions_startAsyncValidation = function startAsyncValidation(form, field) {\n  return {\n    type: START_ASYNC_VALIDATION,\n    meta: {\n      form: form,\n      field: field\n    }\n  };\n};\n\nvar actions_startSubmit = function startSubmit(form) {\n  return {\n    type: START_SUBMIT,\n    meta: {\n      form: form\n    }\n  };\n};\n\nvar actions_stopAsyncValidation = function stopAsyncValidation(form, errors) {\n  return {\n    type: STOP_ASYNC_VALIDATION,\n    meta: {\n      form: form\n    },\n    payload: errors,\n    error: !!(errors && Object.keys(errors).length)\n  };\n};\n\nvar actions_stopSubmit = function stopSubmit(form, errors) {\n  return {\n    type: STOP_SUBMIT,\n    meta: {\n      form: form\n    },\n    payload: errors,\n    error: !!(errors && Object.keys(errors).length)\n  };\n};\n\nvar actions_submit = function submit(form) {\n  return {\n    type: SUBMIT,\n    meta: {\n      form: form\n    }\n  };\n};\n\nvar actions_setSubmitFailed = function setSubmitFailed(form) {\n  for (var _len4 = arguments.length, fields = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    fields[_key4 - 1] = arguments[_key4];\n  }\n\n  return {\n    type: SET_SUBMIT_FAILED,\n    meta: {\n      form: form,\n      fields: fields\n    },\n    error: true\n  };\n};\n\nvar actions_setSubmitSucceeded = function setSubmitSucceeded(form) {\n  for (var _len5 = arguments.length, fields = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n    fields[_key5 - 1] = arguments[_key5];\n  }\n\n  return {\n    type: SET_SUBMIT_SUCCEEDED,\n    meta: {\n      form: form,\n      fields: fields\n    },\n    error: false\n  };\n};\n\nvar actions_touch = function touch(form) {\n  for (var _len6 = arguments.length, fields = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n    fields[_key6 - 1] = arguments[_key6];\n  }\n\n  return {\n    type: TOUCH,\n    meta: {\n      form: form,\n      fields: fields\n    }\n  };\n};\n\nvar actions_unregisterField = function unregisterField(form, name, destroyOnUnmount) {\n  if (destroyOnUnmount === void 0) {\n    destroyOnUnmount = true;\n  }\n\n  return {\n    type: UNREGISTER_FIELD,\n    meta: {\n      form: form\n    },\n    payload: {\n      name: name,\n      destroyOnUnmount: destroyOnUnmount\n    }\n  };\n};\n\nvar actions_untouch = function untouch(form) {\n  for (var _len7 = arguments.length, fields = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n    fields[_key7 - 1] = arguments[_key7];\n  }\n\n  return {\n    type: UNTOUCH,\n    meta: {\n      form: form,\n      fields: fields\n    }\n  };\n};\n\nvar actions_updateSyncErrors = function updateSyncErrors(form, syncErrors, error) {\n  if (syncErrors === void 0) {\n    syncErrors = {};\n  }\n\n  return {\n    type: UPDATE_SYNC_ERRORS,\n    meta: {\n      form: form\n    },\n    payload: {\n      syncErrors: syncErrors,\n      error: error\n    }\n  };\n};\n\nvar actions_updateSyncWarnings = function updateSyncWarnings(form, syncWarnings, warning) {\n  if (syncWarnings === void 0) {\n    syncWarnings = {};\n  }\n\n  return {\n    type: UPDATE_SYNC_WARNINGS,\n    meta: {\n      form: form\n    },\n    payload: {\n      syncWarnings: syncWarnings,\n      warning: warning\n    }\n  };\n};\n\nvar actions = {\n  arrayInsert: actions_arrayInsert,\n  arrayMove: actions_arrayMove,\n  arrayPop: actions_arrayPop,\n  arrayPush: actions_arrayPush,\n  arrayRemove: actions_arrayRemove,\n  arrayRemoveAll: actions_arrayRemoveAll,\n  arrayShift: actions_arrayShift,\n  arraySplice: actions_arraySplice,\n  arraySwap: actions_arraySwap,\n  arrayUnshift: actions_arrayUnshift,\n  autofill: actions_autofill,\n  blur: actions_blur,\n  change: actions_change,\n  clearFields: actions_clearFields,\n  clearSubmit: actions_clearSubmit,\n  clearSubmitErrors: actions_clearSubmitErrors,\n  clearAsyncError: actions_clearAsyncError,\n  destroy: actions_destroy,\n  focus: actions_focus,\n  initialize: actions_initialize,\n  registerField: actions_registerField,\n  reset: actions_reset,\n  resetSection: actions_resetSection,\n  startAsyncValidation: actions_startAsyncValidation,\n  startSubmit: actions_startSubmit,\n  stopAsyncValidation: actions_stopAsyncValidation,\n  stopSubmit: actions_stopSubmit,\n  submit: actions_submit,\n  setSubmitFailed: actions_setSubmitFailed,\n  setSubmitSucceeded: actions_setSubmitSucceeded,\n  touch: actions_touch,\n  unregisterField: actions_unregisterField,\n  untouch: actions_untouch,\n  updateSyncErrors: actions_updateSyncErrors,\n  updateSyncWarnings: actions_updateSyncWarnings\n};\n/* harmony default export */ var es_actions = (actions);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/asyncValidation.js\n\n\nvar asyncValidation_asyncValidation = function asyncValidation(fn, start, stop, field) {\n  start(field);\n  var promise = fn();\n\n  if (!is_promise_default()(promise)) {\n    throw new Error(\'asyncValidate function passed to reduxForm must return a promise\');\n  }\n\n  var handleErrors = function handleErrors(rejected) {\n    return function (errors) {\n      if (rejected) {\n        if (errors && Object.keys(errors).length) {\n          stop(errors);\n          return errors;\n        } else {\n          stop();\n          throw new Error(\'Asynchronous validation promise was rejected without errors.\');\n        }\n      }\n\n      stop();\n      return Promise.resolve();\n    };\n  };\n\n  return promise.then(handleErrors(false), handleErrors(true));\n};\n\n/* harmony default export */ var es_asyncValidation = (asyncValidation_asyncValidation);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/defaultShouldAsyncValidate.js\nvar defaultShouldAsyncValidate = function defaultShouldAsyncValidate(_ref) {\n  var initialized = _ref.initialized,\n      trigger = _ref.trigger,\n      pristine = _ref.pristine,\n      syncValidationPasses = _ref.syncValidationPasses;\n\n  if (!syncValidationPasses) {\n    return false;\n  }\n\n  switch (trigger) {\n    case \'blur\':\n    case \'change\':\n      // blurring\n      return true;\n\n    case \'submit\':\n      // submitting, so only async validate if form is dirty or was never initialized\n      // conversely, DON\'T async validate if the form is pristine just as it was initialized\n      return !pristine || !initialized;\n\n    default:\n      return false;\n  }\n};\n\n/* harmony default export */ var es_defaultShouldAsyncValidate = (defaultShouldAsyncValidate);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/defaultShouldValidate.js\nvar defaultShouldValidate = function defaultShouldValidate(_ref) {\n  var values = _ref.values,\n      nextProps = _ref.nextProps,\n      initialRender = _ref.initialRender,\n      lastFieldValidatorKeys = _ref.lastFieldValidatorKeys,\n      fieldValidatorKeys = _ref.fieldValidatorKeys,\n      structure = _ref.structure;\n\n  if (initialRender) {\n    return true;\n  }\n\n  return !structure.deepEqual(values, nextProps && nextProps.values) || !structure.deepEqual(lastFieldValidatorKeys, fieldValidatorKeys);\n};\n\n/* harmony default export */ var es_defaultShouldValidate = (defaultShouldValidate);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/defaultShouldError.js\nvar defaultShouldError = function defaultShouldError(_ref) {\n  var values = _ref.values,\n      nextProps = _ref.nextProps,\n      initialRender = _ref.initialRender,\n      lastFieldValidatorKeys = _ref.lastFieldValidatorKeys,\n      fieldValidatorKeys = _ref.fieldValidatorKeys,\n      structure = _ref.structure;\n\n  if (initialRender) {\n    return true;\n  }\n\n  return !structure.deepEqual(values, nextProps && nextProps.values) || !structure.deepEqual(lastFieldValidatorKeys, fieldValidatorKeys);\n};\n\n/* harmony default export */ var es_defaultShouldError = (defaultShouldError);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/defaultShouldWarn.js\nvar defaultShouldWarn = function defaultShouldWarn(_ref) {\n  var values = _ref.values,\n      nextProps = _ref.nextProps,\n      initialRender = _ref.initialRender,\n      lastFieldValidatorKeys = _ref.lastFieldValidatorKeys,\n      fieldValidatorKeys = _ref.fieldValidatorKeys,\n      structure = _ref.structure;\n\n  if (initialRender) {\n    return true;\n  }\n\n  return !structure.deepEqual(values, nextProps && nextProps.values) || !structure.deepEqual(lastFieldValidatorKeys, fieldValidatorKeys);\n};\n\n/* harmony default export */ var es_defaultShouldWarn = (defaultShouldWarn);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/events/isEvent.js\nvar isEvent = function isEvent(candidate) {\n  return !!(candidate && candidate.stopPropagation && candidate.preventDefault);\n};\n\n/* harmony default export */ var events_isEvent = (isEvent);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/events/silenceEvent.js\n\n\nvar silenceEvent_silenceEvent = function silenceEvent(event) {\n  var is = events_isEvent(event);\n\n  if (is) {\n    event.preventDefault();\n  }\n\n  return is;\n};\n\n/* harmony default export */ var events_silenceEvent = (silenceEvent_silenceEvent);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/events/silenceEvents.js\n\n\nvar silenceEvents_silenceEvents = function silenceEvents(fn) {\n  return function (event) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    return events_silenceEvent(event) ? fn.apply(void 0, args) : fn.apply(void 0, [event].concat(args));\n  };\n};\n\n/* harmony default export */ var events_silenceEvents = (silenceEvents_silenceEvents);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/generateValidator.js\n\n\nvar toArray = function toArray(value) {\n  return Array.isArray(value) ? value : [value];\n};\n\nvar getError = function getError(value, values, props, validators, name) {\n  var array = toArray(validators);\n\n  for (var i = 0; i < array.length; i++) {\n    var error = array[i](value, values, props, name);\n\n    if (error) {\n      return error;\n    }\n  }\n};\n\nvar generateValidator_generateValidator = function generateValidator(validators, _ref) {\n  var getIn = _ref.getIn;\n  return function (values, props) {\n    var errors = {};\n    Object.keys(validators).forEach(function (name) {\n      var value = getIn(values, name);\n      var error = getError(value, values, props, validators[name], name);\n\n      if (error) {\n        errors = plain.setIn(errors, name, error);\n      }\n    });\n    return errors;\n  };\n};\n\n/* harmony default export */ var es_generateValidator = (generateValidator_generateValidator);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/es6-error/es6/index.js\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _extendableBuiltin(cls) {\n  function ExtendableBuiltin() {\n    cls.apply(this, arguments);\n  }\n\n  ExtendableBuiltin.prototype = Object.create(cls.prototype, {\n    constructor: {\n      value: cls,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n\n  if (Object.setPrototypeOf) {\n    Object.setPrototypeOf(ExtendableBuiltin, cls);\n  } else {\n    ExtendableBuiltin.__proto__ = cls;\n  }\n\n  return ExtendableBuiltin;\n}\n\nvar ExtendableError = function (_extendableBuiltin2) {\n  _inherits(ExtendableError, _extendableBuiltin2);\n\n  function ExtendableError() {\n    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \'\';\n\n    _classCallCheck(this, ExtendableError);\n\n    // extending Error is weird and does not propagate `message`\n    var _this = _possibleConstructorReturn(this, (ExtendableError.__proto__ || Object.getPrototypeOf(ExtendableError)).call(this, message));\n\n    Object.defineProperty(_this, \'message\', {\n      configurable: true,\n      enumerable: false,\n      value: message,\n      writable: true\n    });\n\n    Object.defineProperty(_this, \'name\', {\n      configurable: true,\n      enumerable: false,\n      value: _this.constructor.name,\n      writable: true\n    });\n\n    if (Error.hasOwnProperty(\'captureStackTrace\')) {\n      Error.captureStackTrace(_this, _this.constructor);\n      return _possibleConstructorReturn(_this);\n    }\n\n    Object.defineProperty(_this, \'stack\', {\n      configurable: true,\n      enumerable: false,\n      value: new Error(message).stack,\n      writable: true\n    });\n    return _this;\n  }\n\n  return ExtendableError;\n}(_extendableBuiltin(Error));\n\n/* harmony default export */ var es6 = (ExtendableError);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/SubmissionError.js\n\n\n\nvar SubmissionError_SubmissionError =\n/*#__PURE__*/\nfunction (_ExtendableError) {\n  inheritsLoose_default()(SubmissionError, _ExtendableError);\n\n  function SubmissionError(errors) {\n    var _this;\n\n    _this = _ExtendableError.call(this, \'Submit Validation Failed\') || this;\n    _this.errors = errors;\n    return _this;\n  }\n\n  return SubmissionError;\n}(es6);\n\n/* harmony default export */ var es_SubmissionError = (SubmissionError_SubmissionError);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/handleSubmit.js\n\n\n\n\nvar handleSubmit_isSubmissionError = function isSubmissionError(error) {\n  return error && error.name === es_SubmissionError.name;\n};\n\nvar handleSubmit_mergeErrors = function mergeErrors(_ref) {\n  var asyncErrors = _ref.asyncErrors,\n      syncErrors = _ref.syncErrors;\n  return asyncErrors && typeof asyncErrors.merge === \'function\' ? asyncErrors.merge(syncErrors).toJS() : extends_default()({}, asyncErrors, syncErrors);\n};\n\nvar handleSubmit_handleSubmit = function handleSubmit(submit, props, valid, asyncValidate, fields) {\n  var dispatch = props.dispatch,\n      onSubmitFail = props.onSubmitFail,\n      onSubmitSuccess = props.onSubmitSuccess,\n      startSubmit = props.startSubmit,\n      stopSubmit = props.stopSubmit,\n      setSubmitFailed = props.setSubmitFailed,\n      setSubmitSucceeded = props.setSubmitSucceeded,\n      syncErrors = props.syncErrors,\n      asyncErrors = props.asyncErrors,\n      touch = props.touch,\n      values = props.values,\n      persistentSubmitErrors = props.persistentSubmitErrors;\n  touch.apply(void 0, Array.from(fields)); // mark all fields as touched\n\n  if (valid || persistentSubmitErrors) {\n    var doSubmit = function doSubmit() {\n      var result;\n\n      try {\n        result = submit(values, dispatch, props);\n      } catch (submitError) {\n        var error = handleSubmit_isSubmissionError(submitError) ? submitError.errors : undefined;\n        stopSubmit(error);\n        setSubmitFailed.apply(void 0, fields);\n\n        if (onSubmitFail) {\n          onSubmitFail(error, dispatch, submitError, props);\n        }\n\n        if (error || onSubmitFail) {\n          // if you\'ve provided an onSubmitFail callback, don\'t re-throw the error\n          return error;\n        } else {\n          throw submitError;\n        }\n      }\n\n      if (is_promise_default()(result)) {\n        startSubmit();\n        return result.then(function (submitResult) {\n          stopSubmit();\n          setSubmitSucceeded();\n\n          if (onSubmitSuccess) {\n            onSubmitSuccess(submitResult, dispatch, props);\n          }\n\n          return submitResult;\n        }, function (submitError) {\n          var error = handleSubmit_isSubmissionError(submitError) ? submitError.errors : undefined;\n          stopSubmit(error);\n          setSubmitFailed.apply(void 0, fields);\n\n          if (onSubmitFail) {\n            onSubmitFail(error, dispatch, submitError, props);\n          }\n\n          if (error || onSubmitFail) {\n            // if you\'ve provided an onSubmitFail callback, don\'t re-throw the error\n            return error;\n          } else {\n            throw submitError;\n          }\n        });\n      } else {\n        setSubmitSucceeded();\n\n        if (onSubmitSuccess) {\n          onSubmitSuccess(result, dispatch, props);\n        }\n      }\n\n      return result;\n    };\n\n    var asyncValidateResult = asyncValidate && asyncValidate();\n\n    if (asyncValidateResult) {\n      return asyncValidateResult.then(function (asyncErrors) {\n        if (asyncErrors) {\n          throw asyncErrors;\n        }\n\n        return doSubmit();\n      }).catch(function (asyncErrors) {\n        setSubmitFailed.apply(void 0, fields);\n\n        if (onSubmitFail) {\n          onSubmitFail(asyncErrors, dispatch, null, props);\n        }\n\n        return Promise.reject(asyncErrors);\n      });\n    } else {\n      return doSubmit();\n    }\n  } else {\n    setSubmitFailed.apply(void 0, fields);\n    var errors = handleSubmit_mergeErrors({\n      asyncErrors: asyncErrors,\n      syncErrors: syncErrors\n    });\n\n    if (onSubmitFail) {\n      onSubmitFail(errors, dispatch, null, props);\n    }\n\n    return errors;\n  }\n};\n\n/* harmony default export */ var es_handleSubmit = (handleSubmit_handleSubmit);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/hasError.js\nvar getErrorKeys = function getErrorKeys(name, type) {\n  switch (type) {\n    case \'Field\':\n      return [name, name + "._error"];\n\n    case \'FieldArray\':\n      return [name + "._error"];\n\n    default:\n      throw new Error(\'Unknown field type\');\n  }\n};\n\nvar createHasError = function createHasError(_ref) {\n  var getIn = _ref.getIn;\n\n  var hasError = function hasError(field, syncErrors, asyncErrors, submitErrors) {\n    if (!syncErrors && !asyncErrors && !submitErrors) {\n      return false;\n    }\n\n    var name = getIn(field, \'name\');\n    var type = getIn(field, \'type\');\n    return getErrorKeys(name, type).some(function (key) {\n      return getIn(syncErrors, key) || getIn(asyncErrors, key) || getIn(submitErrors, key);\n    });\n  };\n\n  return hasError;\n};\n\n/* harmony default export */ var es_hasError = (createHasError);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/selectors/isValid.js\n\n\nvar isValid_createIsValid = function createIsValid(structure) {\n  var getIn = structure.getIn,\n      keys = structure.keys;\n  var hasError = es_hasError(structure);\n  return function (form, getFormState, ignoreSubmitErrors) {\n    if (ignoreSubmitErrors === void 0) {\n      ignoreSubmitErrors = false;\n    }\n\n    return function (state) {\n      var nonNullGetFormState = getFormState || function (state) {\n        return getIn(state, \'form\');\n      };\n\n      var formState = nonNullGetFormState(state);\n      var syncError = getIn(formState, form + ".syncError");\n\n      if (syncError) {\n        return false;\n      }\n\n      if (!ignoreSubmitErrors) {\n        var error = getIn(formState, form + ".error");\n\n        if (error) {\n          return false;\n        }\n      }\n\n      var syncErrors = getIn(formState, form + ".syncErrors");\n      var asyncErrors = getIn(formState, form + ".asyncErrors");\n      var submitErrors = ignoreSubmitErrors ? undefined : getIn(formState, form + ".submitErrors");\n\n      if (!syncErrors && !asyncErrors && !submitErrors) {\n        return true;\n      }\n\n      var registeredFields = getIn(formState, form + ".registeredFields");\n\n      if (!registeredFields) {\n        return true;\n      }\n\n      return !keys(registeredFields).filter(function (name) {\n        return getIn(registeredFields, "[\'" + name + "\'].count") > 0;\n      }).some(function (name) {\n        return hasError(getIn(registeredFields, "[\'" + name + "\']"), syncErrors, asyncErrors, submitErrors);\n      });\n    };\n  };\n};\n\n/* harmony default export */ var selectors_isValid = (isValid_createIsValid);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/util/getDisplayName.js\nvar getDisplayName_getDisplayName = function getDisplayName(Comp) {\n  return Comp.displayName || Comp.name || \'Component\';\n};\n\n/* harmony default export */ var util_getDisplayName = (getDisplayName_getDisplayName);\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/util/isHotReloading.js\nvar isHotReloading = __webpack_require__(61);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/ReduxFormContext.js\n\n\n\n\nvar ReduxFormContext = react["createContext"](null);\nvar ReduxFormContext_withReduxForm = function withReduxForm(Component) {\n  var Hoc =\n  /*#__PURE__*/\n  function (_React$Component) {\n    inheritsLoose_default()(Hoc, _React$Component);\n\n    function Hoc() {\n      return _React$Component.apply(this, arguments) || this;\n    }\n\n    var _proto = Hoc.prototype;\n\n    _proto.render = function render() {\n      var _this$props = this.props,\n          forwardedRef = _this$props.forwardedRef,\n          rest = objectWithoutPropertiesLoose_default()(_this$props, ["forwardedRef"]);\n\n      return react["createElement"](ReduxFormContext.Consumer, {\n        children: function children(_reduxForm) {\n          return react["createElement"](Component, extends_default()({\n            _reduxForm: _reduxForm,\n            ref: forwardedRef\n          }, rest));\n        }\n      });\n    };\n\n    return Hoc;\n  }(react["Component"]);\n\n  var ref = react["forwardRef"](function (props, ref) {\n    return react["createElement"](Hoc, extends_default()({}, props, {\n      forwardedRef: ref\n    }));\n  });\n  ref.displayName = Component.displayName || Component.name || \'Component\';\n  return ref;\n};\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/createReduxForm.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar isClassComponent = function isClassComponent(Component) {\n  return Boolean(Component && Component.prototype && typeof Component.prototype.isReactComponent === \'object\');\n}; // extract field-specific actions\n\n\nvar createReduxForm_arrayInsert = es_actions.arrayInsert,\n    createReduxForm_arrayMove = es_actions.arrayMove,\n    createReduxForm_arrayPop = es_actions.arrayPop,\n    createReduxForm_arrayPush = es_actions.arrayPush,\n    createReduxForm_arrayRemove = es_actions.arrayRemove,\n    createReduxForm_arrayRemoveAll = es_actions.arrayRemoveAll,\n    createReduxForm_arrayShift = es_actions.arrayShift,\n    createReduxForm_arraySplice = es_actions.arraySplice,\n    createReduxForm_arraySwap = es_actions.arraySwap,\n    createReduxForm_arrayUnshift = es_actions.arrayUnshift,\n    createReduxForm_blur = es_actions.blur,\n    createReduxForm_change = es_actions.change,\n    createReduxForm_focus = es_actions.focus,\n    formActions = objectWithoutPropertiesLoose_default()(es_actions, ["arrayInsert", "arrayMove", "arrayPop", "arrayPush", "arrayRemove", "arrayRemoveAll", "arrayShift", "arraySplice", "arraySwap", "arrayUnshift", "blur", "change", "focus"]);\n\nvar arrayActions = {\n  arrayInsert: createReduxForm_arrayInsert,\n  arrayMove: createReduxForm_arrayMove,\n  arrayPop: createReduxForm_arrayPop,\n  arrayPush: createReduxForm_arrayPush,\n  arrayRemove: createReduxForm_arrayRemove,\n  arrayRemoveAll: createReduxForm_arrayRemoveAll,\n  arrayShift: createReduxForm_arrayShift,\n  arraySplice: createReduxForm_arraySplice,\n  arraySwap: createReduxForm_arraySwap,\n  arrayUnshift: createReduxForm_arrayUnshift\n};\nvar propsToNotUpdateFor = [].concat(Object.keys(es_actions), [\'array\', \'asyncErrors\', \'initialValues\', \'syncErrors\', \'syncWarnings\', \'values\', \'registeredFields\']);\n\nvar checkSubmit = function checkSubmit(submit) {\n  if (!submit || typeof submit !== \'function\') {\n    throw new Error(\'You must either pass handleSubmit() an onSubmit function or pass onSubmit as a prop\');\n  }\n\n  return submit;\n};\n\n/**\n * The decorator that is the main API to redux-form\n */\nvar createReduxForm_createReduxForm = function createReduxForm(structure) {\n  var deepEqual = structure.deepEqual,\n      empty = structure.empty,\n      getIn = structure.getIn,\n      setIn = structure.setIn,\n      keys = structure.keys,\n      fromJS = structure.fromJS;\n  var isValid = selectors_isValid(structure);\n  return function (initialConfig) {\n    var config = extends_default()({\n      touchOnBlur: true,\n      touchOnChange: false,\n      persistentSubmitErrors: false,\n      destroyOnUnmount: true,\n      shouldAsyncValidate: es_defaultShouldAsyncValidate,\n      shouldValidate: es_defaultShouldValidate,\n      shouldError: es_defaultShouldError,\n      shouldWarn: es_defaultShouldWarn,\n      enableReinitialize: false,\n      keepDirtyOnReinitialize: false,\n      updateUnregisteredFields: false,\n      getFormState: function getFormState(state) {\n        return getIn(state, \'form\');\n      },\n      pure: true,\n      forceUnregisterOnUnmount: false\n    }, initialConfig);\n\n    return function (WrappedComponent) {\n      var Form =\n      /*#__PURE__*/\n      function (_React$Component) {\n        inheritsLoose_default()(Form, _React$Component);\n\n        function Form() {\n          var _this;\n\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n          _this.wrapped = react_default.a.createRef();\n          _this.destroyed = false;\n          _this.fieldCounts = {};\n          _this.fieldValidators = {};\n          _this.lastFieldValidatorKeys = [];\n          _this.fieldWarners = {};\n          _this.lastFieldWarnerKeys = [];\n          _this.innerOnSubmit = undefined;\n          _this.submitPromise = undefined;\n\n          _this.getValues = function () {\n            return _this.props.values;\n          };\n\n          _this.isValid = function () {\n            return _this.props.valid;\n          };\n\n          _this.isPristine = function () {\n            return _this.props.pristine;\n          };\n\n          _this.register = function (name, type, getValidator, getWarner) {\n            var lastCount = _this.fieldCounts[name];\n            var nextCount = (lastCount || 0) + 1;\n            _this.fieldCounts[name] = nextCount;\n\n            _this.props.registerField(name, type);\n\n            if (getValidator) {\n              _this.fieldValidators[name] = getValidator;\n            }\n\n            if (getWarner) {\n              _this.fieldWarners[name] = getWarner;\n            }\n          };\n\n          _this.unregister = function (name) {\n            var lastCount = _this.fieldCounts[name];\n            if (lastCount === 1) delete _this.fieldCounts[name];else if (lastCount != null) _this.fieldCounts[name] = lastCount - 1;\n\n            if (!_this.destroyed) {\n              var _this$props = _this.props,\n                  _destroyOnUnmount = _this$props.destroyOnUnmount,\n                  forceUnregisterOnUnmount = _this$props.forceUnregisterOnUnmount,\n                  unregisterField = _this$props.unregisterField;\n\n              if (_destroyOnUnmount || forceUnregisterOnUnmount) {\n                unregisterField(name, _destroyOnUnmount);\n\n                if (!_this.fieldCounts[name]) {\n                  delete _this.fieldValidators[name];\n                  delete _this.fieldWarners[name];\n                  _this.lastFieldValidatorKeys = _this.lastFieldValidatorKeys.filter(function (key) {\n                    return key !== name;\n                  });\n                }\n              } else {\n                unregisterField(name, false);\n              }\n            }\n          };\n\n          _this.getFieldList = function (options) {\n            var registeredFields = _this.props.registeredFields;\n            var list = [];\n\n            if (!registeredFields) {\n              return list;\n            }\n\n            var keySeq = keys(registeredFields);\n\n            if (options && options.excludeFieldArray) {\n              keySeq = keySeq.filter(function (name) {\n                return getIn(registeredFields, "[\'" + name + "\'].type") !== \'FieldArray\';\n              });\n            }\n\n            return fromJS(keySeq.reduce(function (acc, key) {\n              acc.push(key);\n              return acc;\n            }, list));\n          };\n\n          _this.getValidators = function () {\n            var validators = {};\n            Object.keys(_this.fieldValidators).forEach(function (name) {\n              var validator = _this.fieldValidators[name]();\n\n              if (validator) {\n                validators[name] = validator;\n              }\n            });\n            return validators;\n          };\n\n          _this.generateValidator = function () {\n            var validators = _this.getValidators();\n\n            return Object.keys(validators).length ? es_generateValidator(validators, structure) : undefined;\n          };\n\n          _this.getWarners = function () {\n            var warners = {};\n            Object.keys(_this.fieldWarners).forEach(function (name) {\n              var warner = _this.fieldWarners[name]();\n\n              if (warner) {\n                warners[name] = warner;\n              }\n            });\n            return warners;\n          };\n\n          _this.generateWarner = function () {\n            var warners = _this.getWarners();\n\n            return Object.keys(warners).length ? es_generateValidator(warners, structure) : undefined;\n          };\n\n          _this.asyncValidate = function (name, value, trigger) {\n            var _this$props2 = _this.props,\n                asyncBlurFields = _this$props2.asyncBlurFields,\n                asyncChangeFields = _this$props2.asyncChangeFields,\n                asyncErrors = _this$props2.asyncErrors,\n                asyncValidate = _this$props2.asyncValidate,\n                dispatch = _this$props2.dispatch,\n                initialized = _this$props2.initialized,\n                pristine = _this$props2.pristine,\n                shouldAsyncValidate = _this$props2.shouldAsyncValidate,\n                startAsyncValidation = _this$props2.startAsyncValidation,\n                stopAsyncValidation = _this$props2.stopAsyncValidation,\n                syncErrors = _this$props2.syncErrors,\n                values = _this$props2.values;\n            var submitting = !name;\n\n            var fieldNeedsValidation = function fieldNeedsValidation() {\n              var fieldNeedsValidationForBlur = asyncBlurFields && name && ~asyncBlurFields.indexOf(name.replace(/\\[[0-9]+\\]/g, \'[]\'));\n              var fieldNeedsValidationForChange = asyncChangeFields && name && ~asyncChangeFields.indexOf(name.replace(/\\[[0-9]+\\]/g, \'[]\'));\n              var asyncValidateByDefault = !(asyncBlurFields || asyncChangeFields);\n              return submitting || asyncValidateByDefault || (trigger === \'blur\' ? fieldNeedsValidationForBlur : fieldNeedsValidationForChange);\n            };\n\n            if (asyncValidate) {\n              var valuesToValidate = submitting ? values : setIn(values, name, value);\n              var syncValidationPasses = submitting || !getIn(syncErrors, name);\n\n              if (fieldNeedsValidation() && shouldAsyncValidate({\n                asyncErrors: asyncErrors,\n                initialized: initialized,\n                trigger: submitting ? \'submit\' : trigger,\n                blurredField: name,\n                pristine: pristine,\n                syncValidationPasses: syncValidationPasses\n              })) {\n                return es_asyncValidation(function () {\n                  return asyncValidate(valuesToValidate, dispatch, _this.props, name);\n                }, startAsyncValidation, stopAsyncValidation, name);\n              }\n            }\n          };\n\n          _this.submitCompleted = function (result) {\n            delete _this.submitPromise;\n            return result;\n          };\n\n          _this.submitFailed = function (error) {\n            delete _this.submitPromise;\n            throw error;\n          };\n\n          _this.listenToSubmit = function (promise) {\n            if (!is_promise_default()(promise)) {\n              return promise;\n            }\n\n            _this.submitPromise = promise;\n            return promise.then(_this.submitCompleted, _this.submitFailed);\n          };\n\n          _this.submit = function (submitOrEvent) {\n            var _this$props3 = _this.props,\n                onSubmit = _this$props3.onSubmit,\n                blur = _this$props3.blur,\n                change = _this$props3.change,\n                dispatch = _this$props3.dispatch;\n\n            if (!submitOrEvent || events_silenceEvent(submitOrEvent)) {\n              // submitOrEvent is an event: fire submit if not already submitting\n              if (!_this.submitPromise) {\n                // avoid recursive stack trace if use Form with onSubmit as handleSubmit\n                if (_this.innerOnSubmit && _this.innerOnSubmit !== _this.submit) {\n                  // will call "submitOrEvent is the submit function" block below\n                  return _this.innerOnSubmit();\n                } else {\n                  return _this.listenToSubmit(es_handleSubmit(checkSubmit(onSubmit), extends_default()({}, _this.props, bindActionCreators({\n                    blur: blur,\n                    change: change\n                  }, dispatch)), _this.props.validExceptSubmit, _this.asyncValidate, _this.getFieldList({\n                    excludeFieldArray: true\n                  })));\n                }\n              }\n            } else {\n              // submitOrEvent is the submit function: return deferred submit thunk\n              return events_silenceEvents(function () {\n                return !_this.submitPromise && _this.listenToSubmit(es_handleSubmit(checkSubmit(submitOrEvent), extends_default()({}, _this.props, bindActionCreators({\n                  blur: blur,\n                  change: change\n                }, dispatch)), _this.props.validExceptSubmit, _this.asyncValidate, _this.getFieldList({\n                  excludeFieldArray: true\n                })));\n              });\n            }\n          };\n\n          _this.reset = function () {\n            return _this.props.reset();\n          };\n\n          return _this;\n        }\n\n        var _proto = Form.prototype;\n\n        _proto.initIfNeeded = function initIfNeeded(nextProps) {\n          var enableReinitialize = this.props.enableReinitialize;\n\n          if (nextProps) {\n            if ((enableReinitialize || !nextProps.initialized) && !deepEqual(this.props.initialValues, nextProps.initialValues)) {\n              var _keepDirty = nextProps.initialized && this.props.keepDirtyOnReinitialize;\n\n              this.props.initialize(nextProps.initialValues, _keepDirty, {\n                keepValues: nextProps.keepValues,\n                lastInitialValues: this.props.initialValues,\n                updateUnregisteredFields: nextProps.updateUnregisteredFields\n              });\n            }\n          } else if (this.props.initialValues && (!this.props.initialized || enableReinitialize)) {\n            this.props.initialize(this.props.initialValues, this.props.keepDirtyOnReinitialize, {\n              keepValues: this.props.keepValues,\n              updateUnregisteredFields: this.props.updateUnregisteredFields\n            });\n          }\n        };\n\n        _proto.updateSyncErrorsIfNeeded = function updateSyncErrorsIfNeeded(nextSyncErrors, nextError, lastSyncErrors) {\n          var _this$props4 = this.props,\n              error = _this$props4.error,\n              updateSyncErrors = _this$props4.updateSyncErrors;\n          var noErrors = (!lastSyncErrors || !Object.keys(lastSyncErrors).length) && !error;\n          var nextNoErrors = (!nextSyncErrors || !Object.keys(nextSyncErrors).length) && !nextError;\n\n          if (!(noErrors && nextNoErrors) && (!plain.deepEqual(lastSyncErrors, nextSyncErrors) || !plain.deepEqual(error, nextError))) {\n            updateSyncErrors(nextSyncErrors, nextError);\n          }\n        };\n\n        _proto.clearSubmitPromiseIfNeeded = function clearSubmitPromiseIfNeeded(nextProps) {\n          var submitting = this.props.submitting;\n\n          if (this.submitPromise && submitting && !nextProps.submitting) {\n            delete this.submitPromise;\n          }\n        };\n\n        _proto.submitIfNeeded = function submitIfNeeded(nextProps) {\n          var _this$props5 = this.props,\n              clearSubmit = _this$props5.clearSubmit,\n              triggerSubmit = _this$props5.triggerSubmit;\n\n          if (!triggerSubmit && nextProps.triggerSubmit) {\n            clearSubmit();\n            this.submit();\n          }\n        };\n\n        _proto.shouldErrorFunction = function shouldErrorFunction() {\n          var _this$props6 = this.props,\n              shouldValidate = _this$props6.shouldValidate,\n              shouldError = _this$props6.shouldError;\n          var shouldValidateOverridden = shouldValidate !== es_defaultShouldValidate;\n          var shouldErrorOverridden = shouldError !== es_defaultShouldError;\n          return shouldValidateOverridden && !shouldErrorOverridden ? shouldValidate : shouldError;\n        };\n\n        _proto.validateIfNeeded = function validateIfNeeded(nextProps) {\n          var _this$props7 = this.props,\n              validate = _this$props7.validate,\n              values = _this$props7.values;\n          var shouldError = this.shouldErrorFunction();\n          var fieldLevelValidate = this.generateValidator();\n\n          if (validate || fieldLevelValidate) {\n            var initialRender = nextProps === undefined;\n            var fieldValidatorKeys = Object.keys(this.getValidators());\n            var validateParams = {\n              values: values,\n              nextProps: nextProps,\n              props: this.props,\n              initialRender: initialRender,\n              lastFieldValidatorKeys: this.lastFieldValidatorKeys,\n              fieldValidatorKeys: fieldValidatorKeys,\n              structure: structure\n            };\n\n            if (shouldError(validateParams)) {\n              var propsToValidate = initialRender || !nextProps ? this.props : nextProps;\n\n              var _merge2 = merge_default()(validate ? validate(propsToValidate.values, propsToValidate) || {} : {}, fieldLevelValidate ? fieldLevelValidate(propsToValidate.values, propsToValidate) || {} : {}),\n                  _error = _merge2._error,\n                  nextSyncErrors = objectWithoutPropertiesLoose_default()(_merge2, ["_error"]);\n\n              this.lastFieldValidatorKeys = fieldValidatorKeys;\n              this.updateSyncErrorsIfNeeded(nextSyncErrors, _error, propsToValidate.syncErrors);\n            }\n          } else {\n            this.lastFieldValidatorKeys = [];\n          }\n        };\n\n        _proto.updateSyncWarningsIfNeeded = function updateSyncWarningsIfNeeded(nextSyncWarnings, nextWarning, lastSyncWarnings) {\n          var _this$props8 = this.props,\n              warning = _this$props8.warning,\n              syncWarnings = _this$props8.syncWarnings,\n              updateSyncWarnings = _this$props8.updateSyncWarnings;\n          var noWarnings = (!syncWarnings || !Object.keys(syncWarnings).length) && !warning;\n          var nextNoWarnings = (!nextSyncWarnings || !Object.keys(nextSyncWarnings).length) && !nextWarning;\n\n          if (!(noWarnings && nextNoWarnings) && (!plain.deepEqual(lastSyncWarnings, nextSyncWarnings) || !plain.deepEqual(warning, nextWarning))) {\n            updateSyncWarnings(nextSyncWarnings, nextWarning);\n          }\n        };\n\n        _proto.shouldWarnFunction = function shouldWarnFunction() {\n          var _this$props9 = this.props,\n              shouldValidate = _this$props9.shouldValidate,\n              shouldWarn = _this$props9.shouldWarn;\n          var shouldValidateOverridden = shouldValidate !== es_defaultShouldValidate;\n          var shouldWarnOverridden = shouldWarn !== es_defaultShouldWarn;\n          return shouldValidateOverridden && !shouldWarnOverridden ? shouldValidate : shouldWarn;\n        };\n\n        _proto.warnIfNeeded = function warnIfNeeded(nextProps) {\n          var _this$props10 = this.props,\n              warn = _this$props10.warn,\n              values = _this$props10.values;\n          var shouldWarn = this.shouldWarnFunction();\n          var fieldLevelWarn = this.generateWarner();\n\n          if (warn || fieldLevelWarn) {\n            var initialRender = nextProps === undefined;\n            var fieldWarnerKeys = Object.keys(this.getWarners());\n            var validateParams = {\n              values: values,\n              nextProps: nextProps,\n              props: this.props,\n              initialRender: initialRender,\n              lastFieldValidatorKeys: this.lastFieldWarnerKeys,\n              fieldValidatorKeys: fieldWarnerKeys,\n              structure: structure\n            };\n\n            if (shouldWarn(validateParams)) {\n              var propsToWarn = initialRender || !nextProps ? this.props : nextProps;\n\n              var _merge3 = merge_default()(warn ? warn(propsToWarn.values, propsToWarn) : {}, fieldLevelWarn ? fieldLevelWarn(propsToWarn.values, propsToWarn) : {}),\n                  _warning = _merge3._warning,\n                  nextSyncWarnings = objectWithoutPropertiesLoose_default()(_merge3, ["_warning"]);\n\n              this.lastFieldWarnerKeys = fieldWarnerKeys;\n              this.updateSyncWarningsIfNeeded(nextSyncWarnings, _warning, propsToWarn.syncWarnings);\n            }\n          }\n        };\n\n        _proto.componentWillMount = function componentWillMount() {\n          if (!Object(isHotReloading["a" /* default */])()) {\n            this.initIfNeeded();\n            this.validateIfNeeded();\n            this.warnIfNeeded();\n          }\n\n          browser_default()(this.props.shouldValidate, \'shouldValidate() is deprecated and will be removed in v9.0.0. Use shouldWarn() or shouldError() instead.\');\n        };\n\n        _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n          this.initIfNeeded(nextProps);\n          this.validateIfNeeded(nextProps);\n          this.warnIfNeeded(nextProps);\n          this.clearSubmitPromiseIfNeeded(nextProps);\n          this.submitIfNeeded(nextProps);\n          var onChange = nextProps.onChange,\n              values = nextProps.values,\n              dispatch = nextProps.dispatch;\n\n          if (onChange && !deepEqual(values, this.props.values)) {\n            onChange(values, dispatch, nextProps, this.props.values);\n          }\n        };\n\n        _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {\n          var _this2 = this;\n\n          if (!this.props.pure) return true;\n          var _config$immutableProp = config.immutableProps,\n              immutableProps = _config$immutableProp === void 0 ? [] : _config$immutableProp; // if we have children, we MUST update in React 16\n          // https://twitter.com/erikras/status/915866544558788608\n\n          return !!(this.props.children || nextProps.children || Object.keys(nextProps).some(function (prop) {\n            // useful to debug rerenders\n            // if (!plain.deepEqual(this.props[ prop ], nextProps[ prop ])) {\n            //   console.info(prop, \'changed\', this.props[ prop ], \'==>\', nextProps[ prop ])\n            // }\n            if (~immutableProps.indexOf(prop)) {\n              return _this2.props[prop] !== nextProps[prop];\n            }\n\n            return !~propsToNotUpdateFor.indexOf(prop) && !deepEqual(_this2.props[prop], nextProps[prop]);\n          }));\n        };\n\n        _proto.componentDidMount = function componentDidMount() {\n          if (!Object(isHotReloading["a" /* default */])()) {\n            this.initIfNeeded(this.props);\n            this.validateIfNeeded();\n            this.warnIfNeeded();\n          }\n\n          browser_default()(this.props.shouldValidate, \'shouldValidate() is deprecated and will be removed in v9.0.0. Use shouldWarn() or shouldError() instead.\');\n        };\n\n        _proto.componentWillUnmount = function componentWillUnmount() {\n          var _this$props11 = this.props,\n              destroyOnUnmount = _this$props11.destroyOnUnmount,\n              destroy = _this$props11.destroy;\n\n          if (destroyOnUnmount && !Object(isHotReloading["a" /* default */])()) {\n            this.destroyed = true;\n            destroy();\n          }\n        };\n\n        _proto.render = function render() {\n          var _ref,\n              _this3 = this;\n\n          // remove some redux-form config-only props\n\n          /* eslint-disable no-unused-vars */\n          var _this$props12 = this.props,\n              anyTouched = _this$props12.anyTouched,\n              array = _this$props12.array,\n              arrayInsert = _this$props12.arrayInsert,\n              arrayMove = _this$props12.arrayMove,\n              arrayPop = _this$props12.arrayPop,\n              arrayPush = _this$props12.arrayPush,\n              arrayRemove = _this$props12.arrayRemove,\n              arrayRemoveAll = _this$props12.arrayRemoveAll,\n              arrayShift = _this$props12.arrayShift,\n              arraySplice = _this$props12.arraySplice,\n              arraySwap = _this$props12.arraySwap,\n              arrayUnshift = _this$props12.arrayUnshift,\n              asyncErrors = _this$props12.asyncErrors,\n              asyncValidate = _this$props12.asyncValidate,\n              asyncValidating = _this$props12.asyncValidating,\n              blur = _this$props12.blur,\n              change = _this$props12.change,\n              clearSubmit = _this$props12.clearSubmit,\n              destroy = _this$props12.destroy,\n              destroyOnUnmount = _this$props12.destroyOnUnmount,\n              forceUnregisterOnUnmount = _this$props12.forceUnregisterOnUnmount,\n              dirty = _this$props12.dirty,\n              dispatch = _this$props12.dispatch,\n              enableReinitialize = _this$props12.enableReinitialize,\n              error = _this$props12.error,\n              focus = _this$props12.focus,\n              form = _this$props12.form,\n              getFormState = _this$props12.getFormState,\n              immutableProps = _this$props12.immutableProps,\n              initialize = _this$props12.initialize,\n              initialized = _this$props12.initialized,\n              initialValues = _this$props12.initialValues,\n              invalid = _this$props12.invalid,\n              keepDirtyOnReinitialize = _this$props12.keepDirtyOnReinitialize,\n              keepValues = _this$props12.keepValues,\n              updateUnregisteredFields = _this$props12.updateUnregisteredFields,\n              pristine = _this$props12.pristine,\n              propNamespace = _this$props12.propNamespace,\n              registeredFields = _this$props12.registeredFields,\n              registerField = _this$props12.registerField,\n              reset = _this$props12.reset,\n              resetSection = _this$props12.resetSection,\n              setSubmitFailed = _this$props12.setSubmitFailed,\n              setSubmitSucceeded = _this$props12.setSubmitSucceeded,\n              shouldAsyncValidate = _this$props12.shouldAsyncValidate,\n              shouldValidate = _this$props12.shouldValidate,\n              shouldError = _this$props12.shouldError,\n              shouldWarn = _this$props12.shouldWarn,\n              startAsyncValidation = _this$props12.startAsyncValidation,\n              startSubmit = _this$props12.startSubmit,\n              stopAsyncValidation = _this$props12.stopAsyncValidation,\n              stopSubmit = _this$props12.stopSubmit,\n              submitting = _this$props12.submitting,\n              submitFailed = _this$props12.submitFailed,\n              submitSucceeded = _this$props12.submitSucceeded,\n              touch = _this$props12.touch,\n              touchOnBlur = _this$props12.touchOnBlur,\n              touchOnChange = _this$props12.touchOnChange,\n              persistentSubmitErrors = _this$props12.persistentSubmitErrors,\n              syncErrors = _this$props12.syncErrors,\n              syncWarnings = _this$props12.syncWarnings,\n              unregisterField = _this$props12.unregisterField,\n              untouch = _this$props12.untouch,\n              updateSyncErrors = _this$props12.updateSyncErrors,\n              updateSyncWarnings = _this$props12.updateSyncWarnings,\n              valid = _this$props12.valid,\n              validExceptSubmit = _this$props12.validExceptSubmit,\n              values = _this$props12.values,\n              warning = _this$props12.warning,\n              rest = objectWithoutPropertiesLoose_default()(_this$props12, ["anyTouched", "array", "arrayInsert", "arrayMove", "arrayPop", "arrayPush", "arrayRemove", "arrayRemoveAll", "arrayShift", "arraySplice", "arraySwap", "arrayUnshift", "asyncErrors", "asyncValidate", "asyncValidating", "blur", "change", "clearSubmit", "destroy", "destroyOnUnmount", "forceUnregisterOnUnmount", "dirty", "dispatch", "enableReinitialize", "error", "focus", "form", "getFormState", "immutableProps", "initialize", "initialized", "initialValues", "invalid", "keepDirtyOnReinitialize", "keepValues", "updateUnregisteredFields", "pristine", "propNamespace", "registeredFields", "registerField", "reset", "resetSection", "setSubmitFailed", "setSubmitSucceeded", "shouldAsyncValidate", "shouldValidate", "shouldError", "shouldWarn", "startAsyncValidation", "startSubmit", "stopAsyncValidation", "stopSubmit", "submitting", "submitFailed", "submitSucceeded", "touch", "touchOnBlur", "touchOnChange", "persistentSubmitErrors", "syncErrors", "syncWarnings", "unregisterField", "untouch", "updateSyncErrors", "updateSyncWarnings", "valid", "validExceptSubmit", "values", "warning"]);\n          /* eslint-enable no-unused-vars */\n\n\n          var reduxFormProps = extends_default()({\n            array: array,\n            anyTouched: anyTouched,\n            asyncValidate: this.asyncValidate,\n            asyncValidating: asyncValidating\n          }, bindActionCreators({\n            blur: blur,\n            change: change\n          }, dispatch), {\n            clearSubmit: clearSubmit,\n            destroy: destroy,\n            dirty: dirty,\n            dispatch: dispatch,\n            error: error,\n            form: form,\n            handleSubmit: this.submit,\n            initialize: initialize,\n            initialized: initialized,\n            initialValues: initialValues,\n            invalid: invalid,\n            pristine: pristine,\n            reset: reset,\n            resetSection: resetSection,\n            submitting: submitting,\n            submitFailed: submitFailed,\n            submitSucceeded: submitSucceeded,\n            touch: touch,\n            untouch: untouch,\n            valid: valid,\n            warning: warning\n          });\n\n          var propsToPass = extends_default()({}, propNamespace ? (_ref = {}, _ref[propNamespace] = reduxFormProps, _ref) : reduxFormProps, rest);\n\n          if (isClassComponent(WrappedComponent)) {\n            ;\n            propsToPass.ref = this.wrapped;\n          }\n\n          var _reduxForm = extends_default()({}, this.props, {\n            getFormState: function getFormState(state) {\n              return getIn(_this3.props.getFormState(state), _this3.props.form);\n            },\n            asyncValidate: this.asyncValidate,\n            getValues: this.getValues,\n            sectionPrefix: undefined,\n            register: this.register,\n            unregister: this.unregister,\n            registerInnerOnSubmit: function registerInnerOnSubmit(innerOnSubmit) {\n              return _this3.innerOnSubmit = innerOnSubmit;\n            }\n          });\n\n          return Object(react["createElement"])(ReduxFormContext.Provider, {\n            value: _reduxForm,\n            children: Object(react["createElement"])(WrappedComponent, propsToPass)\n          });\n        };\n\n        return Form;\n      }(react_default.a.Component);\n\n      Form.displayName = "Form(" + util_getDisplayName(WrappedComponent) + ")";\n      Form.WrappedComponent = WrappedComponent;\n      Form.propTypes = {\n        destroyOnUnmount: prop_types_default.a.bool,\n        forceUnregisterOnUnmount: prop_types_default.a.bool,\n        form: prop_types_default.a.string.isRequired,\n        immutableProps: prop_types_default.a.arrayOf(prop_types_default.a.string),\n        initialValues: prop_types_default.a.oneOfType([prop_types_default.a.array, prop_types_default.a.object]),\n        getFormState: prop_types_default.a.func,\n        onSubmitFail: prop_types_default.a.func,\n        onSubmitSuccess: prop_types_default.a.func,\n        propNamespace: prop_types_default.a.string,\n        validate: prop_types_default.a.func,\n        warn: prop_types_default.a.func,\n        touchOnBlur: prop_types_default.a.bool,\n        touchOnChange: prop_types_default.a.bool,\n        triggerSubmit: prop_types_default.a.bool,\n        persistentSubmitErrors: prop_types_default.a.bool,\n        registeredFields: prop_types_default.a.any\n      };\n      var connector = connect_connect(function (state, props) {\n        var form = props.form,\n            getFormState = props.getFormState,\n            initialValues = props.initialValues,\n            enableReinitialize = props.enableReinitialize,\n            keepDirtyOnReinitialize = props.keepDirtyOnReinitialize;\n        var formState = getIn(getFormState(state) || empty, form) || empty;\n        var stateInitial = getIn(formState, \'initial\');\n        var initialized = !!stateInitial;\n        var shouldUpdateInitialValues = enableReinitialize && initialized && !deepEqual(initialValues, stateInitial);\n        var shouldResetValues = shouldUpdateInitialValues && !keepDirtyOnReinitialize;\n        var initial = initialValues || stateInitial || empty;\n\n        if (!shouldUpdateInitialValues) {\n          initial = stateInitial || empty;\n        }\n\n        var values = getIn(formState, \'values\') || initial;\n\n        if (shouldResetValues) {\n          values = initial;\n        }\n\n        var pristine = shouldResetValues || deepEqual(initial, values);\n        var asyncErrors = getIn(formState, \'asyncErrors\');\n        var syncErrors = getIn(formState, \'syncErrors\') || plain.empty;\n        var syncWarnings = getIn(formState, \'syncWarnings\') || plain.empty;\n        var registeredFields = getIn(formState, \'registeredFields\');\n        var valid = isValid(form, getFormState, false)(state);\n        var validExceptSubmit = isValid(form, getFormState, true)(state);\n        var anyTouched = !!getIn(formState, \'anyTouched\');\n        var submitting = !!getIn(formState, \'submitting\');\n        var submitFailed = !!getIn(formState, \'submitFailed\');\n        var submitSucceeded = !!getIn(formState, \'submitSucceeded\');\n        var error = getIn(formState, \'error\');\n        var warning = getIn(formState, \'warning\');\n        var triggerSubmit = getIn(formState, \'triggerSubmit\');\n        return {\n          anyTouched: anyTouched,\n          asyncErrors: asyncErrors,\n          asyncValidating: getIn(formState, \'asyncValidating\') || false,\n          dirty: !pristine,\n          error: error,\n          initialized: initialized,\n          invalid: !valid,\n          pristine: pristine,\n          registeredFields: registeredFields,\n          submitting: submitting,\n          submitFailed: submitFailed,\n          submitSucceeded: submitSucceeded,\n          syncErrors: syncErrors,\n          syncWarnings: syncWarnings,\n          triggerSubmit: triggerSubmit,\n          values: values,\n          valid: valid,\n          validExceptSubmit: validExceptSubmit,\n          warning: warning\n        };\n      }, function (dispatch, initialProps) {\n        var bindForm = function bindForm(actionCreator) {\n          return actionCreator.bind(null, initialProps.form);\n        }; // Bind the first parameter on `props.form`\n\n\n        var boundFormACs = mapValues_default()(formActions, bindForm);\n\n        var boundArrayACs = mapValues_default()(arrayActions, bindForm);\n\n        var boundBlur = function boundBlur(field, value) {\n          return createReduxForm_blur(initialProps.form, field, value, !!initialProps.touchOnBlur);\n        };\n\n        var boundChange = function boundChange(field, value) {\n          return createReduxForm_change(initialProps.form, field, value, !!initialProps.touchOnChange, !!initialProps.persistentSubmitErrors);\n        };\n\n        var boundFocus = bindForm(createReduxForm_focus); // Wrap action creators with `dispatch`\n\n        var connectedFormACs = bindActionCreators(boundFormACs, dispatch);\n        var connectedArrayACs = {\n          insert: bindActionCreators(boundArrayACs.arrayInsert, dispatch),\n          move: bindActionCreators(boundArrayACs.arrayMove, dispatch),\n          pop: bindActionCreators(boundArrayACs.arrayPop, dispatch),\n          push: bindActionCreators(boundArrayACs.arrayPush, dispatch),\n          remove: bindActionCreators(boundArrayACs.arrayRemove, dispatch),\n          removeAll: bindActionCreators(boundArrayACs.arrayRemoveAll, dispatch),\n          shift: bindActionCreators(boundArrayACs.arrayShift, dispatch),\n          splice: bindActionCreators(boundArrayACs.arraySplice, dispatch),\n          swap: bindActionCreators(boundArrayACs.arraySwap, dispatch),\n          unshift: bindActionCreators(boundArrayACs.arrayUnshift, dispatch)\n        };\n\n        var computedActions = extends_default()({}, connectedFormACs, boundArrayACs, {\n          blur: boundBlur,\n          change: boundChange,\n          array: connectedArrayACs,\n          focus: boundFocus,\n          dispatch: dispatch\n        });\n\n        return function () {\n          return computedActions;\n        };\n      }, undefined, {\n        forwardRef: true\n      });\n      var ConnectedForm = hoist_non_react_statics_cjs_default()(connector(Form), WrappedComponent);\n      ConnectedForm.defaultProps = config; // build outer component to expose instance api\n\n      var ReduxForm =\n      /*#__PURE__*/\n      function (_React$Component2) {\n        inheritsLoose_default()(ReduxForm, _React$Component2);\n\n        function ReduxForm() {\n          var _this4;\n\n          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            args[_key2] = arguments[_key2];\n          }\n\n          _this4 = _React$Component2.call.apply(_React$Component2, [this].concat(args)) || this;\n          _this4.ref = react_default.a.createRef();\n          return _this4;\n        }\n\n        var _proto2 = ReduxForm.prototype;\n\n        _proto2.submit = function submit() {\n          return this.ref.current && this.ref.current.submit();\n        };\n\n        _proto2.reset = function reset() {\n          if (this.ref) {\n            this.ref.current.reset();\n          }\n        };\n\n        _proto2.render = function render() {\n          var _this$props13 = this.props,\n              initialValues = _this$props13.initialValues,\n              rest = objectWithoutPropertiesLoose_default()(_this$props13, ["initialValues"]);\n\n          return Object(react["createElement"])(ConnectedForm, extends_default()({}, rest, {\n            ref: this.ref,\n            // convert initialValues if need to\n            initialValues: fromJS(initialValues)\n          }));\n        };\n\n        createClass_default()(ReduxForm, [{\n          key: "valid",\n          get: function get() {\n            return !!(this.ref.current && this.ref.current.isValid());\n          }\n        }, {\n          key: "invalid",\n          get: function get() {\n            return !this.valid;\n          }\n        }, {\n          key: "pristine",\n          get: function get() {\n            return !!(this.ref.current && this.ref.current.isPristine());\n          }\n        }, {\n          key: "dirty",\n          get: function get() {\n            return !this.pristine;\n          }\n        }, {\n          key: "values",\n          get: function get() {\n            return this.ref.current ? this.ref.current.getValues() : empty;\n          }\n        }, {\n          key: "fieldList",\n          get: function get() {\n            // mainly provided for testing\n            return this.ref.current ? this.ref.current.getFieldList() : [];\n          }\n        }, {\n          key: "wrappedInstance",\n          get: function get() {\n            // for testing\n            return this.ref.current && this.ref.current.wrapped.current;\n          }\n        }]);\n\n        return ReduxForm;\n      }(react_default.a.Component);\n\n      Object(react_lifecycles_compat_es["polyfill"])(ReduxForm);\n      var WithContext = hoist_non_react_statics_cjs_default()(ReduxFormContext_withReduxForm(ReduxForm), WrappedComponent);\n      WithContext.defaultProps = config;\n      return WithContext;\n    };\n  };\n};\n\n/* harmony default export */ var es_createReduxForm = (createReduxForm_createReduxForm);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/reduxForm.js\n\n\n/* harmony default export */ var reduxForm = (es_createReduxForm(plain));\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/createFieldProps.js\n\n\n\nvar createFieldProps_processProps = function processProps(type, props, _value, deepEqual) {\n  var value = props.value;\n\n  if (type === \'checkbox\') {\n    return extends_default()({}, props, {\n      checked: !!value\n    });\n  }\n\n  if (type === \'radio\') {\n    return extends_default()({}, props, {\n      checked: deepEqual(value, _value),\n      value: _value\n    });\n  }\n\n  if (type === \'select-multiple\') {\n    return extends_default()({}, props, {\n      value: value || []\n    });\n  }\n\n  if (type === \'file\') {\n    return extends_default()({}, props, {\n      value: value || undefined\n    });\n  }\n\n  return props;\n};\n\nvar createFieldProps_createFieldProps = function createFieldProps(_ref, name, _ref2) {\n  var getIn = _ref.getIn,\n      toJS = _ref.toJS,\n      deepEqual = _ref.deepEqual;\n\n  var asyncError = _ref2.asyncError,\n      asyncValidating = _ref2.asyncValidating,\n      onBlur = _ref2.onBlur,\n      onChange = _ref2.onChange,\n      onDrop = _ref2.onDrop,\n      onDragStart = _ref2.onDragStart,\n      dirty = _ref2.dirty,\n      dispatch = _ref2.dispatch,\n      onFocus = _ref2.onFocus,\n      form = _ref2.form,\n      format = _ref2.format,\n      initial = _ref2.initial,\n      parse = _ref2.parse,\n      pristine = _ref2.pristine,\n      props = _ref2.props,\n      state = _ref2.state,\n      submitError = _ref2.submitError,\n      submitFailed = _ref2.submitFailed,\n      submitting = _ref2.submitting,\n      syncError = _ref2.syncError,\n      syncWarning = _ref2.syncWarning,\n      validate = _ref2.validate,\n      value = _ref2.value,\n      _value = _ref2._value,\n      warn = _ref2.warn,\n      custom = objectWithoutPropertiesLoose_default()(_ref2, ["asyncError", "asyncValidating", "onBlur", "onChange", "onDrop", "onDragStart", "dirty", "dispatch", "onFocus", "form", "format", "initial", "parse", "pristine", "props", "state", "submitError", "submitFailed", "submitting", "syncError", "syncWarning", "validate", "value", "_value", "warn"]);\n\n  var error = syncError || asyncError || submitError;\n  var warning = syncWarning;\n\n  var formatFieldValue = function formatFieldValue(value, format) {\n    if (format === null) {\n      return value;\n    }\n\n    var defaultFormattedValue = value == null ? \'\' : value;\n    return format ? format(value, name) : defaultFormattedValue;\n  };\n\n  var formattedFieldValue = formatFieldValue(value, format);\n  return {\n    input: createFieldProps_processProps(custom.type, {\n      name: name,\n      onBlur: onBlur,\n      onChange: onChange,\n      onDragStart: onDragStart,\n      onDrop: onDrop,\n      onFocus: onFocus,\n      value: formattedFieldValue\n    }, _value, deepEqual),\n    meta: extends_default()({}, toJS(state), {\n      active: !!(state && getIn(state, \'active\')),\n      asyncValidating: asyncValidating,\n      autofilled: !!(state && getIn(state, \'autofilled\')),\n      dirty: dirty,\n      dispatch: dispatch,\n      error: error,\n      form: form,\n      initial: initial,\n      warning: warning,\n      invalid: !!error,\n      pristine: pristine,\n      submitting: !!submitting,\n      submitFailed: !!submitFailed,\n      touched: !!(state && getIn(state, \'touched\')),\n      valid: !error,\n      visited: !!(state && getIn(state, \'visited\'))\n    }),\n    custom: extends_default()({}, custom, props)\n  };\n};\n\n/* harmony default export */ var es_createFieldProps = (createFieldProps_createFieldProps);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/events/getValue.js\n\n\nvar getSelectedValues = function getSelectedValues(options) {\n  var result = [];\n\n  if (options) {\n    for (var index = 0; index < options.length; index++) {\n      var option = options[index];\n\n      if (option.selected) {\n        result.push(option.value);\n      }\n    }\n  }\n\n  return result;\n};\n\nvar getValue_getValue = function getValue(event, isReactNative) {\n  if (events_isEvent(event)) {\n    if (!isReactNative && event.nativeEvent && event.nativeEvent.text !== undefined) {\n      return event.nativeEvent.text;\n    }\n\n    if (isReactNative && event.nativeEvent !== undefined) {\n      return event.nativeEvent.text;\n    }\n\n    var detypedEvent = event;\n    var _detypedEvent$target = detypedEvent.target,\n        type = _detypedEvent$target.type,\n        value = _detypedEvent$target.value,\n        checked = _detypedEvent$target.checked,\n        files = _detypedEvent$target.files,\n        dataTransfer = detypedEvent.dataTransfer;\n\n    if (type === \'checkbox\') {\n      return !!checked;\n    }\n\n    if (type === \'file\') {\n      return files || dataTransfer && dataTransfer.files;\n    }\n\n    if (type === \'select-multiple\') {\n      return getSelectedValues(event.target.options);\n    }\n\n    return value;\n  }\n\n  return event;\n};\n\n/* harmony default export */ var events_getValue = (getValue_getValue);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/isReactNative.js\nvar isReactNative_isReactNative = typeof window !== \'undefined\' && window.navigator && window.navigator.product && window.navigator.product === \'ReactNative\';\n/* harmony default export */ var es_isReactNative = (isReactNative_isReactNative);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/events/onChangeValue.js\n\n\n\nvar onChangeValue_onChangeValue = function onChangeValue(event, _ref) {\n  var name = _ref.name,\n      parse = _ref.parse,\n      normalize = _ref.normalize;\n  // read value from input\n  var value = events_getValue(event, es_isReactNative); // parse value if we have a parser\n\n  if (parse) {\n    value = parse(value, name);\n  } // normalize value\n\n\n  if (normalize) {\n    value = normalize(name, value);\n  }\n\n  return value;\n};\n\n/* harmony default export */ var events_onChangeValue = (onChangeValue_onChangeValue);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/util/eventConsts.js\nvar dataKey = \'text\';\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/util/validateComponentProp.js\n\n\nvar validateComponentProp_validateComponentProp = function validateComponentProp(props, propName, componentName) {\n  if (!Object(react_is["isValidElementType"])(props[propName])) {\n    return new Error(\'Invalid prop `\' + propName + \'` supplied to\' + \' `\' + componentName + \'`.\');\n  }\n\n  return null;\n};\n\n/* harmony default export */ var util_validateComponentProp = (validateComponentProp_validateComponentProp);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/ConnectedField.js\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar ConnectedField_propsToNotUpdateFor = [\'_reduxForm\'];\n\nvar isObject = function isObject(entity) {\n  return entity && typeof entity === \'object\';\n};\n\nvar ConnectedField_isFunction = function isFunction(entity) {\n  return entity && typeof entity === \'function\';\n};\n\nvar eventPreventDefault = function eventPreventDefault(event) {\n  if (isObject(event) && ConnectedField_isFunction(event.preventDefault)) {\n    event.preventDefault();\n  }\n};\n\nvar eventDataTransferGetData = function eventDataTransferGetData(event, key) {\n  if (isObject(event) && isObject(event.dataTransfer) && ConnectedField_isFunction(event.dataTransfer.getData)) {\n    return event.dataTransfer.getData(key);\n  }\n};\n\nvar eventDataTransferSetData = function eventDataTransferSetData(event, key, value) {\n  if (isObject(event) && isObject(event.dataTransfer) && ConnectedField_isFunction(event.dataTransfer.setData)) {\n    event.dataTransfer.setData(key, value);\n  }\n};\n\nvar ConnectedField_createConnectedField = function createConnectedField(structure) {\n  var deepEqual = structure.deepEqual,\n      getIn = structure.getIn;\n\n  var getSyncError = function getSyncError(syncErrors, name) {\n    var error = plain.getIn(syncErrors, name); // Because the error for this field might not be at a level in the error structure where\n    // it can be set directly, it might need to be unwrapped from the _error property\n\n    return error && error._error ? error._error : error;\n  };\n\n  var getSyncWarning = function getSyncWarning(syncWarnings, name) {\n    var warning = getIn(syncWarnings, name); // Because the warning for this field might not be at a level in the warning structure where\n    // it can be set directly, it might need to be unwrapped from the _warning property\n\n    return warning && warning._warning ? warning._warning : warning;\n  };\n\n  var ConnectedField =\n  /*#__PURE__*/\n  function (_Component) {\n    inheritsLoose_default()(ConnectedField, _Component);\n\n    function ConnectedField() {\n      var _this;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this = _Component.call.apply(_Component, [this].concat(args)) || this;\n      _this.ref = react_default.a.createRef();\n\n      _this.isPristine = function () {\n        return _this.props.pristine;\n      };\n\n      _this.getValue = function () {\n        return _this.props.value;\n      };\n\n      _this.handleChange = function (event) {\n        var _this$props = _this.props,\n            name = _this$props.name,\n            dispatch = _this$props.dispatch,\n            parse = _this$props.parse,\n            normalize = _this$props.normalize,\n            onChange = _this$props.onChange,\n            _reduxForm = _this$props._reduxForm,\n            previousValue = _this$props.value;\n        var newValue = events_onChangeValue(event, {\n          name: name,\n          parse: parse,\n          normalize: normalize\n        });\n        var defaultPrevented = false;\n\n        if (onChange) {\n          // Can\'t seem to find a way to extend Event in React Native,\n          // thus I simply avoid adding preventDefault() in a RN environment\n          // to prevent the following error:\n          // `One of the sources for assign has an enumerable key on the prototype chain`\n          // Reference: https://github.com/facebook/react-native/issues/5507\n          if (!es_isReactNative && events_isEvent(event)) {\n            onChange(extends_default()({}, event, {\n              preventDefault: function preventDefault() {\n                defaultPrevented = true;\n                return eventPreventDefault(event);\n              }\n            }), newValue, previousValue, name);\n          } else {\n            defaultPrevented = onChange(event, newValue, previousValue, name);\n          }\n        }\n\n        if (!defaultPrevented) {\n          // dispatch change action\n          dispatch(_reduxForm.change(name, newValue)); // call post-change callback\n\n          if (_reduxForm.asyncValidate) {\n            _reduxForm.asyncValidate(name, newValue, \'change\');\n          }\n        }\n      };\n\n      _this.handleFocus = function (event) {\n        var _this$props2 = _this.props,\n            name = _this$props2.name,\n            dispatch = _this$props2.dispatch,\n            onFocus = _this$props2.onFocus,\n            _reduxForm = _this$props2._reduxForm;\n        var defaultPrevented = false;\n\n        if (onFocus) {\n          if (!es_isReactNative) {\n            onFocus(extends_default()({}, event, {\n              preventDefault: function preventDefault() {\n                defaultPrevented = true;\n                return eventPreventDefault(event);\n              }\n            }), name);\n          } else {\n            defaultPrevented = onFocus(event, name);\n          }\n        }\n\n        if (!defaultPrevented) {\n          dispatch(_reduxForm.focus(name));\n        }\n      };\n\n      _this.handleBlur = function (event) {\n        var _this$props3 = _this.props,\n            name = _this$props3.name,\n            dispatch = _this$props3.dispatch,\n            parse = _this$props3.parse,\n            normalize = _this$props3.normalize,\n            onBlur = _this$props3.onBlur,\n            _reduxForm = _this$props3._reduxForm,\n            _value = _this$props3._value,\n            previousValue = _this$props3.value;\n        var newValue = events_onChangeValue(event, {\n          name: name,\n          parse: parse,\n          normalize: normalize\n        }); // for checkbox and radio, if the value property of checkbox or radio equals\n        // the value passed by blur event, then fire blur action with previousValue.\n\n        if (newValue === _value && _value !== undefined) {\n          newValue = previousValue;\n        }\n\n        var defaultPrevented = false;\n\n        if (onBlur) {\n          if (!es_isReactNative) {\n            onBlur(extends_default()({}, event, {\n              preventDefault: function preventDefault() {\n                defaultPrevented = true;\n                return eventPreventDefault(event);\n              }\n            }), newValue, previousValue, name);\n          } else {\n            defaultPrevented = onBlur(event, newValue, previousValue, name);\n          }\n        }\n\n        if (!defaultPrevented) {\n          // dispatch blur action\n          dispatch(_reduxForm.blur(name, newValue)); // call post-blur callback\n\n          if (_reduxForm.asyncValidate) {\n            _reduxForm.asyncValidate(name, newValue, \'blur\');\n          }\n        }\n      };\n\n      _this.handleDragStart = function (event) {\n        var _this$props4 = _this.props,\n            name = _this$props4.name,\n            onDragStart = _this$props4.onDragStart,\n            value = _this$props4.value;\n        eventDataTransferSetData(event, dataKey, value == null ? \'\' : value);\n\n        if (onDragStart) {\n          onDragStart(event, name);\n        }\n      };\n\n      _this.handleDrop = function (event) {\n        var _this$props5 = _this.props,\n            name = _this$props5.name,\n            dispatch = _this$props5.dispatch,\n            onDrop = _this$props5.onDrop,\n            _reduxForm = _this$props5._reduxForm,\n            previousValue = _this$props5.value;\n        var newValue = eventDataTransferGetData(event, dataKey);\n        var defaultPrevented = false;\n\n        if (onDrop) {\n          onDrop(extends_default()({}, event, {\n            preventDefault: function preventDefault() {\n              defaultPrevented = true;\n              return eventPreventDefault(event);\n            }\n          }), newValue, previousValue, name);\n        }\n\n        if (!defaultPrevented) {\n          // dispatch change action\n          dispatch(_reduxForm.change(name, newValue));\n          eventPreventDefault(event);\n        }\n      };\n\n      return _this;\n    }\n\n    var _proto = ConnectedField.prototype;\n\n    _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {\n      var _this2 = this;\n\n      var nextPropsKeys = Object.keys(nextProps);\n      var thisPropsKeys = Object.keys(this.props); // if we have children, we MUST update in React 16\n      // https://twitter.com/erikras/status/915866544558788608\n\n      return !!(this.props.children || nextProps.children || nextPropsKeys.length !== thisPropsKeys.length || nextPropsKeys.some(function (prop) {\n        if (~(nextProps.immutableProps || []).indexOf(prop)) {\n          return _this2.props[prop] !== nextProps[prop];\n        }\n\n        return !~ConnectedField_propsToNotUpdateFor.indexOf(prop) && !deepEqual(_this2.props[prop], nextProps[prop]);\n      }));\n    };\n\n    _proto.getRenderedComponent = function getRenderedComponent() {\n      return this.ref.current;\n    };\n\n    _proto.render = function render() {\n      var _this$props6 = this.props,\n          component = _this$props6.component,\n          forwardRef = _this$props6.forwardRef,\n          name = _this$props6.name,\n          _reduxForm = _this$props6._reduxForm,\n          normalize = _this$props6.normalize,\n          onBlur = _this$props6.onBlur,\n          onChange = _this$props6.onChange,\n          onFocus = _this$props6.onFocus,\n          onDragStart = _this$props6.onDragStart,\n          onDrop = _this$props6.onDrop,\n          immutableProps = _this$props6.immutableProps,\n          rest = objectWithoutPropertiesLoose_default()(_this$props6, ["component", "forwardRef", "name", "_reduxForm", "normalize", "onBlur", "onChange", "onFocus", "onDragStart", "onDrop", "immutableProps"]);\n\n      var _createFieldProps = es_createFieldProps(structure, name, extends_default()({}, rest, {\n        form: _reduxForm.form,\n        onBlur: this.handleBlur,\n        onChange: this.handleChange,\n        onDrop: this.handleDrop,\n        onDragStart: this.handleDragStart,\n        onFocus: this.handleFocus\n      })),\n          custom = _createFieldProps.custom,\n          props = objectWithoutPropertiesLoose_default()(_createFieldProps, ["custom"]);\n\n      if (forwardRef) {\n        custom.ref = this.ref;\n      }\n\n      if (typeof component === \'string\') {\n        var input = props.input,\n            meta = props.meta; // eslint-disable-line no-unused-vars\n        // flatten input into other props\n\n        return Object(react["createElement"])(component, extends_default()({}, input, custom));\n      } else {\n        return Object(react["createElement"])(component, extends_default()({}, props, custom));\n      }\n    };\n\n    return ConnectedField;\n  }(react["Component"]);\n\n  ConnectedField.propTypes = {\n    component: util_validateComponentProp,\n    props: prop_types_default.a.object\n  };\n  var connector = connect_connect(function (state, ownProps) {\n    var name = ownProps.name,\n        _ownProps$_reduxForm = ownProps._reduxForm,\n        initialValues = _ownProps$_reduxForm.initialValues,\n        getFormState = _ownProps$_reduxForm.getFormState;\n    var formState = getFormState(state);\n    var initialState = getIn(formState, "initial." + name);\n    var initial = initialState !== undefined ? initialState : initialValues && getIn(initialValues, name);\n    var value = getIn(formState, "values." + name);\n    var submitting = getIn(formState, \'submitting\');\n    var syncError = getSyncError(getIn(formState, \'syncErrors\'), name);\n    var syncWarning = getSyncWarning(getIn(formState, \'syncWarnings\'), name);\n    var pristine = deepEqual(value, initial);\n    return {\n      asyncError: getIn(formState, "asyncErrors." + name),\n      asyncValidating: getIn(formState, \'asyncValidating\') === name,\n      dirty: !pristine,\n      pristine: pristine,\n      state: getIn(formState, "fields." + name),\n      submitError: getIn(formState, "submitErrors." + name),\n      submitFailed: getIn(formState, \'submitFailed\'),\n      submitting: submitting,\n      syncError: syncError,\n      syncWarning: syncWarning,\n      initial: initial,\n      value: value,\n      _value: ownProps.value // save value passed in (for radios)\n\n    };\n  }, undefined, undefined, {\n    forwardRef: true\n  });\n  return connector(ConnectedField);\n};\n\n/* harmony default export */ var es_ConnectedField = (ConnectedField_createConnectedField);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/util/shallowCompare.js\n\n\nvar shallowCompare_customizer = function customizer(objectValue, otherValue, indexOrkey, object, other, stack) {\n  // https://lodash.com/docs/4.17.4#isEqualWith\n  if (stack) {\n    // Shallow compares\n    // For 1st level, stack === undefined.\n    //   -> Do nothing (and implicitly return undefined so that it goes to compare 2nd level)\n    // For 2nd level and up, stack !== undefined.\n    //   -> Compare by === operator\n    return objectValue === otherValue;\n  }\n};\n\nvar shallowCompare_shallowCompare = function shallowCompare(instance, nextProps, nextState) {\n  var propsEqual = isEqualWith_default()(instance.props, nextProps, shallowCompare_customizer);\n\n  var stateEqual = isEqualWith_default()(instance.state, nextState, shallowCompare_customizer);\n\n  return !propsEqual || !stateEqual;\n};\n\n/* harmony default export */ var util_shallowCompare = (shallowCompare_shallowCompare);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/util/prefixName.js\nvar formatName = function formatName(_ref, name) {\n  var sectionPrefix = _ref._reduxForm.sectionPrefix;\n  return sectionPrefix ? sectionPrefix + "." + name : name;\n};\n\n/* harmony default export */ var prefixName = (formatName);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/createField.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar createField_createField = function createField(structure) {\n  var ConnectedField = es_ConnectedField(structure);\n  var setIn = structure.setIn;\n\n  var Field =\n  /*#__PURE__*/\n  function (_Component) {\n    inheritsLoose_default()(Field, _Component);\n\n    function Field(props) {\n      var _this;\n\n      _this = _Component.call(this, props) || this;\n      _this.ref = react_default.a.createRef();\n      _this.ref = react_default.a.createRef();\n\n      _this.normalize = function (name, value) {\n        var normalize = _this.props.normalize;\n\n        if (!normalize) {\n          return value;\n        }\n\n        var previousValues = _this.props._reduxForm.getValues();\n\n        var previousValue = _this.value;\n        var nextValues = setIn(previousValues, name, value);\n        return normalize(value, previousValue, nextValues, previousValues, name);\n      };\n\n      if (!props._reduxForm) {\n        throw new Error(\'Field must be inside a component decorated with reduxForm()\');\n      }\n\n      return _this;\n    }\n\n    var _proto = Field.prototype;\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this2 = this;\n\n      this.props._reduxForm.register(this.name, \'Field\', function () {\n        return _this2.props.validate;\n      }, function () {\n        return _this2.props.warn;\n      });\n    };\n\n    _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {\n      return util_shallowCompare(this, nextProps, nextState);\n    };\n\n    _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n      var oldName = prefixName(this.props, this.props.name);\n      var newName = prefixName(nextProps, nextProps.name);\n\n      if (oldName !== newName || // use deepEqual here because they could be a function or an array of functions\n      !plain.deepEqual(this.props.validate, nextProps.validate) || !plain.deepEqual(this.props.warn, nextProps.warn)) {\n        // unregister old name\n        this.props._reduxForm.unregister(oldName); // register new name\n\n\n        this.props._reduxForm.register(newName, \'Field\', function () {\n          return nextProps.validate;\n        }, function () {\n          return nextProps.warn;\n        });\n      }\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      this.props._reduxForm.unregister(this.name);\n    };\n\n    _proto.getRenderedComponent = function getRenderedComponent() {\n      browser_default()(this.props.forwardRef, \'If you want to access getRenderedComponent(), \' + \'you must specify a forwardRef prop to Field\');\n      return this.ref.current ? this.ref.current.getRenderedComponent() : undefined;\n    };\n\n    _proto.render = function render() {\n      return Object(react["createElement"])(ConnectedField, extends_default()({}, this.props, {\n        name: this.name,\n        normalize: this.normalize,\n        ref: this.ref\n      }));\n    };\n\n    createClass_default()(Field, [{\n      key: "name",\n      get: function get() {\n        return prefixName(this.props, this.props.name);\n      }\n    }, {\n      key: "dirty",\n      get: function get() {\n        return !this.pristine;\n      }\n    }, {\n      key: "pristine",\n      get: function get() {\n        return !!(this.ref.current && this.ref.current.isPristine());\n      }\n    }, {\n      key: "value",\n      get: function get() {\n        return this.ref.current && this.ref.current.getValue();\n      }\n    }]);\n\n    return Field;\n  }(react["Component"]);\n\n  Field.propTypes = {\n    name: prop_types_default.a.string.isRequired,\n    component: util_validateComponentProp,\n    format: prop_types_default.a.func,\n    normalize: prop_types_default.a.func,\n    onBlur: prop_types_default.a.func,\n    onChange: prop_types_default.a.func,\n    onFocus: prop_types_default.a.func,\n    onDragStart: prop_types_default.a.func,\n    onDrop: prop_types_default.a.func,\n    parse: prop_types_default.a.func,\n    props: prop_types_default.a.object,\n    validate: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.arrayOf(prop_types_default.a.func)]),\n    warn: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.arrayOf(prop_types_default.a.func)]),\n    forwardRef: prop_types_default.a.bool,\n    immutableProps: prop_types_default.a.arrayOf(prop_types_default.a.string),\n    _reduxForm: prop_types_default.a.object\n  };\n  Object(react_lifecycles_compat_es["polyfill"])(Field);\n  return ReduxFormContext_withReduxForm(Field);\n};\n\n/* harmony default export */ var es_createField = (createField_createField);\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/redux-form/es/Field.js\n\n\n/* harmony default export */ var es_Field = (es_createField(plain));\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/@material-ui/core/FormControl/index.js\nvar FormControl = __webpack_require__(86);\nvar FormControl_default = /*#__PURE__*/__webpack_require__.n(FormControl);\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/@material-ui/core/Grid/index.js\nvar Grid = __webpack_require__(106);\nvar Grid_default = /*#__PURE__*/__webpack_require__.n(Grid);\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/@material-ui/core/InputLabel/index.js\nvar InputLabel = __webpack_require__(84);\nvar InputLabel_default = /*#__PURE__*/__webpack_require__.n(InputLabel);\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/@material-ui/core/MenuItem/index.js\nvar MenuItem = __webpack_require__(209);\nvar MenuItem_default = /*#__PURE__*/__webpack_require__.n(MenuItem);\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/@material-ui/core/Select/index.js\nvar Select = __webpack_require__(67);\nvar Select_default = /*#__PURE__*/__webpack_require__.n(Select);\n\n// EXTERNAL MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/@material-ui/core/TextField/index.js\nvar TextField = __webpack_require__(138);\nvar TextField_default = /*#__PURE__*/__webpack_require__.n(TextField);\n\n// CONCATENATED MODULE: C:/Users/user/git_workspace/TechOffice-React/900-Library/010-Main/node_modules/@material-ui/core/index.es.js\n/** @license Material-UI v3.8.3\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// CONCATENATED MODULE: ./src/form/control/TextField.tsx\nfunction TextField_extends() { TextField_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return TextField_extends.apply(this, arguments); }\n\n\n\n/* harmony default export */ var control_TextField = (function (field) {\n  return react["createElement"](TextField_default.a, TextField_extends({}, field.input, {\n    label: field.label,\n    required: field.required,\n    disabled: field.disabled\n  }));\n});\n// CONCATENATED MODULE: ./src/form/control/Select.tsx\nfunction Select_extends() { Select_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return Select_extends.apply(this, arguments); }\n\n\n\n/* harmony default export */ var control_Select = (function (field) {\n  return react["createElement"](FormControl_default.a, {\n    style: {\n      minWidth: 120\n    }\n  }, react["createElement"](InputLabel_default.a, null, field.label), react["createElement"](Select_default.a, Select_extends({}, field.input, {\n    required: field.required,\n    disabled: field.disabled\n  }), field.children));\n});\n// CONCATENATED MODULE: ./src/form/control/RemoteSelect.tsx\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction RemoteSelect_extends() { RemoteSelect_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return RemoteSelect_extends.apply(this, arguments); }\n\nfunction RemoteSelect_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction RemoteSelect_possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return RemoteSelect_assertThisInitialized(self); }\n\nfunction RemoteSelect_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction RemoteSelect_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\nvar RemoteSelect_RemoteSelect =\n/*#__PURE__*/\nfunction (_React$Component) {\n  RemoteSelect_inherits(RemoteSelect, _React$Component);\n\n  function RemoteSelect(props) {\n    var _this;\n\n    RemoteSelect_classCallCheck(this, RemoteSelect);\n\n    _this = RemoteSelect_possibleConstructorReturn(this, _getPrototypeOf(RemoteSelect).call(this, props));\n    _this.state = {};\n    _this.rendered = false;\n    return _this;\n  }\n\n  _createClass(RemoteSelect, [{\n    key: "componentDidMount",\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      console.log("remote select");\n      console.log(this.props);\n      this.props.meta.dispatch({\n        type: "LOADING",\n        name: this.props.input.name\n      });\n      setTimeout(function () {\n        var select = [react["createElement"](MenuItem_default.a, {\n          value: 10\n        }, "Remote Ten"), react["createElement"](MenuItem_default.a, {\n          value: 20\n        }, "Remote Twenty"), react["createElement"](MenuItem_default.a, {\n          value: 30\n        }, "Remote Thirty")];\n\n        _this2.setState({\n          select: select\n        });\n      }, 10);\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      return react["createElement"](FormControl_default.a, {\n        style: {\n          minWidth: 120\n        }\n      }, react["createElement"](InputLabel_default.a, null, this.props.label), react["createElement"](Select_default.a, RemoteSelect_extends({}, this.props.input, {\n        required: this.props.required,\n        disabled: this.props.disabled\n      }), this.state.select));\n    }\n  }]);\n\n  return RemoteSelect;\n}(react["Component"]);\n\n\n// CONCATENATED MODULE: ./src/SimpleFormComponent.tsx\nvar _dec, _dec2, _class;\n\nfunction SimpleFormComponent_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { SimpleFormComponent_typeof = function _typeof(obj) { return typeof obj; }; } else { SimpleFormComponent_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return SimpleFormComponent_typeof(obj); }\n\nfunction SimpleFormComponent_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction SimpleFormComponent_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction SimpleFormComponent_createClass(Constructor, protoProps, staticProps) { if (protoProps) SimpleFormComponent_defineProperties(Constructor.prototype, protoProps); if (staticProps) SimpleFormComponent_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction SimpleFormComponent_possibleConstructorReturn(self, call) { if (call && (SimpleFormComponent_typeof(call) === "object" || typeof call === "function")) { return call; } return SimpleFormComponent_assertThisInitialized(self); }\n\nfunction SimpleFormComponent_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction SimpleFormComponent_getPrototypeOf(o) { SimpleFormComponent_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return SimpleFormComponent_getPrototypeOf(o); }\n\nfunction SimpleFormComponent_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) SimpleFormComponent_setPrototypeOf(subClass, superClass); }\n\nfunction SimpleFormComponent_setPrototypeOf(o, p) { SimpleFormComponent_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return SimpleFormComponent_setPrototypeOf(o, p); }\n\n\n\n\n\n\n\n\n/**\r\n * Simple Form Component \r\n */\n\nvar SimpleFormComponent_SimpleFormComponent = (_dec = connect_connect( // map state to props\nfunction (state) {\n  // console.log(state);\n  return {\n    simple: state && state.form && state.form.simple && state.form.simple.values ? state.form.simple.values : {}\n  };\n}, // map dispatch to props\nfunction (dispatch) {\n  return {};\n}), _dec2 = reduxForm({\n  form: \'simple\'\n}), _dec(_class = _dec2(_class =\n/*#__PURE__*/\nfunction (_React$Component) {\n  SimpleFormComponent_inherits(SimpleFormComponent, _React$Component);\n\n  function SimpleFormComponent(props) {\n    var _this;\n\n    SimpleFormComponent_classCallCheck(this, SimpleFormComponent);\n\n    _this = SimpleFormComponent_possibleConstructorReturn(this, SimpleFormComponent_getPrototypeOf(SimpleFormComponent).call(this, props));\n    _this.state = props;\n    return _this;\n  }\n\n  SimpleFormComponent_createClass(SimpleFormComponent, [{\n    key: "render",\n    value: function render() {\n      return react["createElement"]("form", null, react["createElement"](Grid_default.a, {\n        container: true\n      }, react["createElement"](Grid_default.a, {\n        item: true\n      }, react["createElement"](es_Field, {\n        name: "simpleTextField1",\n        label: "Simple Text Field 1",\n        component: control_TextField\n      }))), react["createElement"](Grid_default.a, {\n        container: true\n      }, react["createElement"](Grid_default.a, {\n        item: true\n      }, react["createElement"](es_Field, {\n        name: "simpleSelectField",\n        label: "Simple Select",\n        component: control_Select\n      }, react["createElement"](MenuItem_default.a, {\n        value: 10\n      }, "Ten"), react["createElement"](MenuItem_default.a, {\n        value: 20\n      }, "Twenty"), react["createElement"](MenuItem_default.a, {\n        value: 30\n      }, "Thirty")))), react["createElement"](Grid_default.a, {\n        container: true\n      }, react["createElement"](Grid_default.a, {\n        item: true\n      }, react["createElement"](es_Field, {\n        name: "remoteSelectField",\n        label: "Remote Select",\n        component: RemoteSelect_RemoteSelect\n      }))));\n    }\n  }]);\n\n  return SimpleFormComponent;\n}(react["Component"])) || _class) || _class);\n\n// CONCATENATED MODULE: ./src/App.tsx\nvar App_dec, App_class;\n\nfunction App_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { App_typeof = function _typeof(obj) { return typeof obj; }; } else { App_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return App_typeof(obj); }\n\nfunction App_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction App_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction App_createClass(Constructor, protoProps, staticProps) { if (protoProps) App_defineProperties(Constructor.prototype, protoProps); if (staticProps) App_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction App_possibleConstructorReturn(self, call) { if (call && (App_typeof(call) === "object" || typeof call === "function")) { return call; } return App_assertThisInitialized(self); }\n\nfunction App_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction App_getPrototypeOf(o) { App_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return App_getPrototypeOf(o); }\n\nfunction App_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) App_setPrototypeOf(subClass, superClass); }\n\nfunction App_setPrototypeOf(o, p) { App_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return App_setPrototypeOf(o, p); }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === \'function\') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\n\nvar rootReducer = combineReducers({\n  form: es_reducer.plugin({\n    loading: function loading(state, action) {\n      switch (action.type) {\n        case "LOADING":\n          if (!action.name) {\n            return state;\n          }\n\n          if (!state) {\n            state = {};\n          }\n\n          return _objectSpread({}, state, {\n            loading: true\n          });\n\n        default:\n          state;\n      }\n    }\n  })\n});\nvar App_store = createStore_createStore(rootReducer, {});\nvar App_App = (App_dec = connect_connect( // map state to props\nfunction (state) {\n  // console.log(state);\n  return {\n    simple: state && state.form && state.form.simple && state.form.simple.values ? state.form.simple.values : {},\n    form: state && state.form && state.form.simple ? state.form.simple : {}\n  };\n}, // map dispatch to props\nfunction (dispatch) {\n  return {};\n}), App_dec(App_class =\n/*#__PURE__*/\nfunction (_React$Component) {\n  App_inherits(App, _React$Component);\n\n  function App(props) {\n    var _this;\n\n    App_classCallCheck(this, App);\n\n    _this = App_possibleConstructorReturn(this, App_getPrototypeOf(App).call(this, props));\n    _this.state = props;\n    return _this;\n  }\n\n  App_createClass(App, [{\n    key: "componentWillReceiveProps",\n    value: function componentWillReceiveProps(nextProps) {\n      console.log(\'componentWillReceiveProps\', nextProps);\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      return react["createElement"]("div", null, react["createElement"]("h1", null, "Hello World"), react["createElement"](SimpleFormComponent_SimpleFormComponent, null), react["createElement"]("div", null, this.props.simple.simpleTextField1), react["createElement"]("div", null, this.props.simple.simpleSelectField), react["createElement"]("div", null, this.props.simple.remoteSelectField));\n    }\n  }]);\n\n  return App;\n}(react["Component"])) || App_class);\nreact_dom["render"](react["createElement"](components_Provider, {\n  store: App_store\n}, react["createElement"](App_App, null)), document.getElementById(\'app\'));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fcm9vdC5qcz9lNTc1Iiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19TeW1ib2wuanM/YTJmNCIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UmF3VGFnLmpzPzEzMjIiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX29iamVjdFRvU3RyaW5nLmpzPzgzODAiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VHZXRUYWcuanM/ZTJhMSIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb3ZlckFyZy5qcz85MzAwIiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRQcm90b3R5cGUuanM/MzU1NCIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdExpa2UuanM/NzU0NSIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1BsYWluT2JqZWN0LmpzPzMwODAiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9yZWR1eC9lcy9jcmVhdGVTdG9yZS5qcz8zM2NlIiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVkdXgvZXMvdXRpbHMvd2FybmluZy5qcz80Njk5Iiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVkdXgvZXMvY29tYmluZVJlZHVjZXJzLmpzP2EyMDciLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9yZWR1eC9lcy9iaW5kQWN0aW9uQ3JlYXRvcnMuanM/YTQ0NSIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlZHV4L2VzL2NvbXBvc2UuanM/ZjFkYyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlZHV4L2VzL2FwcGx5TWlkZGxld2FyZS5qcz84NzdjIiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVkdXgvZXMvaW5kZXguanM/NGU3ZiIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlZHV4LWZvcm0vZXMvYWN0aW9uVHlwZXMuanM/ZmI2OSIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlZHV4LWZvcm0vZXMvZGVsZXRlSW5XaXRoQ2xlYW5VcC5qcz9lMGRkIiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVkdXgtZm9ybS9lcy9zdHJ1Y3R1cmUvcGxhaW4vc3BsaWNlLmpzPzQ4YWYiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9yZWR1eC1mb3JtL2VzL3N0cnVjdHVyZS9wbGFpbi9nZXRJbi5qcz81OWY4Iiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVkdXgtZm9ybS9lcy9zdHJ1Y3R1cmUvcGxhaW4vc2V0SW4uanM/YjE0NiIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlZHV4LWZvcm0vZXMvc3RydWN0dXJlL3BsYWluL2RlZXBFcXVhbC5qcz9mOGI0Iiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVkdXgtZm9ybS9lcy9zdHJ1Y3R1cmUvcGxhaW4vZGVsZXRlSW4uanM/YjY5YyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlZHV4LWZvcm0vZXMvc3RydWN0dXJlL3BsYWluL2tleXMuanM/MmU3NiIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlZHV4LWZvcm0vZXMvc3RydWN0dXJlL3BsYWluL2luZGV4LmpzPzQ2Y2MiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9yZWR1eC1mb3JtL2VzL2NyZWF0ZVJlZHVjZXIuanM/N2IxZCIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlZHV4LWZvcm0vZXMvcmVkdWNlci5qcz9iYWY5Iiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNMb29zZS5qcz9kZWNlIiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvdXRpbHMvUHJvcFR5cGVzLmpzPzcxMjYiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy93YXJuaW5nLmpzPzEzN2EiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb21wb25lbnRzL1Byb3ZpZGVyLmpzPzAxNjAiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanM/MzI4MiIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMuanM/ZWVkMSIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UuanM/ZWNiMyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL3V0aWxzL1N1YnNjcmlwdGlvbi5qcz9mMGFkIiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29tcG9uZW50cy9jb25uZWN0QWR2YW5jZWQuanM/MTBhNiIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL3V0aWxzL3NoYWxsb3dFcXVhbC5qcz9kOTQ1Iiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvdXRpbHMvaXNQbGFpbk9iamVjdC5qcz8yNTI2Iiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvdXRpbHMvdmVyaWZ5UGxhaW5PYmplY3QuanM/ODM4YSIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3Qvd3JhcE1hcFRvUHJvcHMuanM/MmNhNyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3QvbWFwRGlzcGF0Y2hUb1Byb3BzLmpzPzVlMWMiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L21hcFN0YXRlVG9Qcm9wcy5qcz84YjA0Iiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29ubmVjdC9tZXJnZVByb3BzLmpzP2FlYmQiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L3ZlcmlmeVN1YnNlbGVjdG9ycy5qcz80YzQ3Iiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29ubmVjdC9zZWxlY3RvckZhY3RvcnkuanM/NDZkNiIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3QvY29ubmVjdC5qcz9hNjAyIiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvaW5kZXguanM/N2JkYyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlZHV4LWZvcm0vZXMvYWN0aW9ucy5qcz8yMDhkIiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVkdXgtZm9ybS9lcy9hc3luY1ZhbGlkYXRpb24uanM/ZjdmZSIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlZHV4LWZvcm0vZXMvZGVmYXVsdFNob3VsZEFzeW5jVmFsaWRhdGUuanM/ODExYSIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlZHV4LWZvcm0vZXMvZGVmYXVsdFNob3VsZFZhbGlkYXRlLmpzPzA5OTgiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9yZWR1eC1mb3JtL2VzL2RlZmF1bHRTaG91bGRFcnJvci5qcz8zYzE3Iiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVkdXgtZm9ybS9lcy9kZWZhdWx0U2hvdWxkV2Fybi5qcz85YzczIiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVkdXgtZm9ybS9lcy9ldmVudHMvaXNFdmVudC5qcz8wMmE0Iiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVkdXgtZm9ybS9lcy9ldmVudHMvc2lsZW5jZUV2ZW50LmpzP2RiYzQiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9yZWR1eC1mb3JtL2VzL2V2ZW50cy9zaWxlbmNlRXZlbnRzLmpzPzY3NzEiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9yZWR1eC1mb3JtL2VzL2dlbmVyYXRlVmFsaWRhdG9yLmpzPzllNzciLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9lczYtZXJyb3IvZXM2L2luZGV4LmpzPzhkZDUiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9yZWR1eC1mb3JtL2VzL1N1Ym1pc3Npb25FcnJvci5qcz8zNDU0Iiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVkdXgtZm9ybS9lcy9oYW5kbGVTdWJtaXQuanM/ZDdlYyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlZHV4LWZvcm0vZXMvaGFzRXJyb3IuanM/Y2ZjYyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlZHV4LWZvcm0vZXMvc2VsZWN0b3JzL2lzVmFsaWQuanM/ODBjNSIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlZHV4LWZvcm0vZXMvdXRpbC9nZXREaXNwbGF5TmFtZS5qcz80NjE5Iiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVkdXgtZm9ybS9lcy9SZWR1eEZvcm1Db250ZXh0LmpzPzQxMGUiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9yZWR1eC1mb3JtL2VzL2NyZWF0ZVJlZHV4Rm9ybS5qcz8yZjk0Iiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVkdXgtZm9ybS9lcy9yZWR1eEZvcm0uanM/ODkzYSIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlZHV4LWZvcm0vZXMvY3JlYXRlRmllbGRQcm9wcy5qcz9mMjUzIiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVkdXgtZm9ybS9lcy9ldmVudHMvZ2V0VmFsdWUuanM/NTIwMSIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlZHV4LWZvcm0vZXMvaXNSZWFjdE5hdGl2ZS5qcz8zNDI0Iiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVkdXgtZm9ybS9lcy9ldmVudHMvb25DaGFuZ2VWYWx1ZS5qcz9lNzA4Iiwid2VicGFjazovLy9DOi9Vc2Vycy91c2VyL2dpdF93b3Jrc3BhY2UvVGVjaE9mZmljZS1SZWFjdC85MDAtTGlicmFyeS8wMTAtTWFpbi9ub2RlX21vZHVsZXMvcmVkdXgtZm9ybS9lcy91dGlsL2V2ZW50Q29uc3RzLmpzPzAwNjgiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9yZWR1eC1mb3JtL2VzL3V0aWwvdmFsaWRhdGVDb21wb25lbnRQcm9wLmpzPzE1ZGIiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9yZWR1eC1mb3JtL2VzL0Nvbm5lY3RlZEZpZWxkLmpzPzMyYTMiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9yZWR1eC1mb3JtL2VzL3V0aWwvc2hhbGxvd0NvbXBhcmUuanM/YjVhZCIsIndlYnBhY2s6Ly8vQzovVXNlcnMvdXNlci9naXRfd29ya3NwYWNlL1RlY2hPZmZpY2UtUmVhY3QvOTAwLUxpYnJhcnkvMDEwLU1haW4vbm9kZV9tb2R1bGVzL3JlZHV4LWZvcm0vZXMvdXRpbC9wcmVmaXhOYW1lLmpzPzVkZTQiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9yZWR1eC1mb3JtL2VzL2NyZWF0ZUZpZWxkLmpzPzM5NTciLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9yZWR1eC1mb3JtL2VzL0ZpZWxkLmpzPzBjMmUiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL3VzZXIvZ2l0X3dvcmtzcGFjZS9UZWNoT2ZmaWNlLVJlYWN0LzkwMC1MaWJyYXJ5LzAxMC1NYWluL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9pbmRleC5lcy5qcz80YTU2Iiwid2VicGFjazovLy8uL3NyYy9mb3JtL2NvbnRyb2wvVGV4dEZpZWxkLnRzeD8wNjE1Iiwid2VicGFjazovLy8uL3NyYy9mb3JtL2NvbnRyb2wvU2VsZWN0LnRzeD81ZDY4Iiwid2VicGFjazovLy8uL3NyYy9mb3JtL2NvbnRyb2wvUmVtb3RlU2VsZWN0LnRzeD9lNTYyIiwid2VicGFjazovLy8uL3NyYy9TaW1wbGVGb3JtQ29tcG9uZW50LnRzeD8wNzhkIiwid2VicGFjazovLy8uL3NyYy9BcHAudHN4PzFjNmQiXSwibmFtZXMiOlsiZmllbGQiLCJpbnB1dCIsImxhYmVsIiwicmVxdWlyZWQiLCJkaXNhYmxlZCIsIm1pbldpZHRoIiwiY2hpbGRyZW4iLCJSZW1vdGVTZWxlY3QiLCJwcm9wcyIsInN0YXRlIiwicmVuZGVyZWQiLCJjb25zb2xlIiwibG9nIiwibWV0YSIsImRpc3BhdGNoIiwidHlwZSIsIm5hbWUiLCJzZXRUaW1lb3V0Iiwic2VsZWN0Iiwic2V0U3RhdGUiLCJSZWFjdCIsIlNpbXBsZUZvcm1Db21wb25lbnQiLCJjb25uZWN0Iiwic2ltcGxlIiwiZm9ybSIsInZhbHVlcyIsInJlZHV4Rm9ybSIsIlRleHRGaWVsZCIsIlNlbGVjdCIsInJvb3RSZWR1Y2VyIiwiY29tYmluZVJlZHVjZXJzIiwicmVkdWNlciIsInBsdWdpbiIsImxvYWRpbmciLCJhY3Rpb24iLCJzdG9yZSIsImNyZWF0ZVN0b3JlIiwiQXBwIiwibmV4dFByb3BzIiwic2ltcGxlVGV4dEZpZWxkMSIsInNpbXBsZVNlbGVjdEZpZWxkIiwicmVtb3RlU2VsZWN0RmllbGQiLCJSZWFjdERPTSIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBMEM7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLDhCQUFVOztBQUVOLDhDQUFJLEVBQUM7OztBQ1JVOztBQUU5QjtBQUNBLElBQUksY0FBTSxHQUFHLEtBQUk7O0FBRUYsMERBQU0sRUFBQzs7O0FDTFk7O0FBRWxDO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLHlCQUFjOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsT0FBTSxHQUFHLE9BQU07O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQSxjQUFjLHlCQUFjO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZSx3REFBUyxFQUFDOzs7QUM3Q3pCO0FBQ0EsSUFBSSwyQkFBVzs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxvQ0FBb0IsR0FBRywyQkFBVzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBLFNBQVMsb0NBQW9CO0FBQzdCOztBQUVlLGtFQUFjLEVBQUM7OztBQ3JCSTtBQUNNO0FBQ1U7O0FBRWxEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksMEJBQWMsR0FBRyxPQUFNLEdBQUcsT0FBTTs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLE9B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SSxFQUFFZixLQUFLLElBQUlBLEtBQUssQ0FBQ2UsSUFBZixJQUF1QmYsS0FBSyxDQUFDZSxJQUFOLENBQVdELE1BQWxDLEdBQTJDZCxLQUFLLENBQUNlLElBQU4sQ0FBV0QsTUFBdEQsR0FBK0Q7QUFGbEUsR0FBUDtBQUlILENBUkksRUFTTDtBQUNBLFVBQVNULFFBQVQsRUFBa0I7QUFDZCxTQUFPLEVBQVA7QUFDSCxDQVpJLEM7Ozs7O0FBZ0JMLGVBQVlOLEtBQVosRUFBa0I7QUFBQTs7QUFBQTs7QUFDZCxtRkFBTUEsS0FBTjtBQUNBLFVBQUtDLEtBQUwsR0FBYUQsS0FBYjtBQUZjO0FBR2pCOzs7OzhDQUV5QjhCLFMsRUFBVTtBQUNoQzNCLGFBQU8sQ0FBQ0MsR0FBUixDQUFZLDJCQUFaLEVBQXlDMEIsU0FBekM7QUFDSDs7OzZCQUVPO0FBQ0osYUFDSSxvQ0FDSSxpREFESixFQUVRLHVCQUFDLHVDQUFELE9BRlIsRUFHSSxvQ0FDSyxLQUFLOUIsS0FBTCxDQUFXZSxNQUFYLENBQWtCZ0IsZ0JBRHZCLENBSEosRUFNSSxvQ0FDSyxLQUFLL0IsS0FBTCxDQUFXZSxNQUFYLENBQWtCaUIsaUJBRHZCLENBTkosRUFTSSxvQ0FDSyxLQUFLaEMsS0FBTCxDQUFXZSxNQUFYLENBQWtCa0IsaUJBRHZCLENBVEosQ0FESjtBQWVIOzs7O0VBM0JhckIsa0I7QUErQmxCc0IsbUJBQUEsQ0FDSSx1QkFBQyxtQkFBRDtBQUFVLE9BQUssRUFBRVAsU0FBS0E7QUFBdEIsR0FDSSx1QkFBQyxPQUFELE9BREosQ0FESixFQUlBUSxRQUFRLENBQUNDLGNBQVQsQ0FBd0IsS0FBeEIsQ0FKQSIsImZpbGUiOiI0NTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZnJlZUdsb2JhbCBmcm9tICcuL19mcmVlR2xvYmFsLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5leHBvcnQgZGVmYXVsdCByb290O1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5leHBvcnQgZGVmYXVsdCBTeW1ib2w7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0UmF3VGFnO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG9iamVjdFRvU3RyaW5nO1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuaW1wb3J0IGdldFJhd1RhZyBmcm9tICcuL19nZXRSYXdUYWcuanMnO1xuaW1wb3J0IG9iamVjdFRvU3RyaW5nIGZyb20gJy4vX29iamVjdFRvU3RyaW5nLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VHZXRUYWc7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb3ZlckFyZztcbiIsImltcG9ydCBvdmVyQXJnIGZyb20gJy4vX292ZXJBcmcuanMnO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcblxuZXhwb3J0IGRlZmF1bHQgZ2V0UHJvdG90eXBlO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzT2JqZWN0TGlrZTtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGdldFByb3RvdHlwZSBmcm9tICcuL19nZXRQcm90b3R5cGUuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNQbGFpbk9iamVjdDtcbiIsImltcG9ydCBpc1BsYWluT2JqZWN0IGZyb20gJ2xvZGFzaC1lcy9pc1BsYWluT2JqZWN0JztcbmltcG9ydCAkJG9ic2VydmFibGUgZnJvbSAnc3ltYm9sLW9ic2VydmFibGUnO1xuXG4vKipcbiAqIFRoZXNlIGFyZSBwcml2YXRlIGFjdGlvbiB0eXBlcyByZXNlcnZlZCBieSBSZWR1eC5cbiAqIEZvciBhbnkgdW5rbm93biBhY3Rpb25zLCB5b3UgbXVzdCByZXR1cm4gdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBJZiB0aGUgY3VycmVudCBzdGF0ZSBpcyB1bmRlZmluZWQsIHlvdSBtdXN0IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZS5cbiAqIERvIG5vdCByZWZlcmVuY2UgdGhlc2UgYWN0aW9uIHR5cGVzIGRpcmVjdGx5IGluIHlvdXIgY29kZS5cbiAqL1xuZXhwb3J0IHZhciBBY3Rpb25UeXBlcyA9IHtcbiAgSU5JVDogJ0BAcmVkdXgvSU5JVCdcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFJlZHV4IHN0b3JlIHRoYXQgaG9sZHMgdGhlIHN0YXRlIHRyZWUuXG4gICAqIFRoZSBvbmx5IHdheSB0byBjaGFuZ2UgdGhlIGRhdGEgaW4gdGhlIHN0b3JlIGlzIHRvIGNhbGwgYGRpc3BhdGNoKClgIG9uIGl0LlxuICAgKlxuICAgKiBUaGVyZSBzaG91bGQgb25seSBiZSBhIHNpbmdsZSBzdG9yZSBpbiB5b3VyIGFwcC4gVG8gc3BlY2lmeSBob3cgZGlmZmVyZW50XG4gICAqIHBhcnRzIG9mIHRoZSBzdGF0ZSB0cmVlIHJlc3BvbmQgdG8gYWN0aW9ucywgeW91IG1heSBjb21iaW5lIHNldmVyYWwgcmVkdWNlcnNcbiAgICogaW50byBhIHNpbmdsZSByZWR1Y2VyIGZ1bmN0aW9uIGJ5IHVzaW5nIGBjb21iaW5lUmVkdWNlcnNgLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWR1Y2VyIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBuZXh0IHN0YXRlIHRyZWUsIGdpdmVuXG4gICAqIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgYW5kIHRoZSBhY3Rpb24gdG8gaGFuZGxlLlxuICAgKlxuICAgKiBAcGFyYW0ge2FueX0gW3ByZWxvYWRlZFN0YXRlXSBUaGUgaW5pdGlhbCBzdGF0ZS4gWW91IG1heSBvcHRpb25hbGx5IHNwZWNpZnkgaXRcbiAgICogdG8gaHlkcmF0ZSB0aGUgc3RhdGUgZnJvbSB0aGUgc2VydmVyIGluIHVuaXZlcnNhbCBhcHBzLCBvciB0byByZXN0b3JlIGFcbiAgICogcHJldmlvdXNseSBzZXJpYWxpemVkIHVzZXIgc2Vzc2lvbi5cbiAgICogSWYgeW91IHVzZSBgY29tYmluZVJlZHVjZXJzYCB0byBwcm9kdWNlIHRoZSByb290IHJlZHVjZXIgZnVuY3Rpb24sIHRoaXMgbXVzdCBiZVxuICAgKiBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzaGFwZSBhcyBgY29tYmluZVJlZHVjZXJzYCBrZXlzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZW5oYW5jZXJdIFRoZSBzdG9yZSBlbmhhbmNlci4gWW91IG1heSBvcHRpb25hbGx5IHNwZWNpZnkgaXRcbiAgICogdG8gZW5oYW5jZSB0aGUgc3RvcmUgd2l0aCB0aGlyZC1wYXJ0eSBjYXBhYmlsaXRpZXMgc3VjaCBhcyBtaWRkbGV3YXJlLFxuICAgKiB0aW1lIHRyYXZlbCwgcGVyc2lzdGVuY2UsIGV0Yy4gVGhlIG9ubHkgc3RvcmUgZW5oYW5jZXIgdGhhdCBzaGlwcyB3aXRoIFJlZHV4XG4gICAqIGlzIGBhcHBseU1pZGRsZXdhcmUoKWAuXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdG9yZX0gQSBSZWR1eCBzdG9yZSB0aGF0IGxldHMgeW91IHJlYWQgdGhlIHN0YXRlLCBkaXNwYXRjaCBhY3Rpb25zXG4gICAqIGFuZCBzdWJzY3JpYmUgdG8gY2hhbmdlcy5cbiAgICovXG59O2V4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZVN0b3JlKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBlbmhhbmNlcikge1xuICB2YXIgX3JlZjI7XG5cbiAgaWYgKHR5cGVvZiBwcmVsb2FkZWRTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZW5oYW5jZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZW5oYW5jZXIgPSBwcmVsb2FkZWRTdGF0ZTtcbiAgICBwcmVsb2FkZWRTdGF0ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBlbmhhbmNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgZW5oYW5jZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5oYW5jZXIoY3JlYXRlU3RvcmUpKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIHJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHZhciBjdXJyZW50UmVkdWNlciA9IHJlZHVjZXI7XG4gIHZhciBjdXJyZW50U3RhdGUgPSBwcmVsb2FkZWRTdGF0ZTtcbiAgdmFyIGN1cnJlbnRMaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzO1xuICB2YXIgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKG5leHRMaXN0ZW5lcnMgPT09IGN1cnJlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzLnNsaWNlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIHRoZSBzdGF0ZSB0cmVlIG1hbmFnZWQgYnkgdGhlIHN0b3JlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7YW55fSBUaGUgY3VycmVudCBzdGF0ZSB0cmVlIG9mIHlvdXIgYXBwbGljYXRpb24uXG4gICAqL1xuICBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICByZXR1cm4gY3VycmVudFN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBjaGFuZ2UgbGlzdGVuZXIuIEl0IHdpbGwgYmUgY2FsbGVkIGFueSB0aW1lIGFuIGFjdGlvbiBpcyBkaXNwYXRjaGVkLFxuICAgKiBhbmQgc29tZSBwYXJ0IG9mIHRoZSBzdGF0ZSB0cmVlIG1heSBwb3RlbnRpYWxseSBoYXZlIGNoYW5nZWQuIFlvdSBtYXkgdGhlblxuICAgKiBjYWxsIGBnZXRTdGF0ZSgpYCB0byByZWFkIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgaW5zaWRlIHRoZSBjYWxsYmFjay5cbiAgICpcbiAgICogWW91IG1heSBjYWxsIGBkaXNwYXRjaCgpYCBmcm9tIGEgY2hhbmdlIGxpc3RlbmVyLCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICogY2F2ZWF0czpcbiAgICpcbiAgICogMS4gVGhlIHN1YnNjcmlwdGlvbnMgYXJlIHNuYXBzaG90dGVkIGp1c3QgYmVmb3JlIGV2ZXJ5IGBkaXNwYXRjaCgpYCBjYWxsLlxuICAgKiBJZiB5b3Ugc3Vic2NyaWJlIG9yIHVuc3Vic2NyaWJlIHdoaWxlIHRoZSBsaXN0ZW5lcnMgYXJlIGJlaW5nIGludm9rZWQsIHRoaXNcbiAgICogd2lsbCBub3QgaGF2ZSBhbnkgZWZmZWN0IG9uIHRoZSBgZGlzcGF0Y2goKWAgdGhhdCBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3MuXG4gICAqIEhvd2V2ZXIsIHRoZSBuZXh0IGBkaXNwYXRjaCgpYCBjYWxsLCB3aGV0aGVyIG5lc3RlZCBvciBub3QsIHdpbGwgdXNlIGEgbW9yZVxuICAgKiByZWNlbnQgc25hcHNob3Qgb2YgdGhlIHN1YnNjcmlwdGlvbiBsaXN0LlxuICAgKlxuICAgKiAyLiBUaGUgbGlzdGVuZXIgc2hvdWxkIG5vdCBleHBlY3QgdG8gc2VlIGFsbCBzdGF0ZSBjaGFuZ2VzLCBhcyB0aGUgc3RhdGVcbiAgICogbWlnaHQgaGF2ZSBiZWVuIHVwZGF0ZWQgbXVsdGlwbGUgdGltZXMgZHVyaW5nIGEgbmVzdGVkIGBkaXNwYXRjaCgpYCBiZWZvcmVcbiAgICogdGhlIGxpc3RlbmVyIGlzIGNhbGxlZC4gSXQgaXMsIGhvd2V2ZXIsIGd1YXJhbnRlZWQgdGhhdCBhbGwgc3Vic2NyaWJlcnNcbiAgICogcmVnaXN0ZXJlZCBiZWZvcmUgdGhlIGBkaXNwYXRjaCgpYCBzdGFydGVkIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGxhdGVzdFxuICAgKiBzdGF0ZSBieSB0aGUgdGltZSBpdCBleGl0cy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgQSBjYWxsYmFjayB0byBiZSBpbnZva2VkIG9uIGV2ZXJ5IGRpc3BhdGNoLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdG8gcmVtb3ZlIHRoaXMgY2hhbmdlIGxpc3RlbmVyLlxuICAgKi9cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIHZhciBpc1N1YnNjcmliZWQgPSB0cnVlO1xuXG4gICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgIG5leHRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICBpZiAoIWlzU3Vic2NyaWJlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlzU3Vic2NyaWJlZCA9IGZhbHNlO1xuXG4gICAgICBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCk7XG4gICAgICB2YXIgaW5kZXggPSBuZXh0TGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgbmV4dExpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhbiBhY3Rpb24uIEl0IGlzIHRoZSBvbmx5IHdheSB0byB0cmlnZ2VyIGEgc3RhdGUgY2hhbmdlLlxuICAgKlxuICAgKiBUaGUgYHJlZHVjZXJgIGZ1bmN0aW9uLCB1c2VkIHRvIGNyZWF0ZSB0aGUgc3RvcmUsIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlXG4gICAqIGN1cnJlbnQgc3RhdGUgdHJlZSBhbmQgdGhlIGdpdmVuIGBhY3Rpb25gLiBJdHMgcmV0dXJuIHZhbHVlIHdpbGxcbiAgICogYmUgY29uc2lkZXJlZCB0aGUgKipuZXh0Kiogc3RhdGUgb2YgdGhlIHRyZWUsIGFuZCB0aGUgY2hhbmdlIGxpc3RlbmVyc1xuICAgKiB3aWxsIGJlIG5vdGlmaWVkLlxuICAgKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvbmx5IHN1cHBvcnRzIHBsYWluIG9iamVjdCBhY3Rpb25zLiBJZiB5b3Ugd2FudCB0b1xuICAgKiBkaXNwYXRjaCBhIFByb21pc2UsIGFuIE9ic2VydmFibGUsIGEgdGh1bmssIG9yIHNvbWV0aGluZyBlbHNlLCB5b3UgbmVlZCB0b1xuICAgKiB3cmFwIHlvdXIgc3RvcmUgY3JlYXRpbmcgZnVuY3Rpb24gaW50byB0aGUgY29ycmVzcG9uZGluZyBtaWRkbGV3YXJlLiBGb3JcbiAgICogZXhhbXBsZSwgc2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciB0aGUgYHJlZHV4LXRodW5rYCBwYWNrYWdlLiBFdmVuIHRoZVxuICAgKiBtaWRkbGV3YXJlIHdpbGwgZXZlbnR1YWxseSBkaXNwYXRjaCBwbGFpbiBvYmplY3QgYWN0aW9ucyB1c2luZyB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBBIHBsYWluIG9iamVjdCByZXByZXNlbnRpbmcg4oCcd2hhdCBjaGFuZ2Vk4oCdLiBJdCBpc1xuICAgKiBhIGdvb2QgaWRlYSB0byBrZWVwIGFjdGlvbnMgc2VyaWFsaXphYmxlIHNvIHlvdSBjYW4gcmVjb3JkIGFuZCByZXBsYXkgdXNlclxuICAgKiBzZXNzaW9ucywgb3IgdXNlIHRoZSB0aW1lIHRyYXZlbGxpbmcgYHJlZHV4LWRldnRvb2xzYC4gQW4gYWN0aW9uIG11c3QgaGF2ZVxuICAgKiBhIGB0eXBlYCBwcm9wZXJ0eSB3aGljaCBtYXkgbm90IGJlIGB1bmRlZmluZWRgLiBJdCBpcyBhIGdvb2QgaWRlYSB0byB1c2VcbiAgICogc3RyaW5nIGNvbnN0YW50cyBmb3IgYWN0aW9uIHR5cGVzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBGb3IgY29udmVuaWVuY2UsIHRoZSBzYW1lIGFjdGlvbiBvYmplY3QgeW91IGRpc3BhdGNoZWQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCwgaWYgeW91IHVzZSBhIGN1c3RvbSBtaWRkbGV3YXJlLCBpdCBtYXkgd3JhcCBgZGlzcGF0Y2goKWAgdG9cbiAgICogcmV0dXJuIHNvbWV0aGluZyBlbHNlIChmb3IgZXhhbXBsZSwgYSBQcm9taXNlIHlvdSBjYW4gYXdhaXQpLlxuICAgKi9cbiAgZnVuY3Rpb24gZGlzcGF0Y2goYWN0aW9uKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KGFjdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWN0aW9ucyBtdXN0IGJlIHBsYWluIG9iamVjdHMuICcgKyAnVXNlIGN1c3RvbSBtaWRkbGV3YXJlIGZvciBhc3luYyBhY3Rpb25zLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYWN0aW9uLnR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdGlvbnMgbWF5IG5vdCBoYXZlIGFuIHVuZGVmaW5lZCBcInR5cGVcIiBwcm9wZXJ0eS4gJyArICdIYXZlIHlvdSBtaXNzcGVsbGVkIGEgY29uc3RhbnQ/Jyk7XG4gICAgfVxuXG4gICAgaWYgKGlzRGlzcGF0Y2hpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVkdWNlcnMgbWF5IG5vdCBkaXNwYXRjaCBhY3Rpb25zLicpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpc0Rpc3BhdGNoaW5nID0gdHJ1ZTtcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnRSZWR1Y2VyKGN1cnJlbnRTdGF0ZSwgYWN0aW9uKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBsaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzID0gbmV4dExpc3RlbmVycztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzW2ldO1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSByZWR1Y2VyIGN1cnJlbnRseSB1c2VkIGJ5IHRoZSBzdG9yZSB0byBjYWxjdWxhdGUgdGhlIHN0YXRlLlxuICAgKlxuICAgKiBZb3UgbWlnaHQgbmVlZCB0aGlzIGlmIHlvdXIgYXBwIGltcGxlbWVudHMgY29kZSBzcGxpdHRpbmcgYW5kIHlvdSB3YW50IHRvXG4gICAqIGxvYWQgc29tZSBvZiB0aGUgcmVkdWNlcnMgZHluYW1pY2FsbHkuIFlvdSBtaWdodCBhbHNvIG5lZWQgdGhpcyBpZiB5b3VcbiAgICogaW1wbGVtZW50IGEgaG90IHJlbG9hZGluZyBtZWNoYW5pc20gZm9yIFJlZHV4LlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0UmVkdWNlciBUaGUgcmVkdWNlciBmb3IgdGhlIHN0b3JlIHRvIHVzZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGZ1bmN0aW9uIHJlcGxhY2VSZWR1Y2VyKG5leHRSZWR1Y2VyKSB7XG4gICAgaWYgKHR5cGVvZiBuZXh0UmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgbmV4dFJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICBjdXJyZW50UmVkdWNlciA9IG5leHRSZWR1Y2VyO1xuICAgIGRpc3BhdGNoKHsgdHlwZTogQWN0aW9uVHlwZXMuSU5JVCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm9wZXJhYmlsaXR5IHBvaW50IGZvciBvYnNlcnZhYmxlL3JlYWN0aXZlIGxpYnJhcmllcy5cbiAgICogQHJldHVybnMge29ic2VydmFibGV9IEEgbWluaW1hbCBvYnNlcnZhYmxlIG9mIHN0YXRlIGNoYW5nZXMuXG4gICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhlIG9ic2VydmFibGUgcHJvcG9zYWw6XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9ic2VydmFibGVcbiAgICovXG4gIGZ1bmN0aW9uIG9ic2VydmFibGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgb3V0ZXJTdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gICAgcmV0dXJuIF9yZWYgPSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBtaW5pbWFsIG9ic2VydmFibGUgc3Vic2NyaXB0aW9uIG1ldGhvZC5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYnNlcnZlciBBbnkgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgYXMgYW4gb2JzZXJ2ZXIuXG4gICAgICAgKiBUaGUgb2JzZXJ2ZXIgb2JqZWN0IHNob3VsZCBoYXZlIGEgYG5leHRgIG1ldGhvZC5cbiAgICAgICAqIEByZXR1cm5zIHtzdWJzY3JpcHRpb259IEFuIG9iamVjdCB3aXRoIGFuIGB1bnN1YnNjcmliZWAgbWV0aG9kIHRoYXQgY2FuXG4gICAgICAgKiBiZSB1c2VkIHRvIHVuc3Vic2NyaWJlIHRoZSBvYnNlcnZhYmxlIGZyb20gdGhlIHN0b3JlLCBhbmQgcHJldmVudCBmdXJ0aGVyXG4gICAgICAgKiBlbWlzc2lvbiBvZiB2YWx1ZXMgZnJvbSB0aGUgb2JzZXJ2YWJsZS5cbiAgICAgICAqL1xuICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiBzdWJzY3JpYmUob2JzZXJ2ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYnNlcnZlciAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCB0aGUgb2JzZXJ2ZXIgdG8gYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gb2JzZXJ2ZVN0YXRlKCkge1xuICAgICAgICAgIGlmIChvYnNlcnZlci5uZXh0KSB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KGdldFN0YXRlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9ic2VydmVTdGF0ZSgpO1xuICAgICAgICB2YXIgdW5zdWJzY3JpYmUgPSBvdXRlclN1YnNjcmliZShvYnNlcnZlU3RhdGUpO1xuICAgICAgICByZXR1cm4geyB1bnN1YnNjcmliZTogdW5zdWJzY3JpYmUgfTtcbiAgICAgIH1cbiAgICB9LCBfcmVmWyQkb2JzZXJ2YWJsZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBfcmVmO1xuICB9XG5cbiAgLy8gV2hlbiBhIHN0b3JlIGlzIGNyZWF0ZWQsIGFuIFwiSU5JVFwiIGFjdGlvbiBpcyBkaXNwYXRjaGVkIHNvIHRoYXQgZXZlcnlcbiAgLy8gcmVkdWNlciByZXR1cm5zIHRoZWlyIGluaXRpYWwgc3RhdGUuIFRoaXMgZWZmZWN0aXZlbHkgcG9wdWxhdGVzXG4gIC8vIHRoZSBpbml0aWFsIHN0YXRlIHRyZWUuXG4gIGRpc3BhdGNoKHsgdHlwZTogQWN0aW9uVHlwZXMuSU5JVCB9KTtcblxuICByZXR1cm4gX3JlZjIgPSB7XG4gICAgZGlzcGF0Y2g6IGRpc3BhdGNoLFxuICAgIHN1YnNjcmliZTogc3Vic2NyaWJlLFxuICAgIGdldFN0YXRlOiBnZXRTdGF0ZSxcbiAgICByZXBsYWNlUmVkdWNlcjogcmVwbGFjZVJlZHVjZXJcbiAgfSwgX3JlZjJbJCRvYnNlcnZhYmxlXSA9IG9ic2VydmFibGUsIF9yZWYyO1xufSIsIi8qKlxuICogUHJpbnRzIGEgd2FybmluZyBpbiB0aGUgY29uc29sZSBpZiBpdCBleGlzdHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIHdhcm5pbmcgbWVzc2FnZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IGlmIHlvdSBlbmFibGVcbiAgICAvLyBcImJyZWFrIG9uIGFsbCBleGNlcHRpb25zXCIgaW4geW91ciBjb25zb2xlLFxuICAgIC8vIGl0IHdvdWxkIHBhdXNlIHRoZSBleGVjdXRpb24gYXQgdGhpcyBsaW5lLlxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1lbXB0eSAqL1xuICB9IGNhdGNoIChlKSB7fVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWVtcHR5ICovXG59IiwiaW1wb3J0IHsgQWN0aW9uVHlwZXMgfSBmcm9tICcuL2NyZWF0ZVN0b3JlJztcbmltcG9ydCBpc1BsYWluT2JqZWN0IGZyb20gJ2xvZGFzaC1lcy9pc1BsYWluT2JqZWN0JztcbmltcG9ydCB3YXJuaW5nIGZyb20gJy4vdXRpbHMvd2FybmluZyc7XG5cbmZ1bmN0aW9uIGdldFVuZGVmaW5lZFN0YXRlRXJyb3JNZXNzYWdlKGtleSwgYWN0aW9uKSB7XG4gIHZhciBhY3Rpb25UeXBlID0gYWN0aW9uICYmIGFjdGlvbi50eXBlO1xuICB2YXIgYWN0aW9uTmFtZSA9IGFjdGlvblR5cGUgJiYgJ1wiJyArIGFjdGlvblR5cGUudG9TdHJpbmcoKSArICdcIicgfHwgJ2FuIGFjdGlvbic7XG5cbiAgcmV0dXJuICdHaXZlbiBhY3Rpb24gJyArIGFjdGlvbk5hbWUgKyAnLCByZWR1Y2VyIFwiJyArIGtleSArICdcIiByZXR1cm5lZCB1bmRlZmluZWQuICcgKyAnVG8gaWdub3JlIGFuIGFjdGlvbiwgeW91IG11c3QgZXhwbGljaXRseSByZXR1cm4gdGhlIHByZXZpb3VzIHN0YXRlLiAnICsgJ0lmIHlvdSB3YW50IHRoaXMgcmVkdWNlciB0byBob2xkIG5vIHZhbHVlLCB5b3UgY2FuIHJldHVybiBudWxsIGluc3RlYWQgb2YgdW5kZWZpbmVkLic7XG59XG5cbmZ1bmN0aW9uIGdldFVuZXhwZWN0ZWRTdGF0ZVNoYXBlV2FybmluZ01lc3NhZ2UoaW5wdXRTdGF0ZSwgcmVkdWNlcnMsIGFjdGlvbiwgdW5leHBlY3RlZEtleUNhY2hlKSB7XG4gIHZhciByZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKTtcbiAgdmFyIGFyZ3VtZW50TmFtZSA9IGFjdGlvbiAmJiBhY3Rpb24udHlwZSA9PT0gQWN0aW9uVHlwZXMuSU5JVCA/ICdwcmVsb2FkZWRTdGF0ZSBhcmd1bWVudCBwYXNzZWQgdG8gY3JlYXRlU3RvcmUnIDogJ3ByZXZpb3VzIHN0YXRlIHJlY2VpdmVkIGJ5IHRoZSByZWR1Y2VyJztcblxuICBpZiAocmVkdWNlcktleXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICdTdG9yZSBkb2VzIG5vdCBoYXZlIGEgdmFsaWQgcmVkdWNlci4gTWFrZSBzdXJlIHRoZSBhcmd1bWVudCBwYXNzZWQgJyArICd0byBjb21iaW5lUmVkdWNlcnMgaXMgYW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgcmVkdWNlcnMuJztcbiAgfVxuXG4gIGlmICghaXNQbGFpbk9iamVjdChpbnB1dFN0YXRlKSkge1xuICAgIHJldHVybiAnVGhlICcgKyBhcmd1bWVudE5hbWUgKyAnIGhhcyB1bmV4cGVjdGVkIHR5cGUgb2YgXCInICsge30udG9TdHJpbmcuY2FsbChpbnB1dFN0YXRlKS5tYXRjaCgvXFxzKFthLXp8QS1aXSspLylbMV0gKyAnXCIuIEV4cGVjdGVkIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgJyArICgna2V5czogXCInICsgcmVkdWNlcktleXMuam9pbignXCIsIFwiJykgKyAnXCInKTtcbiAgfVxuXG4gIHZhciB1bmV4cGVjdGVkS2V5cyA9IE9iamVjdC5rZXlzKGlucHV0U3RhdGUpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuICFyZWR1Y2Vycy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICF1bmV4cGVjdGVkS2V5Q2FjaGVba2V5XTtcbiAgfSk7XG5cbiAgdW5leHBlY3RlZEtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdW5leHBlY3RlZEtleUNhY2hlW2tleV0gPSB0cnVlO1xuICB9KTtcblxuICBpZiAodW5leHBlY3RlZEtleXMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiAnVW5leHBlY3RlZCAnICsgKHVuZXhwZWN0ZWRLZXlzLmxlbmd0aCA+IDEgPyAna2V5cycgOiAna2V5JykgKyAnICcgKyAoJ1wiJyArIHVuZXhwZWN0ZWRLZXlzLmpvaW4oJ1wiLCBcIicpICsgJ1wiIGZvdW5kIGluICcgKyBhcmd1bWVudE5hbWUgKyAnLiAnKSArICdFeHBlY3RlZCB0byBmaW5kIG9uZSBvZiB0aGUga25vd24gcmVkdWNlciBrZXlzIGluc3RlYWQ6ICcgKyAoJ1wiJyArIHJlZHVjZXJLZXlzLmpvaW4oJ1wiLCBcIicpICsgJ1wiLiBVbmV4cGVjdGVkIGtleXMgd2lsbCBiZSBpZ25vcmVkLicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFJlZHVjZXJTaGFwZShyZWR1Y2Vycykge1xuICBPYmplY3Qua2V5cyhyZWR1Y2VycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHJlZHVjZXIgPSByZWR1Y2Vyc1trZXldO1xuICAgIHZhciBpbml0aWFsU3RhdGUgPSByZWR1Y2VyKHVuZGVmaW5lZCwgeyB0eXBlOiBBY3Rpb25UeXBlcy5JTklUIH0pO1xuXG4gICAgaWYgKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZXIgXCInICsga2V5ICsgJ1wiIHJldHVybmVkIHVuZGVmaW5lZCBkdXJpbmcgaW5pdGlhbGl6YXRpb24uICcgKyAnSWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGUgcmVkdWNlciBpcyB1bmRlZmluZWQsIHlvdSBtdXN0ICcgKyAnZXhwbGljaXRseSByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSAnICsgJ25vdCBiZSB1bmRlZmluZWQuIElmIHlvdSBkb25cXCd0IHdhbnQgdG8gc2V0IGEgdmFsdWUgZm9yIHRoaXMgcmVkdWNlciwgJyArICd5b3UgY2FuIHVzZSBudWxsIGluc3RlYWQgb2YgdW5kZWZpbmVkLicpO1xuICAgIH1cblxuICAgIHZhciB0eXBlID0gJ0BAcmVkdXgvUFJPQkVfVU5LTk9XTl9BQ1RJT05fJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KS5zcGxpdCgnJykuam9pbignLicpO1xuICAgIGlmICh0eXBlb2YgcmVkdWNlcih1bmRlZmluZWQsIHsgdHlwZTogdHlwZSB9KSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVkdWNlciBcIicgKyBrZXkgKyAnXCIgcmV0dXJuZWQgdW5kZWZpbmVkIHdoZW4gcHJvYmVkIHdpdGggYSByYW5kb20gdHlwZS4gJyArICgnRG9uXFwndCB0cnkgdG8gaGFuZGxlICcgKyBBY3Rpb25UeXBlcy5JTklUICsgJyBvciBvdGhlciBhY3Rpb25zIGluIFwicmVkdXgvKlwiICcpICsgJ25hbWVzcGFjZS4gVGhleSBhcmUgY29uc2lkZXJlZCBwcml2YXRlLiBJbnN0ZWFkLCB5b3UgbXVzdCByZXR1cm4gdGhlICcgKyAnY3VycmVudCBzdGF0ZSBmb3IgYW55IHVua25vd24gYWN0aW9ucywgdW5sZXNzIGl0IGlzIHVuZGVmaW5lZCwgJyArICdpbiB3aGljaCBjYXNlIHlvdSBtdXN0IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZSwgcmVnYXJkbGVzcyBvZiB0aGUgJyArICdhY3Rpb24gdHlwZS4gVGhlIGluaXRpYWwgc3RhdGUgbWF5IG5vdCBiZSB1bmRlZmluZWQsIGJ1dCBjYW4gYmUgbnVsbC4nKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFR1cm5zIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGRpZmZlcmVudCByZWR1Y2VyIGZ1bmN0aW9ucywgaW50byBhIHNpbmdsZVxuICogcmVkdWNlciBmdW5jdGlvbi4gSXQgd2lsbCBjYWxsIGV2ZXJ5IGNoaWxkIHJlZHVjZXIsIGFuZCBnYXRoZXIgdGhlaXIgcmVzdWx0c1xuICogaW50byBhIHNpbmdsZSBzdGF0ZSBvYmplY3QsIHdob3NlIGtleXMgY29ycmVzcG9uZCB0byB0aGUga2V5cyBvZiB0aGUgcGFzc2VkXG4gKiByZWR1Y2VyIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcmVkdWNlcnMgQW4gb2JqZWN0IHdob3NlIHZhbHVlcyBjb3JyZXNwb25kIHRvIGRpZmZlcmVudFxuICogcmVkdWNlciBmdW5jdGlvbnMgdGhhdCBuZWVkIHRvIGJlIGNvbWJpbmVkIGludG8gb25lLiBPbmUgaGFuZHkgd2F5IHRvIG9idGFpblxuICogaXQgaXMgdG8gdXNlIEVTNiBgaW1wb3J0ICogYXMgcmVkdWNlcnNgIHN5bnRheC4gVGhlIHJlZHVjZXJzIG1heSBuZXZlciByZXR1cm5cbiAqIHVuZGVmaW5lZCBmb3IgYW55IGFjdGlvbi4gSW5zdGVhZCwgdGhleSBzaG91bGQgcmV0dXJuIHRoZWlyIGluaXRpYWwgc3RhdGVcbiAqIGlmIHRoZSBzdGF0ZSBwYXNzZWQgdG8gdGhlbSB3YXMgdW5kZWZpbmVkLCBhbmQgdGhlIGN1cnJlbnQgc3RhdGUgZm9yIGFueVxuICogdW5yZWNvZ25pemVkIGFjdGlvbi5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgcmVkdWNlciBmdW5jdGlvbiB0aGF0IGludm9rZXMgZXZlcnkgcmVkdWNlciBpbnNpZGUgdGhlXG4gKiBwYXNzZWQgb2JqZWN0LCBhbmQgYnVpbGRzIGEgc3RhdGUgb2JqZWN0IHdpdGggdGhlIHNhbWUgc2hhcGUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbWJpbmVSZWR1Y2VycyhyZWR1Y2Vycykge1xuICB2YXIgcmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XG4gIHZhciBmaW5hbFJlZHVjZXJzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVkdWNlcktleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gcmVkdWNlcktleXNbaV07XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHR5cGVvZiByZWR1Y2Vyc1trZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3YXJuaW5nKCdObyByZWR1Y2VyIHByb3ZpZGVkIGZvciBrZXkgXCInICsga2V5ICsgJ1wiJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiByZWR1Y2Vyc1trZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmaW5hbFJlZHVjZXJzW2tleV0gPSByZWR1Y2Vyc1trZXldO1xuICAgIH1cbiAgfVxuICB2YXIgZmluYWxSZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKGZpbmFsUmVkdWNlcnMpO1xuXG4gIHZhciB1bmV4cGVjdGVkS2V5Q2FjaGUgPSB2b2lkIDA7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdW5leHBlY3RlZEtleUNhY2hlID0ge307XG4gIH1cblxuICB2YXIgc2hhcGVBc3NlcnRpb25FcnJvciA9IHZvaWQgMDtcbiAgdHJ5IHtcbiAgICBhc3NlcnRSZWR1Y2VyU2hhcGUoZmluYWxSZWR1Y2Vycyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBzaGFwZUFzc2VydGlvbkVycm9yID0gZTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBjb21iaW5hdGlvbigpIHtcbiAgICB2YXIgc3RhdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHZhciBhY3Rpb24gPSBhcmd1bWVudHNbMV07XG5cbiAgICBpZiAoc2hhcGVBc3NlcnRpb25FcnJvcikge1xuICAgICAgdGhyb3cgc2hhcGVBc3NlcnRpb25FcnJvcjtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHdhcm5pbmdNZXNzYWdlID0gZ2V0VW5leHBlY3RlZFN0YXRlU2hhcGVXYXJuaW5nTWVzc2FnZShzdGF0ZSwgZmluYWxSZWR1Y2VycywgYWN0aW9uLCB1bmV4cGVjdGVkS2V5Q2FjaGUpO1xuICAgICAgaWYgKHdhcm5pbmdNZXNzYWdlKSB7XG4gICAgICAgIHdhcm5pbmcod2FybmluZ01lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBoYXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgdmFyIG5leHRTdGF0ZSA9IHt9O1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBmaW5hbFJlZHVjZXJLZXlzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9rZXkgPSBmaW5hbFJlZHVjZXJLZXlzW19pXTtcbiAgICAgIHZhciByZWR1Y2VyID0gZmluYWxSZWR1Y2Vyc1tfa2V5XTtcbiAgICAgIHZhciBwcmV2aW91c1N0YXRlRm9yS2V5ID0gc3RhdGVbX2tleV07XG4gICAgICB2YXIgbmV4dFN0YXRlRm9yS2V5ID0gcmVkdWNlcihwcmV2aW91c1N0YXRlRm9yS2V5LCBhY3Rpb24pO1xuICAgICAgaWYgKHR5cGVvZiBuZXh0U3RhdGVGb3JLZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSBnZXRVbmRlZmluZWRTdGF0ZUVycm9yTWVzc2FnZShfa2V5LCBhY3Rpb24pO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIG5leHRTdGF0ZVtfa2V5XSA9IG5leHRTdGF0ZUZvcktleTtcbiAgICAgIGhhc0NoYW5nZWQgPSBoYXNDaGFuZ2VkIHx8IG5leHRTdGF0ZUZvcktleSAhPT0gcHJldmlvdXNTdGF0ZUZvcktleTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc0NoYW5nZWQgPyBuZXh0U3RhdGUgOiBzdGF0ZTtcbiAgfTtcbn0iLCJmdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9yLCBkaXNwYXRjaCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkaXNwYXRjaChhY3Rpb25DcmVhdG9yLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gIH07XG59XG5cbi8qKlxuICogVHVybnMgYW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgYWN0aW9uIGNyZWF0b3JzLCBpbnRvIGFuIG9iamVjdCB3aXRoIHRoZVxuICogc2FtZSBrZXlzLCBidXQgd2l0aCBldmVyeSBmdW5jdGlvbiB3cmFwcGVkIGludG8gYSBgZGlzcGF0Y2hgIGNhbGwgc28gdGhleVxuICogbWF5IGJlIGludm9rZWQgZGlyZWN0bHkuIFRoaXMgaXMganVzdCBhIGNvbnZlbmllbmNlIG1ldGhvZCwgYXMgeW91IGNhbiBjYWxsXG4gKiBgc3RvcmUuZGlzcGF0Y2goTXlBY3Rpb25DcmVhdG9ycy5kb1NvbWV0aGluZygpKWAgeW91cnNlbGYganVzdCBmaW5lLlxuICpcbiAqIEZvciBjb252ZW5pZW5jZSwgeW91IGNhbiBhbHNvIHBhc3MgYSBzaW5nbGUgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IGFyZ3VtZW50LFxuICogYW5kIGdldCBhIGZ1bmN0aW9uIGluIHJldHVybi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdH0gYWN0aW9uQ3JlYXRvcnMgQW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgYWN0aW9uXG4gKiBjcmVhdG9yIGZ1bmN0aW9ucy4gT25lIGhhbmR5IHdheSB0byBvYnRhaW4gaXQgaXMgdG8gdXNlIEVTNiBgaW1wb3J0ICogYXNgXG4gKiBzeW50YXguIFlvdSBtYXkgYWxzbyBwYXNzIGEgc2luZ2xlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRpc3BhdGNoIFRoZSBgZGlzcGF0Y2hgIGZ1bmN0aW9uIGF2YWlsYWJsZSBvbiB5b3VyIFJlZHV4XG4gKiBzdG9yZS5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb258T2JqZWN0fSBUaGUgb2JqZWN0IG1pbWlja2luZyB0aGUgb3JpZ2luYWwgb2JqZWN0LCBidXQgd2l0aFxuICogZXZlcnkgYWN0aW9uIGNyZWF0b3Igd3JhcHBlZCBpbnRvIHRoZSBgZGlzcGF0Y2hgIGNhbGwuIElmIHlvdSBwYXNzZWQgYVxuICogZnVuY3Rpb24gYXMgYGFjdGlvbkNyZWF0b3JzYCwgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGFsc28gYmUgYSBzaW5nbGVcbiAqIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcnMoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKSB7XG4gIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvcnMgIT09ICdvYmplY3QnIHx8IGFjdGlvbkNyZWF0b3JzID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdiaW5kQWN0aW9uQ3JlYXRvcnMgZXhwZWN0ZWQgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb24sIGluc3RlYWQgcmVjZWl2ZWQgJyArIChhY3Rpb25DcmVhdG9ycyA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBhY3Rpb25DcmVhdG9ycykgKyAnLiAnICsgJ0RpZCB5b3Ugd3JpdGUgXCJpbXBvcnQgQWN0aW9uQ3JlYXRvcnMgZnJvbVwiIGluc3RlYWQgb2YgXCJpbXBvcnQgKiBhcyBBY3Rpb25DcmVhdG9ycyBmcm9tXCI/Jyk7XG4gIH1cblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFjdGlvbkNyZWF0b3JzKTtcbiAgdmFyIGJvdW5kQWN0aW9uQ3JlYXRvcnMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgdmFyIGFjdGlvbkNyZWF0b3IgPSBhY3Rpb25DcmVhdG9yc1trZXldO1xuICAgIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYm91bmRBY3Rpb25DcmVhdG9yc1trZXldID0gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvciwgZGlzcGF0Y2gpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYm91bmRBY3Rpb25DcmVhdG9ycztcbn0iLCIvKipcbiAqIENvbXBvc2VzIHNpbmdsZS1hcmd1bWVudCBmdW5jdGlvbnMgZnJvbSByaWdodCB0byBsZWZ0LiBUaGUgcmlnaHRtb3N0XG4gKiBmdW5jdGlvbiBjYW4gdGFrZSBtdWx0aXBsZSBhcmd1bWVudHMgYXMgaXQgcHJvdmlkZXMgdGhlIHNpZ25hdHVyZSBmb3JcbiAqIHRoZSByZXN1bHRpbmcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IGZ1bmNzIFRoZSBmdW5jdGlvbnMgdG8gY29tcG9zZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiBvYnRhaW5lZCBieSBjb21wb3NpbmcgdGhlIGFyZ3VtZW50IGZ1bmN0aW9uc1xuICogZnJvbSByaWdodCB0byBsZWZ0LiBGb3IgZXhhbXBsZSwgY29tcG9zZShmLCBnLCBoKSBpcyBpZGVudGljYWwgdG8gZG9pbmdcbiAqICguLi5hcmdzKSA9PiBmKGcoaCguLi5hcmdzKSkpLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXBvc2UoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBmdW5jcyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGZ1bmNzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKGZ1bmNzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICByZXR1cm4gYXJnO1xuICAgIH07XG4gIH1cblxuICBpZiAoZnVuY3MubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGZ1bmNzWzBdO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmNzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYShiLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfSk7XG59IiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuaW1wb3J0IGNvbXBvc2UgZnJvbSAnLi9jb21wb3NlJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RvcmUgZW5oYW5jZXIgdGhhdCBhcHBsaWVzIG1pZGRsZXdhcmUgdG8gdGhlIGRpc3BhdGNoIG1ldGhvZFxuICogb2YgdGhlIFJlZHV4IHN0b3JlLiBUaGlzIGlzIGhhbmR5IGZvciBhIHZhcmlldHkgb2YgdGFza3MsIHN1Y2ggYXMgZXhwcmVzc2luZ1xuICogYXN5bmNocm9ub3VzIGFjdGlvbnMgaW4gYSBjb25jaXNlIG1hbm5lciwgb3IgbG9nZ2luZyBldmVyeSBhY3Rpb24gcGF5bG9hZC5cbiAqXG4gKiBTZWUgYHJlZHV4LXRodW5rYCBwYWNrYWdlIGFzIGFuIGV4YW1wbGUgb2YgdGhlIFJlZHV4IG1pZGRsZXdhcmUuXG4gKlxuICogQmVjYXVzZSBtaWRkbGV3YXJlIGlzIHBvdGVudGlhbGx5IGFzeW5jaHJvbm91cywgdGhpcyBzaG91bGQgYmUgdGhlIGZpcnN0XG4gKiBzdG9yZSBlbmhhbmNlciBpbiB0aGUgY29tcG9zaXRpb24gY2hhaW4uXG4gKlxuICogTm90ZSB0aGF0IGVhY2ggbWlkZGxld2FyZSB3aWxsIGJlIGdpdmVuIHRoZSBgZGlzcGF0Y2hgIGFuZCBgZ2V0U3RhdGVgIGZ1bmN0aW9uc1xuICogYXMgbmFtZWQgYXJndW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IG1pZGRsZXdhcmVzIFRoZSBtaWRkbGV3YXJlIGNoYWluIHRvIGJlIGFwcGxpZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgc3RvcmUgZW5oYW5jZXIgYXBwbHlpbmcgdGhlIG1pZGRsZXdhcmUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFwcGx5TWlkZGxld2FyZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG1pZGRsZXdhcmVzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgbWlkZGxld2FyZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGNyZWF0ZVN0b3JlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSwgZW5oYW5jZXIpIHtcbiAgICAgIHZhciBzdG9yZSA9IGNyZWF0ZVN0b3JlKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBlbmhhbmNlcik7XG4gICAgICB2YXIgX2Rpc3BhdGNoID0gc3RvcmUuZGlzcGF0Y2g7XG4gICAgICB2YXIgY2hhaW4gPSBbXTtcblxuICAgICAgdmFyIG1pZGRsZXdhcmVBUEkgPSB7XG4gICAgICAgIGdldFN0YXRlOiBzdG9yZS5nZXRTdGF0ZSxcbiAgICAgICAgZGlzcGF0Y2g6IGZ1bmN0aW9uIGRpc3BhdGNoKGFjdGlvbikge1xuICAgICAgICAgIHJldHVybiBfZGlzcGF0Y2goYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNoYWluID0gbWlkZGxld2FyZXMubWFwKGZ1bmN0aW9uIChtaWRkbGV3YXJlKSB7XG4gICAgICAgIHJldHVybiBtaWRkbGV3YXJlKG1pZGRsZXdhcmVBUEkpO1xuICAgICAgfSk7XG4gICAgICBfZGlzcGF0Y2ggPSBjb21wb3NlLmFwcGx5KHVuZGVmaW5lZCwgY2hhaW4pKHN0b3JlLmRpc3BhdGNoKTtcblxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdG9yZSwge1xuICAgICAgICBkaXNwYXRjaDogX2Rpc3BhdGNoXG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xufSIsImltcG9ydCBjcmVhdGVTdG9yZSBmcm9tICcuL2NyZWF0ZVN0b3JlJztcbmltcG9ydCBjb21iaW5lUmVkdWNlcnMgZnJvbSAnLi9jb21iaW5lUmVkdWNlcnMnO1xuaW1wb3J0IGJpbmRBY3Rpb25DcmVhdG9ycyBmcm9tICcuL2JpbmRBY3Rpb25DcmVhdG9ycyc7XG5pbXBvcnQgYXBwbHlNaWRkbGV3YXJlIGZyb20gJy4vYXBwbHlNaWRkbGV3YXJlJztcbmltcG9ydCBjb21wb3NlIGZyb20gJy4vY29tcG9zZSc7XG5pbXBvcnQgd2FybmluZyBmcm9tICcuL3V0aWxzL3dhcm5pbmcnO1xuXG4vKlxuKiBUaGlzIGlzIGEgZHVtbXkgZnVuY3Rpb24gdG8gY2hlY2sgaWYgdGhlIGZ1bmN0aW9uIG5hbWUgaGFzIGJlZW4gYWx0ZXJlZCBieSBtaW5pZmljYXRpb24uXG4qIElmIHRoZSBmdW5jdGlvbiBoYXMgYmVlbiBtaW5pZmllZCBhbmQgTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJywgd2FybiB0aGUgdXNlci5cbiovXG5mdW5jdGlvbiBpc0NydXNoZWQoKSB7fVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgaXNDcnVzaGVkLm5hbWUgPT09ICdzdHJpbmcnICYmIGlzQ3J1c2hlZC5uYW1lICE9PSAnaXNDcnVzaGVkJykge1xuICB3YXJuaW5nKCdZb3UgYXJlIGN1cnJlbnRseSB1c2luZyBtaW5pZmllZCBjb2RlIG91dHNpZGUgb2YgTk9ERV9FTlYgPT09IFxcJ3Byb2R1Y3Rpb25cXCcuICcgKyAnVGhpcyBtZWFucyB0aGF0IHlvdSBhcmUgcnVubmluZyBhIHNsb3dlciBkZXZlbG9wbWVudCBidWlsZCBvZiBSZWR1eC4gJyArICdZb3UgY2FuIHVzZSBsb29zZS1lbnZpZnkgKGh0dHBzOi8vZ2l0aHViLmNvbS96ZXJ0b3NoL2xvb3NlLWVudmlmeSkgZm9yIGJyb3dzZXJpZnkgJyArICdvciBEZWZpbmVQbHVnaW4gZm9yIHdlYnBhY2sgKGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzAwMzAwMzEpICcgKyAndG8gZW5zdXJlIHlvdSBoYXZlIHRoZSBjb3JyZWN0IGNvZGUgZm9yIHlvdXIgcHJvZHVjdGlvbiBidWlsZC4nKTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlU3RvcmUsIGNvbWJpbmVSZWR1Y2VycywgYmluZEFjdGlvbkNyZWF0b3JzLCBhcHBseU1pZGRsZXdhcmUsIGNvbXBvc2UgfTsiLCJleHBvcnQgdmFyIHByZWZpeCA9ICdAQHJlZHV4LWZvcm0vJztcbmV4cG9ydCB2YXIgQVJSQVlfSU5TRVJUID0gcHJlZml4ICsgXCJBUlJBWV9JTlNFUlRcIjtcbmV4cG9ydCB2YXIgQVJSQVlfTU9WRSA9IHByZWZpeCArIFwiQVJSQVlfTU9WRVwiO1xuZXhwb3J0IHZhciBBUlJBWV9QT1AgPSBwcmVmaXggKyBcIkFSUkFZX1BPUFwiO1xuZXhwb3J0IHZhciBBUlJBWV9QVVNIID0gcHJlZml4ICsgXCJBUlJBWV9QVVNIXCI7XG5leHBvcnQgdmFyIEFSUkFZX1JFTU9WRSA9IHByZWZpeCArIFwiQVJSQVlfUkVNT1ZFXCI7XG5leHBvcnQgdmFyIEFSUkFZX1JFTU9WRV9BTEwgPSBwcmVmaXggKyBcIkFSUkFZX1JFTU9WRV9BTExcIjtcbmV4cG9ydCB2YXIgQVJSQVlfU0hJRlQgPSBwcmVmaXggKyBcIkFSUkFZX1NISUZUXCI7XG5leHBvcnQgdmFyIEFSUkFZX1NQTElDRSA9IHByZWZpeCArIFwiQVJSQVlfU1BMSUNFXCI7XG5leHBvcnQgdmFyIEFSUkFZX1VOU0hJRlQgPSBwcmVmaXggKyBcIkFSUkFZX1VOU0hJRlRcIjtcbmV4cG9ydCB2YXIgQVJSQVlfU1dBUCA9IHByZWZpeCArIFwiQVJSQVlfU1dBUFwiO1xuZXhwb3J0IHZhciBBVVRPRklMTCA9IHByZWZpeCArIFwiQVVUT0ZJTExcIjtcbmV4cG9ydCB2YXIgQkxVUiA9IHByZWZpeCArIFwiQkxVUlwiO1xuZXhwb3J0IHZhciBDSEFOR0UgPSBwcmVmaXggKyBcIkNIQU5HRVwiO1xuZXhwb3J0IHZhciBDTEVBUl9GSUVMRFMgPSBwcmVmaXggKyBcIkNMRUFSX0ZJRUxEU1wiO1xuZXhwb3J0IHZhciBDTEVBUl9TVUJNSVQgPSBwcmVmaXggKyBcIkNMRUFSX1NVQk1JVFwiO1xuZXhwb3J0IHZhciBDTEVBUl9TVUJNSVRfRVJST1JTID0gcHJlZml4ICsgXCJDTEVBUl9TVUJNSVRfRVJST1JTXCI7XG5leHBvcnQgdmFyIENMRUFSX0FTWU5DX0VSUk9SID0gcHJlZml4ICsgXCJDTEVBUl9BU1lOQ19FUlJPUlwiO1xuZXhwb3J0IHZhciBERVNUUk9ZID0gcHJlZml4ICsgXCJERVNUUk9ZXCI7XG5leHBvcnQgdmFyIEZPQ1VTID0gcHJlZml4ICsgXCJGT0NVU1wiO1xuZXhwb3J0IHZhciBJTklUSUFMSVpFID0gcHJlZml4ICsgXCJJTklUSUFMSVpFXCI7XG5leHBvcnQgdmFyIFJFR0lTVEVSX0ZJRUxEID0gcHJlZml4ICsgXCJSRUdJU1RFUl9GSUVMRFwiO1xuZXhwb3J0IHZhciBSRVNFVCA9IHByZWZpeCArIFwiUkVTRVRcIjtcbmV4cG9ydCB2YXIgUkVTRVRfU0VDVElPTiA9IHByZWZpeCArIFwiUkVTRVRfU0VDVElPTlwiO1xuZXhwb3J0IHZhciBTRVRfU1VCTUlUX0ZBSUxFRCA9IHByZWZpeCArIFwiU0VUX1NVQk1JVF9GQUlMRURcIjtcbmV4cG9ydCB2YXIgU0VUX1NVQk1JVF9TVUNDRUVERUQgPSBwcmVmaXggKyBcIlNFVF9TVUJNSVRfU1VDQ0VFREVEXCI7XG5leHBvcnQgdmFyIFNUQVJUX0FTWU5DX1ZBTElEQVRJT04gPSBwcmVmaXggKyBcIlNUQVJUX0FTWU5DX1ZBTElEQVRJT05cIjtcbmV4cG9ydCB2YXIgU1RBUlRfU1VCTUlUID0gcHJlZml4ICsgXCJTVEFSVF9TVUJNSVRcIjtcbmV4cG9ydCB2YXIgU1RPUF9BU1lOQ19WQUxJREFUSU9OID0gcHJlZml4ICsgXCJTVE9QX0FTWU5DX1ZBTElEQVRJT05cIjtcbmV4cG9ydCB2YXIgU1RPUF9TVUJNSVQgPSBwcmVmaXggKyBcIlNUT1BfU1VCTUlUXCI7XG5leHBvcnQgdmFyIFNVQk1JVCA9IHByZWZpeCArIFwiU1VCTUlUXCI7XG5leHBvcnQgdmFyIFRPVUNIID0gcHJlZml4ICsgXCJUT1VDSFwiO1xuZXhwb3J0IHZhciBVTlJFR0lTVEVSX0ZJRUxEID0gcHJlZml4ICsgXCJVTlJFR0lTVEVSX0ZJRUxEXCI7XG5leHBvcnQgdmFyIFVOVE9VQ0ggPSBwcmVmaXggKyBcIlVOVE9VQ0hcIjtcbmV4cG9ydCB2YXIgVVBEQVRFX1NZTkNfRVJST1JTID0gcHJlZml4ICsgXCJVUERBVEVfU1lOQ19FUlJPUlNcIjtcbmV4cG9ydCB2YXIgVVBEQVRFX1NZTkNfV0FSTklOR1MgPSBwcmVmaXggKyBcIlVQREFURV9TWU5DX1dBUk5JTkdTXCI7IiwiaW1wb3J0IF90b1BhdGggZnJvbSBcImxvZGFzaC90b1BhdGhcIjtcblxuZnVuY3Rpb24gY3JlYXRlRGVsZXRlSW5XaXRoQ2xlYW5VcChzdHJ1Y3R1cmUpIHtcbiAgdmFyIHNob3VsZERlbGV0ZURlZmF1bHQgPSBmdW5jdGlvbiBzaG91bGREZWxldGVEZWZhdWx0KHN0cnVjdHVyZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIHBhdGgpIHtcbiAgICAgIHJldHVybiBzdHJ1Y3R1cmUuZ2V0SW4oc3RhdGUsIHBhdGgpICE9PSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgZGVlcEVxdWFsID0gc3RydWN0dXJlLmRlZXBFcXVhbCxcbiAgICAgIGVtcHR5ID0gc3RydWN0dXJlLmVtcHR5LFxuICAgICAgZ2V0SW4gPSBzdHJ1Y3R1cmUuZ2V0SW4sXG4gICAgICBkZWxldGVJbiA9IHN0cnVjdHVyZS5kZWxldGVJbixcbiAgICAgIHNldEluID0gc3RydWN0dXJlLnNldEluO1xuICByZXR1cm4gZnVuY3Rpb24gKHNob3VsZERlbGV0ZSkge1xuICAgIGlmIChzaG91bGREZWxldGUgPT09IHZvaWQgMCkge1xuICAgICAgc2hvdWxkRGVsZXRlID0gc2hvdWxkRGVsZXRlRGVmYXVsdDtcbiAgICB9XG5cbiAgICB2YXIgZGVsZXRlSW5XaXRoQ2xlYW5VcCA9IGZ1bmN0aW9uIGRlbGV0ZUluV2l0aENsZWFuVXAoc3RhdGUsIHBhdGgpIHtcbiAgICAgIGlmIChwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPT09ICddJykge1xuICAgICAgICAvLyBhcnJheSBwYXRoXG4gICAgICAgIHZhciBwYXRoVG9rZW5zID0gX3RvUGF0aChwYXRoKTtcblxuICAgICAgICBwYXRoVG9rZW5zLnBvcCgpO1xuICAgICAgICB2YXIgcGFyZW50ID0gZ2V0SW4oc3RhdGUsIHBhdGhUb2tlbnMuam9pbignLicpKTtcbiAgICAgICAgcmV0dXJuIHBhcmVudCA/IHNldEluKHN0YXRlLCBwYXRoKSA6IHN0YXRlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gc3RhdGU7XG5cbiAgICAgIGlmIChzaG91bGREZWxldGUoc3RydWN0dXJlKShzdGF0ZSwgcGF0aCkpIHtcbiAgICAgICAgcmVzdWx0ID0gZGVsZXRlSW4oc3RhdGUsIHBhdGgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZG90SW5kZXggPSBwYXRoLmxhc3RJbmRleE9mKCcuJyk7XG5cbiAgICAgIGlmIChkb3RJbmRleCA+IDApIHtcbiAgICAgICAgdmFyIHBhcmVudFBhdGggPSBwYXRoLnN1YnN0cmluZygwLCBkb3RJbmRleCk7XG5cbiAgICAgICAgaWYgKHBhcmVudFBhdGhbcGFyZW50UGF0aC5sZW5ndGggLSAxXSAhPT0gJ10nKSB7XG4gICAgICAgICAgdmFyIF9wYXJlbnQgPSBnZXRJbihyZXN1bHQsIHBhcmVudFBhdGgpO1xuXG4gICAgICAgICAgaWYgKGRlZXBFcXVhbChfcGFyZW50LCBlbXB0eSkpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWxldGVJbldpdGhDbGVhblVwKHJlc3VsdCwgcGFyZW50UGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHJldHVybiBkZWxldGVJbldpdGhDbGVhblVwO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVEZWxldGVJbldpdGhDbGVhblVwOyIsInZhciBzcGxpY2UgPSBmdW5jdGlvbiBzcGxpY2UoYXJyYXksIGluZGV4LCByZW1vdmVOdW0sIHZhbHVlKSB7XG4gIGFycmF5ID0gYXJyYXkgfHwgW107XG5cbiAgaWYgKGluZGV4IDwgYXJyYXkubGVuZ3RoKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIXJlbW92ZU51bSkge1xuICAgICAgLy8gaW5zZXJ0aW5nIHVuZGVmaW5lZFxuICAgICAgdmFyIF9jb3B5MiA9IFtdLmNvbmNhdChhcnJheSk7XG5cbiAgICAgIF9jb3B5Mi5zcGxpY2UoaW5kZXgsIDAsIHRydWUpOyAvLyB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcblxuXG4gICAgICBfY29weTJbaW5kZXhdID0gdW5kZWZpbmVkOyAvLyBzZXQgdG8gdW5kZWZpbmVkXG5cbiAgICAgIHJldHVybiBfY29weTI7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIHZhciBfY29weTMgPSBbXS5jb25jYXQoYXJyYXkpO1xuXG4gICAgICBfY29weTMuc3BsaWNlKGluZGV4LCByZW1vdmVOdW0sIHZhbHVlKTsgLy8gcmVtb3ZpbmcgYW5kIGFkZGluZ1xuXG5cbiAgICAgIHJldHVybiBfY29weTM7XG4gICAgfVxuXG4gICAgdmFyIF9jb3B5ID0gW10uY29uY2F0KGFycmF5KTtcblxuICAgIF9jb3B5LnNwbGljZShpbmRleCwgcmVtb3ZlTnVtKTsgLy8gcmVtb3ZpbmdcblxuXG4gICAgcmV0dXJuIF9jb3B5O1xuICB9XG5cbiAgaWYgKHJlbW92ZU51bSkge1xuICAgIC8vIHRyeWluZyB0byByZW1vdmUgbm9uLWV4aXN0YW50IGl0ZW06IHJldHVybiBvcmlnaW5hbCBhcnJheVxuICAgIHJldHVybiBhcnJheTtcbiAgfSAvLyB0cnlpbmcgdG8gYWRkIG91dHNpZGUgb2YgcmFuZ2U6IGp1c3Qgc2V0IHZhbHVlXG5cblxuICB2YXIgY29weSA9IFtdLmNvbmNhdChhcnJheSk7XG4gIGNvcHlbaW5kZXhdID0gdmFsdWU7XG4gIHJldHVybiBjb3B5O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgc3BsaWNlOyIsImltcG9ydCBfdG9QYXRoIGZyb20gXCJsb2Rhc2gvdG9QYXRoXCI7XG5cbnZhciBnZXRJbiA9IGZ1bmN0aW9uIGdldEluKHN0YXRlLCBmaWVsZCkge1xuICBpZiAoIXN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgdmFyIHBhdGggPSBfdG9QYXRoKGZpZWxkKTtcblxuICB2YXIgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgaWYgKCFsZW5ndGgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IHN0YXRlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoICYmIHJlc3VsdDsgKytpKSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0W3BhdGhbaV1dO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGdldEluOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9leHRlbmRzXCI7XG5pbXBvcnQgX3RvUGF0aCBmcm9tIFwibG9kYXNoL3RvUGF0aFwiO1xuXG52YXIgc2V0SW5XaXRoUGF0aCA9IGZ1bmN0aW9uIHNldEluV2l0aFBhdGgoc3RhdGUsIHZhbHVlLCBwYXRoLCBwYXRoSW5kZXgpIHtcbiAgdmFyIF9leHRlbmRzMjtcblxuICBpZiAocGF0aEluZGV4ID49IHBhdGgubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgdmFyIGZpcnN0ID0gcGF0aFtwYXRoSW5kZXhdO1xuICB2YXIgZmlyc3RTdGF0ZSA9IHN0YXRlICYmIChBcnJheS5pc0FycmF5KHN0YXRlKSA/IHN0YXRlW051bWJlcihmaXJzdCldIDogc3RhdGVbZmlyc3RdKTtcbiAgdmFyIG5leHQgPSBzZXRJbldpdGhQYXRoKGZpcnN0U3RhdGUsIHZhbHVlLCBwYXRoLCBwYXRoSW5kZXggKyAxKTtcblxuICBpZiAoIXN0YXRlKSB7XG4gICAgaWYgKGlzTmFOKGZpcnN0KSkge1xuICAgICAgdmFyIF9yZWY7XG5cbiAgICAgIHJldHVybiBfcmVmID0ge30sIF9yZWZbZmlyc3RdID0gbmV4dCwgX3JlZjtcbiAgICB9XG5cbiAgICB2YXIgaW5pdGlhbGl6ZWQgPSBbXTtcbiAgICBpbml0aWFsaXplZFtwYXJzZUludChmaXJzdCwgMTApXSA9IG5leHQ7XG4gICAgcmV0dXJuIGluaXRpYWxpemVkO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoc3RhdGUpKSB7XG4gICAgdmFyIGNvcHkgPSBbXS5jb25jYXQoc3RhdGUpO1xuICAgIGNvcHlbcGFyc2VJbnQoZmlyc3QsIDEwKV0gPSBuZXh0O1xuICAgIHJldHVybiBjb3B5O1xuICB9XG5cbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwgKF9leHRlbmRzMiA9IHt9LCBfZXh0ZW5kczJbZmlyc3RdID0gbmV4dCwgX2V4dGVuZHMyKSk7XG59O1xuXG52YXIgc2V0SW4gPSBmdW5jdGlvbiBzZXRJbihzdGF0ZSwgZmllbGQsIHZhbHVlKSB7XG4gIHJldHVybiBzZXRJbldpdGhQYXRoKHN0YXRlLCB2YWx1ZSwgX3RvUGF0aChmaWVsZCksIDApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgc2V0SW47IiwiaW1wb3J0IF9pc0VxdWFsV2l0aCBmcm9tIFwibG9kYXNoL2lzRXF1YWxXaXRoXCI7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG52YXIgY3VzdG9taXplciA9IGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqLCBvdGhlcikge1xuICBpZiAob2JqID09PSBvdGhlcikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKCFvYmogJiYgIW90aGVyKSB7XG4gICAgdmFyIG9iaklzRW1wdHkgPSBvYmogPT09IG51bGwgfHwgb2JqID09PSB1bmRlZmluZWQgfHwgb2JqID09PSAnJztcbiAgICB2YXIgb3RoZXJJc0VtcHR5ID0gb3RoZXIgPT09IG51bGwgfHwgb3RoZXIgPT09IHVuZGVmaW5lZCB8fCBvdGhlciA9PT0gJyc7XG4gICAgcmV0dXJuIG9iaklzRW1wdHkgPT09IG90aGVySXNFbXB0eTtcbiAgfVxuXG4gIGlmIChvYmogJiYgb3RoZXIgJiYgb2JqLl9lcnJvciAhPT0gb3RoZXIuX2Vycm9yKSByZXR1cm4gZmFsc2U7XG4gIGlmIChvYmogJiYgb3RoZXIgJiYgb2JqLl93YXJuaW5nICE9PSBvdGhlci5fd2FybmluZykgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVhY3QuaXNWYWxpZEVsZW1lbnQob2JqKSB8fCBSZWFjdC5pc1ZhbGlkRWxlbWVudChvdGhlcikpIHJldHVybiBmYWxzZTtcbn07XG5cbnZhciBkZWVwRXF1YWwgPSBmdW5jdGlvbiBkZWVwRXF1YWwoYSwgYikge1xuICByZXR1cm4gX2lzRXF1YWxXaXRoKGEsIGIsIGN1c3RvbWl6ZXIpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZGVlcEVxdWFsOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9leHRlbmRzXCI7XG5pbXBvcnQgX3RvUGF0aCBmcm9tIFwibG9kYXNoL3RvUGF0aFwiO1xuXG5mdW5jdGlvbiBkZWxldGVJbldpdGhQYXRoKHN0YXRlLCBmaXJzdCkge1xuICBpZiAoc3RhdGUgPT09IHVuZGVmaW5lZCB8fCBzdGF0ZSA9PT0gbnVsbCB8fCBmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGZpcnN0ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBuZXcgQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHJlc3RbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKHJlc3QubGVuZ3RoKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3RhdGUpKSB7XG4gICAgICBpZiAoaXNOYU4oZmlyc3QpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgYWNjZXNzIGFycmF5IGVsZW1lbnRzIHdpdGggYSBudW1iZXIsIG5vdCBcXFwiXCIgKyBTdHJpbmcoZmlyc3QpICsgXCJcXFwiLlwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZpcnN0SW5kZXggPSBOdW1iZXIoZmlyc3QpO1xuXG4gICAgICBpZiAoZmlyc3RJbmRleCA8IHN0YXRlLmxlbmd0aCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZGVsZXRlSW5XaXRoUGF0aC5hcHBseSh2b2lkIDAsIFtzdGF0ZSAmJiBzdGF0ZVtmaXJzdEluZGV4XV0uY29uY2F0KHJlc3QpKTtcblxuICAgICAgICBpZiAocmVzdWx0ICE9PSBzdGF0ZVtmaXJzdEluZGV4XSkge1xuICAgICAgICAgIHZhciBjb3B5ID0gW10uY29uY2F0KHN0YXRlKTtcbiAgICAgICAgICBjb3B5W2ZpcnN0SW5kZXhdID0gcmVzdWx0O1xuICAgICAgICAgIHJldHVybiBjb3B5O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG5cbiAgICBpZiAoZmlyc3QgaW4gc3RhdGUpIHtcbiAgICAgIHZhciBfZXh0ZW5kczI7XG5cbiAgICAgIHZhciBfcmVzdWx0ID0gZGVsZXRlSW5XaXRoUGF0aC5hcHBseSh2b2lkIDAsIFtzdGF0ZSAmJiBzdGF0ZVtmaXJzdF1dLmNvbmNhdChyZXN0KSk7XG5cbiAgICAgIHJldHVybiBzdGF0ZVtmaXJzdF0gPT09IF9yZXN1bHQgPyBzdGF0ZSA6IF9leHRlbmRzKHt9LCBzdGF0ZSwgKF9leHRlbmRzMiA9IHt9LCBfZXh0ZW5kczJbZmlyc3RdID0gX3Jlc3VsdCwgX2V4dGVuZHMyKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoc3RhdGUpKSB7XG4gICAgaWYgKGlzTmFOKGZpcnN0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGRlbGV0ZSBub24tbnVtZXJpY2FsIGluZGV4IGZyb20gYW4gYXJyYXkuIEdpdmVuOiBcXFwiXCIgKyBTdHJpbmcoZmlyc3QpKTtcbiAgICB9XG5cbiAgICB2YXIgX2ZpcnN0SW5kZXggPSBOdW1iZXIoZmlyc3QpO1xuXG4gICAgaWYgKF9maXJzdEluZGV4IDwgc3RhdGUubGVuZ3RoKSB7XG4gICAgICB2YXIgX2NvcHkgPSBbXS5jb25jYXQoc3RhdGUpO1xuXG4gICAgICBfY29weS5zcGxpY2UoX2ZpcnN0SW5kZXgsIDEpO1xuXG4gICAgICByZXR1cm4gX2NvcHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgaWYgKGZpcnN0IGluIHN0YXRlKSB7XG4gICAgdmFyIF9jb3B5MiA9IF9leHRlbmRzKHt9LCBzdGF0ZSk7XG5cbiAgICBkZWxldGUgX2NvcHkyW2ZpcnN0XTtcbiAgICByZXR1cm4gX2NvcHkyO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG52YXIgZGVsZXRlSW4gPSBmdW5jdGlvbiBkZWxldGVJbihzdGF0ZSwgZmllbGQpIHtcbiAgcmV0dXJuIGRlbGV0ZUluV2l0aFBhdGguYXBwbHkodm9pZCAwLCBbc3RhdGVdLmNvbmNhdChfdG9QYXRoKGZpZWxkKSkpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZGVsZXRlSW47IiwiZnVuY3Rpb24ga2V5cyh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIGkubmFtZTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGtleXM7IiwiaW1wb3J0IHNwbGljZSBmcm9tICcuL3NwbGljZSc7XG5pbXBvcnQgZ2V0SW4gZnJvbSAnLi9nZXRJbic7XG5pbXBvcnQgc2V0SW4gZnJvbSAnLi9zZXRJbic7XG5pbXBvcnQgZGVlcEVxdWFsIGZyb20gJy4vZGVlcEVxdWFsJztcbmltcG9ydCBkZWxldGVJbiBmcm9tICcuL2RlbGV0ZUluJztcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cyc7XG52YXIgc3RydWN0dXJlID0ge1xuICBhbGxvd3NBcnJheUVycm9yczogdHJ1ZSxcbiAgZW1wdHk6IHt9LFxuICBlbXB0eUxpc3Q6IFtdLFxuICBnZXRJbjogZ2V0SW4sXG4gIHNldEluOiBzZXRJbixcbiAgZGVlcEVxdWFsOiBkZWVwRXF1YWwsXG4gIGRlbGV0ZUluOiBkZWxldGVJbixcbiAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChpdGVtcywgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gaXRlbXMuZm9yRWFjaChjYWxsYmFjayk7XG4gIH0sXG4gIGZyb21KUzogZnVuY3Rpb24gZnJvbUpTKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBrZXlzOiBrZXlzLFxuICBzaXplOiBmdW5jdGlvbiBzaXplKGFycmF5KSB7XG4gICAgcmV0dXJuIGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgfSxcbiAgc29tZTogZnVuY3Rpb24gc29tZShpdGVtcywgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gaXRlbXMuc29tZShjYWxsYmFjayk7XG4gIH0sXG4gIHNwbGljZTogc3BsaWNlLFxuICBlcXVhbHM6IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIGIuZXZlcnkoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcmV0dXJuIH5hLmluZGV4T2YodmFsKTtcbiAgICB9KTtcbiAgfSxcbiAgb3JkZXJDaGFuZ2VkOiBmdW5jdGlvbiBvcmRlckNoYW5nZWQoYSwgYikge1xuICAgIHJldHVybiBiLnNvbWUoZnVuY3Rpb24gKHZhbCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiB2YWwgIT09IGFbaW5kZXhdO1xuICAgIH0pO1xuICB9LFxuICB0b0pTOiBmdW5jdGlvbiB0b0pTKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59O1xuZXhwb3J0IGRlZmF1bHQgc3RydWN0dXJlOyIsImltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlXCI7XG5pbXBvcnQgX2lzRnVuY3Rpb24gZnJvbSBcImxvZGFzaC9pc0Z1bmN0aW9uXCI7XG5pbXBvcnQgeyBBUlJBWV9JTlNFUlQsIEFSUkFZX01PVkUsIEFSUkFZX1BPUCwgQVJSQVlfUFVTSCwgQVJSQVlfUkVNT1ZFLCBBUlJBWV9SRU1PVkVfQUxMLCBBUlJBWV9TSElGVCwgQVJSQVlfU1BMSUNFLCBBUlJBWV9TV0FQLCBBUlJBWV9VTlNISUZULCBBVVRPRklMTCwgQkxVUiwgQ0hBTkdFLCBDTEVBUl9BU1lOQ19FUlJPUiwgQ0xFQVJfU1VCTUlULCBDTEVBUl9TVUJNSVRfRVJST1JTLCBERVNUUk9ZLCBGT0NVUywgSU5JVElBTElaRSwgcHJlZml4LCBSRUdJU1RFUl9GSUVMRCwgUkVTRVQsIFJFU0VUX1NFQ1RJT04sIFNFVF9TVUJNSVRfRkFJTEVELCBTRVRfU1VCTUlUX1NVQ0NFRURFRCwgU1RBUlRfQVNZTkNfVkFMSURBVElPTiwgU1RBUlRfU1VCTUlULCBTVE9QX0FTWU5DX1ZBTElEQVRJT04sIFNUT1BfU1VCTUlULCBTVUJNSVQsIFRPVUNILCBVTlJFR0lTVEVSX0ZJRUxELCBVTlRPVUNILCBVUERBVEVfU1lOQ19FUlJPUlMsIENMRUFSX0ZJRUxEUywgVVBEQVRFX1NZTkNfV0FSTklOR1MgfSBmcm9tICcuL2FjdGlvblR5cGVzJztcbmltcG9ydCBjcmVhdGVEZWxldGVJbldpdGhDbGVhblVwIGZyb20gJy4vZGVsZXRlSW5XaXRoQ2xlYW5VcCc7XG5pbXBvcnQgcGxhaW4gZnJvbSAnLi9zdHJ1Y3R1cmUvcGxhaW4nO1xuXG52YXIgc2hvdWxkRGVsZXRlID0gZnVuY3Rpb24gc2hvdWxkRGVsZXRlKF9yZWYpIHtcbiAgdmFyIGdldEluID0gX3JlZi5nZXRJbjtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgcGF0aCkge1xuICAgIHZhciBpbml0aWFsVmFsdWVzUGF0aCA9IG51bGw7XG5cbiAgICBpZiAoL152YWx1ZXMvLnRlc3QocGF0aCkpIHtcbiAgICAgIGluaXRpYWxWYWx1ZXNQYXRoID0gcGF0aC5yZXBsYWNlKCd2YWx1ZXMnLCAnaW5pdGlhbCcpO1xuICAgIH1cblxuICAgIHZhciBpbml0aWFsVmFsdWVDb21wYXJpc29uID0gaW5pdGlhbFZhbHVlc1BhdGggPyBnZXRJbihzdGF0ZSwgaW5pdGlhbFZhbHVlc1BhdGgpID09PSB1bmRlZmluZWQgOiB0cnVlO1xuICAgIHJldHVybiBnZXRJbihzdGF0ZSwgcGF0aCkgIT09IHVuZGVmaW5lZCAmJiBpbml0aWFsVmFsdWVDb21wYXJpc29uO1xuICB9O1xufTtcblxudmFyIGlzUmVkdXhGb3JtQWN0aW9uID0gZnVuY3Rpb24gaXNSZWR1eEZvcm1BY3Rpb24oYWN0aW9uKSB7XG4gIHJldHVybiBhY3Rpb24gJiYgYWN0aW9uLnR5cGUgJiYgYWN0aW9uLnR5cGUubGVuZ3RoID4gcHJlZml4Lmxlbmd0aCAmJiBhY3Rpb24udHlwZS5zdWJzdHJpbmcoMCwgcHJlZml4Lmxlbmd0aCkgPT09IHByZWZpeDtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlZHVjZXIoc3RydWN0dXJlKSB7XG4gIHZhciBfYmVoYXZpb3JzO1xuXG4gIHZhciBkZWVwRXF1YWwgPSBzdHJ1Y3R1cmUuZGVlcEVxdWFsLFxuICAgICAgZW1wdHkgPSBzdHJ1Y3R1cmUuZW1wdHksXG4gICAgICBmb3JFYWNoID0gc3RydWN0dXJlLmZvckVhY2gsXG4gICAgICBnZXRJbiA9IHN0cnVjdHVyZS5nZXRJbixcbiAgICAgIHNldEluID0gc3RydWN0dXJlLnNldEluLFxuICAgICAgZGVsZXRlSW4gPSBzdHJ1Y3R1cmUuZGVsZXRlSW4sXG4gICAgICBmcm9tSlMgPSBzdHJ1Y3R1cmUuZnJvbUpTLFxuICAgICAga2V5cyA9IHN0cnVjdHVyZS5rZXlzLFxuICAgICAgc2l6ZSA9IHN0cnVjdHVyZS5zaXplLFxuICAgICAgc29tZSA9IHN0cnVjdHVyZS5zb21lLFxuICAgICAgc3BsaWNlID0gc3RydWN0dXJlLnNwbGljZTtcbiAgdmFyIGRlbGV0ZUluV2l0aENsZWFuVXAgPSBjcmVhdGVEZWxldGVJbldpdGhDbGVhblVwKHN0cnVjdHVyZSkoc2hvdWxkRGVsZXRlKTtcbiAgdmFyIHBsYWluRGVsZXRlSW5XaXRoQ2xlYW5VcCA9IGNyZWF0ZURlbGV0ZUluV2l0aENsZWFuVXAocGxhaW4pKHNob3VsZERlbGV0ZSk7XG5cbiAgdmFyIGRvU3BsaWNlID0gZnVuY3Rpb24gZG9TcGxpY2Uoc3RhdGUsIGtleSwgZmllbGQsIGluZGV4LCByZW1vdmVOdW0sIHZhbHVlLCBmb3JjZSkge1xuICAgIHZhciBleGlzdGluZyA9IGdldEluKHN0YXRlLCBrZXkgKyBcIi5cIiArIGZpZWxkKTtcbiAgICByZXR1cm4gZXhpc3RpbmcgfHwgZm9yY2UgPyBzZXRJbihzdGF0ZSwga2V5ICsgXCIuXCIgKyBmaWVsZCwgc3BsaWNlKGV4aXN0aW5nLCBpbmRleCwgcmVtb3ZlTnVtLCB2YWx1ZSkpIDogc3RhdGU7XG4gIH07XG5cbiAgdmFyIGRvUGxhaW5TcGxpY2UgPSBmdW5jdGlvbiBkb1BsYWluU3BsaWNlKHN0YXRlLCBrZXksIGZpZWxkLCBpbmRleCwgcmVtb3ZlTnVtLCB2YWx1ZSwgZm9yY2UpIHtcbiAgICB2YXIgc2xpY2UgPSBnZXRJbihzdGF0ZSwga2V5KTtcbiAgICB2YXIgZXhpc3RpbmcgPSBwbGFpbi5nZXRJbihzbGljZSwgZmllbGQpO1xuICAgIHJldHVybiBleGlzdGluZyB8fCBmb3JjZSA/IHNldEluKHN0YXRlLCBrZXksIHBsYWluLnNldEluKHNsaWNlLCBmaWVsZCwgcGxhaW4uc3BsaWNlKGV4aXN0aW5nLCBpbmRleCwgcmVtb3ZlTnVtLCB2YWx1ZSkpKSA6IHN0YXRlO1xuICB9O1xuXG4gIHZhciByb290S2V5cyA9IFsndmFsdWVzJywgJ2ZpZWxkcycsICdzdWJtaXRFcnJvcnMnLCAnYXN5bmNFcnJvcnMnXTtcblxuICB2YXIgYXJyYXlTcGxpY2UgPSBmdW5jdGlvbiBhcnJheVNwbGljZShzdGF0ZSwgZmllbGQsIGluZGV4LCByZW1vdmVOdW0sIHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IHN0YXRlO1xuICAgIHZhciBub25WYWx1ZXNWYWx1ZSA9IHZhbHVlICE9IG51bGwgPyBlbXB0eSA6IHVuZGVmaW5lZDtcbiAgICByZXN1bHQgPSBkb1NwbGljZShyZXN1bHQsICd2YWx1ZXMnLCBmaWVsZCwgaW5kZXgsIHJlbW92ZU51bSwgdmFsdWUsIHRydWUpO1xuICAgIHJlc3VsdCA9IGRvU3BsaWNlKHJlc3VsdCwgJ2ZpZWxkcycsIGZpZWxkLCBpbmRleCwgcmVtb3ZlTnVtLCBub25WYWx1ZXNWYWx1ZSk7XG4gICAgcmVzdWx0ID0gZG9QbGFpblNwbGljZShyZXN1bHQsICdzeW5jRXJyb3JzJywgZmllbGQsIGluZGV4LCByZW1vdmVOdW0sIHVuZGVmaW5lZCk7XG4gICAgcmVzdWx0ID0gZG9QbGFpblNwbGljZShyZXN1bHQsICdzeW5jV2FybmluZ3MnLCBmaWVsZCwgaW5kZXgsIHJlbW92ZU51bSwgdW5kZWZpbmVkKTtcbiAgICByZXN1bHQgPSBkb1NwbGljZShyZXN1bHQsICdzdWJtaXRFcnJvcnMnLCBmaWVsZCwgaW5kZXgsIHJlbW92ZU51bSwgdW5kZWZpbmVkKTtcbiAgICByZXN1bHQgPSBkb1NwbGljZShyZXN1bHQsICdhc3luY0Vycm9ycycsIGZpZWxkLCBpbmRleCwgcmVtb3ZlTnVtLCB1bmRlZmluZWQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIGJlaGF2aW9ycyA9IChfYmVoYXZpb3JzID0ge30sIF9iZWhhdmlvcnNbQVJSQVlfSU5TRVJUXSA9IGZ1bmN0aW9uIChzdGF0ZSwgX3JlZjIpIHtcbiAgICB2YXIgX3JlZjIkbWV0YSA9IF9yZWYyLm1ldGEsXG4gICAgICAgIGZpZWxkID0gX3JlZjIkbWV0YS5maWVsZCxcbiAgICAgICAgaW5kZXggPSBfcmVmMiRtZXRhLmluZGV4LFxuICAgICAgICBwYXlsb2FkID0gX3JlZjIucGF5bG9hZDtcbiAgICByZXR1cm4gYXJyYXlTcGxpY2Uoc3RhdGUsIGZpZWxkLCBpbmRleCwgMCwgcGF5bG9hZCk7XG4gIH0sIF9iZWhhdmlvcnNbQVJSQVlfTU9WRV0gPSBmdW5jdGlvbiAoc3RhdGUsIF9yZWYzKSB7XG4gICAgdmFyIF9yZWYzJG1ldGEgPSBfcmVmMy5tZXRhLFxuICAgICAgICBmaWVsZCA9IF9yZWYzJG1ldGEuZmllbGQsXG4gICAgICAgIGZyb20gPSBfcmVmMyRtZXRhLmZyb20sXG4gICAgICAgIHRvID0gX3JlZjMkbWV0YS50bztcbiAgICB2YXIgYXJyYXkgPSBnZXRJbihzdGF0ZSwgXCJ2YWx1ZXMuXCIgKyBmaWVsZCk7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gc2l6ZShhcnJheSkgOiAwO1xuICAgIHZhciByZXN1bHQgPSBzdGF0ZTtcblxuICAgIGlmIChsZW5ndGgpIHtcbiAgICAgIHJvb3RLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgcGF0aCA9IGtleSArIFwiLlwiICsgZmllbGQ7XG5cbiAgICAgICAgaWYgKGdldEluKHJlc3VsdCwgcGF0aCkpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBnZXRJbihyZXN1bHQsIHBhdGggKyBcIltcIiArIGZyb20gKyBcIl1cIik7XG4gICAgICAgICAgcmVzdWx0ID0gc2V0SW4ocmVzdWx0LCBwYXRoLCBzcGxpY2UoZ2V0SW4ocmVzdWx0LCBwYXRoKSwgZnJvbSwgMSkpOyAvLyByZW1vdmVcblxuICAgICAgICAgIHJlc3VsdCA9IHNldEluKHJlc3VsdCwgcGF0aCwgc3BsaWNlKGdldEluKHJlc3VsdCwgcGF0aCksIHRvLCAwLCB2YWx1ZSkpOyAvLyBpbnNlcnRcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgX2JlaGF2aW9yc1tBUlJBWV9QT1BdID0gZnVuY3Rpb24gKHN0YXRlLCBfcmVmNCkge1xuICAgIHZhciBmaWVsZCA9IF9yZWY0Lm1ldGEuZmllbGQ7XG4gICAgdmFyIGFycmF5ID0gZ2V0SW4oc3RhdGUsIFwidmFsdWVzLlwiICsgZmllbGQpO1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA/IHNpemUoYXJyYXkpIDogMDtcbiAgICByZXR1cm4gbGVuZ3RoID8gYXJyYXlTcGxpY2Uoc3RhdGUsIGZpZWxkLCBsZW5ndGggLSAxLCAxKSA6IHN0YXRlO1xuICB9LCBfYmVoYXZpb3JzW0FSUkFZX1BVU0hdID0gZnVuY3Rpb24gKHN0YXRlLCBfcmVmNSkge1xuICAgIHZhciBmaWVsZCA9IF9yZWY1Lm1ldGEuZmllbGQsXG4gICAgICAgIHBheWxvYWQgPSBfcmVmNS5wYXlsb2FkO1xuICAgIHZhciBhcnJheSA9IGdldEluKHN0YXRlLCBcInZhbHVlcy5cIiArIGZpZWxkKTtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBzaXplKGFycmF5KSA6IDA7XG4gICAgcmV0dXJuIGFycmF5U3BsaWNlKHN0YXRlLCBmaWVsZCwgbGVuZ3RoLCAwLCBwYXlsb2FkKTtcbiAgfSwgX2JlaGF2aW9yc1tBUlJBWV9SRU1PVkVdID0gZnVuY3Rpb24gKHN0YXRlLCBfcmVmNikge1xuICAgIHZhciBfcmVmNiRtZXRhID0gX3JlZjYubWV0YSxcbiAgICAgICAgZmllbGQgPSBfcmVmNiRtZXRhLmZpZWxkLFxuICAgICAgICBpbmRleCA9IF9yZWY2JG1ldGEuaW5kZXg7XG4gICAgcmV0dXJuIGFycmF5U3BsaWNlKHN0YXRlLCBmaWVsZCwgaW5kZXgsIDEpO1xuICB9LCBfYmVoYXZpb3JzW0FSUkFZX1JFTU9WRV9BTExdID0gZnVuY3Rpb24gKHN0YXRlLCBfcmVmNykge1xuICAgIHZhciBmaWVsZCA9IF9yZWY3Lm1ldGEuZmllbGQ7XG4gICAgdmFyIGFycmF5ID0gZ2V0SW4oc3RhdGUsIFwidmFsdWVzLlwiICsgZmllbGQpO1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA/IHNpemUoYXJyYXkpIDogMDtcbiAgICByZXR1cm4gbGVuZ3RoID8gYXJyYXlTcGxpY2Uoc3RhdGUsIGZpZWxkLCAwLCBsZW5ndGgpIDogc3RhdGU7XG4gIH0sIF9iZWhhdmlvcnNbQVJSQVlfU0hJRlRdID0gZnVuY3Rpb24gKHN0YXRlLCBfcmVmOCkge1xuICAgIHZhciBmaWVsZCA9IF9yZWY4Lm1ldGEuZmllbGQ7XG4gICAgcmV0dXJuIGFycmF5U3BsaWNlKHN0YXRlLCBmaWVsZCwgMCwgMSk7XG4gIH0sIF9iZWhhdmlvcnNbQVJSQVlfU1BMSUNFXSA9IGZ1bmN0aW9uIChzdGF0ZSwgX3JlZjkpIHtcbiAgICB2YXIgX3JlZjkkbWV0YSA9IF9yZWY5Lm1ldGEsXG4gICAgICAgIGZpZWxkID0gX3JlZjkkbWV0YS5maWVsZCxcbiAgICAgICAgaW5kZXggPSBfcmVmOSRtZXRhLmluZGV4LFxuICAgICAgICByZW1vdmVOdW0gPSBfcmVmOSRtZXRhLnJlbW92ZU51bSxcbiAgICAgICAgcGF5bG9hZCA9IF9yZWY5LnBheWxvYWQ7XG4gICAgcmV0dXJuIGFycmF5U3BsaWNlKHN0YXRlLCBmaWVsZCwgaW5kZXgsIHJlbW92ZU51bSwgcGF5bG9hZCk7XG4gIH0sIF9iZWhhdmlvcnNbQVJSQVlfU1dBUF0gPSBmdW5jdGlvbiAoc3RhdGUsIF9yZWYxMCkge1xuICAgIHZhciBfcmVmMTAkbWV0YSA9IF9yZWYxMC5tZXRhLFxuICAgICAgICBmaWVsZCA9IF9yZWYxMCRtZXRhLmZpZWxkLFxuICAgICAgICBpbmRleEEgPSBfcmVmMTAkbWV0YS5pbmRleEEsXG4gICAgICAgIGluZGV4QiA9IF9yZWYxMCRtZXRhLmluZGV4QjtcbiAgICB2YXIgcmVzdWx0ID0gc3RhdGU7XG4gICAgcm9vdEtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgdmFsdWVBID0gZ2V0SW4ocmVzdWx0LCBrZXkgKyBcIi5cIiArIGZpZWxkICsgXCJbXCIgKyBpbmRleEEgKyBcIl1cIik7XG4gICAgICB2YXIgdmFsdWVCID0gZ2V0SW4ocmVzdWx0LCBrZXkgKyBcIi5cIiArIGZpZWxkICsgXCJbXCIgKyBpbmRleEIgKyBcIl1cIik7XG5cbiAgICAgIGlmICh2YWx1ZUEgIT09IHVuZGVmaW5lZCB8fCB2YWx1ZUIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQgPSBzZXRJbihyZXN1bHQsIGtleSArIFwiLlwiICsgZmllbGQgKyBcIltcIiArIGluZGV4QSArIFwiXVwiLCB2YWx1ZUIpO1xuICAgICAgICByZXN1bHQgPSBzZXRJbihyZXN1bHQsIGtleSArIFwiLlwiICsgZmllbGQgKyBcIltcIiArIGluZGV4QiArIFwiXVwiLCB2YWx1ZUEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIF9iZWhhdmlvcnNbQVJSQVlfVU5TSElGVF0gPSBmdW5jdGlvbiAoc3RhdGUsIF9yZWYxMSkge1xuICAgIHZhciBmaWVsZCA9IF9yZWYxMS5tZXRhLmZpZWxkLFxuICAgICAgICBwYXlsb2FkID0gX3JlZjExLnBheWxvYWQ7XG4gICAgcmV0dXJuIGFycmF5U3BsaWNlKHN0YXRlLCBmaWVsZCwgMCwgMCwgcGF5bG9hZCk7XG4gIH0sIF9iZWhhdmlvcnNbQVVUT0ZJTExdID0gZnVuY3Rpb24gKHN0YXRlLCBfcmVmMTIpIHtcbiAgICB2YXIgZmllbGQgPSBfcmVmMTIubWV0YS5maWVsZCxcbiAgICAgICAgcGF5bG9hZCA9IF9yZWYxMi5wYXlsb2FkO1xuICAgIHZhciByZXN1bHQgPSBzdGF0ZTtcbiAgICByZXN1bHQgPSBkZWxldGVJbldpdGhDbGVhblVwKHJlc3VsdCwgXCJhc3luY0Vycm9ycy5cIiArIGZpZWxkKTtcbiAgICByZXN1bHQgPSBkZWxldGVJbldpdGhDbGVhblVwKHJlc3VsdCwgXCJzdWJtaXRFcnJvcnMuXCIgKyBmaWVsZCk7XG4gICAgcmVzdWx0ID0gc2V0SW4ocmVzdWx0LCBcImZpZWxkcy5cIiArIGZpZWxkICsgXCIuYXV0b2ZpbGxlZFwiLCB0cnVlKTtcbiAgICByZXN1bHQgPSBzZXRJbihyZXN1bHQsIFwidmFsdWVzLlwiICsgZmllbGQsIHBheWxvYWQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIF9iZWhhdmlvcnNbQkxVUl0gPSBmdW5jdGlvbiAoc3RhdGUsIF9yZWYxMykge1xuICAgIHZhciBfcmVmMTMkbWV0YSA9IF9yZWYxMy5tZXRhLFxuICAgICAgICBmaWVsZCA9IF9yZWYxMyRtZXRhLmZpZWxkLFxuICAgICAgICB0b3VjaCA9IF9yZWYxMyRtZXRhLnRvdWNoLFxuICAgICAgICBwYXlsb2FkID0gX3JlZjEzLnBheWxvYWQ7XG4gICAgdmFyIHJlc3VsdCA9IHN0YXRlO1xuICAgIHZhciBpbml0aWFsID0gZ2V0SW4ocmVzdWx0LCBcImluaXRpYWwuXCIgKyBmaWVsZCk7XG5cbiAgICBpZiAoaW5pdGlhbCA9PT0gdW5kZWZpbmVkICYmIHBheWxvYWQgPT09ICcnKSB7XG4gICAgICByZXN1bHQgPSBkZWxldGVJbldpdGhDbGVhblVwKHJlc3VsdCwgXCJ2YWx1ZXMuXCIgKyBmaWVsZCk7XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlc3VsdCA9IHNldEluKHJlc3VsdCwgXCJ2YWx1ZXMuXCIgKyBmaWVsZCwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgaWYgKGZpZWxkID09PSBnZXRJbihyZXN1bHQsICdhY3RpdmUnKSkge1xuICAgICAgcmVzdWx0ID0gZGVsZXRlSW4ocmVzdWx0LCAnYWN0aXZlJyk7XG4gICAgfVxuXG4gICAgcmVzdWx0ID0gZGVsZXRlSW4ocmVzdWx0LCBcImZpZWxkcy5cIiArIGZpZWxkICsgXCIuYWN0aXZlXCIpO1xuXG4gICAgaWYgKHRvdWNoKSB7XG4gICAgICByZXN1bHQgPSBzZXRJbihyZXN1bHQsIFwiZmllbGRzLlwiICsgZmllbGQgKyBcIi50b3VjaGVkXCIsIHRydWUpO1xuICAgICAgcmVzdWx0ID0gc2V0SW4ocmVzdWx0LCAnYW55VG91Y2hlZCcsIHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIF9iZWhhdmlvcnNbQ0hBTkdFXSA9IGZ1bmN0aW9uIChzdGF0ZSwgX3JlZjE0KSB7XG4gICAgdmFyIF9yZWYxNCRtZXRhID0gX3JlZjE0Lm1ldGEsXG4gICAgICAgIGZpZWxkID0gX3JlZjE0JG1ldGEuZmllbGQsXG4gICAgICAgIHRvdWNoID0gX3JlZjE0JG1ldGEudG91Y2gsXG4gICAgICAgIHBlcnNpc3RlbnRTdWJtaXRFcnJvcnMgPSBfcmVmMTQkbWV0YS5wZXJzaXN0ZW50U3VibWl0RXJyb3JzLFxuICAgICAgICBwYXlsb2FkID0gX3JlZjE0LnBheWxvYWQ7XG4gICAgdmFyIHJlc3VsdCA9IHN0YXRlO1xuICAgIHZhciBpbml0aWFsID0gZ2V0SW4ocmVzdWx0LCBcImluaXRpYWwuXCIgKyBmaWVsZCk7XG5cbiAgICBpZiAoaW5pdGlhbCA9PT0gdW5kZWZpbmVkICYmIHBheWxvYWQgPT09ICcnKSB7XG4gICAgICByZXN1bHQgPSBkZWxldGVJbldpdGhDbGVhblVwKHJlc3VsdCwgXCJ2YWx1ZXMuXCIgKyBmaWVsZCk7XG4gICAgfSBlbHNlIGlmIChfaXNGdW5jdGlvbihwYXlsb2FkKSkge1xuICAgICAgdmFyIGZpZWxkQ3VycmVudFZhbHVlID0gZ2V0SW4oc3RhdGUsIFwidmFsdWVzLlwiICsgZmllbGQpO1xuICAgICAgcmVzdWx0ID0gc2V0SW4ocmVzdWx0LCBcInZhbHVlcy5cIiArIGZpZWxkLCBwYXlsb2FkKGZpZWxkQ3VycmVudFZhbHVlLCBzdGF0ZS52YWx1ZXMpKTtcbiAgICB9IGVsc2UgaWYgKHBheWxvYWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVzdWx0ID0gc2V0SW4ocmVzdWx0LCBcInZhbHVlcy5cIiArIGZpZWxkLCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICByZXN1bHQgPSBkZWxldGVJbldpdGhDbGVhblVwKHJlc3VsdCwgXCJhc3luY0Vycm9ycy5cIiArIGZpZWxkKTtcblxuICAgIGlmICghcGVyc2lzdGVudFN1Ym1pdEVycm9ycykge1xuICAgICAgcmVzdWx0ID0gZGVsZXRlSW5XaXRoQ2xlYW5VcChyZXN1bHQsIFwic3VibWl0RXJyb3JzLlwiICsgZmllbGQpO1xuICAgIH1cblxuICAgIHJlc3VsdCA9IGRlbGV0ZUluV2l0aENsZWFuVXAocmVzdWx0LCBcImZpZWxkcy5cIiArIGZpZWxkICsgXCIuYXV0b2ZpbGxlZFwiKTtcblxuICAgIGlmICh0b3VjaCkge1xuICAgICAgcmVzdWx0ID0gc2V0SW4ocmVzdWx0LCBcImZpZWxkcy5cIiArIGZpZWxkICsgXCIudG91Y2hlZFwiLCB0cnVlKTtcbiAgICAgIHJlc3VsdCA9IHNldEluKHJlc3VsdCwgJ2FueVRvdWNoZWQnLCB0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCBfYmVoYXZpb3JzW0NMRUFSX1NVQk1JVF0gPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICByZXR1cm4gZGVsZXRlSW4oc3RhdGUsICd0cmlnZ2VyU3VibWl0Jyk7XG4gIH0sIF9iZWhhdmlvcnNbQ0xFQVJfU1VCTUlUX0VSUk9SU10gPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gc3RhdGU7XG4gICAgcmVzdWx0ID0gZGVsZXRlSW5XaXRoQ2xlYW5VcChyZXN1bHQsICdzdWJtaXRFcnJvcnMnKTtcbiAgICByZXN1bHQgPSBkZWxldGVJbihyZXN1bHQsICdlcnJvcicpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIF9iZWhhdmlvcnNbQ0xFQVJfQVNZTkNfRVJST1JdID0gZnVuY3Rpb24gKHN0YXRlLCBfcmVmMTUpIHtcbiAgICB2YXIgZmllbGQgPSBfcmVmMTUubWV0YS5maWVsZDtcbiAgICByZXR1cm4gZGVsZXRlSW4oc3RhdGUsIFwiYXN5bmNFcnJvcnMuXCIgKyBmaWVsZCk7XG4gIH0sIF9iZWhhdmlvcnNbQ0xFQVJfRklFTERTXSA9IGZ1bmN0aW9uIChzdGF0ZSwgX3JlZjE2KSB7XG4gICAgdmFyIF9yZWYxNiRtZXRhID0gX3JlZjE2Lm1ldGEsXG4gICAgICAgIGtlZXBUb3VjaGVkID0gX3JlZjE2JG1ldGEua2VlcFRvdWNoZWQsXG4gICAgICAgIHBlcnNpc3RlbnRTdWJtaXRFcnJvcnMgPSBfcmVmMTYkbWV0YS5wZXJzaXN0ZW50U3VibWl0RXJyb3JzLFxuICAgICAgICBmaWVsZHMgPSBfcmVmMTYkbWV0YS5maWVsZHM7XG4gICAgdmFyIHJlc3VsdCA9IHN0YXRlO1xuICAgIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgcmVzdWx0ID0gZGVsZXRlSW5XaXRoQ2xlYW5VcChyZXN1bHQsIFwidmFsdWVzLlwiICsgZmllbGQpO1xuICAgICAgcmVzdWx0ID0gZGVsZXRlSW5XaXRoQ2xlYW5VcChyZXN1bHQsIFwiYXN5bmNFcnJvcnMuXCIgKyBmaWVsZCk7XG5cbiAgICAgIGlmICghcGVyc2lzdGVudFN1Ym1pdEVycm9ycykge1xuICAgICAgICByZXN1bHQgPSBkZWxldGVJbldpdGhDbGVhblVwKHJlc3VsdCwgXCJzdWJtaXRFcnJvcnMuXCIgKyBmaWVsZCk7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCA9IGRlbGV0ZUluV2l0aENsZWFuVXAocmVzdWx0LCBcImZpZWxkcy5cIiArIGZpZWxkICsgXCIuYXV0b2ZpbGxlZFwiKTtcblxuICAgICAgaWYgKCFrZWVwVG91Y2hlZCkge1xuICAgICAgICByZXN1bHQgPSBkZWxldGVJbihyZXN1bHQsIFwiZmllbGRzLlwiICsgZmllbGQgKyBcIi50b3VjaGVkXCIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBhbnlUb3VjaGVkID0gc29tZShrZXlzKGdldEluKHJlc3VsdCwgJ3JlZ2lzdGVyZWRGaWVsZHMnKSksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBnZXRJbihyZXN1bHQsIFwiZmllbGRzLlwiICsga2V5ICsgXCIudG91Y2hlZFwiKTtcbiAgICB9KTtcbiAgICByZXN1bHQgPSBhbnlUb3VjaGVkID8gc2V0SW4ocmVzdWx0LCAnYW55VG91Y2hlZCcsIHRydWUpIDogZGVsZXRlSW4ocmVzdWx0LCAnYW55VG91Y2hlZCcpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIF9iZWhhdmlvcnNbRk9DVVNdID0gZnVuY3Rpb24gKHN0YXRlLCBfcmVmMTcpIHtcbiAgICB2YXIgZmllbGQgPSBfcmVmMTcubWV0YS5maWVsZDtcbiAgICB2YXIgcmVzdWx0ID0gc3RhdGU7XG4gICAgdmFyIHByZXZpb3VzbHlBY3RpdmUgPSBnZXRJbihzdGF0ZSwgJ2FjdGl2ZScpO1xuICAgIHJlc3VsdCA9IGRlbGV0ZUluKHJlc3VsdCwgXCJmaWVsZHMuXCIgKyBwcmV2aW91c2x5QWN0aXZlICsgXCIuYWN0aXZlXCIpO1xuICAgIHJlc3VsdCA9IHNldEluKHJlc3VsdCwgXCJmaWVsZHMuXCIgKyBmaWVsZCArIFwiLnZpc2l0ZWRcIiwgdHJ1ZSk7XG4gICAgcmVzdWx0ID0gc2V0SW4ocmVzdWx0LCBcImZpZWxkcy5cIiArIGZpZWxkICsgXCIuYWN0aXZlXCIsIHRydWUpO1xuICAgIHJlc3VsdCA9IHNldEluKHJlc3VsdCwgJ2FjdGl2ZScsIGZpZWxkKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCBfYmVoYXZpb3JzW0lOSVRJQUxJWkVdID0gZnVuY3Rpb24gKHN0YXRlLCBfcmVmMTgpIHtcbiAgICB2YXIgcGF5bG9hZCA9IF9yZWYxOC5wYXlsb2FkLFxuICAgICAgICBfcmVmMTgkbWV0YSA9IF9yZWYxOC5tZXRhLFxuICAgICAgICBrZWVwRGlydHkgPSBfcmVmMTgkbWV0YS5rZWVwRGlydHksXG4gICAgICAgIGtlZXBTdWJtaXRTdWNjZWVkZWQgPSBfcmVmMTgkbWV0YS5rZWVwU3VibWl0U3VjY2VlZGVkLFxuICAgICAgICB1cGRhdGVVbnJlZ2lzdGVyZWRGaWVsZHMgPSBfcmVmMTgkbWV0YS51cGRhdGVVbnJlZ2lzdGVyZWRGaWVsZHMsXG4gICAgICAgIGtlZXBWYWx1ZXMgPSBfcmVmMTgkbWV0YS5rZWVwVmFsdWVzO1xuICAgIHZhciBtYXBEYXRhID0gZnJvbUpTKHBheWxvYWQpO1xuICAgIHZhciByZXN1bHQgPSBlbXB0eTsgLy8gY2xlYW4gYWxsIGZpZWxkIHN0YXRlXG4gICAgLy8gcGVyc2lzdCBvbGQgd2FybmluZ3MsIHRoZXkgd2lsbCBnZXQgcmVjYWxjdWxhdGVkIGlmIHRoZSBuZXcgZm9ybSB2YWx1ZXMgYXJlIGRpZmZlcmVudCBmcm9tIHRoZSBvbGQgdmFsdWVzXG5cbiAgICB2YXIgd2FybmluZyA9IGdldEluKHN0YXRlLCAnd2FybmluZycpO1xuXG4gICAgaWYgKHdhcm5pbmcpIHtcbiAgICAgIHJlc3VsdCA9IHNldEluKHJlc3VsdCwgJ3dhcm5pbmcnLCB3YXJuaW5nKTtcbiAgICB9XG5cbiAgICB2YXIgc3luY1dhcm5pbmdzID0gZ2V0SW4oc3RhdGUsICdzeW5jV2FybmluZ3MnKTtcblxuICAgIGlmIChzeW5jV2FybmluZ3MpIHtcbiAgICAgIHJlc3VsdCA9IHNldEluKHJlc3VsdCwgJ3N5bmNXYXJuaW5ncycsIHN5bmNXYXJuaW5ncyk7XG4gICAgfSAvLyBwZXJzaXN0IG9sZCBlcnJvcnMsIHRoZXkgd2lsbCBnZXQgcmVjYWxjdWxhdGVkIGlmIHRoZSBuZXcgZm9ybSB2YWx1ZXMgYXJlIGRpZmZlcmVudCBmcm9tIHRoZSBvbGQgdmFsdWVzXG5cblxuICAgIHZhciBlcnJvciA9IGdldEluKHN0YXRlLCAnZXJyb3InKTtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgcmVzdWx0ID0gc2V0SW4ocmVzdWx0LCAnZXJyb3InLCBlcnJvcik7XG4gICAgfVxuXG4gICAgdmFyIHN5bmNFcnJvcnMgPSBnZXRJbihzdGF0ZSwgJ3N5bmNFcnJvcnMnKTtcblxuICAgIGlmIChzeW5jRXJyb3JzKSB7XG4gICAgICByZXN1bHQgPSBzZXRJbihyZXN1bHQsICdzeW5jRXJyb3JzJywgc3luY0Vycm9ycyk7XG4gICAgfVxuXG4gICAgdmFyIHJlZ2lzdGVyZWRGaWVsZHMgPSBnZXRJbihzdGF0ZSwgJ3JlZ2lzdGVyZWRGaWVsZHMnKTtcblxuICAgIGlmIChyZWdpc3RlcmVkRmllbGRzKSB7XG4gICAgICByZXN1bHQgPSBzZXRJbihyZXN1bHQsICdyZWdpc3RlcmVkRmllbGRzJywgcmVnaXN0ZXJlZEZpZWxkcyk7XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzVmFsdWVzID0gZ2V0SW4oc3RhdGUsICd2YWx1ZXMnKTtcbiAgICB2YXIgcHJldmlvdXNJbml0aWFsVmFsdWVzID0gZ2V0SW4oc3RhdGUsICdpbml0aWFsJyk7XG4gICAgdmFyIG5ld0luaXRpYWxWYWx1ZXMgPSBtYXBEYXRhO1xuICAgIHZhciBuZXdWYWx1ZXMgPSBwcmV2aW91c1ZhbHVlcztcblxuICAgIGlmIChrZWVwRGlydHkgJiYgcmVnaXN0ZXJlZEZpZWxkcykge1xuICAgICAgaWYgKCFkZWVwRXF1YWwobmV3SW5pdGlhbFZhbHVlcywgcHJldmlvdXNJbml0aWFsVmFsdWVzKSkge1xuICAgICAgICAvL1xuICAgICAgICAvLyBLZWVwIHRoZSB2YWx1ZSBvZiBkaXJ0eSBmaWVsZHMgd2hpbGUgdXBkYXRpbmcgdGhlIHZhbHVlIG9mXG4gICAgICAgIC8vIHByaXN0aW5lIGZpZWxkcy4gVGhpcyB3YXksIGFwcHMgY2FuIHJlaW5pdGlhbGl6ZSBmb3JtcyB3aGlsZVxuICAgICAgICAvLyBhdm9pZGluZyBzdG9tcGluZyBvbiB1c2VyIGVkaXRzLlxuICAgICAgICAvL1xuICAgICAgICAvLyBOb3RlIDE6IFRoZSBpbml0aWFsaXplIGFjdGlvbiByZXBsYWNlcyBhbGwgaW5pdGlhbCB2YWx1ZXNcbiAgICAgICAgLy8gcmVnYXJkbGVzcyBvZiBrZWVwRGlydHkuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIE5vdGUgMjogV2hlbiBhIGZpZWxkIGlzIGRpcnR5LCBrZWVwRGlydHkgaXMgZW5hYmxlZCwgYW5kIHRoZSBmaWVsZFxuICAgICAgICAvLyB2YWx1ZSBpcyB0aGUgc2FtZSBhcyB0aGUgbmV3IGluaXRpYWwgdmFsdWUgZm9yIHRoZSBmaWVsZCwgdGhlXG4gICAgICAgIC8vIGluaXRpYWxpemUgYWN0aW9uIGNhdXNlcyB0aGUgZmllbGQgdG8gYmVjb21lIHByaXN0aW5lLiBUaGF0IGVmZmVjdFxuICAgICAgICAvLyBpcyB3aGF0IHdlIHdhbnQuXG4gICAgICAgIC8vXG4gICAgICAgIHZhciBvdmVyd3JpdGVQcmlzdGluZVZhbHVlID0gZnVuY3Rpb24gb3ZlcndyaXRlUHJpc3RpbmVWYWx1ZShuYW1lKSB7XG4gICAgICAgICAgdmFyIHByZXZpb3VzSW5pdGlhbFZhbHVlID0gZ2V0SW4ocHJldmlvdXNJbml0aWFsVmFsdWVzLCBuYW1lKTtcbiAgICAgICAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IGdldEluKHByZXZpb3VzVmFsdWVzLCBuYW1lKTtcblxuICAgICAgICAgIGlmIChkZWVwRXF1YWwocHJldmlvdXNWYWx1ZSwgcHJldmlvdXNJbml0aWFsVmFsdWUpKSB7XG4gICAgICAgICAgICAvLyBPdmVyd3JpdGUgdGhlIG9sZCBwcmlzdGluZSB2YWx1ZSB3aXRoIHRoZSBuZXcgcHJpc3RpbmUgdmFsdWVcbiAgICAgICAgICAgIHZhciBuZXdJbml0aWFsVmFsdWUgPSBnZXRJbihuZXdJbml0aWFsVmFsdWVzLCBuYW1lKTsgLy8gVGhpcyBjaGVjayBwcmV2ZW50cyBhbnkgJ3NldEluJyBjYWxsIHRoYXQgd291bGQgY3JlYXRlIHVzZWxlc3NcbiAgICAgICAgICAgIC8vIG5lc3RlZCBvYmplY3RzLCBzaW5jZSB0aGUgcGF0aCB0byB0aGUgbmV3IGZpZWxkIHZhbHVlIHdvdWxkXG4gICAgICAgICAgICAvLyBldmFsdWF0ZSB0byB0aGUgc2FtZSAoZXNwZWNpYWxseSBmb3IgdW5kZWZpbmVkIHZhbHVlcylcblxuICAgICAgICAgICAgaWYgKGdldEluKG5ld1ZhbHVlcywgbmFtZSkgIT09IG5ld0luaXRpYWxWYWx1ZSkge1xuICAgICAgICAgICAgICBuZXdWYWx1ZXMgPSBzZXRJbihuZXdWYWx1ZXMsIG5hbWUsIG5ld0luaXRpYWxWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghdXBkYXRlVW5yZWdpc3RlcmVkRmllbGRzKSB7XG4gICAgICAgICAgZm9yRWFjaChrZXlzKHJlZ2lzdGVyZWRGaWVsZHMpLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG92ZXJ3cml0ZVByaXN0aW5lVmFsdWUobmFtZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JFYWNoKGtleXMobmV3SW5pdGlhbFZhbHVlcyksIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgdmFyIHByZXZpb3VzSW5pdGlhbFZhbHVlID0gZ2V0SW4ocHJldmlvdXNJbml0aWFsVmFsdWVzLCBuYW1lKTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgcHJldmlvdXNJbml0aWFsVmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBBZGQgbmV3IHZhbHVlcyBhdCB0aGUgcm9vdCBsZXZlbC5cbiAgICAgICAgICAgIHZhciBuZXdJbml0aWFsVmFsdWUgPSBnZXRJbihuZXdJbml0aWFsVmFsdWVzLCBuYW1lKTtcbiAgICAgICAgICAgIG5ld1ZhbHVlcyA9IHNldEluKG5ld1ZhbHVlcywgbmFtZSwgbmV3SW5pdGlhbFZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodXBkYXRlVW5yZWdpc3RlcmVkRmllbGRzKSB7XG4gICAgICAgICAgICBvdmVyd3JpdGVQcmlzdGluZVZhbHVlKG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1ZhbHVlcyA9IG5ld0luaXRpYWxWYWx1ZXM7XG4gICAgfVxuXG4gICAgaWYgKGtlZXBWYWx1ZXMpIHtcbiAgICAgIGZvckVhY2goa2V5cyhwcmV2aW91c1ZhbHVlcyksIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBwcmV2aW91c1ZhbHVlID0gZ2V0SW4ocHJldmlvdXNWYWx1ZXMsIG5hbWUpO1xuICAgICAgICBuZXdWYWx1ZXMgPSBzZXRJbihuZXdWYWx1ZXMsIG5hbWUsIHByZXZpb3VzVmFsdWUpO1xuICAgICAgfSk7XG4gICAgICBmb3JFYWNoKGtleXMocHJldmlvdXNJbml0aWFsVmFsdWVzKSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzSW5pdGlhbFZhbHVlID0gZ2V0SW4ocHJldmlvdXNJbml0aWFsVmFsdWVzLCBuYW1lKTtcbiAgICAgICAgbmV3SW5pdGlhbFZhbHVlcyA9IHNldEluKG5ld0luaXRpYWxWYWx1ZXMsIG5hbWUsIHByZXZpb3VzSW5pdGlhbFZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChrZWVwU3VibWl0U3VjY2VlZGVkICYmIGdldEluKHN0YXRlLCAnc3VibWl0U3VjY2VlZGVkJykpIHtcbiAgICAgIHJlc3VsdCA9IHNldEluKHJlc3VsdCwgJ3N1Ym1pdFN1Y2NlZWRlZCcsIHRydWUpO1xuICAgIH1cblxuICAgIHJlc3VsdCA9IHNldEluKHJlc3VsdCwgJ3ZhbHVlcycsIG5ld1ZhbHVlcyk7XG4gICAgcmVzdWx0ID0gc2V0SW4ocmVzdWx0LCAnaW5pdGlhbCcsIG5ld0luaXRpYWxWYWx1ZXMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIF9iZWhhdmlvcnNbUkVHSVNURVJfRklFTERdID0gZnVuY3Rpb24gKHN0YXRlLCBfcmVmMTkpIHtcbiAgICB2YXIgX3JlZjE5JHBheWxvYWQgPSBfcmVmMTkucGF5bG9hZCxcbiAgICAgICAgbmFtZSA9IF9yZWYxOSRwYXlsb2FkLm5hbWUsXG4gICAgICAgIHR5cGUgPSBfcmVmMTkkcGF5bG9hZC50eXBlO1xuICAgIHZhciBrZXkgPSBcInJlZ2lzdGVyZWRGaWVsZHNbJ1wiICsgbmFtZSArIFwiJ11cIjtcbiAgICB2YXIgZmllbGQgPSBnZXRJbihzdGF0ZSwga2V5KTtcblxuICAgIGlmIChmaWVsZCkge1xuICAgICAgdmFyIGNvdW50ID0gZ2V0SW4oZmllbGQsICdjb3VudCcpICsgMTtcbiAgICAgIGZpZWxkID0gc2V0SW4oZmllbGQsICdjb3VudCcsIGNvdW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmllbGQgPSBmcm9tSlMoe1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBjb3VudDogMVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNldEluKHN0YXRlLCBrZXksIGZpZWxkKTtcbiAgfSwgX2JlaGF2aW9yc1tSRVNFVF0gPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZW1wdHk7XG4gICAgdmFyIHJlZ2lzdGVyZWRGaWVsZHMgPSBnZXRJbihzdGF0ZSwgJ3JlZ2lzdGVyZWRGaWVsZHMnKTtcblxuICAgIGlmIChyZWdpc3RlcmVkRmllbGRzKSB7XG4gICAgICByZXN1bHQgPSBzZXRJbihyZXN1bHQsICdyZWdpc3RlcmVkRmllbGRzJywgcmVnaXN0ZXJlZEZpZWxkcyk7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlcyA9IGdldEluKHN0YXRlLCAnaW5pdGlhbCcpO1xuXG4gICAgaWYgKHZhbHVlcykge1xuICAgICAgcmVzdWx0ID0gc2V0SW4ocmVzdWx0LCAndmFsdWVzJywgdmFsdWVzKTtcbiAgICAgIHJlc3VsdCA9IHNldEluKHJlc3VsdCwgJ2luaXRpYWwnLCB2YWx1ZXMpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIF9iZWhhdmlvcnNbUkVTRVRfU0VDVElPTl0gPSBmdW5jdGlvbiAoc3RhdGUsIF9yZWYyMCkge1xuICAgIHZhciBzZWN0aW9ucyA9IF9yZWYyMC5tZXRhLnNlY3Rpb25zO1xuICAgIHZhciByZXN1bHQgPSBzdGF0ZTtcbiAgICBzZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChzZWN0aW9uKSB7XG4gICAgICByZXN1bHQgPSBkZWxldGVJbldpdGhDbGVhblVwKHJlc3VsdCwgXCJhc3luY0Vycm9ycy5cIiArIHNlY3Rpb24pO1xuICAgICAgcmVzdWx0ID0gZGVsZXRlSW5XaXRoQ2xlYW5VcChyZXN1bHQsIFwic3VibWl0RXJyb3JzLlwiICsgc2VjdGlvbik7XG4gICAgICByZXN1bHQgPSBkZWxldGVJbldpdGhDbGVhblVwKHJlc3VsdCwgXCJmaWVsZHMuXCIgKyBzZWN0aW9uKTtcbiAgICAgIHZhciB2YWx1ZXMgPSBnZXRJbihzdGF0ZSwgXCJpbml0aWFsLlwiICsgc2VjdGlvbik7XG4gICAgICByZXN1bHQgPSB2YWx1ZXMgPyBzZXRJbihyZXN1bHQsIFwidmFsdWVzLlwiICsgc2VjdGlvbiwgdmFsdWVzKSA6IGRlbGV0ZUluV2l0aENsZWFuVXAocmVzdWx0LCBcInZhbHVlcy5cIiArIHNlY3Rpb24pO1xuICAgIH0pO1xuICAgIHZhciBhbnlUb3VjaGVkID0gc29tZShrZXlzKGdldEluKHJlc3VsdCwgJ3JlZ2lzdGVyZWRGaWVsZHMnKSksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBnZXRJbihyZXN1bHQsIFwiZmllbGRzLlwiICsga2V5ICsgXCIudG91Y2hlZFwiKTtcbiAgICB9KTtcbiAgICByZXN1bHQgPSBhbnlUb3VjaGVkID8gc2V0SW4ocmVzdWx0LCAnYW55VG91Y2hlZCcsIHRydWUpIDogZGVsZXRlSW4ocmVzdWx0LCAnYW55VG91Y2hlZCcpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIF9iZWhhdmlvcnNbU1VCTUlUXSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgIHJldHVybiBzZXRJbihzdGF0ZSwgJ3RyaWdnZXJTdWJtaXQnLCB0cnVlKTtcbiAgfSwgX2JlaGF2aW9yc1tTVEFSVF9BU1lOQ19WQUxJREFUSU9OXSA9IGZ1bmN0aW9uIChzdGF0ZSwgX3JlZjIxKSB7XG4gICAgdmFyIGZpZWxkID0gX3JlZjIxLm1ldGEuZmllbGQ7XG4gICAgcmV0dXJuIHNldEluKHN0YXRlLCAnYXN5bmNWYWxpZGF0aW5nJywgZmllbGQgfHwgdHJ1ZSk7XG4gIH0sIF9iZWhhdmlvcnNbU1RBUlRfU1VCTUlUXSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgIHJldHVybiBzZXRJbihzdGF0ZSwgJ3N1Ym1pdHRpbmcnLCB0cnVlKTtcbiAgfSwgX2JlaGF2aW9yc1tTVE9QX0FTWU5DX1ZBTElEQVRJT05dID0gZnVuY3Rpb24gKHN0YXRlLCBfcmVmMjIpIHtcbiAgICB2YXIgcGF5bG9hZCA9IF9yZWYyMi5wYXlsb2FkO1xuICAgIHZhciByZXN1bHQgPSBzdGF0ZTtcbiAgICByZXN1bHQgPSBkZWxldGVJbihyZXN1bHQsICdhc3luY1ZhbGlkYXRpbmcnKTtcblxuICAgIGlmIChwYXlsb2FkICYmIE9iamVjdC5rZXlzKHBheWxvYWQpLmxlbmd0aCkge1xuICAgICAgdmFyIF9lcnJvciA9IHBheWxvYWQuX2Vycm9yLFxuICAgICAgICAgIGZpZWxkRXJyb3JzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocGF5bG9hZCwgW1wiX2Vycm9yXCJdKTtcblxuICAgICAgaWYgKF9lcnJvcikge1xuICAgICAgICByZXN1bHQgPSBzZXRJbihyZXN1bHQsICdlcnJvcicsIF9lcnJvcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChPYmplY3Qua2V5cyhmaWVsZEVycm9ycykubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdCA9IHNldEluKHJlc3VsdCwgJ2FzeW5jRXJyb3JzJywgZnJvbUpTKGZpZWxkRXJyb3JzKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGRlbGV0ZUluKHJlc3VsdCwgJ2Vycm9yJyk7XG4gICAgICByZXN1bHQgPSBkZWxldGVJbihyZXN1bHQsICdhc3luY0Vycm9ycycpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIF9iZWhhdmlvcnNbU1RPUF9TVUJNSVRdID0gZnVuY3Rpb24gKHN0YXRlLCBfcmVmMjMpIHtcbiAgICB2YXIgcGF5bG9hZCA9IF9yZWYyMy5wYXlsb2FkO1xuICAgIHZhciByZXN1bHQgPSBzdGF0ZTtcbiAgICByZXN1bHQgPSBkZWxldGVJbihyZXN1bHQsICdzdWJtaXR0aW5nJyk7XG4gICAgcmVzdWx0ID0gZGVsZXRlSW4ocmVzdWx0LCAnc3VibWl0RmFpbGVkJyk7XG4gICAgcmVzdWx0ID0gZGVsZXRlSW4ocmVzdWx0LCAnc3VibWl0U3VjY2VlZGVkJyk7XG5cbiAgICBpZiAocGF5bG9hZCAmJiBPYmplY3Qua2V5cyhwYXlsb2FkKS5sZW5ndGgpIHtcbiAgICAgIHZhciBfZXJyb3IgPSBwYXlsb2FkLl9lcnJvcixcbiAgICAgICAgICBmaWVsZEVycm9ycyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHBheWxvYWQsIFtcIl9lcnJvclwiXSk7XG5cbiAgICAgIGlmIChfZXJyb3IpIHtcbiAgICAgICAgcmVzdWx0ID0gc2V0SW4ocmVzdWx0LCAnZXJyb3InLCBfZXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gZGVsZXRlSW4ocmVzdWx0LCAnZXJyb3InKTtcbiAgICAgIH1cblxuICAgICAgaWYgKE9iamVjdC5rZXlzKGZpZWxkRXJyb3JzKS5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0ID0gc2V0SW4ocmVzdWx0LCAnc3VibWl0RXJyb3JzJywgZnJvbUpTKGZpZWxkRXJyb3JzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBkZWxldGVJbihyZXN1bHQsICdzdWJtaXRFcnJvcnMnKTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0ID0gc2V0SW4ocmVzdWx0LCAnc3VibWl0RmFpbGVkJywgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGRlbGV0ZUluKHJlc3VsdCwgJ2Vycm9yJyk7XG4gICAgICByZXN1bHQgPSBkZWxldGVJbihyZXN1bHQsICdzdWJtaXRFcnJvcnMnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCBfYmVoYXZpb3JzW1NFVF9TVUJNSVRfRkFJTEVEXSA9IGZ1bmN0aW9uIChzdGF0ZSwgX3JlZjI0KSB7XG4gICAgdmFyIGZpZWxkcyA9IF9yZWYyNC5tZXRhLmZpZWxkcztcbiAgICB2YXIgcmVzdWx0ID0gc3RhdGU7XG4gICAgcmVzdWx0ID0gc2V0SW4ocmVzdWx0LCAnc3VibWl0RmFpbGVkJywgdHJ1ZSk7XG4gICAgcmVzdWx0ID0gZGVsZXRlSW4ocmVzdWx0LCAnc3VibWl0U3VjY2VlZGVkJyk7XG4gICAgcmVzdWx0ID0gZGVsZXRlSW4ocmVzdWx0LCAnc3VibWl0dGluZycpO1xuICAgIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCA9IHNldEluKHJlc3VsdCwgXCJmaWVsZHMuXCIgKyBmaWVsZCArIFwiLnRvdWNoZWRcIiwgdHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpZiAoZmllbGRzLmxlbmd0aCkge1xuICAgICAgcmVzdWx0ID0gc2V0SW4ocmVzdWx0LCAnYW55VG91Y2hlZCcsIHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIF9iZWhhdmlvcnNbU0VUX1NVQk1JVF9TVUNDRUVERURdID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IHN0YXRlO1xuICAgIHJlc3VsdCA9IGRlbGV0ZUluKHJlc3VsdCwgJ3N1Ym1pdEZhaWxlZCcpO1xuICAgIHJlc3VsdCA9IHNldEluKHJlc3VsdCwgJ3N1Ym1pdFN1Y2NlZWRlZCcsIHRydWUpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIF9iZWhhdmlvcnNbVE9VQ0hdID0gZnVuY3Rpb24gKHN0YXRlLCBfcmVmMjUpIHtcbiAgICB2YXIgZmllbGRzID0gX3JlZjI1Lm1ldGEuZmllbGRzO1xuICAgIHZhciByZXN1bHQgPSBzdGF0ZTtcbiAgICBmaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiByZXN1bHQgPSBzZXRJbihyZXN1bHQsIFwiZmllbGRzLlwiICsgZmllbGQgKyBcIi50b3VjaGVkXCIsIHRydWUpO1xuICAgIH0pO1xuICAgIHJlc3VsdCA9IHNldEluKHJlc3VsdCwgJ2FueVRvdWNoZWQnLCB0cnVlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCBfYmVoYXZpb3JzW1VOUkVHSVNURVJfRklFTERdID0gZnVuY3Rpb24gKHN0YXRlLCBfcmVmMjYpIHtcbiAgICB2YXIgX3JlZjI2JHBheWxvYWQgPSBfcmVmMjYucGF5bG9hZCxcbiAgICAgICAgbmFtZSA9IF9yZWYyNiRwYXlsb2FkLm5hbWUsXG4gICAgICAgIGRlc3Ryb3lPblVubW91bnQgPSBfcmVmMjYkcGF5bG9hZC5kZXN0cm95T25Vbm1vdW50O1xuICAgIHZhciByZXN1bHQgPSBzdGF0ZTtcbiAgICB2YXIga2V5ID0gXCJyZWdpc3RlcmVkRmllbGRzWydcIiArIG5hbWUgKyBcIiddXCI7XG4gICAgdmFyIGZpZWxkID0gZ2V0SW4ocmVzdWx0LCBrZXkpO1xuXG4gICAgaWYgKCFmaWVsZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICB2YXIgY291bnQgPSBnZXRJbihmaWVsZCwgJ2NvdW50JykgLSAxO1xuXG4gICAgaWYgKGNvdW50IDw9IDAgJiYgZGVzdHJveU9uVW5tb3VudCkge1xuICAgICAgLy8gTm90ZTogQ2Fubm90IHVzZSBkZWxldGVXaXRoQ2xlYW5VcCBoZXJlIGJlY2F1c2Ugb2YgdGhlIGZsYXQgbmF0dXJlIG9mIHJlZ2lzdGVyZWRGaWVsZHNcbiAgICAgIHJlc3VsdCA9IGRlbGV0ZUluKHJlc3VsdCwga2V5KTtcblxuICAgICAgaWYgKGRlZXBFcXVhbChnZXRJbihyZXN1bHQsICdyZWdpc3RlcmVkRmllbGRzJyksIGVtcHR5KSkge1xuICAgICAgICByZXN1bHQgPSBkZWxldGVJbihyZXN1bHQsICdyZWdpc3RlcmVkRmllbGRzJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzeW5jRXJyb3JzID0gZ2V0SW4ocmVzdWx0LCAnc3luY0Vycm9ycycpO1xuXG4gICAgICBpZiAoc3luY0Vycm9ycykge1xuICAgICAgICBzeW5jRXJyb3JzID0gcGxhaW5EZWxldGVJbldpdGhDbGVhblVwKHN5bmNFcnJvcnMsIG5hbWUpO1xuXG4gICAgICAgIGlmIChwbGFpbi5kZWVwRXF1YWwoc3luY0Vycm9ycywgcGxhaW4uZW1wdHkpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZGVsZXRlSW4ocmVzdWx0LCAnc3luY0Vycm9ycycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCA9IHNldEluKHJlc3VsdCwgJ3N5bmNFcnJvcnMnLCBzeW5jRXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc3luY1dhcm5pbmdzID0gZ2V0SW4ocmVzdWx0LCAnc3luY1dhcm5pbmdzJyk7XG5cbiAgICAgIGlmIChzeW5jV2FybmluZ3MpIHtcbiAgICAgICAgc3luY1dhcm5pbmdzID0gcGxhaW5EZWxldGVJbldpdGhDbGVhblVwKHN5bmNXYXJuaW5ncywgbmFtZSk7XG5cbiAgICAgICAgaWYgKHBsYWluLmRlZXBFcXVhbChzeW5jV2FybmluZ3MsIHBsYWluLmVtcHR5KSkge1xuICAgICAgICAgIHJlc3VsdCA9IGRlbGV0ZUluKHJlc3VsdCwgJ3N5bmNXYXJuaW5ncycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCA9IHNldEluKHJlc3VsdCwgJ3N5bmNXYXJuaW5ncycsIHN5bmNXYXJuaW5ncyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzdWx0ID0gZGVsZXRlSW5XaXRoQ2xlYW5VcChyZXN1bHQsIFwic3VibWl0RXJyb3JzLlwiICsgbmFtZSk7XG4gICAgICByZXN1bHQgPSBkZWxldGVJbldpdGhDbGVhblVwKHJlc3VsdCwgXCJhc3luY0Vycm9ycy5cIiArIG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaWVsZCA9IHNldEluKGZpZWxkLCAnY291bnQnLCBjb3VudCk7XG4gICAgICByZXN1bHQgPSBzZXRJbihyZXN1bHQsIGtleSwgZmllbGQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIF9iZWhhdmlvcnNbVU5UT1VDSF0gPSBmdW5jdGlvbiAoc3RhdGUsIF9yZWYyNykge1xuICAgIHZhciBmaWVsZHMgPSBfcmVmMjcubWV0YS5maWVsZHM7XG4gICAgdmFyIHJlc3VsdCA9IHN0YXRlO1xuICAgIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCA9IGRlbGV0ZUluKHJlc3VsdCwgXCJmaWVsZHMuXCIgKyBmaWVsZCArIFwiLnRvdWNoZWRcIik7XG4gICAgfSk7XG4gICAgdmFyIGFueVRvdWNoZWQgPSBzb21lKGtleXMoZ2V0SW4ocmVzdWx0LCAncmVnaXN0ZXJlZEZpZWxkcycpKSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIGdldEluKHJlc3VsdCwgXCJmaWVsZHMuXCIgKyBrZXkgKyBcIi50b3VjaGVkXCIpO1xuICAgIH0pO1xuICAgIHJlc3VsdCA9IGFueVRvdWNoZWQgPyBzZXRJbihyZXN1bHQsICdhbnlUb3VjaGVkJywgdHJ1ZSkgOiBkZWxldGVJbihyZXN1bHQsICdhbnlUb3VjaGVkJyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgX2JlaGF2aW9yc1tVUERBVEVfU1lOQ19FUlJPUlNdID0gZnVuY3Rpb24gKHN0YXRlLCBfcmVmMjgpIHtcbiAgICB2YXIgX3JlZjI4JHBheWxvYWQgPSBfcmVmMjgucGF5bG9hZCxcbiAgICAgICAgc3luY0Vycm9ycyA9IF9yZWYyOCRwYXlsb2FkLnN5bmNFcnJvcnMsXG4gICAgICAgIGVycm9yID0gX3JlZjI4JHBheWxvYWQuZXJyb3I7XG4gICAgdmFyIHJlc3VsdCA9IHN0YXRlO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICByZXN1bHQgPSBzZXRJbihyZXN1bHQsICdlcnJvcicsIGVycm9yKTtcbiAgICAgIHJlc3VsdCA9IHNldEluKHJlc3VsdCwgJ3N5bmNFcnJvcicsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBkZWxldGVJbihyZXN1bHQsICdlcnJvcicpO1xuICAgICAgcmVzdWx0ID0gZGVsZXRlSW4ocmVzdWx0LCAnc3luY0Vycm9yJyk7XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5rZXlzKHN5bmNFcnJvcnMpLmxlbmd0aCkge1xuICAgICAgcmVzdWx0ID0gc2V0SW4ocmVzdWx0LCAnc3luY0Vycm9ycycsIHN5bmNFcnJvcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBkZWxldGVJbihyZXN1bHQsICdzeW5jRXJyb3JzJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgX2JlaGF2aW9yc1tVUERBVEVfU1lOQ19XQVJOSU5HU10gPSBmdW5jdGlvbiAoc3RhdGUsIF9yZWYyOSkge1xuICAgIHZhciBfcmVmMjkkcGF5bG9hZCA9IF9yZWYyOS5wYXlsb2FkLFxuICAgICAgICBzeW5jV2FybmluZ3MgPSBfcmVmMjkkcGF5bG9hZC5zeW5jV2FybmluZ3MsXG4gICAgICAgIHdhcm5pbmcgPSBfcmVmMjkkcGF5bG9hZC53YXJuaW5nO1xuICAgIHZhciByZXN1bHQgPSBzdGF0ZTtcblxuICAgIGlmICh3YXJuaW5nKSB7XG4gICAgICByZXN1bHQgPSBzZXRJbihyZXN1bHQsICd3YXJuaW5nJywgd2FybmluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGRlbGV0ZUluKHJlc3VsdCwgJ3dhcm5pbmcnKTtcbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LmtleXMoc3luY1dhcm5pbmdzKS5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdCA9IHNldEluKHJlc3VsdCwgJ3N5bmNXYXJuaW5ncycsIHN5bmNXYXJuaW5ncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGRlbGV0ZUluKHJlc3VsdCwgJ3N5bmNXYXJuaW5ncycpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIF9iZWhhdmlvcnMpO1xuXG4gIHZhciByZWR1Y2VyID0gZnVuY3Rpb24gcmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgaWYgKHN0YXRlID09PSB2b2lkIDApIHtcbiAgICAgIHN0YXRlID0gZW1wdHk7XG4gICAgfVxuXG4gICAgdmFyIGJlaGF2aW9yID0gYmVoYXZpb3JzW2FjdGlvbi50eXBlXTtcbiAgICByZXR1cm4gYmVoYXZpb3IgPyBiZWhhdmlvcihzdGF0ZSwgYWN0aW9uKSA6IHN0YXRlO1xuICB9O1xuXG4gIHZhciBieUZvcm0gPSBmdW5jdGlvbiBieUZvcm0ocmVkdWNlcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGFjdGlvbikge1xuICAgICAgaWYgKHN0YXRlID09PSB2b2lkIDApIHtcbiAgICAgICAgc3RhdGUgPSBlbXB0eTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFjdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGFjdGlvbiA9IHtcbiAgICAgICAgICB0eXBlOiAnTk9ORSdcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZvcm0gPSBhY3Rpb24gJiYgYWN0aW9uLm1ldGEgJiYgYWN0aW9uLm1ldGEuZm9ybTtcblxuICAgICAgaWYgKCFmb3JtIHx8ICFpc1JlZHV4Rm9ybUFjdGlvbihhY3Rpb24pKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFjdGlvbi50eXBlID09PSBERVNUUk9ZICYmIGFjdGlvbi5tZXRhICYmIGFjdGlvbi5tZXRhLmZvcm0pIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbi5tZXRhLmZvcm0ucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGZvcm0pIHtcbiAgICAgICAgICByZXR1cm4gZGVsZXRlSW5XaXRoQ2xlYW5VcChyZXN1bHQsIGZvcm0pO1xuICAgICAgICB9LCBzdGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBmb3JtU3RhdGUgPSBnZXRJbihzdGF0ZSwgZm9ybSk7XG4gICAgICB2YXIgcmVzdWx0ID0gcmVkdWNlcihmb3JtU3RhdGUsIGFjdGlvbik7XG4gICAgICByZXR1cm4gcmVzdWx0ID09PSBmb3JtU3RhdGUgPyBzdGF0ZSA6IHNldEluKHN0YXRlLCBmb3JtLCByZXN1bHQpO1xuICAgIH07XG4gIH07XG4gIC8qKlxuICAgKiBBZGRzIGFkZGl0aW9uYWwgZnVuY3Rpb25hbGl0eSB0byB0aGUgcmVkdWNlclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGRlY29yYXRlKHRhcmdldCkge1xuICAgIHRhcmdldC5wbHVnaW4gPSBmdW5jdGlvbiAocmVkdWNlcnMsIGNvbmZpZykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbmZpZyA9IHt9O1xuICAgICAgfVxuXG4gICAgICAvLyB1c2UgJ2Z1bmN0aW9uJyBrZXl3b3JkIHRvIGVuYWJsZSAndGhpcydcbiAgICAgIHJldHVybiBkZWNvcmF0ZShmdW5jdGlvbiAoc3RhdGUsIGFjdGlvbikge1xuICAgICAgICBpZiAoc3RhdGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHN0YXRlID0gZW1wdHk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWN0aW9uID09PSB2b2lkIDApIHtcbiAgICAgICAgICBhY3Rpb24gPSB7XG4gICAgICAgICAgICB0eXBlOiAnTk9ORSdcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNhbGxQbHVnaW4gPSBmdW5jdGlvbiBjYWxsUGx1Z2luKHByb2Nlc3NlZCwga2V5KSB7XG4gICAgICAgICAgdmFyIHByZXZpb3VzU3RhdGUgPSBnZXRJbihwcm9jZXNzZWQsIGtleSk7XG4gICAgICAgICAgdmFyIG5leHRTdGF0ZSA9IHJlZHVjZXJzW2tleV0ocHJldmlvdXNTdGF0ZSwgYWN0aW9uLCBnZXRJbihzdGF0ZSwga2V5KSk7XG4gICAgICAgICAgcmV0dXJuIG5leHRTdGF0ZSAhPT0gcHJldmlvdXNTdGF0ZSA/IHNldEluKHByb2Nlc3NlZCwga2V5LCBuZXh0U3RhdGUpIDogcHJvY2Vzc2VkO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBwcm9jZXNzZWQgPSBfdGhpcyhzdGF0ZSwgYWN0aW9uKTsgLy8gcnVuIHRocm91Z2ggcmVkdXgtZm9ybSByZWR1Y2VyXG5cblxuICAgICAgICB2YXIgZm9ybSA9IGFjdGlvbiAmJiBhY3Rpb24ubWV0YSAmJiBhY3Rpb24ubWV0YS5mb3JtO1xuXG4gICAgICAgIGlmIChmb3JtICYmICFjb25maWcucmVjZWl2ZUFsbEZvcm1BY3Rpb25zKSB7XG4gICAgICAgICAgLy8gdGhpcyBpcyBhbiBhY3Rpb24gYWltZWQgYXQgZm9ybXMsIHNvIG9ubHkgZ2l2ZSBpdCB0byB0aGUgc3BlY2lmaWVkIGZvcm0ncyBwbHVnaW5cbiAgICAgICAgICByZXR1cm4gcmVkdWNlcnNbZm9ybV0gPyBjYWxsUGx1Z2luKHByb2Nlc3NlZCwgZm9ybSkgOiBwcm9jZXNzZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdGhpcyBpcyBub3QgYSBmb3JtLXNwZWNpZmljIGFjdGlvbiwgc28gc2VuZCBpdCB0byBhbGwgdGhlIHBsdWdpbnNcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMocmVkdWNlcnMpLnJlZHVjZShjYWxsUGx1Z2luLCBwcm9jZXNzZWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIHJldHVybiBkZWNvcmF0ZShieUZvcm0ocmVkdWNlcikpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVSZWR1Y2VyOyIsImltcG9ydCBjcmVhdGVSZWR1Y2VyIGZyb20gJy4vY3JlYXRlUmVkdWNlcic7XG5pbXBvcnQgcGxhaW4gZnJvbSAnLi9zdHJ1Y3R1cmUvcGxhaW4nO1xuZXhwb3J0IGRlZmF1bHQgY3JlYXRlUmVkdWNlcihwbGFpbik7IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufSIsImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5leHBvcnQgdmFyIHN1YnNjcmlwdGlvblNoYXBlID0gUHJvcFR5cGVzLnNoYXBlKHtcbiAgdHJ5U3Vic2NyaWJlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB0cnlVbnN1YnNjcmliZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgbm90aWZ5TmVzdGVkU3ViczogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgaXNTdWJzY3JpYmVkOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG59KTtcbmV4cG9ydCB2YXIgc3RvcmVTaGFwZSA9IFByb3BUeXBlcy5zaGFwZSh7XG4gIHN1YnNjcmliZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgZGlzcGF0Y2g6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIGdldFN0YXRlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG59KTsiLCIvKipcbiAqIFByaW50cyBhIHdhcm5pbmcgaW4gdGhlIGNvbnNvbGUgaWYgaXQgZXhpc3RzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSB3YXJuaW5nIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gd2FybmluZyhtZXNzYWdlKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG5cblxuICB0cnkge1xuICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgaWYgeW91IGVuYWJsZVxuICAgIC8vIFwiYnJlYWsgb24gYWxsIGV4Y2VwdGlvbnNcIiBpbiB5b3VyIGNvbnNvbGUsXG4gICAgLy8gaXQgd291bGQgcGF1c2UgdGhlIGV4ZWN1dGlvbiBhdCB0aGlzIGxpbmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWVtcHR5ICovXG4gIH0gY2F0Y2ggKGUpIHt9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tZW1wdHkgKi9cblxufSIsImltcG9ydCBfaW5oZXJpdHNMb29zZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNMb29zZVwiO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBDaGlsZHJlbiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBzdG9yZVNoYXBlLCBzdWJzY3JpcHRpb25TaGFwZSB9IGZyb20gJy4uL3V0aWxzL1Byb3BUeXBlcyc7XG5pbXBvcnQgd2FybmluZyBmcm9tICcuLi91dGlscy93YXJuaW5nJztcbnZhciBkaWRXYXJuQWJvdXRSZWNlaXZpbmdTdG9yZSA9IGZhbHNlO1xuXG5mdW5jdGlvbiB3YXJuQWJvdXRSZWNlaXZpbmdTdG9yZSgpIHtcbiAgaWYgKGRpZFdhcm5BYm91dFJlY2VpdmluZ1N0b3JlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZGlkV2FybkFib3V0UmVjZWl2aW5nU3RvcmUgPSB0cnVlO1xuICB3YXJuaW5nKCc8UHJvdmlkZXI+IGRvZXMgbm90IHN1cHBvcnQgY2hhbmdpbmcgYHN0b3JlYCBvbiB0aGUgZmx5LiAnICsgJ0l0IGlzIG1vc3QgbGlrZWx5IHRoYXQgeW91IHNlZSB0aGlzIGVycm9yIGJlY2F1c2UgeW91IHVwZGF0ZWQgdG8gJyArICdSZWR1eCAyLnggYW5kIFJlYWN0IFJlZHV4IDIueCB3aGljaCBubyBsb25nZXIgaG90IHJlbG9hZCByZWR1Y2VycyAnICsgJ2F1dG9tYXRpY2FsbHkuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVkdXhqcy9yZWFjdC1yZWR1eC9yZWxlYXNlcy8nICsgJ3RhZy92Mi4wLjAgZm9yIHRoZSBtaWdyYXRpb24gaW5zdHJ1Y3Rpb25zLicpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUHJvdmlkZXIoc3RvcmVLZXkpIHtcbiAgdmFyIF9Qcm92aWRlciRjaGlsZENvbnRleDtcblxuICBpZiAoc3RvcmVLZXkgPT09IHZvaWQgMCkge1xuICAgIHN0b3JlS2V5ID0gJ3N0b3JlJztcbiAgfVxuXG4gIHZhciBzdWJzY3JpcHRpb25LZXkgPSBzdG9yZUtleSArIFwiU3Vic2NyaXB0aW9uXCI7XG5cbiAgdmFyIFByb3ZpZGVyID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICAgIF9pbmhlcml0c0xvb3NlKFByb3ZpZGVyLCBfQ29tcG9uZW50KTtcblxuICAgIHZhciBfcHJvdG8gPSBQcm92aWRlci5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uZ2V0Q2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgICAgdmFyIF9yZWY7XG5cbiAgICAgIHJldHVybiBfcmVmID0ge30sIF9yZWZbc3RvcmVLZXldID0gdGhpc1tzdG9yZUtleV0sIF9yZWZbc3Vic2NyaXB0aW9uS2V5XSA9IG51bGwsIF9yZWY7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIFByb3ZpZGVyKHByb3BzLCBjb250ZXh0KSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIF90aGlzID0gX0NvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgX3RoaXNbc3RvcmVLZXldID0gcHJvcHMuc3RvcmU7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHJldHVybiBDaGlsZHJlbi5vbmx5KHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICAgIH07XG5cbiAgICByZXR1cm4gUHJvdmlkZXI7XG4gIH0oQ29tcG9uZW50KTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIFByb3ZpZGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gKG5leHRQcm9wcykge1xuICAgICAgaWYgKHRoaXNbc3RvcmVLZXldICE9PSBuZXh0UHJvcHMuc3RvcmUpIHtcbiAgICAgICAgd2FybkFib3V0UmVjZWl2aW5nU3RvcmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgUHJvdmlkZXIucHJvcFR5cGVzID0ge1xuICAgIHN0b3JlOiBzdG9yZVNoYXBlLmlzUmVxdWlyZWQsXG4gICAgY2hpbGRyZW46IFByb3BUeXBlcy5lbGVtZW50LmlzUmVxdWlyZWRcbiAgfTtcbiAgUHJvdmlkZXIuY2hpbGRDb250ZXh0VHlwZXMgPSAoX1Byb3ZpZGVyJGNoaWxkQ29udGV4ID0ge30sIF9Qcm92aWRlciRjaGlsZENvbnRleFtzdG9yZUtleV0gPSBzdG9yZVNoYXBlLmlzUmVxdWlyZWQsIF9Qcm92aWRlciRjaGlsZENvbnRleFtzdWJzY3JpcHRpb25LZXldID0gc3Vic2NyaXB0aW9uU2hhcGUsIF9Qcm92aWRlciRjaGlsZENvbnRleCk7XG4gIHJldHVybiBQcm92aWRlcjtcbn1cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVByb3ZpZGVyKCk7IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufSIsIi8vIGVuY2Fwc3VsYXRlcyB0aGUgc3Vic2NyaXB0aW9uIGxvZ2ljIGZvciBjb25uZWN0aW5nIGEgY29tcG9uZW50IHRvIHRoZSByZWR1eCBzdG9yZSwgYXNcbi8vIHdlbGwgYXMgbmVzdGluZyBzdWJzY3JpcHRpb25zIG9mIGRlc2NlbmRhbnQgY29tcG9uZW50cywgc28gdGhhdCB3ZSBjYW4gZW5zdXJlIHRoZVxuLy8gYW5jZXN0b3IgY29tcG9uZW50cyByZS1yZW5kZXIgYmVmb3JlIGRlc2NlbmRhbnRzXG52YXIgQ0xFQVJFRCA9IG51bGw7XG52YXIgbnVsbExpc3RlbmVycyA9IHtcbiAgbm90aWZ5OiBmdW5jdGlvbiBub3RpZnkoKSB7fVxufTtcblxuZnVuY3Rpb24gY3JlYXRlTGlzdGVuZXJDb2xsZWN0aW9uKCkge1xuICAvLyB0aGUgY3VycmVudC9uZXh0IHBhdHRlcm4gaXMgY29waWVkIGZyb20gcmVkdXgncyBjcmVhdGVTdG9yZSBjb2RlLlxuICAvLyBUT0RPOiByZWZhY3RvcitleHBvc2UgdGhhdCBjb2RlIHRvIGJlIHJldXNhYmxlIGhlcmU/XG4gIHZhciBjdXJyZW50ID0gW107XG4gIHZhciBuZXh0ID0gW107XG4gIHJldHVybiB7XG4gICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgbmV4dCA9IENMRUFSRUQ7XG4gICAgICBjdXJyZW50ID0gQ0xFQVJFRDtcbiAgICB9LFxuICAgIG5vdGlmeTogZnVuY3Rpb24gbm90aWZ5KCkge1xuICAgICAgdmFyIGxpc3RlbmVycyA9IGN1cnJlbnQgPSBuZXh0O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsaXN0ZW5lcnNbaV0oKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfSxcbiAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgICAgdmFyIGlzU3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICBpZiAobmV4dCA9PT0gY3VycmVudCkgbmV4dCA9IGN1cnJlbnQuc2xpY2UoKTtcbiAgICAgIG5leHQucHVzaChsaXN0ZW5lcik7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgIGlmICghaXNTdWJzY3JpYmVkIHx8IGN1cnJlbnQgPT09IENMRUFSRUQpIHJldHVybjtcbiAgICAgICAgaXNTdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICAgIGlmIChuZXh0ID09PSBjdXJyZW50KSBuZXh0ID0gY3VycmVudC5zbGljZSgpO1xuICAgICAgICBuZXh0LnNwbGljZShuZXh0LmluZGV4T2YobGlzdGVuZXIpLCAxKTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuXG52YXIgU3Vic2NyaXB0aW9uID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3Vic2NyaXB0aW9uKHN0b3JlLCBwYXJlbnRTdWIsIG9uU3RhdGVDaGFuZ2UpIHtcbiAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgdGhpcy5wYXJlbnRTdWIgPSBwYXJlbnRTdWI7XG4gICAgdGhpcy5vblN0YXRlQ2hhbmdlID0gb25TdGF0ZUNoYW5nZTtcbiAgICB0aGlzLnVuc3Vic2NyaWJlID0gbnVsbDtcbiAgICB0aGlzLmxpc3RlbmVycyA9IG51bGxMaXN0ZW5lcnM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU3Vic2NyaXB0aW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8uYWRkTmVzdGVkU3ViID0gZnVuY3Rpb24gYWRkTmVzdGVkU3ViKGxpc3RlbmVyKSB7XG4gICAgdGhpcy50cnlTdWJzY3JpYmUoKTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lcnMuc3Vic2NyaWJlKGxpc3RlbmVyKTtcbiAgfTtcblxuICBfcHJvdG8ubm90aWZ5TmVzdGVkU3VicyA9IGZ1bmN0aW9uIG5vdGlmeU5lc3RlZFN1YnMoKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMubm90aWZ5KCk7XG4gIH07XG5cbiAgX3Byb3RvLmlzU3Vic2NyaWJlZCA9IGZ1bmN0aW9uIGlzU3Vic2NyaWJlZCgpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLnVuc3Vic2NyaWJlKTtcbiAgfTtcblxuICBfcHJvdG8udHJ5U3Vic2NyaWJlID0gZnVuY3Rpb24gdHJ5U3Vic2NyaWJlKCkge1xuICAgIGlmICghdGhpcy51bnN1YnNjcmliZSkge1xuICAgICAgdGhpcy51bnN1YnNjcmliZSA9IHRoaXMucGFyZW50U3ViID8gdGhpcy5wYXJlbnRTdWIuYWRkTmVzdGVkU3ViKHRoaXMub25TdGF0ZUNoYW5nZSkgOiB0aGlzLnN0b3JlLnN1YnNjcmliZSh0aGlzLm9uU3RhdGVDaGFuZ2UpO1xuICAgICAgdGhpcy5saXN0ZW5lcnMgPSBjcmVhdGVMaXN0ZW5lckNvbGxlY3Rpb24oKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnRyeVVuc3Vic2NyaWJlID0gZnVuY3Rpb24gdHJ5VW5zdWJzY3JpYmUoKSB7XG4gICAgaWYgKHRoaXMudW5zdWJzY3JpYmUpIHtcbiAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgIHRoaXMudW5zdWJzY3JpYmUgPSBudWxsO1xuICAgICAgdGhpcy5saXN0ZW5lcnMuY2xlYXIoKTtcbiAgICAgIHRoaXMubGlzdGVuZXJzID0gbnVsbExpc3RlbmVycztcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFN1YnNjcmlwdGlvbjtcbn0oKTtcblxuZXhwb3J0IHsgU3Vic2NyaXB0aW9uIGFzIGRlZmF1bHQgfTsiLCJpbXBvcnQgX2luaGVyaXRzTG9vc2UgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzTG9vc2VcIjtcbmltcG9ydCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIjtcbmltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlXCI7XG5pbXBvcnQgaG9pc3RTdGF0aWNzIGZyb20gJ2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcbmltcG9ydCB7IENvbXBvbmVudCwgY3JlYXRlRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGlzVmFsaWRFbGVtZW50VHlwZSB9IGZyb20gJ3JlYWN0LWlzJztcbmltcG9ydCBTdWJzY3JpcHRpb24gZnJvbSAnLi4vdXRpbHMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IHN0b3JlU2hhcGUsIHN1YnNjcmlwdGlvblNoYXBlIH0gZnJvbSAnLi4vdXRpbHMvUHJvcFR5cGVzJztcbnZhciBob3RSZWxvYWRpbmdWZXJzaW9uID0gMDtcbnZhciBkdW1teVN0YXRlID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5mdW5jdGlvbiBtYWtlU2VsZWN0b3JTdGF0ZWZ1bChzb3VyY2VTZWxlY3Rvciwgc3RvcmUpIHtcbiAgLy8gd3JhcCB0aGUgc2VsZWN0b3IgaW4gYW4gb2JqZWN0IHRoYXQgdHJhY2tzIGl0cyByZXN1bHRzIGJldHdlZW4gcnVucy5cbiAgdmFyIHNlbGVjdG9yID0ge1xuICAgIHJ1bjogZnVuY3Rpb24gcnVuQ29tcG9uZW50U2VsZWN0b3IocHJvcHMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBuZXh0UHJvcHMgPSBzb3VyY2VTZWxlY3RvcihzdG9yZS5nZXRTdGF0ZSgpLCBwcm9wcyk7XG5cbiAgICAgICAgaWYgKG5leHRQcm9wcyAhPT0gc2VsZWN0b3IucHJvcHMgfHwgc2VsZWN0b3IuZXJyb3IpIHtcbiAgICAgICAgICBzZWxlY3Rvci5zaG91bGRDb21wb25lbnRVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgIHNlbGVjdG9yLnByb3BzID0gbmV4dFByb3BzO1xuICAgICAgICAgIHNlbGVjdG9yLmVycm9yID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgc2VsZWN0b3Iuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgc2VsZWN0b3IuZXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29ubmVjdEFkdmFuY2VkKFxuLypcbiAgc2VsZWN0b3JGYWN0b3J5IGlzIGEgZnVuYyB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciByZXR1cm5pbmcgdGhlIHNlbGVjdG9yIGZ1bmN0aW9uIHVzZWQgdG9cbiAgY29tcHV0ZSBuZXcgcHJvcHMgZnJvbSBzdGF0ZSwgcHJvcHMsIGFuZCBkaXNwYXRjaC4gRm9yIGV4YW1wbGU6XG4gICAgIGV4cG9ydCBkZWZhdWx0IGNvbm5lY3RBZHZhbmNlZCgoZGlzcGF0Y2gsIG9wdGlvbnMpID0+IChzdGF0ZSwgcHJvcHMpID0+ICh7XG4gICAgICB0aGluZzogc3RhdGUudGhpbmdzW3Byb3BzLnRoaW5nSWRdLFxuICAgICAgc2F2ZVRoaW5nOiBmaWVsZHMgPT4gZGlzcGF0Y2goYWN0aW9uQ3JlYXRvcnMuc2F2ZVRoaW5nKHByb3BzLnRoaW5nSWQsIGZpZWxkcykpLFxuICAgIH0pKShZb3VyQ29tcG9uZW50KVxuICAgQWNjZXNzIHRvIGRpc3BhdGNoIGlzIHByb3ZpZGVkIHRvIHRoZSBmYWN0b3J5IHNvIHNlbGVjdG9yRmFjdG9yaWVzIGNhbiBiaW5kIGFjdGlvbkNyZWF0b3JzXG4gIG91dHNpZGUgb2YgdGhlaXIgc2VsZWN0b3IgYXMgYW4gb3B0aW1pemF0aW9uLiBPcHRpb25zIHBhc3NlZCB0byBjb25uZWN0QWR2YW5jZWQgYXJlIHBhc3NlZCB0b1xuICB0aGUgc2VsZWN0b3JGYWN0b3J5LCBhbG9uZyB3aXRoIGRpc3BsYXlOYW1lIGFuZCBXcmFwcGVkQ29tcG9uZW50LCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuICAgTm90ZSB0aGF0IHNlbGVjdG9yRmFjdG9yeSBpcyByZXNwb25zaWJsZSBmb3IgYWxsIGNhY2hpbmcvbWVtb2l6YXRpb24gb2YgaW5ib3VuZCBhbmQgb3V0Ym91bmRcbiAgcHJvcHMuIERvIG5vdCB1c2UgY29ubmVjdEFkdmFuY2VkIGRpcmVjdGx5IHdpdGhvdXQgbWVtb2l6aW5nIHJlc3VsdHMgYmV0d2VlbiBjYWxscyB0byB5b3VyXG4gIHNlbGVjdG9yLCBvdGhlcndpc2UgdGhlIENvbm5lY3QgY29tcG9uZW50IHdpbGwgcmUtcmVuZGVyIG9uIGV2ZXJ5IHN0YXRlIG9yIHByb3BzIGNoYW5nZS5cbiovXG5zZWxlY3RvckZhY3RvcnksIC8vIG9wdGlvbnMgb2JqZWN0OlxuX3JlZikge1xuICB2YXIgX2NvbnRleHRUeXBlcywgX2NoaWxkQ29udGV4dFR5cGVzO1xuXG4gIGlmIChfcmVmID09PSB2b2lkIDApIHtcbiAgICBfcmVmID0ge307XG4gIH1cblxuICB2YXIgX3JlZjIgPSBfcmVmLFxuICAgICAgX3JlZjIkZ2V0RGlzcGxheU5hbWUgPSBfcmVmMi5nZXREaXNwbGF5TmFtZSxcbiAgICAgIGdldERpc3BsYXlOYW1lID0gX3JlZjIkZ2V0RGlzcGxheU5hbWUgPT09IHZvaWQgMCA/IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIFwiQ29ubmVjdEFkdmFuY2VkKFwiICsgbmFtZSArIFwiKVwiO1xuICB9IDogX3JlZjIkZ2V0RGlzcGxheU5hbWUsXG4gICAgICBfcmVmMiRtZXRob2ROYW1lID0gX3JlZjIubWV0aG9kTmFtZSxcbiAgICAgIG1ldGhvZE5hbWUgPSBfcmVmMiRtZXRob2ROYW1lID09PSB2b2lkIDAgPyAnY29ubmVjdEFkdmFuY2VkJyA6IF9yZWYyJG1ldGhvZE5hbWUsXG4gICAgICBfcmVmMiRyZW5kZXJDb3VudFByb3AgPSBfcmVmMi5yZW5kZXJDb3VudFByb3AsXG4gICAgICByZW5kZXJDb3VudFByb3AgPSBfcmVmMiRyZW5kZXJDb3VudFByb3AgPT09IHZvaWQgMCA/IHVuZGVmaW5lZCA6IF9yZWYyJHJlbmRlckNvdW50UHJvcCxcbiAgICAgIF9yZWYyJHNob3VsZEhhbmRsZVN0YSA9IF9yZWYyLnNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcyxcbiAgICAgIHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcyA9IF9yZWYyJHNob3VsZEhhbmRsZVN0YSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYyJHNob3VsZEhhbmRsZVN0YSxcbiAgICAgIF9yZWYyJHN0b3JlS2V5ID0gX3JlZjIuc3RvcmVLZXksXG4gICAgICBzdG9yZUtleSA9IF9yZWYyJHN0b3JlS2V5ID09PSB2b2lkIDAgPyAnc3RvcmUnIDogX3JlZjIkc3RvcmVLZXksXG4gICAgICBfcmVmMiR3aXRoUmVmID0gX3JlZjIud2l0aFJlZixcbiAgICAgIHdpdGhSZWYgPSBfcmVmMiR3aXRoUmVmID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYyJHdpdGhSZWYsXG4gICAgICBjb25uZWN0T3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYyLCBbXCJnZXREaXNwbGF5TmFtZVwiLCBcIm1ldGhvZE5hbWVcIiwgXCJyZW5kZXJDb3VudFByb3BcIiwgXCJzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXNcIiwgXCJzdG9yZUtleVwiLCBcIndpdGhSZWZcIl0pO1xuXG4gIHZhciBzdWJzY3JpcHRpb25LZXkgPSBzdG9yZUtleSArICdTdWJzY3JpcHRpb24nO1xuICB2YXIgdmVyc2lvbiA9IGhvdFJlbG9hZGluZ1ZlcnNpb24rKztcbiAgdmFyIGNvbnRleHRUeXBlcyA9IChfY29udGV4dFR5cGVzID0ge30sIF9jb250ZXh0VHlwZXNbc3RvcmVLZXldID0gc3RvcmVTaGFwZSwgX2NvbnRleHRUeXBlc1tzdWJzY3JpcHRpb25LZXldID0gc3Vic2NyaXB0aW9uU2hhcGUsIF9jb250ZXh0VHlwZXMpO1xuICB2YXIgY2hpbGRDb250ZXh0VHlwZXMgPSAoX2NoaWxkQ29udGV4dFR5cGVzID0ge30sIF9jaGlsZENvbnRleHRUeXBlc1tzdWJzY3JpcHRpb25LZXldID0gc3Vic2NyaXB0aW9uU2hhcGUsIF9jaGlsZENvbnRleHRUeXBlcyk7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwV2l0aENvbm5lY3QoV3JhcHBlZENvbXBvbmVudCkge1xuICAgIGludmFyaWFudChpc1ZhbGlkRWxlbWVudFR5cGUoV3JhcHBlZENvbXBvbmVudCksIFwiWW91IG11c3QgcGFzcyBhIGNvbXBvbmVudCB0byB0aGUgZnVuY3Rpb24gcmV0dXJuZWQgYnkgXCIgKyAobWV0aG9kTmFtZSArIFwiLiBJbnN0ZWFkIHJlY2VpdmVkIFwiICsgSlNPTi5zdHJpbmdpZnkoV3JhcHBlZENvbXBvbmVudCkpKTtcbiAgICB2YXIgd3JhcHBlZENvbXBvbmVudE5hbWUgPSBXcmFwcGVkQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IFdyYXBwZWRDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JztcbiAgICB2YXIgZGlzcGxheU5hbWUgPSBnZXREaXNwbGF5TmFtZSh3cmFwcGVkQ29tcG9uZW50TmFtZSk7XG5cbiAgICB2YXIgc2VsZWN0b3JGYWN0b3J5T3B0aW9ucyA9IF9leHRlbmRzKHt9LCBjb25uZWN0T3B0aW9ucywge1xuICAgICAgZ2V0RGlzcGxheU5hbWU6IGdldERpc3BsYXlOYW1lLFxuICAgICAgbWV0aG9kTmFtZTogbWV0aG9kTmFtZSxcbiAgICAgIHJlbmRlckNvdW50UHJvcDogcmVuZGVyQ291bnRQcm9wLFxuICAgICAgc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzOiBzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMsXG4gICAgICBzdG9yZUtleTogc3RvcmVLZXksXG4gICAgICB3aXRoUmVmOiB3aXRoUmVmLFxuICAgICAgZGlzcGxheU5hbWU6IGRpc3BsYXlOYW1lLFxuICAgICAgd3JhcHBlZENvbXBvbmVudE5hbWU6IHdyYXBwZWRDb21wb25lbnROYW1lLFxuICAgICAgV3JhcHBlZENvbXBvbmVudDogV3JhcHBlZENvbXBvbmVudCAvLyBUT0RPIEFjdHVhbGx5IGZpeCBvdXIgdXNlIG9mIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcblxuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3Qvbm8tZGVwcmVjYXRlZCAqL1xuXG4gICAgfSk7XG5cbiAgICB2YXIgQ29ubmVjdCA9XG4gICAgLyojX19QVVJFX18qL1xuICAgIGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gICAgICBfaW5oZXJpdHNMb29zZShDb25uZWN0LCBfQ29tcG9uZW50KTtcblxuICAgICAgZnVuY3Rpb24gQ29ubmVjdChwcm9wcywgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXM7XG5cbiAgICAgICAgX3RoaXMgPSBfQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHt9O1xuICAgICAgICBfdGhpcy5yZW5kZXJDb3VudCA9IDA7XG4gICAgICAgIF90aGlzLnN0b3JlID0gcHJvcHNbc3RvcmVLZXldIHx8IGNvbnRleHRbc3RvcmVLZXldO1xuICAgICAgICBfdGhpcy5wcm9wc01vZGUgPSBCb29sZWFuKHByb3BzW3N0b3JlS2V5XSk7XG4gICAgICAgIF90aGlzLnNldFdyYXBwZWRJbnN0YW5jZSA9IF90aGlzLnNldFdyYXBwZWRJbnN0YW5jZS5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpKTtcbiAgICAgICAgaW52YXJpYW50KF90aGlzLnN0b3JlLCBcIkNvdWxkIG5vdCBmaW5kIFxcXCJcIiArIHN0b3JlS2V5ICsgXCJcXFwiIGluIGVpdGhlciB0aGUgY29udGV4dCBvciBwcm9wcyBvZiBcIiArIChcIlxcXCJcIiArIGRpc3BsYXlOYW1lICsgXCJcXFwiLiBFaXRoZXIgd3JhcCB0aGUgcm9vdCBjb21wb25lbnQgaW4gYSA8UHJvdmlkZXI+LCBcIikgKyAoXCJvciBleHBsaWNpdGx5IHBhc3MgXFxcIlwiICsgc3RvcmVLZXkgKyBcIlxcXCIgYXMgYSBwcm9wIHRvIFxcXCJcIiArIGRpc3BsYXlOYW1lICsgXCJcXFwiLlwiKSk7XG5cbiAgICAgICAgX3RoaXMuaW5pdFNlbGVjdG9yKCk7XG5cbiAgICAgICAgX3RoaXMuaW5pdFN1YnNjcmlwdGlvbigpO1xuXG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIF9wcm90byA9IENvbm5lY3QucHJvdG90eXBlO1xuXG4gICAgICBfcHJvdG8uZ2V0Q2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgICAgICB2YXIgX3JlZjM7XG5cbiAgICAgICAgLy8gSWYgdGhpcyBjb21wb25lbnQgcmVjZWl2ZWQgc3RvcmUgZnJvbSBwcm9wcywgaXRzIHN1YnNjcmlwdGlvbiBzaG91bGQgYmUgdHJhbnNwYXJlbnRcbiAgICAgICAgLy8gdG8gYW55IGRlc2NlbmRhbnRzIHJlY2VpdmluZyBzdG9yZStzdWJzY3JpcHRpb24gZnJvbSBjb250ZXh0OyBpdCBwYXNzZXMgYWxvbmdcbiAgICAgICAgLy8gc3Vic2NyaXB0aW9uIHBhc3NlZCB0byBpdC4gT3RoZXJ3aXNlLCBpdCBzaGFkb3dzIHRoZSBwYXJlbnQgc3Vic2NyaXB0aW9uLCB3aGljaCBhbGxvd3NcbiAgICAgICAgLy8gQ29ubmVjdCB0byBjb250cm9sIG9yZGVyaW5nIG9mIG5vdGlmaWNhdGlvbnMgdG8gZmxvdyB0b3AtZG93bi5cbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMucHJvcHNNb2RlID8gbnVsbCA6IHRoaXMuc3Vic2NyaXB0aW9uO1xuICAgICAgICByZXR1cm4gX3JlZjMgPSB7fSwgX3JlZjNbc3Vic2NyaXB0aW9uS2V5XSA9IHN1YnNjcmlwdGlvbiB8fCB0aGlzLmNvbnRleHRbc3Vic2NyaXB0aW9uS2V5XSwgX3JlZjM7XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgaWYgKCFzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMpIHJldHVybjsgLy8gY29tcG9uZW50V2lsbE1vdW50IGZpcmVzIGR1cmluZyBzZXJ2ZXIgc2lkZSByZW5kZXJpbmcsIGJ1dCBjb21wb25lbnREaWRNb3VudCBhbmRcbiAgICAgICAgLy8gY29tcG9uZW50V2lsbFVubW91bnQgZG8gbm90LiBCZWNhdXNlIG9mIHRoaXMsIHRyeVN1YnNjcmliZSBoYXBwZW5zIGR1cmluZyAuLi5kaWRNb3VudC5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB1bnN1YnNjcmlwdGlvbiB3b3VsZCBuZXZlciB0YWtlIHBsYWNlIGR1cmluZyBTU1IsIGNhdXNpbmcgYSBtZW1vcnkgbGVhay5cbiAgICAgICAgLy8gVG8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIGEgY2hpbGQgY29tcG9uZW50IG1heSBoYXZlIHRyaWdnZXJlZCBhIHN0YXRlIGNoYW5nZSBieVxuICAgICAgICAvLyBkaXNwYXRjaGluZyBhbiBhY3Rpb24gaW4gaXRzIGNvbXBvbmVudFdpbGxNb3VudCwgd2UgaGF2ZSB0byByZS1ydW4gdGhlIHNlbGVjdCBhbmQgbWF5YmVcbiAgICAgICAgLy8gcmUtcmVuZGVyLlxuXG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnRyeVN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLnNlbGVjdG9yLnJ1bih0aGlzLnByb3BzKTtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0b3Iuc2hvdWxkQ29tcG9uZW50VXBkYXRlKSB0aGlzLmZvcmNlVXBkYXRlKCk7XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8uY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IucnVuKG5leHRQcm9wcyk7XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8uc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rvci5zaG91bGRDb21wb25lbnRVcGRhdGU7XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8uY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uKSB0aGlzLnN1YnNjcmlwdGlvbi50cnlVbnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMubm90aWZ5TmVzdGVkU3VicyA9IG5vb3A7XG4gICAgICAgIHRoaXMuc3RvcmUgPSBudWxsO1xuICAgICAgICB0aGlzLnNlbGVjdG9yLnJ1biA9IG5vb3A7XG4gICAgICAgIHRoaXMuc2VsZWN0b3Iuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZmFsc2U7XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8uZ2V0V3JhcHBlZEluc3RhbmNlID0gZnVuY3Rpb24gZ2V0V3JhcHBlZEluc3RhbmNlKCkge1xuICAgICAgICBpbnZhcmlhbnQod2l0aFJlZiwgXCJUbyBhY2Nlc3MgdGhlIHdyYXBwZWQgaW5zdGFuY2UsIHlvdSBuZWVkIHRvIHNwZWNpZnkgXCIgKyAoXCJ7IHdpdGhSZWY6IHRydWUgfSBpbiB0aGUgb3B0aW9ucyBhcmd1bWVudCBvZiB0aGUgXCIgKyBtZXRob2ROYW1lICsgXCIoKSBjYWxsLlwiKSk7XG4gICAgICAgIHJldHVybiB0aGlzLndyYXBwZWRJbnN0YW5jZTtcbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5zZXRXcmFwcGVkSW5zdGFuY2UgPSBmdW5jdGlvbiBzZXRXcmFwcGVkSW5zdGFuY2UocmVmKSB7XG4gICAgICAgIHRoaXMud3JhcHBlZEluc3RhbmNlID0gcmVmO1xuICAgICAgfTtcblxuICAgICAgX3Byb3RvLmluaXRTZWxlY3RvciA9IGZ1bmN0aW9uIGluaXRTZWxlY3RvcigpIHtcbiAgICAgICAgdmFyIHNvdXJjZVNlbGVjdG9yID0gc2VsZWN0b3JGYWN0b3J5KHRoaXMuc3RvcmUuZGlzcGF0Y2gsIHNlbGVjdG9yRmFjdG9yeU9wdGlvbnMpO1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gbWFrZVNlbGVjdG9yU3RhdGVmdWwoc291cmNlU2VsZWN0b3IsIHRoaXMuc3RvcmUpO1xuICAgICAgICB0aGlzLnNlbGVjdG9yLnJ1bih0aGlzLnByb3BzKTtcbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5pbml0U3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gaW5pdFN1YnNjcmlwdGlvbigpIHtcbiAgICAgICAgaWYgKCFzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMpIHJldHVybjsgLy8gcGFyZW50U3ViJ3Mgc291cmNlIHNob3VsZCBtYXRjaCB3aGVyZSBzdG9yZSBjYW1lIGZyb206IHByb3BzIHZzLiBjb250ZXh0LiBBIGNvbXBvbmVudFxuICAgICAgICAvLyBjb25uZWN0ZWQgdG8gdGhlIHN0b3JlIHZpYSBwcm9wcyBzaG91bGRuJ3QgdXNlIHN1YnNjcmlwdGlvbiBmcm9tIGNvbnRleHQsIG9yIHZpY2UgdmVyc2EuXG5cbiAgICAgICAgdmFyIHBhcmVudFN1YiA9ICh0aGlzLnByb3BzTW9kZSA/IHRoaXMucHJvcHMgOiB0aGlzLmNvbnRleHQpW3N1YnNjcmlwdGlvbktleV07XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbih0aGlzLnN0b3JlLCBwYXJlbnRTdWIsIHRoaXMub25TdGF0ZUNoYW5nZS5iaW5kKHRoaXMpKTsgLy8gYG5vdGlmeU5lc3RlZFN1YnNgIGlzIGR1cGxpY2F0ZWQgdG8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRoZSBjb21wb25lbnQgaXMgdW5tb3VudGVkIGluXG4gICAgICAgIC8vIHRoZSBtaWRkbGUgb2YgdGhlIG5vdGlmaWNhdGlvbiBsb29wLCB3aGVyZSBgdGhpcy5zdWJzY3JpcHRpb25gIHdpbGwgdGhlbiBiZSBudWxsLiBBblxuICAgICAgICAvLyBleHRyYSBudWxsIGNoZWNrIGV2ZXJ5IGNoYW5nZSBjYW4gYmUgYXZvaWRlZCBieSBjb3B5aW5nIHRoZSBtZXRob2Qgb250byBgdGhpc2AgYW5kIHRoZW5cbiAgICAgICAgLy8gcmVwbGFjaW5nIGl0IHdpdGggYSBuby1vcCBvbiB1bm1vdW50LiBUaGlzIGNhbiBwcm9iYWJseSBiZSBhdm9pZGVkIGlmIFN1YnNjcmlwdGlvbidzXG4gICAgICAgIC8vIGxpc3RlbmVycyBsb2dpYyBpcyBjaGFuZ2VkIHRvIG5vdCBjYWxsIGxpc3RlbmVycyB0aGF0IGhhdmUgYmVlbiB1bnN1YnNjcmliZWQgaW4gdGhlXG4gICAgICAgIC8vIG1pZGRsZSBvZiB0aGUgbm90aWZpY2F0aW9uIGxvb3AuXG5cbiAgICAgICAgdGhpcy5ub3RpZnlOZXN0ZWRTdWJzID0gdGhpcy5zdWJzY3JpcHRpb24ubm90aWZ5TmVzdGVkU3Vicy5iaW5kKHRoaXMuc3Vic2NyaXB0aW9uKTtcbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5vblN0YXRlQ2hhbmdlID0gZnVuY3Rpb24gb25TdGF0ZUNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rvci5ydW4odGhpcy5wcm9wcyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdG9yLnNob3VsZENvbXBvbmVudFVwZGF0ZSkge1xuICAgICAgICAgIHRoaXMubm90aWZ5TmVzdGVkU3VicygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY29tcG9uZW50RGlkVXBkYXRlID0gdGhpcy5ub3RpZnlOZXN0ZWRTdWJzT25Db21wb25lbnREaWRVcGRhdGU7XG4gICAgICAgICAgdGhpcy5zZXRTdGF0ZShkdW1teVN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgX3Byb3RvLm5vdGlmeU5lc3RlZFN1YnNPbkNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIG5vdGlmeU5lc3RlZFN1YnNPbkNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgLy8gYGNvbXBvbmVudERpZFVwZGF0ZWAgaXMgY29uZGl0aW9uYWxseSBpbXBsZW1lbnRlZCB3aGVuIGBvblN0YXRlQ2hhbmdlYCBkZXRlcm1pbmVzIGl0XG4gICAgICAgIC8vIG5lZWRzIHRvIG5vdGlmeSBuZXN0ZWQgc3Vicy4gT25jZSBjYWxsZWQsIGl0IHVuaW1wbGVtZW50cyBpdHNlbGYgdW50aWwgZnVydGhlciBzdGF0ZVxuICAgICAgICAvLyBjaGFuZ2VzIG9jY3VyLiBEb2luZyBpdCB0aGlzIHdheSB2cyBoYXZpbmcgYSBwZXJtYW5lbnQgYGNvbXBvbmVudERpZFVwZGF0ZWAgdGhhdCBkb2VzXG4gICAgICAgIC8vIGEgYm9vbGVhbiBjaGVjayBldmVyeSB0aW1lIGF2b2lkcyBhbiBleHRyYSBtZXRob2QgY2FsbCBtb3N0IG9mIHRoZSB0aW1lLCByZXN1bHRpbmdcbiAgICAgICAgLy8gaW4gc29tZSBwZXJmIGJvb3N0LlxuICAgICAgICB0aGlzLmNvbXBvbmVudERpZFVwZGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5ub3RpZnlOZXN0ZWRTdWJzKCk7XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8uaXNTdWJzY3JpYmVkID0gZnVuY3Rpb24gaXNTdWJzY3JpYmVkKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLnN1YnNjcmlwdGlvbikgJiYgdGhpcy5zdWJzY3JpcHRpb24uaXNTdWJzY3JpYmVkKCk7XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8uYWRkRXh0cmFQcm9wcyA9IGZ1bmN0aW9uIGFkZEV4dHJhUHJvcHMocHJvcHMpIHtcbiAgICAgICAgaWYgKCF3aXRoUmVmICYmICFyZW5kZXJDb3VudFByb3AgJiYgISh0aGlzLnByb3BzTW9kZSAmJiB0aGlzLnN1YnNjcmlwdGlvbikpIHJldHVybiBwcm9wczsgLy8gbWFrZSBhIHNoYWxsb3cgY29weSBzbyB0aGF0IGZpZWxkcyBhZGRlZCBkb24ndCBsZWFrIHRvIHRoZSBvcmlnaW5hbCBzZWxlY3Rvci5cbiAgICAgICAgLy8gdGhpcyBpcyBlc3BlY2lhbGx5IGltcG9ydGFudCBmb3IgJ3JlZicgc2luY2UgdGhhdCdzIGEgcmVmZXJlbmNlIGJhY2sgdG8gdGhlIGNvbXBvbmVudFxuICAgICAgICAvLyBpbnN0YW5jZS4gYSBzaW5nbGV0b24gbWVtb2l6ZWQgc2VsZWN0b3Igd291bGQgdGhlbiBiZSBob2xkaW5nIGEgcmVmZXJlbmNlIHRvIHRoZVxuICAgICAgICAvLyBpbnN0YW5jZSwgcHJldmVudGluZyB0aGUgaW5zdGFuY2UgZnJvbSBiZWluZyBnYXJiYWdlIGNvbGxlY3RlZCwgYW5kIHRoYXQgd291bGQgYmUgYmFkXG5cbiAgICAgICAgdmFyIHdpdGhFeHRyYXMgPSBfZXh0ZW5kcyh7fSwgcHJvcHMpO1xuXG4gICAgICAgIGlmICh3aXRoUmVmKSB3aXRoRXh0cmFzLnJlZiA9IHRoaXMuc2V0V3JhcHBlZEluc3RhbmNlO1xuICAgICAgICBpZiAocmVuZGVyQ291bnRQcm9wKSB3aXRoRXh0cmFzW3JlbmRlckNvdW50UHJvcF0gPSB0aGlzLnJlbmRlckNvdW50Kys7XG4gICAgICAgIGlmICh0aGlzLnByb3BzTW9kZSAmJiB0aGlzLnN1YnNjcmlwdGlvbikgd2l0aEV4dHJhc1tzdWJzY3JpcHRpb25LZXldID0gdGhpcy5zdWJzY3JpcHRpb247XG4gICAgICAgIHJldHVybiB3aXRoRXh0cmFzO1xuICAgICAgfTtcblxuICAgICAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gdGhpcy5zZWxlY3RvcjtcbiAgICAgICAgc2VsZWN0b3Iuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHNlbGVjdG9yLmVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgc2VsZWN0b3IuZXJyb3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoV3JhcHBlZENvbXBvbmVudCwgdGhpcy5hZGRFeHRyYVByb3BzKHNlbGVjdG9yLnByb3BzKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBDb25uZWN0O1xuICAgIH0oQ29tcG9uZW50KTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0L25vLWRlcHJlY2F0ZWQgKi9cblxuXG4gICAgQ29ubmVjdC5XcmFwcGVkQ29tcG9uZW50ID0gV3JhcHBlZENvbXBvbmVudDtcbiAgICBDb25uZWN0LmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gICAgQ29ubmVjdC5jaGlsZENvbnRleHRUeXBlcyA9IGNoaWxkQ29udGV4dFR5cGVzO1xuICAgIENvbm5lY3QuY29udGV4dFR5cGVzID0gY29udGV4dFR5cGVzO1xuICAgIENvbm5lY3QucHJvcFR5cGVzID0gY29udGV4dFR5cGVzO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVXBkYXRlKCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAvLyBXZSBhcmUgaG90IHJlbG9hZGluZyFcbiAgICAgICAgaWYgKHRoaXMudmVyc2lvbiAhPT0gdmVyc2lvbikge1xuICAgICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgICAgdGhpcy5pbml0U2VsZWN0b3IoKTsgLy8gSWYgYW55IGNvbm5lY3RlZCBkZXNjZW5kYW50cyBkb24ndCBob3QgcmVsb2FkIChhbmQgcmVzdWJzY3JpYmUgaW4gdGhlIHByb2Nlc3MpLCB0aGVpclxuICAgICAgICAgIC8vIGxpc3RlbmVycyB3aWxsIGJlIGxvc3Qgd2hlbiB3ZSB1bnN1YnNjcmliZS4gVW5mb3J0dW5hdGVseSwgYnkgY29weWluZyBvdmVyIGFsbFxuICAgICAgICAgIC8vIGxpc3RlbmVycywgdGhpcyBkb2VzIG1lYW4gdGhhdCB0aGUgb2xkIHZlcnNpb25zIG9mIGNvbm5lY3RlZCBkZXNjZW5kYW50cyB3aWxsIHN0aWxsIGJlXG4gICAgICAgICAgLy8gbm90aWZpZWQgb2Ygc3RhdGUgY2hhbmdlczsgaG93ZXZlciwgdGhlaXIgb25TdGF0ZUNoYW5nZSBmdW5jdGlvbiBpcyBhIG5vLW9wIHNvIHRoaXNcbiAgICAgICAgICAvLyBpc24ndCBhIGh1Z2UgZGVhbC5cblxuICAgICAgICAgIHZhciBvbGRMaXN0ZW5lcnMgPSBbXTtcblxuICAgICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgb2xkTGlzdGVuZXJzID0gdGhpcy5zdWJzY3JpcHRpb24ubGlzdGVuZXJzLmdldCgpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24udHJ5VW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmluaXRTdWJzY3JpcHRpb24oKTtcblxuICAgICAgICAgIGlmIChzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnRyeVN1YnNjcmliZSgpO1xuICAgICAgICAgICAgb2xkTGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczIuc3Vic2NyaXB0aW9uLmxpc3RlbmVycy5zdWJzY3JpYmUobGlzdGVuZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBob2lzdFN0YXRpY3MoQ29ubmVjdCwgV3JhcHBlZENvbXBvbmVudCk7XG4gIH07XG59IiwidmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgaWYgKHggPT09IHkpIHtcbiAgICByZXR1cm4geCAhPT0gMCB8fCB5ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCKSB7XG4gIGlmIChpcyhvYmpBLCBvYmpCKSkgcmV0dXJuIHRydWU7XG5cbiAgaWYgKHR5cGVvZiBvYmpBICE9PSAnb2JqZWN0JyB8fCBvYmpBID09PSBudWxsIHx8IHR5cGVvZiBvYmpCICE9PSAnb2JqZWN0JyB8fCBvYmpCID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFoYXNPd24uY2FsbChvYmpCLCBrZXlzQVtpXSkgfHwgIWlzKG9iakFba2V5c0FbaV1dLCBvYmpCW2tleXNBW2ldXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn0iLCIvKipcclxuICogQHBhcmFtIHthbnl9IG9iaiBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBhcmd1bWVudCBhcHBlYXJzIHRvIGJlIGEgcGxhaW4gb2JqZWN0LlxyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gIGlmIChwcm90byA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gIHZhciBiYXNlUHJvdG8gPSBwcm90bztcblxuICB3aGlsZSAoT2JqZWN0LmdldFByb3RvdHlwZU9mKGJhc2VQcm90bykgIT09IG51bGwpIHtcbiAgICBiYXNlUHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYmFzZVByb3RvKTtcbiAgfVxuXG4gIHJldHVybiBwcm90byA9PT0gYmFzZVByb3RvO1xufSIsImltcG9ydCBpc1BsYWluT2JqZWN0IGZyb20gJy4vaXNQbGFpbk9iamVjdCc7XG5pbXBvcnQgd2FybmluZyBmcm9tICcuL3dhcm5pbmcnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdmVyaWZ5UGxhaW5PYmplY3QodmFsdWUsIGRpc3BsYXlOYW1lLCBtZXRob2ROYW1lKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICB3YXJuaW5nKG1ldGhvZE5hbWUgKyBcIigpIGluIFwiICsgZGlzcGxheU5hbWUgKyBcIiBtdXN0IHJldHVybiBhIHBsYWluIG9iamVjdC4gSW5zdGVhZCByZWNlaXZlZCBcIiArIHZhbHVlICsgXCIuXCIpO1xuICB9XG59IiwiaW1wb3J0IHZlcmlmeVBsYWluT2JqZWN0IGZyb20gJy4uL3V0aWxzL3ZlcmlmeVBsYWluT2JqZWN0JztcbmV4cG9ydCBmdW5jdGlvbiB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KGdldENvbnN0YW50KSB7XG4gIHJldHVybiBmdW5jdGlvbiBpbml0Q29uc3RhbnRTZWxlY3RvcihkaXNwYXRjaCwgb3B0aW9ucykge1xuICAgIHZhciBjb25zdGFudCA9IGdldENvbnN0YW50KGRpc3BhdGNoLCBvcHRpb25zKTtcblxuICAgIGZ1bmN0aW9uIGNvbnN0YW50U2VsZWN0b3IoKSB7XG4gICAgICByZXR1cm4gY29uc3RhbnQ7XG4gICAgfVxuXG4gICAgY29uc3RhbnRTZWxlY3Rvci5kZXBlbmRzT25Pd25Qcm9wcyA9IGZhbHNlO1xuICAgIHJldHVybiBjb25zdGFudFNlbGVjdG9yO1xuICB9O1xufSAvLyBkZXBlbmRzT25Pd25Qcm9wcyBpcyB1c2VkIGJ5IGNyZWF0ZU1hcFRvUHJvcHNQcm94eSB0byBkZXRlcm1pbmUgd2hldGhlciB0byBwYXNzIHByb3BzIGFzIGFyZ3Ncbi8vIHRvIHRoZSBtYXBUb1Byb3BzIGZ1bmN0aW9uIGJlaW5nIHdyYXBwZWQuIEl0IGlzIGFsc28gdXNlZCBieSBtYWtlUHVyZVByb3BzU2VsZWN0b3IgdG8gZGV0ZXJtaW5lXG4vLyB3aGV0aGVyIG1hcFRvUHJvcHMgbmVlZHMgdG8gYmUgaW52b2tlZCB3aGVuIHByb3BzIGhhdmUgY2hhbmdlZC5cbi8vIFxuLy8gQSBsZW5ndGggb2Ygb25lIHNpZ25hbHMgdGhhdCBtYXBUb1Byb3BzIGRvZXMgbm90IGRlcGVuZCBvbiBwcm9wcyBmcm9tIHRoZSBwYXJlbnQgY29tcG9uZW50LlxuLy8gQSBsZW5ndGggb2YgemVybyBpcyBhc3N1bWVkIHRvIG1lYW4gbWFwVG9Qcm9wcyBpcyBnZXR0aW5nIGFyZ3MgdmlhIGFyZ3VtZW50cyBvciAuLi5hcmdzIGFuZFxuLy8gdGhlcmVmb3JlIG5vdCByZXBvcnRpbmcgaXRzIGxlbmd0aCBhY2N1cmF0ZWx5Li5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERlcGVuZHNPbk93blByb3BzKG1hcFRvUHJvcHMpIHtcbiAgcmV0dXJuIG1hcFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMgIT09IG51bGwgJiYgbWFwVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcyAhPT0gdW5kZWZpbmVkID8gQm9vbGVhbihtYXBUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzKSA6IG1hcFRvUHJvcHMubGVuZ3RoICE9PSAxO1xufSAvLyBVc2VkIGJ5IHdoZW5NYXBTdGF0ZVRvUHJvcHNJc0Z1bmN0aW9uIGFuZCB3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNGdW5jdGlvbixcbi8vIHRoaXMgZnVuY3Rpb24gd3JhcHMgbWFwVG9Qcm9wcyBpbiBhIHByb3h5IGZ1bmN0aW9uIHdoaWNoIGRvZXMgc2V2ZXJhbCB0aGluZ3M6XG4vLyBcbi8vICAqIERldGVjdHMgd2hldGhlciB0aGUgbWFwVG9Qcm9wcyBmdW5jdGlvbiBiZWluZyBjYWxsZWQgZGVwZW5kcyBvbiBwcm9wcywgd2hpY2hcbi8vICAgIGlzIHVzZWQgYnkgc2VsZWN0b3JGYWN0b3J5IHRvIGRlY2lkZSBpZiBpdCBzaG91bGQgcmVpbnZva2Ugb24gcHJvcHMgY2hhbmdlcy5cbi8vICAgIFxuLy8gICogT24gZmlyc3QgY2FsbCwgaGFuZGxlcyBtYXBUb1Byb3BzIGlmIHJldHVybnMgYW5vdGhlciBmdW5jdGlvbiwgYW5kIHRyZWF0cyB0aGF0XG4vLyAgICBuZXcgZnVuY3Rpb24gYXMgdGhlIHRydWUgbWFwVG9Qcm9wcyBmb3Igc3Vic2VxdWVudCBjYWxscy5cbi8vICAgIFxuLy8gICogT24gZmlyc3QgY2FsbCwgdmVyaWZpZXMgdGhlIGZpcnN0IHJlc3VsdCBpcyBhIHBsYWluIG9iamVjdCwgaW4gb3JkZXIgdG8gd2FyblxuLy8gICAgdGhlIGRldmVsb3BlciB0aGF0IHRoZWlyIG1hcFRvUHJvcHMgZnVuY3Rpb24gaXMgbm90IHJldHVybmluZyBhIHZhbGlkIHJlc3VsdC5cbi8vICAgIFxuXG5leHBvcnQgZnVuY3Rpb24gd3JhcE1hcFRvUHJvcHNGdW5jKG1hcFRvUHJvcHMsIG1ldGhvZE5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGluaXRQcm94eVNlbGVjdG9yKGRpc3BhdGNoLCBfcmVmKSB7XG4gICAgdmFyIGRpc3BsYXlOYW1lID0gX3JlZi5kaXNwbGF5TmFtZTtcblxuICAgIHZhciBwcm94eSA9IGZ1bmN0aW9uIG1hcFRvUHJvcHNQcm94eShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKSB7XG4gICAgICByZXR1cm4gcHJveHkuZGVwZW5kc09uT3duUHJvcHMgPyBwcm94eS5tYXBUb1Byb3BzKHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpIDogcHJveHkubWFwVG9Qcm9wcyhzdGF0ZU9yRGlzcGF0Y2gpO1xuICAgIH07IC8vIGFsbG93IGRldGVjdEZhY3RvcnlBbmRWZXJpZnkgdG8gZ2V0IG93blByb3BzXG5cblxuICAgIHByb3h5LmRlcGVuZHNPbk93blByb3BzID0gdHJ1ZTtcblxuICAgIHByb3h5Lm1hcFRvUHJvcHMgPSBmdW5jdGlvbiBkZXRlY3RGYWN0b3J5QW5kVmVyaWZ5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpIHtcbiAgICAgIHByb3h5Lm1hcFRvUHJvcHMgPSBtYXBUb1Byb3BzO1xuICAgICAgcHJveHkuZGVwZW5kc09uT3duUHJvcHMgPSBnZXREZXBlbmRzT25Pd25Qcm9wcyhtYXBUb1Byb3BzKTtcbiAgICAgIHZhciBwcm9wcyA9IHByb3h5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpO1xuXG4gICAgICBpZiAodHlwZW9mIHByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByb3h5Lm1hcFRvUHJvcHMgPSBwcm9wcztcbiAgICAgICAgcHJveHkuZGVwZW5kc09uT3duUHJvcHMgPSBnZXREZXBlbmRzT25Pd25Qcm9wcyhwcm9wcyk7XG4gICAgICAgIHByb3BzID0gcHJveHkoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB2ZXJpZnlQbGFpbk9iamVjdChwcm9wcywgZGlzcGxheU5hbWUsIG1ldGhvZE5hbWUpO1xuICAgICAgcmV0dXJuIHByb3BzO1xuICAgIH07XG5cbiAgICByZXR1cm4gcHJveHk7XG4gIH07XG59IiwiaW1wb3J0IHsgYmluZEFjdGlvbkNyZWF0b3JzIH0gZnJvbSAncmVkdXgnO1xuaW1wb3J0IHsgd3JhcE1hcFRvUHJvcHNDb25zdGFudCwgd3JhcE1hcFRvUHJvcHNGdW5jIH0gZnJvbSAnLi93cmFwTWFwVG9Qcm9wcyc7XG5leHBvcnQgZnVuY3Rpb24gd2hlbk1hcERpc3BhdGNoVG9Qcm9wc0lzRnVuY3Rpb24obWFwRGlzcGF0Y2hUb1Byb3BzKSB7XG4gIHJldHVybiB0eXBlb2YgbWFwRGlzcGF0Y2hUb1Byb3BzID09PSAnZnVuY3Rpb24nID8gd3JhcE1hcFRvUHJvcHNGdW5jKG1hcERpc3BhdGNoVG9Qcm9wcywgJ21hcERpc3BhdGNoVG9Qcm9wcycpIDogdW5kZWZpbmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdoZW5NYXBEaXNwYXRjaFRvUHJvcHNJc01pc3NpbmcobWFwRGlzcGF0Y2hUb1Byb3BzKSB7XG4gIHJldHVybiAhbWFwRGlzcGF0Y2hUb1Byb3BzID8gd3JhcE1hcFRvUHJvcHNDb25zdGFudChmdW5jdGlvbiAoZGlzcGF0Y2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGlzcGF0Y2g6IGRpc3BhdGNoXG4gICAgfTtcbiAgfSkgOiB1bmRlZmluZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gd2hlbk1hcERpc3BhdGNoVG9Qcm9wc0lzT2JqZWN0KG1hcERpc3BhdGNoVG9Qcm9wcykge1xuICByZXR1cm4gbWFwRGlzcGF0Y2hUb1Byb3BzICYmIHR5cGVvZiBtYXBEaXNwYXRjaFRvUHJvcHMgPT09ICdvYmplY3QnID8gd3JhcE1hcFRvUHJvcHNDb25zdGFudChmdW5jdGlvbiAoZGlzcGF0Y2gpIHtcbiAgICByZXR1cm4gYmluZEFjdGlvbkNyZWF0b3JzKG1hcERpc3BhdGNoVG9Qcm9wcywgZGlzcGF0Y2gpO1xuICB9KSA6IHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBkZWZhdWx0IFt3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNGdW5jdGlvbiwgd2hlbk1hcERpc3BhdGNoVG9Qcm9wc0lzTWlzc2luZywgd2hlbk1hcERpc3BhdGNoVG9Qcm9wc0lzT2JqZWN0XTsiLCJpbXBvcnQgeyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50LCB3cmFwTWFwVG9Qcm9wc0Z1bmMgfSBmcm9tICcuL3dyYXBNYXBUb1Byb3BzJztcbmV4cG9ydCBmdW5jdGlvbiB3aGVuTWFwU3RhdGVUb1Byb3BzSXNGdW5jdGlvbihtYXBTdGF0ZVRvUHJvcHMpIHtcbiAgcmV0dXJuIHR5cGVvZiBtYXBTdGF0ZVRvUHJvcHMgPT09ICdmdW5jdGlvbicgPyB3cmFwTWFwVG9Qcm9wc0Z1bmMobWFwU3RhdGVUb1Byb3BzLCAnbWFwU3RhdGVUb1Byb3BzJykgOiB1bmRlZmluZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gd2hlbk1hcFN0YXRlVG9Qcm9wc0lzTWlzc2luZyhtYXBTdGF0ZVRvUHJvcHMpIHtcbiAgcmV0dXJuICFtYXBTdGF0ZVRvUHJvcHMgPyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge307XG4gIH0pIDogdW5kZWZpbmVkO1xufVxuZXhwb3J0IGRlZmF1bHQgW3doZW5NYXBTdGF0ZVRvUHJvcHNJc0Z1bmN0aW9uLCB3aGVuTWFwU3RhdGVUb1Byb3BzSXNNaXNzaW5nXTsiLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCB2ZXJpZnlQbGFpbk9iamVjdCBmcm9tICcuLi91dGlscy92ZXJpZnlQbGFpbk9iamVjdCc7XG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdE1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpIHtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBvd25Qcm9wcywgc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcyk7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcE1lcmdlUHJvcHNGdW5jKG1lcmdlUHJvcHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGluaXRNZXJnZVByb3BzUHJveHkoZGlzcGF0Y2gsIF9yZWYpIHtcbiAgICB2YXIgZGlzcGxheU5hbWUgPSBfcmVmLmRpc3BsYXlOYW1lLFxuICAgICAgICBwdXJlID0gX3JlZi5wdXJlLFxuICAgICAgICBhcmVNZXJnZWRQcm9wc0VxdWFsID0gX3JlZi5hcmVNZXJnZWRQcm9wc0VxdWFsO1xuICAgIHZhciBoYXNSdW5PbmNlID0gZmFsc2U7XG4gICAgdmFyIG1lcmdlZFByb3BzO1xuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZVByb3BzUHJveHkoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpIHtcbiAgICAgIHZhciBuZXh0TWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcblxuICAgICAgaWYgKGhhc1J1bk9uY2UpIHtcbiAgICAgICAgaWYgKCFwdXJlIHx8ICFhcmVNZXJnZWRQcm9wc0VxdWFsKG5leHRNZXJnZWRQcm9wcywgbWVyZ2VkUHJvcHMpKSBtZXJnZWRQcm9wcyA9IG5leHRNZXJnZWRQcm9wcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhc1J1bk9uY2UgPSB0cnVlO1xuICAgICAgICBtZXJnZWRQcm9wcyA9IG5leHRNZXJnZWRQcm9wcztcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHZlcmlmeVBsYWluT2JqZWN0KG1lcmdlZFByb3BzLCBkaXNwbGF5TmFtZSwgJ21lcmdlUHJvcHMnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICAgIH07XG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gd2hlbk1lcmdlUHJvcHNJc0Z1bmN0aW9uKG1lcmdlUHJvcHMpIHtcbiAgcmV0dXJuIHR5cGVvZiBtZXJnZVByb3BzID09PSAnZnVuY3Rpb24nID8gd3JhcE1lcmdlUHJvcHNGdW5jKG1lcmdlUHJvcHMpIDogdW5kZWZpbmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdoZW5NZXJnZVByb3BzSXNPbWl0dGVkKG1lcmdlUHJvcHMpIHtcbiAgcmV0dXJuICFtZXJnZVByb3BzID8gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWVyZ2VQcm9wcztcbiAgfSA6IHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBkZWZhdWx0IFt3aGVuTWVyZ2VQcm9wc0lzRnVuY3Rpb24sIHdoZW5NZXJnZVByb3BzSXNPbWl0dGVkXTsiLCJpbXBvcnQgd2FybmluZyBmcm9tICcuLi91dGlscy93YXJuaW5nJztcblxuZnVuY3Rpb24gdmVyaWZ5KHNlbGVjdG9yLCBtZXRob2ROYW1lLCBkaXNwbGF5TmFtZSkge1xuICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCB2YWx1ZSBmb3IgXCIgKyBtZXRob2ROYW1lICsgXCIgaW4gXCIgKyBkaXNwbGF5TmFtZSArIFwiLlwiKTtcbiAgfSBlbHNlIGlmIChtZXRob2ROYW1lID09PSAnbWFwU3RhdGVUb1Byb3BzJyB8fCBtZXRob2ROYW1lID09PSAnbWFwRGlzcGF0Y2hUb1Byb3BzJykge1xuICAgIGlmICghc2VsZWN0b3IuaGFzT3duUHJvcGVydHkoJ2RlcGVuZHNPbk93blByb3BzJykpIHtcbiAgICAgIHdhcm5pbmcoXCJUaGUgc2VsZWN0b3IgZm9yIFwiICsgbWV0aG9kTmFtZSArIFwiIG9mIFwiICsgZGlzcGxheU5hbWUgKyBcIiBkaWQgbm90IHNwZWNpZnkgYSB2YWx1ZSBmb3IgZGVwZW5kc09uT3duUHJvcHMuXCIpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB2ZXJpZnlTdWJzZWxlY3RvcnMobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZlcmlmeShtYXBTdGF0ZVRvUHJvcHMsICdtYXBTdGF0ZVRvUHJvcHMnLCBkaXNwbGF5TmFtZSk7XG4gIHZlcmlmeShtYXBEaXNwYXRjaFRvUHJvcHMsICdtYXBEaXNwYXRjaFRvUHJvcHMnLCBkaXNwbGF5TmFtZSk7XG4gIHZlcmlmeShtZXJnZVByb3BzLCAnbWVyZ2VQcm9wcycsIGRpc3BsYXlOYW1lKTtcbn0iLCJpbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2VcIjtcbmltcG9ydCB2ZXJpZnlTdWJzZWxlY3RvcnMgZnJvbSAnLi92ZXJpZnlTdWJzZWxlY3RvcnMnO1xuZXhwb3J0IGZ1bmN0aW9uIGltcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BhdGNoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpbXB1cmVGaW5hbFByb3BzU2VsZWN0b3Ioc3RhdGUsIG93blByb3BzKSB7XG4gICAgcmV0dXJuIG1lcmdlUHJvcHMobWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyksIG1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3duUHJvcHMpLCBvd25Qcm9wcyk7XG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BhdGNoLCBfcmVmKSB7XG4gIHZhciBhcmVTdGF0ZXNFcXVhbCA9IF9yZWYuYXJlU3RhdGVzRXF1YWwsXG4gICAgICBhcmVPd25Qcm9wc0VxdWFsID0gX3JlZi5hcmVPd25Qcm9wc0VxdWFsLFxuICAgICAgYXJlU3RhdGVQcm9wc0VxdWFsID0gX3JlZi5hcmVTdGF0ZVByb3BzRXF1YWw7XG4gIHZhciBoYXNSdW5BdExlYXN0T25jZSA9IGZhbHNlO1xuICB2YXIgc3RhdGU7XG4gIHZhciBvd25Qcm9wcztcbiAgdmFyIHN0YXRlUHJvcHM7XG4gIHZhciBkaXNwYXRjaFByb3BzO1xuICB2YXIgbWVyZ2VkUHJvcHM7XG5cbiAgZnVuY3Rpb24gaGFuZGxlRmlyc3RDYWxsKGZpcnN0U3RhdGUsIGZpcnN0T3duUHJvcHMpIHtcbiAgICBzdGF0ZSA9IGZpcnN0U3RhdGU7XG4gICAgb3duUHJvcHMgPSBmaXJzdE93blByb3BzO1xuICAgIHN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcbiAgICBkaXNwYXRjaFByb3BzID0gbWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoLCBvd25Qcm9wcyk7XG4gICAgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICBoYXNSdW5BdExlYXN0T25jZSA9IHRydWU7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTmV3UHJvcHNBbmROZXdTdGF0ZSgpIHtcbiAgICBzdGF0ZVByb3BzID0gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyk7XG4gICAgaWYgKG1hcERpc3BhdGNoVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcykgZGlzcGF0Y2hQcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTmV3UHJvcHMoKSB7XG4gICAgaWYgKG1hcFN0YXRlVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcykgc3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIGlmIChtYXBEaXNwYXRjaFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU5ld1N0YXRlKCkge1xuICAgIHZhciBuZXh0U3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIHZhciBzdGF0ZVByb3BzQ2hhbmdlZCA9ICFhcmVTdGF0ZVByb3BzRXF1YWwobmV4dFN0YXRlUHJvcHMsIHN0YXRlUHJvcHMpO1xuICAgIHN0YXRlUHJvcHMgPSBuZXh0U3RhdGVQcm9wcztcbiAgICBpZiAoc3RhdGVQcm9wc0NoYW5nZWQpIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlU3Vic2VxdWVudENhbGxzKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKSB7XG4gICAgdmFyIHByb3BzQ2hhbmdlZCA9ICFhcmVPd25Qcm9wc0VxdWFsKG5leHRPd25Qcm9wcywgb3duUHJvcHMpO1xuICAgIHZhciBzdGF0ZUNoYW5nZWQgPSAhYXJlU3RhdGVzRXF1YWwobmV4dFN0YXRlLCBzdGF0ZSk7XG4gICAgc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgb3duUHJvcHMgPSBuZXh0T3duUHJvcHM7XG4gICAgaWYgKHByb3BzQ2hhbmdlZCAmJiBzdGF0ZUNoYW5nZWQpIHJldHVybiBoYW5kbGVOZXdQcm9wc0FuZE5ld1N0YXRlKCk7XG4gICAgaWYgKHByb3BzQ2hhbmdlZCkgcmV0dXJuIGhhbmRsZU5ld1Byb3BzKCk7XG4gICAgaWYgKHN0YXRlQ2hhbmdlZCkgcmV0dXJuIGhhbmRsZU5ld1N0YXRlKCk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHB1cmVGaW5hbFByb3BzU2VsZWN0b3IobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpIHtcbiAgICByZXR1cm4gaGFzUnVuQXRMZWFzdE9uY2UgPyBoYW5kbGVTdWJzZXF1ZW50Q2FsbHMobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpIDogaGFuZGxlRmlyc3RDYWxsKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKTtcbiAgfTtcbn0gLy8gVE9ETzogQWRkIG1vcmUgY29tbWVudHNcbi8vIElmIHB1cmUgaXMgdHJ1ZSwgdGhlIHNlbGVjdG9yIHJldHVybmVkIGJ5IHNlbGVjdG9yRmFjdG9yeSB3aWxsIG1lbW9pemUgaXRzIHJlc3VsdHMsXG4vLyBhbGxvd2luZyBjb25uZWN0QWR2YW5jZWQncyBzaG91bGRDb21wb25lbnRVcGRhdGUgdG8gcmV0dXJuIGZhbHNlIGlmIGZpbmFsXG4vLyBwcm9wcyBoYXZlIG5vdCBjaGFuZ2VkLiBJZiBmYWxzZSwgdGhlIHNlbGVjdG9yIHdpbGwgYWx3YXlzIHJldHVybiBhIG5ld1xuLy8gb2JqZWN0IGFuZCBzaG91bGRDb21wb25lbnRVcGRhdGUgd2lsbCBhbHdheXMgcmV0dXJuIHRydWUuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkoZGlzcGF0Y2gsIF9yZWYyKSB7XG4gIHZhciBpbml0TWFwU3RhdGVUb1Byb3BzID0gX3JlZjIuaW5pdE1hcFN0YXRlVG9Qcm9wcyxcbiAgICAgIGluaXRNYXBEaXNwYXRjaFRvUHJvcHMgPSBfcmVmMi5pbml0TWFwRGlzcGF0Y2hUb1Byb3BzLFxuICAgICAgaW5pdE1lcmdlUHJvcHMgPSBfcmVmMi5pbml0TWVyZ2VQcm9wcyxcbiAgICAgIG9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmMiwgW1wiaW5pdE1hcFN0YXRlVG9Qcm9wc1wiLCBcImluaXRNYXBEaXNwYXRjaFRvUHJvcHNcIiwgXCJpbml0TWVyZ2VQcm9wc1wiXSk7XG5cbiAgdmFyIG1hcFN0YXRlVG9Qcm9wcyA9IGluaXRNYXBTdGF0ZVRvUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpO1xuICB2YXIgbWFwRGlzcGF0Y2hUb1Byb3BzID0gaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3B0aW9ucyk7XG4gIHZhciBtZXJnZVByb3BzID0gaW5pdE1lcmdlUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmVyaWZ5U3Vic2VsZWN0b3JzKG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzLCBvcHRpb25zLmRpc3BsYXlOYW1lKTtcbiAgfVxuXG4gIHZhciBzZWxlY3RvckZhY3RvcnkgPSBvcHRpb25zLnB1cmUgPyBwdXJlRmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeSA6IGltcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3Rvcnk7XG4gIHJldHVybiBzZWxlY3RvckZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BhdGNoLCBvcHRpb25zKTtcbn0iLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZVwiO1xuaW1wb3J0IGNvbm5lY3RBZHZhbmNlZCBmcm9tICcuLi9jb21wb25lbnRzL2Nvbm5lY3RBZHZhbmNlZCc7XG5pbXBvcnQgc2hhbGxvd0VxdWFsIGZyb20gJy4uL3V0aWxzL3NoYWxsb3dFcXVhbCc7XG5pbXBvcnQgZGVmYXVsdE1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcmllcyBmcm9tICcuL21hcERpc3BhdGNoVG9Qcm9wcyc7XG5pbXBvcnQgZGVmYXVsdE1hcFN0YXRlVG9Qcm9wc0ZhY3RvcmllcyBmcm9tICcuL21hcFN0YXRlVG9Qcm9wcyc7XG5pbXBvcnQgZGVmYXVsdE1lcmdlUHJvcHNGYWN0b3JpZXMgZnJvbSAnLi9tZXJnZVByb3BzJztcbmltcG9ydCBkZWZhdWx0U2VsZWN0b3JGYWN0b3J5IGZyb20gJy4vc2VsZWN0b3JGYWN0b3J5Jztcbi8qXG4gIGNvbm5lY3QgaXMgYSBmYWNhZGUgb3ZlciBjb25uZWN0QWR2YW5jZWQuIEl0IHR1cm5zIGl0cyBhcmdzIGludG8gYSBjb21wYXRpYmxlXG4gIHNlbGVjdG9yRmFjdG9yeSwgd2hpY2ggaGFzIHRoZSBzaWduYXR1cmU6XG5cbiAgICAoZGlzcGF0Y2gsIG9wdGlvbnMpID0+IChuZXh0U3RhdGUsIG5leHRPd25Qcm9wcykgPT4gbmV4dEZpbmFsUHJvcHNcbiAgXG4gIGNvbm5lY3QgcGFzc2VzIGl0cyBhcmdzIHRvIGNvbm5lY3RBZHZhbmNlZCBhcyBvcHRpb25zLCB3aGljaCB3aWxsIGluIHR1cm4gcGFzcyB0aGVtIHRvXG4gIHNlbGVjdG9yRmFjdG9yeSBlYWNoIHRpbWUgYSBDb25uZWN0IGNvbXBvbmVudCBpbnN0YW5jZSBpcyBpbnN0YW50aWF0ZWQgb3IgaG90IHJlbG9hZGVkLlxuXG4gIHNlbGVjdG9yRmFjdG9yeSByZXR1cm5zIGEgZmluYWwgcHJvcHMgc2VsZWN0b3IgZnJvbSBpdHMgbWFwU3RhdGVUb1Byb3BzLFxuICBtYXBTdGF0ZVRvUHJvcHNGYWN0b3JpZXMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yaWVzLCBtZXJnZVByb3BzLFxuICBtZXJnZVByb3BzRmFjdG9yaWVzLCBhbmQgcHVyZSBhcmdzLlxuXG4gIFRoZSByZXN1bHRpbmcgZmluYWwgcHJvcHMgc2VsZWN0b3IgaXMgY2FsbGVkIGJ5IHRoZSBDb25uZWN0IGNvbXBvbmVudCBpbnN0YW5jZSB3aGVuZXZlclxuICBpdCByZWNlaXZlcyBuZXcgcHJvcHMgb3Igc3RvcmUgc3RhdGUuXG4gKi9cblxuZnVuY3Rpb24gbWF0Y2goYXJnLCBmYWN0b3JpZXMsIG5hbWUpIHtcbiAgZm9yICh2YXIgaSA9IGZhY3Rvcmllcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciByZXN1bHQgPSBmYWN0b3JpZXNbaV0oYXJnKTtcbiAgICBpZiAocmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaCwgb3B0aW9ucykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgb2YgdHlwZSBcIiArIHR5cGVvZiBhcmcgKyBcIiBmb3IgXCIgKyBuYW1lICsgXCIgYXJndW1lbnQgd2hlbiBjb25uZWN0aW5nIGNvbXBvbmVudCBcIiArIG9wdGlvbnMud3JhcHBlZENvbXBvbmVudE5hbWUgKyBcIi5cIik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0cmljdEVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IGI7XG59IC8vIGNyZWF0ZUNvbm5lY3Qgd2l0aCBkZWZhdWx0IGFyZ3MgYnVpbGRzIHRoZSAnb2ZmaWNpYWwnIGNvbm5lY3QgYmVoYXZpb3IuIENhbGxpbmcgaXQgd2l0aFxuLy8gZGlmZmVyZW50IG9wdGlvbnMgb3BlbnMgdXAgc29tZSB0ZXN0aW5nIGFuZCBleHRlbnNpYmlsaXR5IHNjZW5hcmlvc1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb25uZWN0KF90ZW1wKSB7XG4gIHZhciBfcmVmID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAsXG4gICAgICBfcmVmJGNvbm5lY3RIT0MgPSBfcmVmLmNvbm5lY3RIT0MsXG4gICAgICBjb25uZWN0SE9DID0gX3JlZiRjb25uZWN0SE9DID09PSB2b2lkIDAgPyBjb25uZWN0QWR2YW5jZWQgOiBfcmVmJGNvbm5lY3RIT0MsXG4gICAgICBfcmVmJG1hcFN0YXRlVG9Qcm9wc0YgPSBfcmVmLm1hcFN0YXRlVG9Qcm9wc0ZhY3RvcmllcyxcbiAgICAgIG1hcFN0YXRlVG9Qcm9wc0ZhY3RvcmllcyA9IF9yZWYkbWFwU3RhdGVUb1Byb3BzRiA9PT0gdm9pZCAwID8gZGVmYXVsdE1hcFN0YXRlVG9Qcm9wc0ZhY3RvcmllcyA6IF9yZWYkbWFwU3RhdGVUb1Byb3BzRixcbiAgICAgIF9yZWYkbWFwRGlzcGF0Y2hUb1BybyA9IF9yZWYubWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yaWVzLFxuICAgICAgbWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yaWVzID0gX3JlZiRtYXBEaXNwYXRjaFRvUHJvID09PSB2b2lkIDAgPyBkZWZhdWx0TWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yaWVzIDogX3JlZiRtYXBEaXNwYXRjaFRvUHJvLFxuICAgICAgX3JlZiRtZXJnZVByb3BzRmFjdG9yID0gX3JlZi5tZXJnZVByb3BzRmFjdG9yaWVzLFxuICAgICAgbWVyZ2VQcm9wc0ZhY3RvcmllcyA9IF9yZWYkbWVyZ2VQcm9wc0ZhY3RvciA9PT0gdm9pZCAwID8gZGVmYXVsdE1lcmdlUHJvcHNGYWN0b3JpZXMgOiBfcmVmJG1lcmdlUHJvcHNGYWN0b3IsXG4gICAgICBfcmVmJHNlbGVjdG9yRmFjdG9yeSA9IF9yZWYuc2VsZWN0b3JGYWN0b3J5LFxuICAgICAgc2VsZWN0b3JGYWN0b3J5ID0gX3JlZiRzZWxlY3RvckZhY3RvcnkgPT09IHZvaWQgMCA/IGRlZmF1bHRTZWxlY3RvckZhY3RvcnkgOiBfcmVmJHNlbGVjdG9yRmFjdG9yeTtcblxuICByZXR1cm4gZnVuY3Rpb24gY29ubmVjdChtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywgX3JlZjIpIHtcbiAgICBpZiAoX3JlZjIgPT09IHZvaWQgMCkge1xuICAgICAgX3JlZjIgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgX3JlZjMgPSBfcmVmMixcbiAgICAgICAgX3JlZjMkcHVyZSA9IF9yZWYzLnB1cmUsXG4gICAgICAgIHB1cmUgPSBfcmVmMyRwdXJlID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZjMkcHVyZSxcbiAgICAgICAgX3JlZjMkYXJlU3RhdGVzRXF1YWwgPSBfcmVmMy5hcmVTdGF0ZXNFcXVhbCxcbiAgICAgICAgYXJlU3RhdGVzRXF1YWwgPSBfcmVmMyRhcmVTdGF0ZXNFcXVhbCA9PT0gdm9pZCAwID8gc3RyaWN0RXF1YWwgOiBfcmVmMyRhcmVTdGF0ZXNFcXVhbCxcbiAgICAgICAgX3JlZjMkYXJlT3duUHJvcHNFcXVhID0gX3JlZjMuYXJlT3duUHJvcHNFcXVhbCxcbiAgICAgICAgYXJlT3duUHJvcHNFcXVhbCA9IF9yZWYzJGFyZU93blByb3BzRXF1YSA9PT0gdm9pZCAwID8gc2hhbGxvd0VxdWFsIDogX3JlZjMkYXJlT3duUHJvcHNFcXVhLFxuICAgICAgICBfcmVmMyRhcmVTdGF0ZVByb3BzRXEgPSBfcmVmMy5hcmVTdGF0ZVByb3BzRXF1YWwsXG4gICAgICAgIGFyZVN0YXRlUHJvcHNFcXVhbCA9IF9yZWYzJGFyZVN0YXRlUHJvcHNFcSA9PT0gdm9pZCAwID8gc2hhbGxvd0VxdWFsIDogX3JlZjMkYXJlU3RhdGVQcm9wc0VxLFxuICAgICAgICBfcmVmMyRhcmVNZXJnZWRQcm9wc0UgPSBfcmVmMy5hcmVNZXJnZWRQcm9wc0VxdWFsLFxuICAgICAgICBhcmVNZXJnZWRQcm9wc0VxdWFsID0gX3JlZjMkYXJlTWVyZ2VkUHJvcHNFID09PSB2b2lkIDAgPyBzaGFsbG93RXF1YWwgOiBfcmVmMyRhcmVNZXJnZWRQcm9wc0UsXG4gICAgICAgIGV4dHJhT3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYzLCBbXCJwdXJlXCIsIFwiYXJlU3RhdGVzRXF1YWxcIiwgXCJhcmVPd25Qcm9wc0VxdWFsXCIsIFwiYXJlU3RhdGVQcm9wc0VxdWFsXCIsIFwiYXJlTWVyZ2VkUHJvcHNFcXVhbFwiXSk7XG5cbiAgICB2YXIgaW5pdE1hcFN0YXRlVG9Qcm9wcyA9IG1hdGNoKG1hcFN0YXRlVG9Qcm9wcywgbWFwU3RhdGVUb1Byb3BzRmFjdG9yaWVzLCAnbWFwU3RhdGVUb1Byb3BzJyk7XG4gICAgdmFyIGluaXRNYXBEaXNwYXRjaFRvUHJvcHMgPSBtYXRjaChtYXBEaXNwYXRjaFRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcmllcywgJ21hcERpc3BhdGNoVG9Qcm9wcycpO1xuICAgIHZhciBpbml0TWVyZ2VQcm9wcyA9IG1hdGNoKG1lcmdlUHJvcHMsIG1lcmdlUHJvcHNGYWN0b3JpZXMsICdtZXJnZVByb3BzJyk7XG4gICAgcmV0dXJuIGNvbm5lY3RIT0Moc2VsZWN0b3JGYWN0b3J5LCBfZXh0ZW5kcyh7XG4gICAgICAvLyB1c2VkIGluIGVycm9yIG1lc3NhZ2VzXG4gICAgICBtZXRob2ROYW1lOiAnY29ubmVjdCcsXG4gICAgICAvLyB1c2VkIHRvIGNvbXB1dGUgQ29ubmVjdCdzIGRpc3BsYXlOYW1lIGZyb20gdGhlIHdyYXBwZWQgY29tcG9uZW50J3MgZGlzcGxheU5hbWUuXG4gICAgICBnZXREaXNwbGF5TmFtZTogZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWUobmFtZSkge1xuICAgICAgICByZXR1cm4gXCJDb25uZWN0KFwiICsgbmFtZSArIFwiKVwiO1xuICAgICAgfSxcbiAgICAgIC8vIGlmIG1hcFN0YXRlVG9Qcm9wcyBpcyBmYWxzeSwgdGhlIENvbm5lY3QgY29tcG9uZW50IGRvZXNuJ3Qgc3Vic2NyaWJlIHRvIHN0b3JlIHN0YXRlIGNoYW5nZXNcbiAgICAgIHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlczogQm9vbGVhbihtYXBTdGF0ZVRvUHJvcHMpLFxuICAgICAgLy8gcGFzc2VkIHRocm91Z2ggdG8gc2VsZWN0b3JGYWN0b3J5XG4gICAgICBpbml0TWFwU3RhdGVUb1Byb3BzOiBpbml0TWFwU3RhdGVUb1Byb3BzLFxuICAgICAgaW5pdE1hcERpc3BhdGNoVG9Qcm9wczogaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyxcbiAgICAgIGluaXRNZXJnZVByb3BzOiBpbml0TWVyZ2VQcm9wcyxcbiAgICAgIHB1cmU6IHB1cmUsXG4gICAgICBhcmVTdGF0ZXNFcXVhbDogYXJlU3RhdGVzRXF1YWwsXG4gICAgICBhcmVPd25Qcm9wc0VxdWFsOiBhcmVPd25Qcm9wc0VxdWFsLFxuICAgICAgYXJlU3RhdGVQcm9wc0VxdWFsOiBhcmVTdGF0ZVByb3BzRXF1YWwsXG4gICAgICBhcmVNZXJnZWRQcm9wc0VxdWFsOiBhcmVNZXJnZWRQcm9wc0VxdWFsXG4gICAgfSwgZXh0cmFPcHRpb25zKSk7XG4gIH07XG59XG5leHBvcnQgZGVmYXVsdCBjcmVhdGVDb25uZWN0KCk7IiwiaW1wb3J0IFByb3ZpZGVyLCB7IGNyZWF0ZVByb3ZpZGVyIH0gZnJvbSAnLi9jb21wb25lbnRzL1Byb3ZpZGVyJztcbmltcG9ydCBjb25uZWN0QWR2YW5jZWQgZnJvbSAnLi9jb21wb25lbnRzL2Nvbm5lY3RBZHZhbmNlZCc7XG5pbXBvcnQgY29ubmVjdCBmcm9tICcuL2Nvbm5lY3QvY29ubmVjdCc7XG5leHBvcnQgeyBQcm92aWRlciwgY3JlYXRlUHJvdmlkZXIsIGNvbm5lY3RBZHZhbmNlZCwgY29ubmVjdCB9OyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9leHRlbmRzXCI7XG5pbXBvcnQgeyBBUlJBWV9JTlNFUlQsIEFSUkFZX01PVkUsIEFSUkFZX1BPUCwgQVJSQVlfUFVTSCwgQVJSQVlfUkVNT1ZFLCBBUlJBWV9SRU1PVkVfQUxMLCBBUlJBWV9TSElGVCwgQVJSQVlfU1BMSUNFLCBBUlJBWV9TV0FQLCBBUlJBWV9VTlNISUZULCBBVVRPRklMTCwgQkxVUiwgQ0hBTkdFLCBDTEVBUl9TVUJNSVQsIENMRUFSX1NVQk1JVF9FUlJPUlMsIENMRUFSX0FTWU5DX0VSUk9SLCBERVNUUk9ZLCBGT0NVUywgSU5JVElBTElaRSwgUkVHSVNURVJfRklFTEQsIFJFU0VULCBSRVNFVF9TRUNUSU9OLCBDTEVBUl9GSUVMRFMsIFNFVF9TVUJNSVRfRkFJTEVELCBTRVRfU1VCTUlUX1NVQ0NFRURFRCwgU1RBUlRfQVNZTkNfVkFMSURBVElPTiwgU1RBUlRfU1VCTUlULCBTVE9QX0FTWU5DX1ZBTElEQVRJT04sIFNUT1BfU1VCTUlULCBTVUJNSVQsIFRPVUNILCBVTlJFR0lTVEVSX0ZJRUxELCBVTlRPVUNILCBVUERBVEVfU1lOQ19FUlJPUlMsIFVQREFURV9TWU5DX1dBUk5JTkdTIH0gZnJvbSAnLi9hY3Rpb25UeXBlcyc7XG5cbnZhciBhcnJheUluc2VydCA9IGZ1bmN0aW9uIGFycmF5SW5zZXJ0KGZvcm0sIGZpZWxkLCBpbmRleCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBBUlJBWV9JTlNFUlQsXG4gICAgbWV0YToge1xuICAgICAgZm9ybTogZm9ybSxcbiAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgIGluZGV4OiBpbmRleFxuICAgIH0sXG4gICAgcGF5bG9hZDogdmFsdWVcbiAgfTtcbn07XG5cbnZhciBhcnJheU1vdmUgPSBmdW5jdGlvbiBhcnJheU1vdmUoZm9ybSwgZmllbGQsIGZyb20sIHRvKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQVJSQVlfTU9WRSxcbiAgICBtZXRhOiB7XG4gICAgICBmb3JtOiBmb3JtLFxuICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgZnJvbTogZnJvbSxcbiAgICAgIHRvOiB0b1xuICAgIH1cbiAgfTtcbn07XG5cbnZhciBhcnJheVBvcCA9IGZ1bmN0aW9uIGFycmF5UG9wKGZvcm0sIGZpZWxkKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQVJSQVlfUE9QLFxuICAgIG1ldGE6IHtcbiAgICAgIGZvcm06IGZvcm0sXG4gICAgICBmaWVsZDogZmllbGRcbiAgICB9XG4gIH07XG59O1xuXG52YXIgYXJyYXlQdXNoID0gZnVuY3Rpb24gYXJyYXlQdXNoKGZvcm0sIGZpZWxkLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFSUkFZX1BVU0gsXG4gICAgbWV0YToge1xuICAgICAgZm9ybTogZm9ybSxcbiAgICAgIGZpZWxkOiBmaWVsZFxuICAgIH0sXG4gICAgcGF5bG9hZDogdmFsdWVcbiAgfTtcbn07XG5cbnZhciBhcnJheVJlbW92ZSA9IGZ1bmN0aW9uIGFycmF5UmVtb3ZlKGZvcm0sIGZpZWxkLCBpbmRleCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFSUkFZX1JFTU9WRSxcbiAgICBtZXRhOiB7XG4gICAgICBmb3JtOiBmb3JtLFxuICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgaW5kZXg6IGluZGV4XG4gICAgfVxuICB9O1xufTtcblxudmFyIGFycmF5UmVtb3ZlQWxsID0gZnVuY3Rpb24gYXJyYXlSZW1vdmVBbGwoZm9ybSwgZmllbGQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBBUlJBWV9SRU1PVkVfQUxMLFxuICAgIG1ldGE6IHtcbiAgICAgIGZvcm06IGZvcm0sXG4gICAgICBmaWVsZDogZmllbGRcbiAgICB9XG4gIH07XG59O1xuXG52YXIgYXJyYXlTaGlmdCA9IGZ1bmN0aW9uIGFycmF5U2hpZnQoZm9ybSwgZmllbGQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBBUlJBWV9TSElGVCxcbiAgICBtZXRhOiB7XG4gICAgICBmb3JtOiBmb3JtLFxuICAgICAgZmllbGQ6IGZpZWxkXG4gICAgfVxuICB9O1xufTtcblxudmFyIGFycmF5U3BsaWNlID0gZnVuY3Rpb24gYXJyYXlTcGxpY2UoZm9ybSwgZmllbGQsIGluZGV4LCByZW1vdmVOdW0sIHZhbHVlKSB7XG4gIHZhciBhY3Rpb24gPSB7XG4gICAgdHlwZTogQVJSQVlfU1BMSUNFLFxuICAgIG1ldGE6IHtcbiAgICAgIGZvcm06IGZvcm0sXG4gICAgICBmaWVsZDogZmllbGQsXG4gICAgICBpbmRleDogaW5kZXgsXG4gICAgICByZW1vdmVOdW06IHJlbW92ZU51bVxuICAgIH1cbiAgfTtcblxuICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGFjdGlvbi5wYXlsb2FkID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gYWN0aW9uO1xufTtcblxudmFyIGFycmF5U3dhcCA9IGZ1bmN0aW9uIGFycmF5U3dhcChmb3JtLCBmaWVsZCwgaW5kZXhBLCBpbmRleEIpIHtcbiAgaWYgKGluZGV4QSA9PT0gaW5kZXhCKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTd2FwIGluZGljZXMgY2Fubm90IGJlIGVxdWFsJyk7XG4gIH1cblxuICBpZiAoaW5kZXhBIDwgMCB8fCBpbmRleEIgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTd2FwIGluZGljZXMgY2Fubm90IGJlIG5lZ2F0aXZlJyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6IEFSUkFZX1NXQVAsXG4gICAgbWV0YToge1xuICAgICAgZm9ybTogZm9ybSxcbiAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgIGluZGV4QTogaW5kZXhBLFxuICAgICAgaW5kZXhCOiBpbmRleEJcbiAgICB9XG4gIH07XG59O1xuXG52YXIgYXJyYXlVbnNoaWZ0ID0gZnVuY3Rpb24gYXJyYXlVbnNoaWZ0KGZvcm0sIGZpZWxkLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFSUkFZX1VOU0hJRlQsXG4gICAgbWV0YToge1xuICAgICAgZm9ybTogZm9ybSxcbiAgICAgIGZpZWxkOiBmaWVsZFxuICAgIH0sXG4gICAgcGF5bG9hZDogdmFsdWVcbiAgfTtcbn07XG5cbnZhciBhdXRvZmlsbCA9IGZ1bmN0aW9uIGF1dG9maWxsKGZvcm0sIGZpZWxkLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFVVE9GSUxMLFxuICAgIG1ldGE6IHtcbiAgICAgIGZvcm06IGZvcm0sXG4gICAgICBmaWVsZDogZmllbGRcbiAgICB9LFxuICAgIHBheWxvYWQ6IHZhbHVlXG4gIH07XG59O1xuXG52YXIgYmx1ciA9IGZ1bmN0aW9uIGJsdXIoZm9ybSwgZmllbGQsIHZhbHVlLCB0b3VjaCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEJMVVIsXG4gICAgbWV0YToge1xuICAgICAgZm9ybTogZm9ybSxcbiAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgIHRvdWNoOiB0b3VjaFxuICAgIH0sXG4gICAgcGF5bG9hZDogdmFsdWVcbiAgfTtcbn07XG5cbnZhciBjaGFuZ2UgPSBmdW5jdGlvbiBjaGFuZ2UoZm9ybSwgZmllbGQsIHZhbHVlLCB0b3VjaCwgcGVyc2lzdGVudFN1Ym1pdEVycm9ycykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IENIQU5HRSxcbiAgICBtZXRhOiB7XG4gICAgICBmb3JtOiBmb3JtLFxuICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgdG91Y2g6IHRvdWNoLFxuICAgICAgcGVyc2lzdGVudFN1Ym1pdEVycm9yczogcGVyc2lzdGVudFN1Ym1pdEVycm9yc1xuICAgIH0sXG4gICAgcGF5bG9hZDogdmFsdWVcbiAgfTtcbn07XG5cbnZhciBjbGVhclN1Ym1pdCA9IGZ1bmN0aW9uIGNsZWFyU3VibWl0KGZvcm0pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBDTEVBUl9TVUJNSVQsXG4gICAgbWV0YToge1xuICAgICAgZm9ybTogZm9ybVxuICAgIH1cbiAgfTtcbn07XG5cbnZhciBjbGVhclN1Ym1pdEVycm9ycyA9IGZ1bmN0aW9uIGNsZWFyU3VibWl0RXJyb3JzKGZvcm0pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBDTEVBUl9TVUJNSVRfRVJST1JTLFxuICAgIG1ldGE6IHtcbiAgICAgIGZvcm06IGZvcm1cbiAgICB9XG4gIH07XG59O1xuXG52YXIgY2xlYXJBc3luY0Vycm9yID0gZnVuY3Rpb24gY2xlYXJBc3luY0Vycm9yKGZvcm0sIGZpZWxkKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQ0xFQVJfQVNZTkNfRVJST1IsXG4gICAgbWV0YToge1xuICAgICAgZm9ybTogZm9ybSxcbiAgICAgIGZpZWxkOiBmaWVsZFxuICAgIH1cbiAgfTtcbn07XG5cbnZhciBjbGVhckZpZWxkcyA9IGZ1bmN0aW9uIGNsZWFyRmllbGRzKGZvcm0sIGtlZXBUb3VjaGVkLCBwZXJzaXN0ZW50U3VibWl0RXJyb3JzKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBmaWVsZHMgPSBuZXcgQXJyYXkoX2xlbiA+IDMgPyBfbGVuIC0gMyA6IDApLCBfa2V5ID0gMzsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGZpZWxkc1tfa2V5IC0gM10gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6IENMRUFSX0ZJRUxEUyxcbiAgICBtZXRhOiB7XG4gICAgICBmb3JtOiBmb3JtLFxuICAgICAga2VlcFRvdWNoZWQ6IGtlZXBUb3VjaGVkLFxuICAgICAgcGVyc2lzdGVudFN1Ym1pdEVycm9yczogcGVyc2lzdGVudFN1Ym1pdEVycm9ycyxcbiAgICAgIGZpZWxkczogZmllbGRzXG4gICAgfVxuICB9O1xufTtcblxudmFyIGRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZvcm0gPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICBmb3JtW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6IERFU1RST1ksXG4gICAgbWV0YToge1xuICAgICAgZm9ybTogZm9ybVxuICAgIH1cbiAgfTtcbn07XG5cbnZhciBmb2N1cyA9IGZ1bmN0aW9uIGZvY3VzKGZvcm0sIGZpZWxkKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogRk9DVVMsXG4gICAgbWV0YToge1xuICAgICAgZm9ybTogZm9ybSxcbiAgICAgIGZpZWxkOiBmaWVsZFxuICAgIH1cbiAgfTtcbn07XG5cbnZhciBpbml0aWFsaXplID0gZnVuY3Rpb24gaW5pdGlhbGl6ZShmb3JtLCB2YWx1ZXMsIGtlZXBEaXJ0eSwgb3RoZXJNZXRhKSB7XG4gIGlmIChvdGhlck1ldGEgPT09IHZvaWQgMCkge1xuICAgIG90aGVyTWV0YSA9IHt9O1xuICB9XG5cbiAgaWYgKGtlZXBEaXJ0eSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgIG90aGVyTWV0YSA9IGtlZXBEaXJ0eTtcbiAgICBrZWVwRGlydHkgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogSU5JVElBTElaRSxcbiAgICBtZXRhOiBfZXh0ZW5kcyh7XG4gICAgICBmb3JtOiBmb3JtLFxuICAgICAga2VlcERpcnR5OiBrZWVwRGlydHlcbiAgICB9LCBvdGhlck1ldGEpLFxuICAgIHBheWxvYWQ6IHZhbHVlc1xuICB9O1xufTtcblxudmFyIHJlZ2lzdGVyRmllbGQgPSBmdW5jdGlvbiByZWdpc3RlckZpZWxkKGZvcm0sIG5hbWUsIHR5cGUpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSRUdJU1RFUl9GSUVMRCxcbiAgICBtZXRhOiB7XG4gICAgICBmb3JtOiBmb3JtXG4gICAgfSxcbiAgICBwYXlsb2FkOiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdHlwZTogdHlwZVxuICAgIH1cbiAgfTtcbn07XG5cbnZhciByZXNldCA9IGZ1bmN0aW9uIHJlc2V0KGZvcm0pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSRVNFVCxcbiAgICBtZXRhOiB7XG4gICAgICBmb3JtOiBmb3JtXG4gICAgfVxuICB9O1xufTtcblxudmFyIHJlc2V0U2VjdGlvbiA9IGZ1bmN0aW9uIHJlc2V0U2VjdGlvbihmb3JtKSB7XG4gIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgc2VjdGlvbnMgPSBuZXcgQXJyYXkoX2xlbjMgPiAxID8gX2xlbjMgLSAxIDogMCksIF9rZXkzID0gMTsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgIHNlY3Rpb25zW19rZXkzIC0gMV0gPSBhcmd1bWVudHNbX2tleTNdO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSRVNFVF9TRUNUSU9OLFxuICAgIG1ldGE6IHtcbiAgICAgIGZvcm06IGZvcm0sXG4gICAgICBzZWN0aW9uczogc2VjdGlvbnNcbiAgICB9XG4gIH07XG59O1xuXG52YXIgc3RhcnRBc3luY1ZhbGlkYXRpb24gPSBmdW5jdGlvbiBzdGFydEFzeW5jVmFsaWRhdGlvbihmb3JtLCBmaWVsZCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFNUQVJUX0FTWU5DX1ZBTElEQVRJT04sXG4gICAgbWV0YToge1xuICAgICAgZm9ybTogZm9ybSxcbiAgICAgIGZpZWxkOiBmaWVsZFxuICAgIH1cbiAgfTtcbn07XG5cbnZhciBzdGFydFN1Ym1pdCA9IGZ1bmN0aW9uIHN0YXJ0U3VibWl0KGZvcm0pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBTVEFSVF9TVUJNSVQsXG4gICAgbWV0YToge1xuICAgICAgZm9ybTogZm9ybVxuICAgIH1cbiAgfTtcbn07XG5cbnZhciBzdG9wQXN5bmNWYWxpZGF0aW9uID0gZnVuY3Rpb24gc3RvcEFzeW5jVmFsaWRhdGlvbihmb3JtLCBlcnJvcnMpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBTVE9QX0FTWU5DX1ZBTElEQVRJT04sXG4gICAgbWV0YToge1xuICAgICAgZm9ybTogZm9ybVxuICAgIH0sXG4gICAgcGF5bG9hZDogZXJyb3JzLFxuICAgIGVycm9yOiAhIShlcnJvcnMgJiYgT2JqZWN0LmtleXMoZXJyb3JzKS5sZW5ndGgpXG4gIH07XG59O1xuXG52YXIgc3RvcFN1Ym1pdCA9IGZ1bmN0aW9uIHN0b3BTdWJtaXQoZm9ybSwgZXJyb3JzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogU1RPUF9TVUJNSVQsXG4gICAgbWV0YToge1xuICAgICAgZm9ybTogZm9ybVxuICAgIH0sXG4gICAgcGF5bG9hZDogZXJyb3JzLFxuICAgIGVycm9yOiAhIShlcnJvcnMgJiYgT2JqZWN0LmtleXMoZXJyb3JzKS5sZW5ndGgpXG4gIH07XG59O1xuXG52YXIgc3VibWl0ID0gZnVuY3Rpb24gc3VibWl0KGZvcm0pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBTVUJNSVQsXG4gICAgbWV0YToge1xuICAgICAgZm9ybTogZm9ybVxuICAgIH1cbiAgfTtcbn07XG5cbnZhciBzZXRTdWJtaXRGYWlsZWQgPSBmdW5jdGlvbiBzZXRTdWJtaXRGYWlsZWQoZm9ybSkge1xuICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGZpZWxkcyA9IG5ldyBBcnJheShfbGVuNCA+IDEgPyBfbGVuNCAtIDEgOiAwKSwgX2tleTQgPSAxOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgZmllbGRzW19rZXk0IC0gMV0gPSBhcmd1bWVudHNbX2tleTRdO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBTRVRfU1VCTUlUX0ZBSUxFRCxcbiAgICBtZXRhOiB7XG4gICAgICBmb3JtOiBmb3JtLFxuICAgICAgZmllbGRzOiBmaWVsZHNcbiAgICB9LFxuICAgIGVycm9yOiB0cnVlXG4gIH07XG59O1xuXG52YXIgc2V0U3VibWl0U3VjY2VlZGVkID0gZnVuY3Rpb24gc2V0U3VibWl0U3VjY2VlZGVkKGZvcm0pIHtcbiAgZm9yICh2YXIgX2xlbjUgPSBhcmd1bWVudHMubGVuZ3RoLCBmaWVsZHMgPSBuZXcgQXJyYXkoX2xlbjUgPiAxID8gX2xlbjUgLSAxIDogMCksIF9rZXk1ID0gMTsgX2tleTUgPCBfbGVuNTsgX2tleTUrKykge1xuICAgIGZpZWxkc1tfa2V5NSAtIDFdID0gYXJndW1lbnRzW19rZXk1XTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogU0VUX1NVQk1JVF9TVUNDRUVERUQsXG4gICAgbWV0YToge1xuICAgICAgZm9ybTogZm9ybSxcbiAgICAgIGZpZWxkczogZmllbGRzXG4gICAgfSxcbiAgICBlcnJvcjogZmFsc2VcbiAgfTtcbn07XG5cbnZhciB0b3VjaCA9IGZ1bmN0aW9uIHRvdWNoKGZvcm0pIHtcbiAgZm9yICh2YXIgX2xlbjYgPSBhcmd1bWVudHMubGVuZ3RoLCBmaWVsZHMgPSBuZXcgQXJyYXkoX2xlbjYgPiAxID8gX2xlbjYgLSAxIDogMCksIF9rZXk2ID0gMTsgX2tleTYgPCBfbGVuNjsgX2tleTYrKykge1xuICAgIGZpZWxkc1tfa2V5NiAtIDFdID0gYXJndW1lbnRzW19rZXk2XTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogVE9VQ0gsXG4gICAgbWV0YToge1xuICAgICAgZm9ybTogZm9ybSxcbiAgICAgIGZpZWxkczogZmllbGRzXG4gICAgfVxuICB9O1xufTtcblxudmFyIHVucmVnaXN0ZXJGaWVsZCA9IGZ1bmN0aW9uIHVucmVnaXN0ZXJGaWVsZChmb3JtLCBuYW1lLCBkZXN0cm95T25Vbm1vdW50KSB7XG4gIGlmIChkZXN0cm95T25Vbm1vdW50ID09PSB2b2lkIDApIHtcbiAgICBkZXN0cm95T25Vbm1vdW50ID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogVU5SRUdJU1RFUl9GSUVMRCxcbiAgICBtZXRhOiB7XG4gICAgICBmb3JtOiBmb3JtXG4gICAgfSxcbiAgICBwYXlsb2FkOiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgZGVzdHJveU9uVW5tb3VudDogZGVzdHJveU9uVW5tb3VudFxuICAgIH1cbiAgfTtcbn07XG5cbnZhciB1bnRvdWNoID0gZnVuY3Rpb24gdW50b3VjaChmb3JtKSB7XG4gIGZvciAodmFyIF9sZW43ID0gYXJndW1lbnRzLmxlbmd0aCwgZmllbGRzID0gbmV3IEFycmF5KF9sZW43ID4gMSA/IF9sZW43IC0gMSA6IDApLCBfa2V5NyA9IDE7IF9rZXk3IDwgX2xlbjc7IF9rZXk3KyspIHtcbiAgICBmaWVsZHNbX2tleTcgLSAxXSA9IGFyZ3VtZW50c1tfa2V5N107XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6IFVOVE9VQ0gsXG4gICAgbWV0YToge1xuICAgICAgZm9ybTogZm9ybSxcbiAgICAgIGZpZWxkczogZmllbGRzXG4gICAgfVxuICB9O1xufTtcblxudmFyIHVwZGF0ZVN5bmNFcnJvcnMgPSBmdW5jdGlvbiB1cGRhdGVTeW5jRXJyb3JzKGZvcm0sIHN5bmNFcnJvcnMsIGVycm9yKSB7XG4gIGlmIChzeW5jRXJyb3JzID09PSB2b2lkIDApIHtcbiAgICBzeW5jRXJyb3JzID0ge307XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6IFVQREFURV9TWU5DX0VSUk9SUyxcbiAgICBtZXRhOiB7XG4gICAgICBmb3JtOiBmb3JtXG4gICAgfSxcbiAgICBwYXlsb2FkOiB7XG4gICAgICBzeW5jRXJyb3JzOiBzeW5jRXJyb3JzLFxuICAgICAgZXJyb3I6IGVycm9yXG4gICAgfVxuICB9O1xufTtcblxudmFyIHVwZGF0ZVN5bmNXYXJuaW5ncyA9IGZ1bmN0aW9uIHVwZGF0ZVN5bmNXYXJuaW5ncyhmb3JtLCBzeW5jV2FybmluZ3MsIHdhcm5pbmcpIHtcbiAgaWYgKHN5bmNXYXJuaW5ncyA9PT0gdm9pZCAwKSB7XG4gICAgc3luY1dhcm5pbmdzID0ge307XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6IFVQREFURV9TWU5DX1dBUk5JTkdTLFxuICAgIG1ldGE6IHtcbiAgICAgIGZvcm06IGZvcm1cbiAgICB9LFxuICAgIHBheWxvYWQ6IHtcbiAgICAgIHN5bmNXYXJuaW5nczogc3luY1dhcm5pbmdzLFxuICAgICAgd2FybmluZzogd2FybmluZ1xuICAgIH1cbiAgfTtcbn07XG5cbnZhciBhY3Rpb25zID0ge1xuICBhcnJheUluc2VydDogYXJyYXlJbnNlcnQsXG4gIGFycmF5TW92ZTogYXJyYXlNb3ZlLFxuICBhcnJheVBvcDogYXJyYXlQb3AsXG4gIGFycmF5UHVzaDogYXJyYXlQdXNoLFxuICBhcnJheVJlbW92ZTogYXJyYXlSZW1vdmUsXG4gIGFycmF5UmVtb3ZlQWxsOiBhcnJheVJlbW92ZUFsbCxcbiAgYXJyYXlTaGlmdDogYXJyYXlTaGlmdCxcbiAgYXJyYXlTcGxpY2U6IGFycmF5U3BsaWNlLFxuICBhcnJheVN3YXA6IGFycmF5U3dhcCxcbiAgYXJyYXlVbnNoaWZ0OiBhcnJheVVuc2hpZnQsXG4gIGF1dG9maWxsOiBhdXRvZmlsbCxcbiAgYmx1cjogYmx1cixcbiAgY2hhbmdlOiBjaGFuZ2UsXG4gIGNsZWFyRmllbGRzOiBjbGVhckZpZWxkcyxcbiAgY2xlYXJTdWJtaXQ6IGNsZWFyU3VibWl0LFxuICBjbGVhclN1Ym1pdEVycm9yczogY2xlYXJTdWJtaXRFcnJvcnMsXG4gIGNsZWFyQXN5bmNFcnJvcjogY2xlYXJBc3luY0Vycm9yLFxuICBkZXN0cm95OiBkZXN0cm95LFxuICBmb2N1czogZm9jdXMsXG4gIGluaXRpYWxpemU6IGluaXRpYWxpemUsXG4gIHJlZ2lzdGVyRmllbGQ6IHJlZ2lzdGVyRmllbGQsXG4gIHJlc2V0OiByZXNldCxcbiAgcmVzZXRTZWN0aW9uOiByZXNldFNlY3Rpb24sXG4gIHN0YXJ0QXN5bmNWYWxpZGF0aW9uOiBzdGFydEFzeW5jVmFsaWRhdGlvbixcbiAgc3RhcnRTdWJtaXQ6IHN0YXJ0U3VibWl0LFxuICBzdG9wQXN5bmNWYWxpZGF0aW9uOiBzdG9wQXN5bmNWYWxpZGF0aW9uLFxuICBzdG9wU3VibWl0OiBzdG9wU3VibWl0LFxuICBzdWJtaXQ6IHN1Ym1pdCxcbiAgc2V0U3VibWl0RmFpbGVkOiBzZXRTdWJtaXRGYWlsZWQsXG4gIHNldFN1Ym1pdFN1Y2NlZWRlZDogc2V0U3VibWl0U3VjY2VlZGVkLFxuICB0b3VjaDogdG91Y2gsXG4gIHVucmVnaXN0ZXJGaWVsZDogdW5yZWdpc3RlckZpZWxkLFxuICB1bnRvdWNoOiB1bnRvdWNoLFxuICB1cGRhdGVTeW5jRXJyb3JzOiB1cGRhdGVTeW5jRXJyb3JzLFxuICB1cGRhdGVTeW5jV2FybmluZ3M6IHVwZGF0ZVN5bmNXYXJuaW5nc1xufTtcbmV4cG9ydCBkZWZhdWx0IGFjdGlvbnM7IiwiaW1wb3J0IGlzUHJvbWlzZSBmcm9tICdpcy1wcm9taXNlJztcblxudmFyIGFzeW5jVmFsaWRhdGlvbiA9IGZ1bmN0aW9uIGFzeW5jVmFsaWRhdGlvbihmbiwgc3RhcnQsIHN0b3AsIGZpZWxkKSB7XG4gIHN0YXJ0KGZpZWxkKTtcbiAgdmFyIHByb21pc2UgPSBmbigpO1xuXG4gIGlmICghaXNQcm9taXNlKHByb21pc2UpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdhc3luY1ZhbGlkYXRlIGZ1bmN0aW9uIHBhc3NlZCB0byByZWR1eEZvcm0gbXVzdCByZXR1cm4gYSBwcm9taXNlJyk7XG4gIH1cblxuICB2YXIgaGFuZGxlRXJyb3JzID0gZnVuY3Rpb24gaGFuZGxlRXJyb3JzKHJlamVjdGVkKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlcnJvcnMpIHtcbiAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICBpZiAoZXJyb3JzICYmIE9iamVjdC5rZXlzKGVycm9ycykubGVuZ3RoKSB7XG4gICAgICAgICAgc3RvcChlcnJvcnMpO1xuICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXN5bmNocm9ub3VzIHZhbGlkYXRpb24gcHJvbWlzZSB3YXMgcmVqZWN0ZWQgd2l0aG91dCBlcnJvcnMuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RvcCgpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH07XG4gIH07XG5cbiAgcmV0dXJuIHByb21pc2UudGhlbihoYW5kbGVFcnJvcnMoZmFsc2UpLCBoYW5kbGVFcnJvcnModHJ1ZSkpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmNWYWxpZGF0aW9uOyIsInZhciBkZWZhdWx0U2hvdWxkQXN5bmNWYWxpZGF0ZSA9IGZ1bmN0aW9uIGRlZmF1bHRTaG91bGRBc3luY1ZhbGlkYXRlKF9yZWYpIHtcbiAgdmFyIGluaXRpYWxpemVkID0gX3JlZi5pbml0aWFsaXplZCxcbiAgICAgIHRyaWdnZXIgPSBfcmVmLnRyaWdnZXIsXG4gICAgICBwcmlzdGluZSA9IF9yZWYucHJpc3RpbmUsXG4gICAgICBzeW5jVmFsaWRhdGlvblBhc3NlcyA9IF9yZWYuc3luY1ZhbGlkYXRpb25QYXNzZXM7XG5cbiAgaWYgKCFzeW5jVmFsaWRhdGlvblBhc3Nlcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN3aXRjaCAodHJpZ2dlcikge1xuICAgIGNhc2UgJ2JsdXInOlxuICAgIGNhc2UgJ2NoYW5nZSc6XG4gICAgICAvLyBibHVycmluZ1xuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlICdzdWJtaXQnOlxuICAgICAgLy8gc3VibWl0dGluZywgc28gb25seSBhc3luYyB2YWxpZGF0ZSBpZiBmb3JtIGlzIGRpcnR5IG9yIHdhcyBuZXZlciBpbml0aWFsaXplZFxuICAgICAgLy8gY29udmVyc2VseSwgRE9OJ1QgYXN5bmMgdmFsaWRhdGUgaWYgdGhlIGZvcm0gaXMgcHJpc3RpbmUganVzdCBhcyBpdCB3YXMgaW5pdGlhbGl6ZWRcbiAgICAgIHJldHVybiAhcHJpc3RpbmUgfHwgIWluaXRpYWxpemVkO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZGVmYXVsdFNob3VsZEFzeW5jVmFsaWRhdGU7IiwidmFyIGRlZmF1bHRTaG91bGRWYWxpZGF0ZSA9IGZ1bmN0aW9uIGRlZmF1bHRTaG91bGRWYWxpZGF0ZShfcmVmKSB7XG4gIHZhciB2YWx1ZXMgPSBfcmVmLnZhbHVlcyxcbiAgICAgIG5leHRQcm9wcyA9IF9yZWYubmV4dFByb3BzLFxuICAgICAgaW5pdGlhbFJlbmRlciA9IF9yZWYuaW5pdGlhbFJlbmRlcixcbiAgICAgIGxhc3RGaWVsZFZhbGlkYXRvcktleXMgPSBfcmVmLmxhc3RGaWVsZFZhbGlkYXRvcktleXMsXG4gICAgICBmaWVsZFZhbGlkYXRvcktleXMgPSBfcmVmLmZpZWxkVmFsaWRhdG9yS2V5cyxcbiAgICAgIHN0cnVjdHVyZSA9IF9yZWYuc3RydWN0dXJlO1xuXG4gIGlmIChpbml0aWFsUmVuZGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gIXN0cnVjdHVyZS5kZWVwRXF1YWwodmFsdWVzLCBuZXh0UHJvcHMgJiYgbmV4dFByb3BzLnZhbHVlcykgfHwgIXN0cnVjdHVyZS5kZWVwRXF1YWwobGFzdEZpZWxkVmFsaWRhdG9yS2V5cywgZmllbGRWYWxpZGF0b3JLZXlzKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmF1bHRTaG91bGRWYWxpZGF0ZTsiLCJ2YXIgZGVmYXVsdFNob3VsZEVycm9yID0gZnVuY3Rpb24gZGVmYXVsdFNob3VsZEVycm9yKF9yZWYpIHtcbiAgdmFyIHZhbHVlcyA9IF9yZWYudmFsdWVzLFxuICAgICAgbmV4dFByb3BzID0gX3JlZi5uZXh0UHJvcHMsXG4gICAgICBpbml0aWFsUmVuZGVyID0gX3JlZi5pbml0aWFsUmVuZGVyLFxuICAgICAgbGFzdEZpZWxkVmFsaWRhdG9yS2V5cyA9IF9yZWYubGFzdEZpZWxkVmFsaWRhdG9yS2V5cyxcbiAgICAgIGZpZWxkVmFsaWRhdG9yS2V5cyA9IF9yZWYuZmllbGRWYWxpZGF0b3JLZXlzLFxuICAgICAgc3RydWN0dXJlID0gX3JlZi5zdHJ1Y3R1cmU7XG5cbiAgaWYgKGluaXRpYWxSZW5kZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiAhc3RydWN0dXJlLmRlZXBFcXVhbCh2YWx1ZXMsIG5leHRQcm9wcyAmJiBuZXh0UHJvcHMudmFsdWVzKSB8fCAhc3RydWN0dXJlLmRlZXBFcXVhbChsYXN0RmllbGRWYWxpZGF0b3JLZXlzLCBmaWVsZFZhbGlkYXRvcktleXMpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZGVmYXVsdFNob3VsZEVycm9yOyIsInZhciBkZWZhdWx0U2hvdWxkV2FybiA9IGZ1bmN0aW9uIGRlZmF1bHRTaG91bGRXYXJuKF9yZWYpIHtcbiAgdmFyIHZhbHVlcyA9IF9yZWYudmFsdWVzLFxuICAgICAgbmV4dFByb3BzID0gX3JlZi5uZXh0UHJvcHMsXG4gICAgICBpbml0aWFsUmVuZGVyID0gX3JlZi5pbml0aWFsUmVuZGVyLFxuICAgICAgbGFzdEZpZWxkVmFsaWRhdG9yS2V5cyA9IF9yZWYubGFzdEZpZWxkVmFsaWRhdG9yS2V5cyxcbiAgICAgIGZpZWxkVmFsaWRhdG9yS2V5cyA9IF9yZWYuZmllbGRWYWxpZGF0b3JLZXlzLFxuICAgICAgc3RydWN0dXJlID0gX3JlZi5zdHJ1Y3R1cmU7XG5cbiAgaWYgKGluaXRpYWxSZW5kZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiAhc3RydWN0dXJlLmRlZXBFcXVhbCh2YWx1ZXMsIG5leHRQcm9wcyAmJiBuZXh0UHJvcHMudmFsdWVzKSB8fCAhc3RydWN0dXJlLmRlZXBFcXVhbChsYXN0RmllbGRWYWxpZGF0b3JLZXlzLCBmaWVsZFZhbGlkYXRvcktleXMpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZGVmYXVsdFNob3VsZFdhcm47IiwidmFyIGlzRXZlbnQgPSBmdW5jdGlvbiBpc0V2ZW50KGNhbmRpZGF0ZSkge1xuICByZXR1cm4gISEoY2FuZGlkYXRlICYmIGNhbmRpZGF0ZS5zdG9wUHJvcGFnYXRpb24gJiYgY2FuZGlkYXRlLnByZXZlbnREZWZhdWx0KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGlzRXZlbnQ7IiwiaW1wb3J0IGlzRXZlbnQgZnJvbSAnLi9pc0V2ZW50JztcblxudmFyIHNpbGVuY2VFdmVudCA9IGZ1bmN0aW9uIHNpbGVuY2VFdmVudChldmVudCkge1xuICB2YXIgaXMgPSBpc0V2ZW50KGV2ZW50KTtcblxuICBpZiAoaXMpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG5cbiAgcmV0dXJuIGlzO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgc2lsZW5jZUV2ZW50OyIsImltcG9ydCBzaWxlbmNlRXZlbnQgZnJvbSAnLi9zaWxlbmNlRXZlbnQnO1xuXG52YXIgc2lsZW5jZUV2ZW50cyA9IGZ1bmN0aW9uIHNpbGVuY2VFdmVudHMoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBzaWxlbmNlRXZlbnQoZXZlbnQpID8gZm4uYXBwbHkodm9pZCAwLCBhcmdzKSA6IGZuLmFwcGx5KHZvaWQgMCwgW2V2ZW50XS5jb25jYXQoYXJncykpO1xuICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgc2lsZW5jZUV2ZW50czsiLCJpbXBvcnQgcGxhaW4gZnJvbSAnLi9zdHJ1Y3R1cmUvcGxhaW4nO1xuXG52YXIgdG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xufTtcblxudmFyIGdldEVycm9yID0gZnVuY3Rpb24gZ2V0RXJyb3IodmFsdWUsIHZhbHVlcywgcHJvcHMsIHZhbGlkYXRvcnMsIG5hbWUpIHtcbiAgdmFyIGFycmF5ID0gdG9BcnJheSh2YWxpZGF0b3JzKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVycm9yID0gYXJyYXlbaV0odmFsdWUsIHZhbHVlcywgcHJvcHMsIG5hbWUpO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuICB9XG59O1xuXG52YXIgZ2VuZXJhdGVWYWxpZGF0b3IgPSBmdW5jdGlvbiBnZW5lcmF0ZVZhbGlkYXRvcih2YWxpZGF0b3JzLCBfcmVmKSB7XG4gIHZhciBnZXRJbiA9IF9yZWYuZ2V0SW47XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWVzLCBwcm9wcykge1xuICAgIHZhciBlcnJvcnMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyh2YWxpZGF0b3JzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXRJbih2YWx1ZXMsIG5hbWUpO1xuICAgICAgdmFyIGVycm9yID0gZ2V0RXJyb3IodmFsdWUsIHZhbHVlcywgcHJvcHMsIHZhbGlkYXRvcnNbbmFtZV0sIG5hbWUpO1xuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgZXJyb3JzID0gcGxhaW4uc2V0SW4oZXJyb3JzLCBuYW1lLCBlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGVycm9ycztcbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGdlbmVyYXRlVmFsaWRhdG9yOyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuZnVuY3Rpb24gX2V4dGVuZGFibGVCdWlsdGluKGNscykge1xuICBmdW5jdGlvbiBFeHRlbmRhYmxlQnVpbHRpbigpIHtcbiAgICBjbHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIEV4dGVuZGFibGVCdWlsdGluLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoY2xzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogY2xzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihFeHRlbmRhYmxlQnVpbHRpbiwgY2xzKTtcbiAgfSBlbHNlIHtcbiAgICBFeHRlbmRhYmxlQnVpbHRpbi5fX3Byb3RvX18gPSBjbHM7XG4gIH1cblxuICByZXR1cm4gRXh0ZW5kYWJsZUJ1aWx0aW47XG59XG5cbnZhciBFeHRlbmRhYmxlRXJyb3IgPSBmdW5jdGlvbiAoX2V4dGVuZGFibGVCdWlsdGluMikge1xuICBfaW5oZXJpdHMoRXh0ZW5kYWJsZUVycm9yLCBfZXh0ZW5kYWJsZUJ1aWx0aW4yKTtcblxuICBmdW5jdGlvbiBFeHRlbmRhYmxlRXJyb3IoKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcnO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEV4dGVuZGFibGVFcnJvcik7XG5cbiAgICAvLyBleHRlbmRpbmcgRXJyb3IgaXMgd2VpcmQgYW5kIGRvZXMgbm90IHByb3BhZ2F0ZSBgbWVzc2FnZWBcbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoRXh0ZW5kYWJsZUVycm9yLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRXh0ZW5kYWJsZUVycm9yKSkuY2FsbCh0aGlzLCBtZXNzYWdlKSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsICdtZXNzYWdlJywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogbWVzc2FnZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsICduYW1lJywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogX3RoaXMuY29uc3RydWN0b3IubmFtZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG5cbiAgICBpZiAoRXJyb3IuaGFzT3duUHJvcGVydHkoJ2NhcHR1cmVTdGFja1RyYWNlJykpIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKF90aGlzLCBfdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMpO1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgJ3N0YWNrJywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogbmV3IEVycm9yKG1lc3NhZ2UpLnN0YWNrLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gRXh0ZW5kYWJsZUVycm9yO1xufShfZXh0ZW5kYWJsZUJ1aWx0aW4oRXJyb3IpKTtcblxuZXhwb3J0IGRlZmF1bHQgRXh0ZW5kYWJsZUVycm9yO1xuIiwiaW1wb3J0IF9pbmhlcml0c0xvb3NlIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzTG9vc2VcIjtcbmltcG9ydCBFeHRlbmRhYmxlRXJyb3IgZnJvbSAnZXM2LWVycm9yJztcblxudmFyIFN1Ym1pc3Npb25FcnJvciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0V4dGVuZGFibGVFcnJvcikge1xuICBfaW5oZXJpdHNMb29zZShTdWJtaXNzaW9uRXJyb3IsIF9FeHRlbmRhYmxlRXJyb3IpO1xuXG4gIGZ1bmN0aW9uIFN1Ym1pc3Npb25FcnJvcihlcnJvcnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9FeHRlbmRhYmxlRXJyb3IuY2FsbCh0aGlzLCAnU3VibWl0IFZhbGlkYXRpb24gRmFpbGVkJykgfHwgdGhpcztcbiAgICBfdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIFN1Ym1pc3Npb25FcnJvcjtcbn0oRXh0ZW5kYWJsZUVycm9yKTtcblxuZXhwb3J0IGRlZmF1bHQgU3VibWlzc2lvbkVycm9yOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9leHRlbmRzXCI7XG5pbXBvcnQgaXNQcm9taXNlIGZyb20gJ2lzLXByb21pc2UnO1xuaW1wb3J0IFN1Ym1pc3Npb25FcnJvciBmcm9tICcuL1N1Ym1pc3Npb25FcnJvcic7XG5cbnZhciBpc1N1Ym1pc3Npb25FcnJvciA9IGZ1bmN0aW9uIGlzU3VibWlzc2lvbkVycm9yKGVycm9yKSB7XG4gIHJldHVybiBlcnJvciAmJiBlcnJvci5uYW1lID09PSBTdWJtaXNzaW9uRXJyb3IubmFtZTtcbn07XG5cbnZhciBtZXJnZUVycm9ycyA9IGZ1bmN0aW9uIG1lcmdlRXJyb3JzKF9yZWYpIHtcbiAgdmFyIGFzeW5jRXJyb3JzID0gX3JlZi5hc3luY0Vycm9ycyxcbiAgICAgIHN5bmNFcnJvcnMgPSBfcmVmLnN5bmNFcnJvcnM7XG4gIHJldHVybiBhc3luY0Vycm9ycyAmJiB0eXBlb2YgYXN5bmNFcnJvcnMubWVyZ2UgPT09ICdmdW5jdGlvbicgPyBhc3luY0Vycm9ycy5tZXJnZShzeW5jRXJyb3JzKS50b0pTKCkgOiBfZXh0ZW5kcyh7fSwgYXN5bmNFcnJvcnMsIHN5bmNFcnJvcnMpO1xufTtcblxudmFyIGhhbmRsZVN1Ym1pdCA9IGZ1bmN0aW9uIGhhbmRsZVN1Ym1pdChzdWJtaXQsIHByb3BzLCB2YWxpZCwgYXN5bmNWYWxpZGF0ZSwgZmllbGRzKSB7XG4gIHZhciBkaXNwYXRjaCA9IHByb3BzLmRpc3BhdGNoLFxuICAgICAgb25TdWJtaXRGYWlsID0gcHJvcHMub25TdWJtaXRGYWlsLFxuICAgICAgb25TdWJtaXRTdWNjZXNzID0gcHJvcHMub25TdWJtaXRTdWNjZXNzLFxuICAgICAgc3RhcnRTdWJtaXQgPSBwcm9wcy5zdGFydFN1Ym1pdCxcbiAgICAgIHN0b3BTdWJtaXQgPSBwcm9wcy5zdG9wU3VibWl0LFxuICAgICAgc2V0U3VibWl0RmFpbGVkID0gcHJvcHMuc2V0U3VibWl0RmFpbGVkLFxuICAgICAgc2V0U3VibWl0U3VjY2VlZGVkID0gcHJvcHMuc2V0U3VibWl0U3VjY2VlZGVkLFxuICAgICAgc3luY0Vycm9ycyA9IHByb3BzLnN5bmNFcnJvcnMsXG4gICAgICBhc3luY0Vycm9ycyA9IHByb3BzLmFzeW5jRXJyb3JzLFxuICAgICAgdG91Y2ggPSBwcm9wcy50b3VjaCxcbiAgICAgIHZhbHVlcyA9IHByb3BzLnZhbHVlcyxcbiAgICAgIHBlcnNpc3RlbnRTdWJtaXRFcnJvcnMgPSBwcm9wcy5wZXJzaXN0ZW50U3VibWl0RXJyb3JzO1xuICB0b3VjaC5hcHBseSh2b2lkIDAsIEFycmF5LmZyb20oZmllbGRzKSk7IC8vIG1hcmsgYWxsIGZpZWxkcyBhcyB0b3VjaGVkXG5cbiAgaWYgKHZhbGlkIHx8IHBlcnNpc3RlbnRTdWJtaXRFcnJvcnMpIHtcbiAgICB2YXIgZG9TdWJtaXQgPSBmdW5jdGlvbiBkb1N1Ym1pdCgpIHtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IHN1Ym1pdCh2YWx1ZXMsIGRpc3BhdGNoLCBwcm9wcyk7XG4gICAgICB9IGNhdGNoIChzdWJtaXRFcnJvcikge1xuICAgICAgICB2YXIgZXJyb3IgPSBpc1N1Ym1pc3Npb25FcnJvcihzdWJtaXRFcnJvcikgPyBzdWJtaXRFcnJvci5lcnJvcnMgOiB1bmRlZmluZWQ7XG4gICAgICAgIHN0b3BTdWJtaXQoZXJyb3IpO1xuICAgICAgICBzZXRTdWJtaXRGYWlsZWQuYXBwbHkodm9pZCAwLCBmaWVsZHMpO1xuXG4gICAgICAgIGlmIChvblN1Ym1pdEZhaWwpIHtcbiAgICAgICAgICBvblN1Ym1pdEZhaWwoZXJyb3IsIGRpc3BhdGNoLCBzdWJtaXRFcnJvciwgcHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yIHx8IG9uU3VibWl0RmFpbCkge1xuICAgICAgICAgIC8vIGlmIHlvdSd2ZSBwcm92aWRlZCBhbiBvblN1Ym1pdEZhaWwgY2FsbGJhY2ssIGRvbid0IHJlLXRocm93IHRoZSBlcnJvclxuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBzdWJtaXRFcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNQcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgICAgc3RhcnRTdWJtaXQoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKGZ1bmN0aW9uIChzdWJtaXRSZXN1bHQpIHtcbiAgICAgICAgICBzdG9wU3VibWl0KCk7XG4gICAgICAgICAgc2V0U3VibWl0U3VjY2VlZGVkKCk7XG5cbiAgICAgICAgICBpZiAob25TdWJtaXRTdWNjZXNzKSB7XG4gICAgICAgICAgICBvblN1Ym1pdFN1Y2Nlc3Moc3VibWl0UmVzdWx0LCBkaXNwYXRjaCwgcHJvcHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzdWJtaXRSZXN1bHQ7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChzdWJtaXRFcnJvcikge1xuICAgICAgICAgIHZhciBlcnJvciA9IGlzU3VibWlzc2lvbkVycm9yKHN1Ym1pdEVycm9yKSA/IHN1Ym1pdEVycm9yLmVycm9ycyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBzdG9wU3VibWl0KGVycm9yKTtcbiAgICAgICAgICBzZXRTdWJtaXRGYWlsZWQuYXBwbHkodm9pZCAwLCBmaWVsZHMpO1xuXG4gICAgICAgICAgaWYgKG9uU3VibWl0RmFpbCkge1xuICAgICAgICAgICAgb25TdWJtaXRGYWlsKGVycm9yLCBkaXNwYXRjaCwgc3VibWl0RXJyb3IsIHByb3BzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZXJyb3IgfHwgb25TdWJtaXRGYWlsKSB7XG4gICAgICAgICAgICAvLyBpZiB5b3UndmUgcHJvdmlkZWQgYW4gb25TdWJtaXRGYWlsIGNhbGxiYWNrLCBkb24ndCByZS10aHJvdyB0aGUgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgc3VibWl0RXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFN1Ym1pdFN1Y2NlZWRlZCgpO1xuXG4gICAgICAgIGlmIChvblN1Ym1pdFN1Y2Nlc3MpIHtcbiAgICAgICAgICBvblN1Ym1pdFN1Y2Nlc3MocmVzdWx0LCBkaXNwYXRjaCwgcHJvcHMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHZhciBhc3luY1ZhbGlkYXRlUmVzdWx0ID0gYXN5bmNWYWxpZGF0ZSAmJiBhc3luY1ZhbGlkYXRlKCk7XG5cbiAgICBpZiAoYXN5bmNWYWxpZGF0ZVJlc3VsdCkge1xuICAgICAgcmV0dXJuIGFzeW5jVmFsaWRhdGVSZXN1bHQudGhlbihmdW5jdGlvbiAoYXN5bmNFcnJvcnMpIHtcbiAgICAgICAgaWYgKGFzeW5jRXJyb3JzKSB7XG4gICAgICAgICAgdGhyb3cgYXN5bmNFcnJvcnM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZG9TdWJtaXQoKTtcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChhc3luY0Vycm9ycykge1xuICAgICAgICBzZXRTdWJtaXRGYWlsZWQuYXBwbHkodm9pZCAwLCBmaWVsZHMpO1xuXG4gICAgICAgIGlmIChvblN1Ym1pdEZhaWwpIHtcbiAgICAgICAgICBvblN1Ym1pdEZhaWwoYXN5bmNFcnJvcnMsIGRpc3BhdGNoLCBudWxsLCBwcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoYXN5bmNFcnJvcnMpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkb1N1Ym1pdCgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzZXRTdWJtaXRGYWlsZWQuYXBwbHkodm9pZCAwLCBmaWVsZHMpO1xuICAgIHZhciBlcnJvcnMgPSBtZXJnZUVycm9ycyh7XG4gICAgICBhc3luY0Vycm9yczogYXN5bmNFcnJvcnMsXG4gICAgICBzeW5jRXJyb3JzOiBzeW5jRXJyb3JzXG4gICAgfSk7XG5cbiAgICBpZiAob25TdWJtaXRGYWlsKSB7XG4gICAgICBvblN1Ym1pdEZhaWwoZXJyb3JzLCBkaXNwYXRjaCwgbnVsbCwgcHJvcHMpO1xuICAgIH1cblxuICAgIHJldHVybiBlcnJvcnM7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGhhbmRsZVN1Ym1pdDsiLCJ2YXIgZ2V0RXJyb3JLZXlzID0gZnVuY3Rpb24gZ2V0RXJyb3JLZXlzKG5hbWUsIHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnRmllbGQnOlxuICAgICAgcmV0dXJuIFtuYW1lLCBuYW1lICsgXCIuX2Vycm9yXCJdO1xuXG4gICAgY2FzZSAnRmllbGRBcnJheSc6XG4gICAgICByZXR1cm4gW25hbWUgKyBcIi5fZXJyb3JcIl07XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGZpZWxkIHR5cGUnKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUhhc0Vycm9yID0gZnVuY3Rpb24gY3JlYXRlSGFzRXJyb3IoX3JlZikge1xuICB2YXIgZ2V0SW4gPSBfcmVmLmdldEluO1xuXG4gIHZhciBoYXNFcnJvciA9IGZ1bmN0aW9uIGhhc0Vycm9yKGZpZWxkLCBzeW5jRXJyb3JzLCBhc3luY0Vycm9ycywgc3VibWl0RXJyb3JzKSB7XG4gICAgaWYgKCFzeW5jRXJyb3JzICYmICFhc3luY0Vycm9ycyAmJiAhc3VibWl0RXJyb3JzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIG5hbWUgPSBnZXRJbihmaWVsZCwgJ25hbWUnKTtcbiAgICB2YXIgdHlwZSA9IGdldEluKGZpZWxkLCAndHlwZScpO1xuICAgIHJldHVybiBnZXRFcnJvcktleXMobmFtZSwgdHlwZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gZ2V0SW4oc3luY0Vycm9ycywga2V5KSB8fCBnZXRJbihhc3luY0Vycm9ycywga2V5KSB8fCBnZXRJbihzdWJtaXRFcnJvcnMsIGtleSk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIGhhc0Vycm9yO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlSGFzRXJyb3I7IiwiaW1wb3J0IGNyZWF0ZUhhc0Vycm9yIGZyb20gJy4uL2hhc0Vycm9yJztcblxudmFyIGNyZWF0ZUlzVmFsaWQgPSBmdW5jdGlvbiBjcmVhdGVJc1ZhbGlkKHN0cnVjdHVyZSkge1xuICB2YXIgZ2V0SW4gPSBzdHJ1Y3R1cmUuZ2V0SW4sXG4gICAgICBrZXlzID0gc3RydWN0dXJlLmtleXM7XG4gIHZhciBoYXNFcnJvciA9IGNyZWF0ZUhhc0Vycm9yKHN0cnVjdHVyZSk7XG4gIHJldHVybiBmdW5jdGlvbiAoZm9ybSwgZ2V0Rm9ybVN0YXRlLCBpZ25vcmVTdWJtaXRFcnJvcnMpIHtcbiAgICBpZiAoaWdub3JlU3VibWl0RXJyb3JzID09PSB2b2lkIDApIHtcbiAgICAgIGlnbm9yZVN1Ym1pdEVycm9ycyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIHZhciBub25OdWxsR2V0Rm9ybVN0YXRlID0gZ2V0Rm9ybVN0YXRlIHx8IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICByZXR1cm4gZ2V0SW4oc3RhdGUsICdmb3JtJyk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgZm9ybVN0YXRlID0gbm9uTnVsbEdldEZvcm1TdGF0ZShzdGF0ZSk7XG4gICAgICB2YXIgc3luY0Vycm9yID0gZ2V0SW4oZm9ybVN0YXRlLCBmb3JtICsgXCIuc3luY0Vycm9yXCIpO1xuXG4gICAgICBpZiAoc3luY0Vycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpZ25vcmVTdWJtaXRFcnJvcnMpIHtcbiAgICAgICAgdmFyIGVycm9yID0gZ2V0SW4oZm9ybVN0YXRlLCBmb3JtICsgXCIuZXJyb3JcIik7XG5cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzeW5jRXJyb3JzID0gZ2V0SW4oZm9ybVN0YXRlLCBmb3JtICsgXCIuc3luY0Vycm9yc1wiKTtcbiAgICAgIHZhciBhc3luY0Vycm9ycyA9IGdldEluKGZvcm1TdGF0ZSwgZm9ybSArIFwiLmFzeW5jRXJyb3JzXCIpO1xuICAgICAgdmFyIHN1Ym1pdEVycm9ycyA9IGlnbm9yZVN1Ym1pdEVycm9ycyA/IHVuZGVmaW5lZCA6IGdldEluKGZvcm1TdGF0ZSwgZm9ybSArIFwiLnN1Ym1pdEVycm9yc1wiKTtcblxuICAgICAgaWYgKCFzeW5jRXJyb3JzICYmICFhc3luY0Vycm9ycyAmJiAhc3VibWl0RXJyb3JzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVnaXN0ZXJlZEZpZWxkcyA9IGdldEluKGZvcm1TdGF0ZSwgZm9ybSArIFwiLnJlZ2lzdGVyZWRGaWVsZHNcIik7XG5cbiAgICAgIGlmICghcmVnaXN0ZXJlZEZpZWxkcykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICFrZXlzKHJlZ2lzdGVyZWRGaWVsZHMpLmZpbHRlcihmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gZ2V0SW4ocmVnaXN0ZXJlZEZpZWxkcywgXCJbJ1wiICsgbmFtZSArIFwiJ10uY291bnRcIikgPiAwO1xuICAgICAgfSkuc29tZShmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gaGFzRXJyb3IoZ2V0SW4ocmVnaXN0ZXJlZEZpZWxkcywgXCJbJ1wiICsgbmFtZSArIFwiJ11cIiksIHN5bmNFcnJvcnMsIGFzeW5jRXJyb3JzLCBzdWJtaXRFcnJvcnMpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUlzVmFsaWQ7IiwidmFyIGdldERpc3BsYXlOYW1lID0gZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWUoQ29tcCkge1xuICByZXR1cm4gQ29tcC5kaXNwbGF5TmFtZSB8fCBDb21wLm5hbWUgfHwgJ0NvbXBvbmVudCc7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBnZXREaXNwbGF5TmFtZTsiLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2VcIjtcbmltcG9ydCBfaW5oZXJpdHNMb29zZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c0xvb3NlXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5leHBvcnQgdmFyIFJlZHV4Rm9ybUNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuZXhwb3J0IHZhciB3aXRoUmVkdXhGb3JtID0gZnVuY3Rpb24gd2l0aFJlZHV4Rm9ybShDb21wb25lbnQpIHtcbiAgdmFyIEhvYyA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHNMb29zZShIb2MsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gSG9jKCkge1xuICAgICAgcmV0dXJuIF9SZWFjdCRDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8gPSBIb2MucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgZm9yd2FyZGVkUmVmID0gX3RoaXMkcHJvcHMuZm9yd2FyZGVkUmVmLFxuICAgICAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdGhpcyRwcm9wcywgW1wiZm9yd2FyZGVkUmVmXCJdKTtcblxuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVkdXhGb3JtQ29udGV4dC5Db25zdW1lciwge1xuICAgICAgICBjaGlsZHJlbjogZnVuY3Rpb24gY2hpbGRyZW4oX3JlZHV4Rm9ybSkge1xuICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgX2V4dGVuZHMoe1xuICAgICAgICAgICAgX3JlZHV4Rm9ybTogX3JlZHV4Rm9ybSxcbiAgICAgICAgICAgIHJlZjogZm9yd2FyZGVkUmVmXG4gICAgICAgICAgfSwgcmVzdCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEhvYztcbiAgfShSZWFjdC5Db21wb25lbnQpO1xuXG4gIHZhciByZWYgPSBSZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIChwcm9wcywgcmVmKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSG9jLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgIGZvcndhcmRlZFJlZjogcmVmXG4gICAgfSkpO1xuICB9KTtcbiAgcmVmLmRpc3BsYXlOYW1lID0gQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnO1xuICByZXR1cm4gcmVmO1xufTsiLCJpbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCI7XG5pbXBvcnQgX2luaGVyaXRzTG9vc2UgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNMb29zZVwiO1xuaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlXCI7XG5pbXBvcnQgX21lcmdlIGZyb20gXCJsb2Rhc2gvbWVyZ2VcIjtcbmltcG9ydCBfbWFwVmFsdWVzIGZyb20gXCJsb2Rhc2gvbWFwVmFsdWVzXCI7XG5pbXBvcnQgeyBwb2x5ZmlsbCB9IGZyb20gJ3JlYWN0LWxpZmVjeWNsZXMtY29tcGF0JztcbmltcG9ydCBob2lzdFN0YXRpY3MgZnJvbSAnaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdpbnZhcmlhbnQnO1xuaW1wb3J0IGlzUHJvbWlzZSBmcm9tICdpcy1wcm9taXNlJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QsIHsgY3JlYXRlRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNvbm5lY3QgfSBmcm9tICdyZWFjdC1yZWR1eCc7XG5pbXBvcnQgeyBiaW5kQWN0aW9uQ3JlYXRvcnMgfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgaW1wb3J0ZWRBY3Rpb25zIGZyb20gJy4vYWN0aW9ucyc7XG5pbXBvcnQgYXN5bmNWYWxpZGF0aW9uIGZyb20gJy4vYXN5bmNWYWxpZGF0aW9uJztcbmltcG9ydCBkZWZhdWx0U2hvdWxkQXN5bmNWYWxpZGF0ZSBmcm9tICcuL2RlZmF1bHRTaG91bGRBc3luY1ZhbGlkYXRlJztcbmltcG9ydCBkZWZhdWx0U2hvdWxkVmFsaWRhdGUgZnJvbSAnLi9kZWZhdWx0U2hvdWxkVmFsaWRhdGUnO1xuaW1wb3J0IGRlZmF1bHRTaG91bGRFcnJvciBmcm9tICcuL2RlZmF1bHRTaG91bGRFcnJvcic7XG5pbXBvcnQgZGVmYXVsdFNob3VsZFdhcm4gZnJvbSAnLi9kZWZhdWx0U2hvdWxkV2Fybic7XG5pbXBvcnQgc2lsZW5jZUV2ZW50IGZyb20gJy4vZXZlbnRzL3NpbGVuY2VFdmVudCc7XG5pbXBvcnQgc2lsZW5jZUV2ZW50cyBmcm9tICcuL2V2ZW50cy9zaWxlbmNlRXZlbnRzJztcbmltcG9ydCBnZW5lcmF0ZVZhbGlkYXRvciBmcm9tICcuL2dlbmVyYXRlVmFsaWRhdG9yJztcbmltcG9ydCBoYW5kbGVTdWJtaXQgZnJvbSAnLi9oYW5kbGVTdWJtaXQnO1xuaW1wb3J0IGNyZWF0ZUlzVmFsaWQgZnJvbSAnLi9zZWxlY3RvcnMvaXNWYWxpZCc7XG5pbXBvcnQgcGxhaW4gZnJvbSAnLi9zdHJ1Y3R1cmUvcGxhaW4nO1xuaW1wb3J0IGdldERpc3BsYXlOYW1lIGZyb20gJy4vdXRpbC9nZXREaXNwbGF5TmFtZSc7XG5pbXBvcnQgaXNIb3RSZWxvYWRpbmcgZnJvbSAnLi91dGlsL2lzSG90UmVsb2FkaW5nJztcbmltcG9ydCB7IHdpdGhSZWR1eEZvcm0sIFJlZHV4Rm9ybUNvbnRleHQgfSBmcm9tICcuL1JlZHV4Rm9ybUNvbnRleHQnO1xuXG52YXIgaXNDbGFzc0NvbXBvbmVudCA9IGZ1bmN0aW9uIGlzQ2xhc3NDb21wb25lbnQoQ29tcG9uZW50KSB7XG4gIHJldHVybiBCb29sZWFuKENvbXBvbmVudCAmJiBDb21wb25lbnQucHJvdG90eXBlICYmIHR5cGVvZiBDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPT09ICdvYmplY3QnKTtcbn07IC8vIGV4dHJhY3QgZmllbGQtc3BlY2lmaWMgYWN0aW9uc1xuXG5cbnZhciBhcnJheUluc2VydCA9IGltcG9ydGVkQWN0aW9ucy5hcnJheUluc2VydCxcbiAgICBhcnJheU1vdmUgPSBpbXBvcnRlZEFjdGlvbnMuYXJyYXlNb3ZlLFxuICAgIGFycmF5UG9wID0gaW1wb3J0ZWRBY3Rpb25zLmFycmF5UG9wLFxuICAgIGFycmF5UHVzaCA9IGltcG9ydGVkQWN0aW9ucy5hcnJheVB1c2gsXG4gICAgYXJyYXlSZW1vdmUgPSBpbXBvcnRlZEFjdGlvbnMuYXJyYXlSZW1vdmUsXG4gICAgYXJyYXlSZW1vdmVBbGwgPSBpbXBvcnRlZEFjdGlvbnMuYXJyYXlSZW1vdmVBbGwsXG4gICAgYXJyYXlTaGlmdCA9IGltcG9ydGVkQWN0aW9ucy5hcnJheVNoaWZ0LFxuICAgIGFycmF5U3BsaWNlID0gaW1wb3J0ZWRBY3Rpb25zLmFycmF5U3BsaWNlLFxuICAgIGFycmF5U3dhcCA9IGltcG9ydGVkQWN0aW9ucy5hcnJheVN3YXAsXG4gICAgYXJyYXlVbnNoaWZ0ID0gaW1wb3J0ZWRBY3Rpb25zLmFycmF5VW5zaGlmdCxcbiAgICBibHVyID0gaW1wb3J0ZWRBY3Rpb25zLmJsdXIsXG4gICAgY2hhbmdlID0gaW1wb3J0ZWRBY3Rpb25zLmNoYW5nZSxcbiAgICBmb2N1cyA9IGltcG9ydGVkQWN0aW9ucy5mb2N1cyxcbiAgICBmb3JtQWN0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKGltcG9ydGVkQWN0aW9ucywgW1wiYXJyYXlJbnNlcnRcIiwgXCJhcnJheU1vdmVcIiwgXCJhcnJheVBvcFwiLCBcImFycmF5UHVzaFwiLCBcImFycmF5UmVtb3ZlXCIsIFwiYXJyYXlSZW1vdmVBbGxcIiwgXCJhcnJheVNoaWZ0XCIsIFwiYXJyYXlTcGxpY2VcIiwgXCJhcnJheVN3YXBcIiwgXCJhcnJheVVuc2hpZnRcIiwgXCJibHVyXCIsIFwiY2hhbmdlXCIsIFwiZm9jdXNcIl0pO1xuXG52YXIgYXJyYXlBY3Rpb25zID0ge1xuICBhcnJheUluc2VydDogYXJyYXlJbnNlcnQsXG4gIGFycmF5TW92ZTogYXJyYXlNb3ZlLFxuICBhcnJheVBvcDogYXJyYXlQb3AsXG4gIGFycmF5UHVzaDogYXJyYXlQdXNoLFxuICBhcnJheVJlbW92ZTogYXJyYXlSZW1vdmUsXG4gIGFycmF5UmVtb3ZlQWxsOiBhcnJheVJlbW92ZUFsbCxcbiAgYXJyYXlTaGlmdDogYXJyYXlTaGlmdCxcbiAgYXJyYXlTcGxpY2U6IGFycmF5U3BsaWNlLFxuICBhcnJheVN3YXA6IGFycmF5U3dhcCxcbiAgYXJyYXlVbnNoaWZ0OiBhcnJheVVuc2hpZnRcbn07XG52YXIgcHJvcHNUb05vdFVwZGF0ZUZvciA9IFtdLmNvbmNhdChPYmplY3Qua2V5cyhpbXBvcnRlZEFjdGlvbnMpLCBbJ2FycmF5JywgJ2FzeW5jRXJyb3JzJywgJ2luaXRpYWxWYWx1ZXMnLCAnc3luY0Vycm9ycycsICdzeW5jV2FybmluZ3MnLCAndmFsdWVzJywgJ3JlZ2lzdGVyZWRGaWVsZHMnXSk7XG5cbnZhciBjaGVja1N1Ym1pdCA9IGZ1bmN0aW9uIGNoZWNrU3VibWl0KHN1Ym1pdCkge1xuICBpZiAoIXN1Ym1pdCB8fCB0eXBlb2Ygc3VibWl0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBlaXRoZXIgcGFzcyBoYW5kbGVTdWJtaXQoKSBhbiBvblN1Ym1pdCBmdW5jdGlvbiBvciBwYXNzIG9uU3VibWl0IGFzIGEgcHJvcCcpO1xuICB9XG5cbiAgcmV0dXJuIHN1Ym1pdDtcbn07XG5cbi8qKlxuICogVGhlIGRlY29yYXRvciB0aGF0IGlzIHRoZSBtYWluIEFQSSB0byByZWR1eC1mb3JtXG4gKi9cbnZhciBjcmVhdGVSZWR1eEZvcm0gPSBmdW5jdGlvbiBjcmVhdGVSZWR1eEZvcm0oc3RydWN0dXJlKSB7XG4gIHZhciBkZWVwRXF1YWwgPSBzdHJ1Y3R1cmUuZGVlcEVxdWFsLFxuICAgICAgZW1wdHkgPSBzdHJ1Y3R1cmUuZW1wdHksXG4gICAgICBnZXRJbiA9IHN0cnVjdHVyZS5nZXRJbixcbiAgICAgIHNldEluID0gc3RydWN0dXJlLnNldEluLFxuICAgICAga2V5cyA9IHN0cnVjdHVyZS5rZXlzLFxuICAgICAgZnJvbUpTID0gc3RydWN0dXJlLmZyb21KUztcbiAgdmFyIGlzVmFsaWQgPSBjcmVhdGVJc1ZhbGlkKHN0cnVjdHVyZSk7XG4gIHJldHVybiBmdW5jdGlvbiAoaW5pdGlhbENvbmZpZykge1xuICAgIHZhciBjb25maWcgPSBfZXh0ZW5kcyh7XG4gICAgICB0b3VjaE9uQmx1cjogdHJ1ZSxcbiAgICAgIHRvdWNoT25DaGFuZ2U6IGZhbHNlLFxuICAgICAgcGVyc2lzdGVudFN1Ym1pdEVycm9yczogZmFsc2UsXG4gICAgICBkZXN0cm95T25Vbm1vdW50OiB0cnVlLFxuICAgICAgc2hvdWxkQXN5bmNWYWxpZGF0ZTogZGVmYXVsdFNob3VsZEFzeW5jVmFsaWRhdGUsXG4gICAgICBzaG91bGRWYWxpZGF0ZTogZGVmYXVsdFNob3VsZFZhbGlkYXRlLFxuICAgICAgc2hvdWxkRXJyb3I6IGRlZmF1bHRTaG91bGRFcnJvcixcbiAgICAgIHNob3VsZFdhcm46IGRlZmF1bHRTaG91bGRXYXJuLFxuICAgICAgZW5hYmxlUmVpbml0aWFsaXplOiBmYWxzZSxcbiAgICAgIGtlZXBEaXJ0eU9uUmVpbml0aWFsaXplOiBmYWxzZSxcbiAgICAgIHVwZGF0ZVVucmVnaXN0ZXJlZEZpZWxkczogZmFsc2UsXG4gICAgICBnZXRGb3JtU3RhdGU6IGZ1bmN0aW9uIGdldEZvcm1TdGF0ZShzdGF0ZSkge1xuICAgICAgICByZXR1cm4gZ2V0SW4oc3RhdGUsICdmb3JtJyk7XG4gICAgICB9LFxuICAgICAgcHVyZTogdHJ1ZSxcbiAgICAgIGZvcmNlVW5yZWdpc3Rlck9uVW5tb3VudDogZmFsc2VcbiAgICB9LCBpbml0aWFsQ29uZmlnKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoV3JhcHBlZENvbXBvbmVudCkge1xuICAgICAgdmFyIEZvcm0gPVxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICAgICAgX2luaGVyaXRzTG9vc2UoRm9ybSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgICAgICAgZnVuY3Rpb24gRm9ybSgpIHtcbiAgICAgICAgICB2YXIgX3RoaXM7XG5cbiAgICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkgfHwgdGhpcztcbiAgICAgICAgICBfdGhpcy53cmFwcGVkID0gUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgICAgICAgX3RoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgICAgX3RoaXMuZmllbGRDb3VudHMgPSB7fTtcbiAgICAgICAgICBfdGhpcy5maWVsZFZhbGlkYXRvcnMgPSB7fTtcbiAgICAgICAgICBfdGhpcy5sYXN0RmllbGRWYWxpZGF0b3JLZXlzID0gW107XG4gICAgICAgICAgX3RoaXMuZmllbGRXYXJuZXJzID0ge307XG4gICAgICAgICAgX3RoaXMubGFzdEZpZWxkV2FybmVyS2V5cyA9IFtdO1xuICAgICAgICAgIF90aGlzLmlubmVyT25TdWJtaXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgX3RoaXMuc3VibWl0UHJvbWlzZSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIF90aGlzLmdldFZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5wcm9wcy52YWx1ZXM7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIF90aGlzLmlzVmFsaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMucHJvcHMudmFsaWQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIF90aGlzLmlzUHJpc3RpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMucHJvcHMucHJpc3RpbmU7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIF90aGlzLnJlZ2lzdGVyID0gZnVuY3Rpb24gKG5hbWUsIHR5cGUsIGdldFZhbGlkYXRvciwgZ2V0V2FybmVyKSB7XG4gICAgICAgICAgICB2YXIgbGFzdENvdW50ID0gX3RoaXMuZmllbGRDb3VudHNbbmFtZV07XG4gICAgICAgICAgICB2YXIgbmV4dENvdW50ID0gKGxhc3RDb3VudCB8fCAwKSArIDE7XG4gICAgICAgICAgICBfdGhpcy5maWVsZENvdW50c1tuYW1lXSA9IG5leHRDb3VudDtcblxuICAgICAgICAgICAgX3RoaXMucHJvcHMucmVnaXN0ZXJGaWVsZChuYW1lLCB0eXBlKTtcblxuICAgICAgICAgICAgaWYgKGdldFZhbGlkYXRvcikge1xuICAgICAgICAgICAgICBfdGhpcy5maWVsZFZhbGlkYXRvcnNbbmFtZV0gPSBnZXRWYWxpZGF0b3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChnZXRXYXJuZXIpIHtcbiAgICAgICAgICAgICAgX3RoaXMuZmllbGRXYXJuZXJzW25hbWVdID0gZ2V0V2FybmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBfdGhpcy51bnJlZ2lzdGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBsYXN0Q291bnQgPSBfdGhpcy5maWVsZENvdW50c1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChsYXN0Q291bnQgPT09IDEpIGRlbGV0ZSBfdGhpcy5maWVsZENvdW50c1tuYW1lXTtlbHNlIGlmIChsYXN0Q291bnQgIT0gbnVsbCkgX3RoaXMuZmllbGRDb3VudHNbbmFtZV0gPSBsYXN0Q291bnQgLSAxO1xuXG4gICAgICAgICAgICBpZiAoIV90aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICB2YXIgX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgICAgIF9kZXN0cm95T25Vbm1vdW50ID0gX3RoaXMkcHJvcHMuZGVzdHJveU9uVW5tb3VudCxcbiAgICAgICAgICAgICAgICAgIGZvcmNlVW5yZWdpc3Rlck9uVW5tb3VudCA9IF90aGlzJHByb3BzLmZvcmNlVW5yZWdpc3Rlck9uVW5tb3VudCxcbiAgICAgICAgICAgICAgICAgIHVucmVnaXN0ZXJGaWVsZCA9IF90aGlzJHByb3BzLnVucmVnaXN0ZXJGaWVsZDtcblxuICAgICAgICAgICAgICBpZiAoX2Rlc3Ryb3lPblVubW91bnQgfHwgZm9yY2VVbnJlZ2lzdGVyT25Vbm1vdW50KSB7XG4gICAgICAgICAgICAgICAgdW5yZWdpc3RlckZpZWxkKG5hbWUsIF9kZXN0cm95T25Vbm1vdW50KTtcblxuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuZmllbGRDb3VudHNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5maWVsZFZhbGlkYXRvcnNbbmFtZV07XG4gICAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMuZmllbGRXYXJuZXJzW25hbWVdO1xuICAgICAgICAgICAgICAgICAgX3RoaXMubGFzdEZpZWxkVmFsaWRhdG9yS2V5cyA9IF90aGlzLmxhc3RGaWVsZFZhbGlkYXRvcktleXMuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleSAhPT0gbmFtZTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1bnJlZ2lzdGVyRmllbGQobmFtZSwgZmFsc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIF90aGlzLmdldEZpZWxkTGlzdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgcmVnaXN0ZXJlZEZpZWxkcyA9IF90aGlzLnByb3BzLnJlZ2lzdGVyZWRGaWVsZHM7XG4gICAgICAgICAgICB2YXIgbGlzdCA9IFtdO1xuXG4gICAgICAgICAgICBpZiAoIXJlZ2lzdGVyZWRGaWVsZHMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBrZXlTZXEgPSBrZXlzKHJlZ2lzdGVyZWRGaWVsZHMpO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmV4Y2x1ZGVGaWVsZEFycmF5KSB7XG4gICAgICAgICAgICAgIGtleVNlcSA9IGtleVNlcS5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0SW4ocmVnaXN0ZXJlZEZpZWxkcywgXCJbJ1wiICsgbmFtZSArIFwiJ10udHlwZVwiKSAhPT0gJ0ZpZWxkQXJyYXknO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZyb21KUyhrZXlTZXEucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuICAgICAgICAgICAgICBhY2MucHVzaChrZXkpO1xuICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwgbGlzdCkpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBfdGhpcy5nZXRWYWxpZGF0b3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHZhbGlkYXRvcnMgPSB7fTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF90aGlzLmZpZWxkVmFsaWRhdG9ycykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICB2YXIgdmFsaWRhdG9yID0gX3RoaXMuZmllbGRWYWxpZGF0b3JzW25hbWVdKCk7XG5cbiAgICAgICAgICAgICAgaWYgKHZhbGlkYXRvcikge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRvcnNbbmFtZV0gPSB2YWxpZGF0b3I7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRvcnM7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIF90aGlzLmdlbmVyYXRlVmFsaWRhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHZhbGlkYXRvcnMgPSBfdGhpcy5nZXRWYWxpZGF0b3JzKCk7XG5cbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWxpZGF0b3JzKS5sZW5ndGggPyBnZW5lcmF0ZVZhbGlkYXRvcih2YWxpZGF0b3JzLCBzdHJ1Y3R1cmUpIDogdW5kZWZpbmVkO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBfdGhpcy5nZXRXYXJuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHdhcm5lcnMgPSB7fTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF90aGlzLmZpZWxkV2FybmVycykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICB2YXIgd2FybmVyID0gX3RoaXMuZmllbGRXYXJuZXJzW25hbWVdKCk7XG5cbiAgICAgICAgICAgICAgaWYgKHdhcm5lcikge1xuICAgICAgICAgICAgICAgIHdhcm5lcnNbbmFtZV0gPSB3YXJuZXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHdhcm5lcnM7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIF90aGlzLmdlbmVyYXRlV2FybmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHdhcm5lcnMgPSBfdGhpcy5nZXRXYXJuZXJzKCk7XG5cbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh3YXJuZXJzKS5sZW5ndGggPyBnZW5lcmF0ZVZhbGlkYXRvcih3YXJuZXJzLCBzdHJ1Y3R1cmUpIDogdW5kZWZpbmVkO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBfdGhpcy5hc3luY1ZhbGlkYXRlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCB0cmlnZ2VyKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMkcHJvcHMyID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgICAgICAgYXN5bmNCbHVyRmllbGRzID0gX3RoaXMkcHJvcHMyLmFzeW5jQmx1ckZpZWxkcyxcbiAgICAgICAgICAgICAgICBhc3luY0NoYW5nZUZpZWxkcyA9IF90aGlzJHByb3BzMi5hc3luY0NoYW5nZUZpZWxkcyxcbiAgICAgICAgICAgICAgICBhc3luY0Vycm9ycyA9IF90aGlzJHByb3BzMi5hc3luY0Vycm9ycyxcbiAgICAgICAgICAgICAgICBhc3luY1ZhbGlkYXRlID0gX3RoaXMkcHJvcHMyLmFzeW5jVmFsaWRhdGUsXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2ggPSBfdGhpcyRwcm9wczIuZGlzcGF0Y2gsXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZWQgPSBfdGhpcyRwcm9wczIuaW5pdGlhbGl6ZWQsXG4gICAgICAgICAgICAgICAgcHJpc3RpbmUgPSBfdGhpcyRwcm9wczIucHJpc3RpbmUsXG4gICAgICAgICAgICAgICAgc2hvdWxkQXN5bmNWYWxpZGF0ZSA9IF90aGlzJHByb3BzMi5zaG91bGRBc3luY1ZhbGlkYXRlLFxuICAgICAgICAgICAgICAgIHN0YXJ0QXN5bmNWYWxpZGF0aW9uID0gX3RoaXMkcHJvcHMyLnN0YXJ0QXN5bmNWYWxpZGF0aW9uLFxuICAgICAgICAgICAgICAgIHN0b3BBc3luY1ZhbGlkYXRpb24gPSBfdGhpcyRwcm9wczIuc3RvcEFzeW5jVmFsaWRhdGlvbixcbiAgICAgICAgICAgICAgICBzeW5jRXJyb3JzID0gX3RoaXMkcHJvcHMyLnN5bmNFcnJvcnMsXG4gICAgICAgICAgICAgICAgdmFsdWVzID0gX3RoaXMkcHJvcHMyLnZhbHVlcztcbiAgICAgICAgICAgIHZhciBzdWJtaXR0aW5nID0gIW5hbWU7XG5cbiAgICAgICAgICAgIHZhciBmaWVsZE5lZWRzVmFsaWRhdGlvbiA9IGZ1bmN0aW9uIGZpZWxkTmVlZHNWYWxpZGF0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgZmllbGROZWVkc1ZhbGlkYXRpb25Gb3JCbHVyID0gYXN5bmNCbHVyRmllbGRzICYmIG5hbWUgJiYgfmFzeW5jQmx1ckZpZWxkcy5pbmRleE9mKG5hbWUucmVwbGFjZSgvXFxbWzAtOV0rXFxdL2csICdbXScpKTtcbiAgICAgICAgICAgICAgdmFyIGZpZWxkTmVlZHNWYWxpZGF0aW9uRm9yQ2hhbmdlID0gYXN5bmNDaGFuZ2VGaWVsZHMgJiYgbmFtZSAmJiB+YXN5bmNDaGFuZ2VGaWVsZHMuaW5kZXhPZihuYW1lLnJlcGxhY2UoL1xcW1swLTldK1xcXS9nLCAnW10nKSk7XG4gICAgICAgICAgICAgIHZhciBhc3luY1ZhbGlkYXRlQnlEZWZhdWx0ID0gIShhc3luY0JsdXJGaWVsZHMgfHwgYXN5bmNDaGFuZ2VGaWVsZHMpO1xuICAgICAgICAgICAgICByZXR1cm4gc3VibWl0dGluZyB8fCBhc3luY1ZhbGlkYXRlQnlEZWZhdWx0IHx8ICh0cmlnZ2VyID09PSAnYmx1cicgPyBmaWVsZE5lZWRzVmFsaWRhdGlvbkZvckJsdXIgOiBmaWVsZE5lZWRzVmFsaWRhdGlvbkZvckNoYW5nZSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoYXN5bmNWYWxpZGF0ZSkge1xuICAgICAgICAgICAgICB2YXIgdmFsdWVzVG9WYWxpZGF0ZSA9IHN1Ym1pdHRpbmcgPyB2YWx1ZXMgOiBzZXRJbih2YWx1ZXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgdmFyIHN5bmNWYWxpZGF0aW9uUGFzc2VzID0gc3VibWl0dGluZyB8fCAhZ2V0SW4oc3luY0Vycm9ycywgbmFtZSk7XG5cbiAgICAgICAgICAgICAgaWYgKGZpZWxkTmVlZHNWYWxpZGF0aW9uKCkgJiYgc2hvdWxkQXN5bmNWYWxpZGF0ZSh7XG4gICAgICAgICAgICAgICAgYXN5bmNFcnJvcnM6IGFzeW5jRXJyb3JzLFxuICAgICAgICAgICAgICAgIGluaXRpYWxpemVkOiBpbml0aWFsaXplZCxcbiAgICAgICAgICAgICAgICB0cmlnZ2VyOiBzdWJtaXR0aW5nID8gJ3N1Ym1pdCcgOiB0cmlnZ2VyLFxuICAgICAgICAgICAgICAgIGJsdXJyZWRGaWVsZDogbmFtZSxcbiAgICAgICAgICAgICAgICBwcmlzdGluZTogcHJpc3RpbmUsXG4gICAgICAgICAgICAgICAgc3luY1ZhbGlkYXRpb25QYXNzZXM6IHN5bmNWYWxpZGF0aW9uUGFzc2VzXG4gICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzeW5jVmFsaWRhdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYXN5bmNWYWxpZGF0ZSh2YWx1ZXNUb1ZhbGlkYXRlLCBkaXNwYXRjaCwgX3RoaXMucHJvcHMsIG5hbWUpO1xuICAgICAgICAgICAgICAgIH0sIHN0YXJ0QXN5bmNWYWxpZGF0aW9uLCBzdG9wQXN5bmNWYWxpZGF0aW9uLCBuYW1lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBfdGhpcy5zdWJtaXRDb21wbGV0ZWQgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICBkZWxldGUgX3RoaXMuc3VibWl0UHJvbWlzZTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIF90aGlzLnN1Ym1pdEZhaWxlZCA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgZGVsZXRlIF90aGlzLnN1Ym1pdFByb21pc2U7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgX3RoaXMubGlzdGVuVG9TdWJtaXQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICAgICAgaWYgKCFpc1Byb21pc2UocHJvbWlzZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF90aGlzLnN1Ym1pdFByb21pc2UgPSBwcm9taXNlO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihfdGhpcy5zdWJtaXRDb21wbGV0ZWQsIF90aGlzLnN1Ym1pdEZhaWxlZCk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIF90aGlzLnN1Ym1pdCA9IGZ1bmN0aW9uIChzdWJtaXRPckV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMkcHJvcHMzID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgICAgICAgb25TdWJtaXQgPSBfdGhpcyRwcm9wczMub25TdWJtaXQsXG4gICAgICAgICAgICAgICAgYmx1ciA9IF90aGlzJHByb3BzMy5ibHVyLFxuICAgICAgICAgICAgICAgIGNoYW5nZSA9IF90aGlzJHByb3BzMy5jaGFuZ2UsXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2ggPSBfdGhpcyRwcm9wczMuZGlzcGF0Y2g7XG5cbiAgICAgICAgICAgIGlmICghc3VibWl0T3JFdmVudCB8fCBzaWxlbmNlRXZlbnQoc3VibWl0T3JFdmVudCkpIHtcbiAgICAgICAgICAgICAgLy8gc3VibWl0T3JFdmVudCBpcyBhbiBldmVudDogZmlyZSBzdWJtaXQgaWYgbm90IGFscmVhZHkgc3VibWl0dGluZ1xuICAgICAgICAgICAgICBpZiAoIV90aGlzLnN1Ym1pdFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBhdm9pZCByZWN1cnNpdmUgc3RhY2sgdHJhY2UgaWYgdXNlIEZvcm0gd2l0aCBvblN1Ym1pdCBhcyBoYW5kbGVTdWJtaXRcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaW5uZXJPblN1Ym1pdCAmJiBfdGhpcy5pbm5lck9uU3VibWl0ICE9PSBfdGhpcy5zdWJtaXQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHdpbGwgY2FsbCBcInN1Ym1pdE9yRXZlbnQgaXMgdGhlIHN1Ym1pdCBmdW5jdGlvblwiIGJsb2NrIGJlbG93XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuaW5uZXJPblN1Ym1pdCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubGlzdGVuVG9TdWJtaXQoaGFuZGxlU3VibWl0KGNoZWNrU3VibWl0KG9uU3VibWl0KSwgX2V4dGVuZHMoe30sIF90aGlzLnByb3BzLCBiaW5kQWN0aW9uQ3JlYXRvcnMoe1xuICAgICAgICAgICAgICAgICAgICBibHVyOiBibHVyLFxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2U6IGNoYW5nZVxuICAgICAgICAgICAgICAgICAgfSwgZGlzcGF0Y2gpKSwgX3RoaXMucHJvcHMudmFsaWRFeGNlcHRTdWJtaXQsIF90aGlzLmFzeW5jVmFsaWRhdGUsIF90aGlzLmdldEZpZWxkTGlzdCh7XG4gICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVGaWVsZEFycmF5OiB0cnVlXG4gICAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gc3VibWl0T3JFdmVudCBpcyB0aGUgc3VibWl0IGZ1bmN0aW9uOiByZXR1cm4gZGVmZXJyZWQgc3VibWl0IHRodW5rXG4gICAgICAgICAgICAgIHJldHVybiBzaWxlbmNlRXZlbnRzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIV90aGlzLnN1Ym1pdFByb21pc2UgJiYgX3RoaXMubGlzdGVuVG9TdWJtaXQoaGFuZGxlU3VibWl0KGNoZWNrU3VibWl0KHN1Ym1pdE9yRXZlbnQpLCBfZXh0ZW5kcyh7fSwgX3RoaXMucHJvcHMsIGJpbmRBY3Rpb25DcmVhdG9ycyh7XG4gICAgICAgICAgICAgICAgICBibHVyOiBibHVyLFxuICAgICAgICAgICAgICAgICAgY2hhbmdlOiBjaGFuZ2VcbiAgICAgICAgICAgICAgICB9LCBkaXNwYXRjaCkpLCBfdGhpcy5wcm9wcy52YWxpZEV4Y2VwdFN1Ym1pdCwgX3RoaXMuYXN5bmNWYWxpZGF0ZSwgX3RoaXMuZ2V0RmllbGRMaXN0KHtcbiAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVGaWVsZEFycmF5OiB0cnVlXG4gICAgICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIF90aGlzLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnByb3BzLnJlc2V0KCk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfcHJvdG8gPSBGb3JtLnByb3RvdHlwZTtcblxuICAgICAgICBfcHJvdG8uaW5pdElmTmVlZGVkID0gZnVuY3Rpb24gaW5pdElmTmVlZGVkKG5leHRQcm9wcykge1xuICAgICAgICAgIHZhciBlbmFibGVSZWluaXRpYWxpemUgPSB0aGlzLnByb3BzLmVuYWJsZVJlaW5pdGlhbGl6ZTtcblxuICAgICAgICAgIGlmIChuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgIGlmICgoZW5hYmxlUmVpbml0aWFsaXplIHx8ICFuZXh0UHJvcHMuaW5pdGlhbGl6ZWQpICYmICFkZWVwRXF1YWwodGhpcy5wcm9wcy5pbml0aWFsVmFsdWVzLCBuZXh0UHJvcHMuaW5pdGlhbFZhbHVlcykpIHtcbiAgICAgICAgICAgICAgdmFyIF9rZWVwRGlydHkgPSBuZXh0UHJvcHMuaW5pdGlhbGl6ZWQgJiYgdGhpcy5wcm9wcy5rZWVwRGlydHlPblJlaW5pdGlhbGl6ZTtcblxuICAgICAgICAgICAgICB0aGlzLnByb3BzLmluaXRpYWxpemUobmV4dFByb3BzLmluaXRpYWxWYWx1ZXMsIF9rZWVwRGlydHksIHtcbiAgICAgICAgICAgICAgICBrZWVwVmFsdWVzOiBuZXh0UHJvcHMua2VlcFZhbHVlcyxcbiAgICAgICAgICAgICAgICBsYXN0SW5pdGlhbFZhbHVlczogdGhpcy5wcm9wcy5pbml0aWFsVmFsdWVzLFxuICAgICAgICAgICAgICAgIHVwZGF0ZVVucmVnaXN0ZXJlZEZpZWxkczogbmV4dFByb3BzLnVwZGF0ZVVucmVnaXN0ZXJlZEZpZWxkc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJvcHMuaW5pdGlhbFZhbHVlcyAmJiAoIXRoaXMucHJvcHMuaW5pdGlhbGl6ZWQgfHwgZW5hYmxlUmVpbml0aWFsaXplKSkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5pbml0aWFsaXplKHRoaXMucHJvcHMuaW5pdGlhbFZhbHVlcywgdGhpcy5wcm9wcy5rZWVwRGlydHlPblJlaW5pdGlhbGl6ZSwge1xuICAgICAgICAgICAgICBrZWVwVmFsdWVzOiB0aGlzLnByb3BzLmtlZXBWYWx1ZXMsXG4gICAgICAgICAgICAgIHVwZGF0ZVVucmVnaXN0ZXJlZEZpZWxkczogdGhpcy5wcm9wcy51cGRhdGVVbnJlZ2lzdGVyZWRGaWVsZHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBfcHJvdG8udXBkYXRlU3luY0Vycm9yc0lmTmVlZGVkID0gZnVuY3Rpb24gdXBkYXRlU3luY0Vycm9yc0lmTmVlZGVkKG5leHRTeW5jRXJyb3JzLCBuZXh0RXJyb3IsIGxhc3RTeW5jRXJyb3JzKSB7XG4gICAgICAgICAgdmFyIF90aGlzJHByb3BzNCA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgIGVycm9yID0gX3RoaXMkcHJvcHM0LmVycm9yLFxuICAgICAgICAgICAgICB1cGRhdGVTeW5jRXJyb3JzID0gX3RoaXMkcHJvcHM0LnVwZGF0ZVN5bmNFcnJvcnM7XG4gICAgICAgICAgdmFyIG5vRXJyb3JzID0gKCFsYXN0U3luY0Vycm9ycyB8fCAhT2JqZWN0LmtleXMobGFzdFN5bmNFcnJvcnMpLmxlbmd0aCkgJiYgIWVycm9yO1xuICAgICAgICAgIHZhciBuZXh0Tm9FcnJvcnMgPSAoIW5leHRTeW5jRXJyb3JzIHx8ICFPYmplY3Qua2V5cyhuZXh0U3luY0Vycm9ycykubGVuZ3RoKSAmJiAhbmV4dEVycm9yO1xuXG4gICAgICAgICAgaWYgKCEobm9FcnJvcnMgJiYgbmV4dE5vRXJyb3JzKSAmJiAoIXBsYWluLmRlZXBFcXVhbChsYXN0U3luY0Vycm9ycywgbmV4dFN5bmNFcnJvcnMpIHx8ICFwbGFpbi5kZWVwRXF1YWwoZXJyb3IsIG5leHRFcnJvcikpKSB7XG4gICAgICAgICAgICB1cGRhdGVTeW5jRXJyb3JzKG5leHRTeW5jRXJyb3JzLCBuZXh0RXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBfcHJvdG8uY2xlYXJTdWJtaXRQcm9taXNlSWZOZWVkZWQgPSBmdW5jdGlvbiBjbGVhclN1Ym1pdFByb21pc2VJZk5lZWRlZChuZXh0UHJvcHMpIHtcbiAgICAgICAgICB2YXIgc3VibWl0dGluZyA9IHRoaXMucHJvcHMuc3VibWl0dGluZztcblxuICAgICAgICAgIGlmICh0aGlzLnN1Ym1pdFByb21pc2UgJiYgc3VibWl0dGluZyAmJiAhbmV4dFByb3BzLnN1Ym1pdHRpbmcpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnN1Ym1pdFByb21pc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIF9wcm90by5zdWJtaXRJZk5lZWRlZCA9IGZ1bmN0aW9uIHN1Ym1pdElmTmVlZGVkKG5leHRQcm9wcykge1xuICAgICAgICAgIHZhciBfdGhpcyRwcm9wczUgPSB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICBjbGVhclN1Ym1pdCA9IF90aGlzJHByb3BzNS5jbGVhclN1Ym1pdCxcbiAgICAgICAgICAgICAgdHJpZ2dlclN1Ym1pdCA9IF90aGlzJHByb3BzNS50cmlnZ2VyU3VibWl0O1xuXG4gICAgICAgICAgaWYgKCF0cmlnZ2VyU3VibWl0ICYmIG5leHRQcm9wcy50cmlnZ2VyU3VibWl0KSB7XG4gICAgICAgICAgICBjbGVhclN1Ym1pdCgpO1xuICAgICAgICAgICAgdGhpcy5zdWJtaXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgX3Byb3RvLnNob3VsZEVycm9yRnVuY3Rpb24gPSBmdW5jdGlvbiBzaG91bGRFcnJvckZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBfdGhpcyRwcm9wczYgPSB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICBzaG91bGRWYWxpZGF0ZSA9IF90aGlzJHByb3BzNi5zaG91bGRWYWxpZGF0ZSxcbiAgICAgICAgICAgICAgc2hvdWxkRXJyb3IgPSBfdGhpcyRwcm9wczYuc2hvdWxkRXJyb3I7XG4gICAgICAgICAgdmFyIHNob3VsZFZhbGlkYXRlT3ZlcnJpZGRlbiA9IHNob3VsZFZhbGlkYXRlICE9PSBkZWZhdWx0U2hvdWxkVmFsaWRhdGU7XG4gICAgICAgICAgdmFyIHNob3VsZEVycm9yT3ZlcnJpZGRlbiA9IHNob3VsZEVycm9yICE9PSBkZWZhdWx0U2hvdWxkRXJyb3I7XG4gICAgICAgICAgcmV0dXJuIHNob3VsZFZhbGlkYXRlT3ZlcnJpZGRlbiAmJiAhc2hvdWxkRXJyb3JPdmVycmlkZGVuID8gc2hvdWxkVmFsaWRhdGUgOiBzaG91bGRFcnJvcjtcbiAgICAgICAgfTtcblxuICAgICAgICBfcHJvdG8udmFsaWRhdGVJZk5lZWRlZCA9IGZ1bmN0aW9uIHZhbGlkYXRlSWZOZWVkZWQobmV4dFByb3BzKSB7XG4gICAgICAgICAgdmFyIF90aGlzJHByb3BzNyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgIHZhbGlkYXRlID0gX3RoaXMkcHJvcHM3LnZhbGlkYXRlLFxuICAgICAgICAgICAgICB2YWx1ZXMgPSBfdGhpcyRwcm9wczcudmFsdWVzO1xuICAgICAgICAgIHZhciBzaG91bGRFcnJvciA9IHRoaXMuc2hvdWxkRXJyb3JGdW5jdGlvbigpO1xuICAgICAgICAgIHZhciBmaWVsZExldmVsVmFsaWRhdGUgPSB0aGlzLmdlbmVyYXRlVmFsaWRhdG9yKCk7XG5cbiAgICAgICAgICBpZiAodmFsaWRhdGUgfHwgZmllbGRMZXZlbFZhbGlkYXRlKSB7XG4gICAgICAgICAgICB2YXIgaW5pdGlhbFJlbmRlciA9IG5leHRQcm9wcyA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdmFyIGZpZWxkVmFsaWRhdG9yS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuZ2V0VmFsaWRhdG9ycygpKTtcbiAgICAgICAgICAgIHZhciB2YWxpZGF0ZVBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICAgICAgICAgIG5leHRQcm9wczogbmV4dFByb3BzLFxuICAgICAgICAgICAgICBwcm9wczogdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgaW5pdGlhbFJlbmRlcjogaW5pdGlhbFJlbmRlcixcbiAgICAgICAgICAgICAgbGFzdEZpZWxkVmFsaWRhdG9yS2V5czogdGhpcy5sYXN0RmllbGRWYWxpZGF0b3JLZXlzLFxuICAgICAgICAgICAgICBmaWVsZFZhbGlkYXRvcktleXM6IGZpZWxkVmFsaWRhdG9yS2V5cyxcbiAgICAgICAgICAgICAgc3RydWN0dXJlOiBzdHJ1Y3R1cmVcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChzaG91bGRFcnJvcih2YWxpZGF0ZVBhcmFtcykpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BzVG9WYWxpZGF0ZSA9IGluaXRpYWxSZW5kZXIgfHwgIW5leHRQcm9wcyA/IHRoaXMucHJvcHMgOiBuZXh0UHJvcHM7XG5cbiAgICAgICAgICAgICAgdmFyIF9tZXJnZTIgPSBfbWVyZ2UodmFsaWRhdGUgPyB2YWxpZGF0ZShwcm9wc1RvVmFsaWRhdGUudmFsdWVzLCBwcm9wc1RvVmFsaWRhdGUpIHx8IHt9IDoge30sIGZpZWxkTGV2ZWxWYWxpZGF0ZSA/IGZpZWxkTGV2ZWxWYWxpZGF0ZShwcm9wc1RvVmFsaWRhdGUudmFsdWVzLCBwcm9wc1RvVmFsaWRhdGUpIHx8IHt9IDoge30pLFxuICAgICAgICAgICAgICAgICAgX2Vycm9yID0gX21lcmdlMi5fZXJyb3IsXG4gICAgICAgICAgICAgICAgICBuZXh0U3luY0Vycm9ycyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9tZXJnZTIsIFtcIl9lcnJvclwiXSk7XG5cbiAgICAgICAgICAgICAgdGhpcy5sYXN0RmllbGRWYWxpZGF0b3JLZXlzID0gZmllbGRWYWxpZGF0b3JLZXlzO1xuICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN5bmNFcnJvcnNJZk5lZWRlZChuZXh0U3luY0Vycm9ycywgX2Vycm9yLCBwcm9wc1RvVmFsaWRhdGUuc3luY0Vycm9ycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGFzdEZpZWxkVmFsaWRhdG9yS2V5cyA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBfcHJvdG8udXBkYXRlU3luY1dhcm5pbmdzSWZOZWVkZWQgPSBmdW5jdGlvbiB1cGRhdGVTeW5jV2FybmluZ3NJZk5lZWRlZChuZXh0U3luY1dhcm5pbmdzLCBuZXh0V2FybmluZywgbGFzdFN5bmNXYXJuaW5ncykge1xuICAgICAgICAgIHZhciBfdGhpcyRwcm9wczggPSB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICB3YXJuaW5nID0gX3RoaXMkcHJvcHM4Lndhcm5pbmcsXG4gICAgICAgICAgICAgIHN5bmNXYXJuaW5ncyA9IF90aGlzJHByb3BzOC5zeW5jV2FybmluZ3MsXG4gICAgICAgICAgICAgIHVwZGF0ZVN5bmNXYXJuaW5ncyA9IF90aGlzJHByb3BzOC51cGRhdGVTeW5jV2FybmluZ3M7XG4gICAgICAgICAgdmFyIG5vV2FybmluZ3MgPSAoIXN5bmNXYXJuaW5ncyB8fCAhT2JqZWN0LmtleXMoc3luY1dhcm5pbmdzKS5sZW5ndGgpICYmICF3YXJuaW5nO1xuICAgICAgICAgIHZhciBuZXh0Tm9XYXJuaW5ncyA9ICghbmV4dFN5bmNXYXJuaW5ncyB8fCAhT2JqZWN0LmtleXMobmV4dFN5bmNXYXJuaW5ncykubGVuZ3RoKSAmJiAhbmV4dFdhcm5pbmc7XG5cbiAgICAgICAgICBpZiAoIShub1dhcm5pbmdzICYmIG5leHROb1dhcm5pbmdzKSAmJiAoIXBsYWluLmRlZXBFcXVhbChsYXN0U3luY1dhcm5pbmdzLCBuZXh0U3luY1dhcm5pbmdzKSB8fCAhcGxhaW4uZGVlcEVxdWFsKHdhcm5pbmcsIG5leHRXYXJuaW5nKSkpIHtcbiAgICAgICAgICAgIHVwZGF0ZVN5bmNXYXJuaW5ncyhuZXh0U3luY1dhcm5pbmdzLCBuZXh0V2FybmluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIF9wcm90by5zaG91bGRXYXJuRnVuY3Rpb24gPSBmdW5jdGlvbiBzaG91bGRXYXJuRnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIF90aGlzJHByb3BzOSA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgIHNob3VsZFZhbGlkYXRlID0gX3RoaXMkcHJvcHM5LnNob3VsZFZhbGlkYXRlLFxuICAgICAgICAgICAgICBzaG91bGRXYXJuID0gX3RoaXMkcHJvcHM5LnNob3VsZFdhcm47XG4gICAgICAgICAgdmFyIHNob3VsZFZhbGlkYXRlT3ZlcnJpZGRlbiA9IHNob3VsZFZhbGlkYXRlICE9PSBkZWZhdWx0U2hvdWxkVmFsaWRhdGU7XG4gICAgICAgICAgdmFyIHNob3VsZFdhcm5PdmVycmlkZGVuID0gc2hvdWxkV2FybiAhPT0gZGVmYXVsdFNob3VsZFdhcm47XG4gICAgICAgICAgcmV0dXJuIHNob3VsZFZhbGlkYXRlT3ZlcnJpZGRlbiAmJiAhc2hvdWxkV2Fybk92ZXJyaWRkZW4gPyBzaG91bGRWYWxpZGF0ZSA6IHNob3VsZFdhcm47XG4gICAgICAgIH07XG5cbiAgICAgICAgX3Byb3RvLndhcm5JZk5lZWRlZCA9IGZ1bmN0aW9uIHdhcm5JZk5lZWRlZChuZXh0UHJvcHMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMkcHJvcHMxMCA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgIHdhcm4gPSBfdGhpcyRwcm9wczEwLndhcm4sXG4gICAgICAgICAgICAgIHZhbHVlcyA9IF90aGlzJHByb3BzMTAudmFsdWVzO1xuICAgICAgICAgIHZhciBzaG91bGRXYXJuID0gdGhpcy5zaG91bGRXYXJuRnVuY3Rpb24oKTtcbiAgICAgICAgICB2YXIgZmllbGRMZXZlbFdhcm4gPSB0aGlzLmdlbmVyYXRlV2FybmVyKCk7XG5cbiAgICAgICAgICBpZiAod2FybiB8fCBmaWVsZExldmVsV2Fybikge1xuICAgICAgICAgICAgdmFyIGluaXRpYWxSZW5kZXIgPSBuZXh0UHJvcHMgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHZhciBmaWVsZFdhcm5lcktleXMgPSBPYmplY3Qua2V5cyh0aGlzLmdldFdhcm5lcnMoKSk7XG4gICAgICAgICAgICB2YXIgdmFsaWRhdGVQYXJhbXMgPSB7XG4gICAgICAgICAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgICAgICAgICBuZXh0UHJvcHM6IG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgcHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgIGluaXRpYWxSZW5kZXI6IGluaXRpYWxSZW5kZXIsXG4gICAgICAgICAgICAgIGxhc3RGaWVsZFZhbGlkYXRvcktleXM6IHRoaXMubGFzdEZpZWxkV2FybmVyS2V5cyxcbiAgICAgICAgICAgICAgZmllbGRWYWxpZGF0b3JLZXlzOiBmaWVsZFdhcm5lcktleXMsXG4gICAgICAgICAgICAgIHN0cnVjdHVyZTogc3RydWN0dXJlXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoc2hvdWxkV2Fybih2YWxpZGF0ZVBhcmFtcykpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BzVG9XYXJuID0gaW5pdGlhbFJlbmRlciB8fCAhbmV4dFByb3BzID8gdGhpcy5wcm9wcyA6IG5leHRQcm9wcztcblxuICAgICAgICAgICAgICB2YXIgX21lcmdlMyA9IF9tZXJnZSh3YXJuID8gd2Fybihwcm9wc1RvV2Fybi52YWx1ZXMsIHByb3BzVG9XYXJuKSA6IHt9LCBmaWVsZExldmVsV2FybiA/IGZpZWxkTGV2ZWxXYXJuKHByb3BzVG9XYXJuLnZhbHVlcywgcHJvcHNUb1dhcm4pIDoge30pLFxuICAgICAgICAgICAgICAgICAgX3dhcm5pbmcgPSBfbWVyZ2UzLl93YXJuaW5nLFxuICAgICAgICAgICAgICAgICAgbmV4dFN5bmNXYXJuaW5ncyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9tZXJnZTMsIFtcIl93YXJuaW5nXCJdKTtcblxuICAgICAgICAgICAgICB0aGlzLmxhc3RGaWVsZFdhcm5lcktleXMgPSBmaWVsZFdhcm5lcktleXM7XG4gICAgICAgICAgICAgIHRoaXMudXBkYXRlU3luY1dhcm5pbmdzSWZOZWVkZWQobmV4dFN5bmNXYXJuaW5ncywgX3dhcm5pbmcsIHByb3BzVG9XYXJuLnN5bmNXYXJuaW5ncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIF9wcm90by5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICAgICAgaWYgKCFpc0hvdFJlbG9hZGluZygpKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRJZk5lZWRlZCgpO1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUlmTmVlZGVkKCk7XG4gICAgICAgICAgICB0aGlzLndhcm5JZk5lZWRlZCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGludmFyaWFudCh0aGlzLnByb3BzLnNob3VsZFZhbGlkYXRlLCAnc2hvdWxkVmFsaWRhdGUoKSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdjkuMC4wLiBVc2Ugc2hvdWxkV2FybigpIG9yIHNob3VsZEVycm9yKCkgaW5zdGVhZC4nKTtcbiAgICAgICAgfTtcblxuICAgICAgICBfcHJvdG8uY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICAgICAgdGhpcy5pbml0SWZOZWVkZWQobmV4dFByb3BzKTtcbiAgICAgICAgICB0aGlzLnZhbGlkYXRlSWZOZWVkZWQobmV4dFByb3BzKTtcbiAgICAgICAgICB0aGlzLndhcm5JZk5lZWRlZChuZXh0UHJvcHMpO1xuICAgICAgICAgIHRoaXMuY2xlYXJTdWJtaXRQcm9taXNlSWZOZWVkZWQobmV4dFByb3BzKTtcbiAgICAgICAgICB0aGlzLnN1Ym1pdElmTmVlZGVkKG5leHRQcm9wcyk7XG4gICAgICAgICAgdmFyIG9uQ2hhbmdlID0gbmV4dFByb3BzLm9uQ2hhbmdlLFxuICAgICAgICAgICAgICB2YWx1ZXMgPSBuZXh0UHJvcHMudmFsdWVzLFxuICAgICAgICAgICAgICBkaXNwYXRjaCA9IG5leHRQcm9wcy5kaXNwYXRjaDtcblxuICAgICAgICAgIGlmIChvbkNoYW5nZSAmJiAhZGVlcEVxdWFsKHZhbHVlcywgdGhpcy5wcm9wcy52YWx1ZXMpKSB7XG4gICAgICAgICAgICBvbkNoYW5nZSh2YWx1ZXMsIGRpc3BhdGNoLCBuZXh0UHJvcHMsIHRoaXMucHJvcHMudmFsdWVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgX3Byb3RvLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAgIGlmICghdGhpcy5wcm9wcy5wdXJlKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB2YXIgX2NvbmZpZyRpbW11dGFibGVQcm9wID0gY29uZmlnLmltbXV0YWJsZVByb3BzLFxuICAgICAgICAgICAgICBpbW11dGFibGVQcm9wcyA9IF9jb25maWckaW1tdXRhYmxlUHJvcCA9PT0gdm9pZCAwID8gW10gOiBfY29uZmlnJGltbXV0YWJsZVByb3A7IC8vIGlmIHdlIGhhdmUgY2hpbGRyZW4sIHdlIE1VU1QgdXBkYXRlIGluIFJlYWN0IDE2XG4gICAgICAgICAgLy8gaHR0cHM6Ly90d2l0dGVyLmNvbS9lcmlrcmFzL3N0YXR1cy85MTU4NjY1NDQ1NTg3ODg2MDhcblxuICAgICAgICAgIHJldHVybiAhISh0aGlzLnByb3BzLmNoaWxkcmVuIHx8IG5leHRQcm9wcy5jaGlsZHJlbiB8fCBPYmplY3Qua2V5cyhuZXh0UHJvcHMpLnNvbWUoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIC8vIHVzZWZ1bCB0byBkZWJ1ZyByZXJlbmRlcnNcbiAgICAgICAgICAgIC8vIGlmICghcGxhaW4uZGVlcEVxdWFsKHRoaXMucHJvcHNbIHByb3AgXSwgbmV4dFByb3BzWyBwcm9wIF0pKSB7XG4gICAgICAgICAgICAvLyAgIGNvbnNvbGUuaW5mbyhwcm9wLCAnY2hhbmdlZCcsIHRoaXMucHJvcHNbIHByb3AgXSwgJz09PicsIG5leHRQcm9wc1sgcHJvcCBdKVxuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgaWYgKH5pbW11dGFibGVQcm9wcy5pbmRleE9mKHByb3ApKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczIucHJvcHNbcHJvcF0gIT09IG5leHRQcm9wc1twcm9wXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICF+cHJvcHNUb05vdFVwZGF0ZUZvci5pbmRleE9mKHByb3ApICYmICFkZWVwRXF1YWwoX3RoaXMyLnByb3BzW3Byb3BdLCBuZXh0UHJvcHNbcHJvcF0pO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcblxuICAgICAgICBfcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgICBpZiAoIWlzSG90UmVsb2FkaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdElmTmVlZGVkKHRoaXMucHJvcHMpO1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUlmTmVlZGVkKCk7XG4gICAgICAgICAgICB0aGlzLndhcm5JZk5lZWRlZCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGludmFyaWFudCh0aGlzLnByb3BzLnNob3VsZFZhbGlkYXRlLCAnc2hvdWxkVmFsaWRhdGUoKSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdjkuMC4wLiBVc2Ugc2hvdWxkV2FybigpIG9yIHNob3VsZEVycm9yKCkgaW5zdGVhZC4nKTtcbiAgICAgICAgfTtcblxuICAgICAgICBfcHJvdG8uY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgICB2YXIgX3RoaXMkcHJvcHMxMSA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgIGRlc3Ryb3lPblVubW91bnQgPSBfdGhpcyRwcm9wczExLmRlc3Ryb3lPblVubW91bnQsXG4gICAgICAgICAgICAgIGRlc3Ryb3kgPSBfdGhpcyRwcm9wczExLmRlc3Ryb3k7XG5cbiAgICAgICAgICBpZiAoZGVzdHJveU9uVW5tb3VudCAmJiAhaXNIb3RSZWxvYWRpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICAgICAgZGVzdHJveSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICAgIHZhciBfcmVmLFxuICAgICAgICAgICAgICBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgICAgLy8gcmVtb3ZlIHNvbWUgcmVkdXgtZm9ybSBjb25maWctb25seSBwcm9wc1xuXG4gICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgICAgICAgICB2YXIgX3RoaXMkcHJvcHMxMiA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgIGFueVRvdWNoZWQgPSBfdGhpcyRwcm9wczEyLmFueVRvdWNoZWQsXG4gICAgICAgICAgICAgIGFycmF5ID0gX3RoaXMkcHJvcHMxMi5hcnJheSxcbiAgICAgICAgICAgICAgYXJyYXlJbnNlcnQgPSBfdGhpcyRwcm9wczEyLmFycmF5SW5zZXJ0LFxuICAgICAgICAgICAgICBhcnJheU1vdmUgPSBfdGhpcyRwcm9wczEyLmFycmF5TW92ZSxcbiAgICAgICAgICAgICAgYXJyYXlQb3AgPSBfdGhpcyRwcm9wczEyLmFycmF5UG9wLFxuICAgICAgICAgICAgICBhcnJheVB1c2ggPSBfdGhpcyRwcm9wczEyLmFycmF5UHVzaCxcbiAgICAgICAgICAgICAgYXJyYXlSZW1vdmUgPSBfdGhpcyRwcm9wczEyLmFycmF5UmVtb3ZlLFxuICAgICAgICAgICAgICBhcnJheVJlbW92ZUFsbCA9IF90aGlzJHByb3BzMTIuYXJyYXlSZW1vdmVBbGwsXG4gICAgICAgICAgICAgIGFycmF5U2hpZnQgPSBfdGhpcyRwcm9wczEyLmFycmF5U2hpZnQsXG4gICAgICAgICAgICAgIGFycmF5U3BsaWNlID0gX3RoaXMkcHJvcHMxMi5hcnJheVNwbGljZSxcbiAgICAgICAgICAgICAgYXJyYXlTd2FwID0gX3RoaXMkcHJvcHMxMi5hcnJheVN3YXAsXG4gICAgICAgICAgICAgIGFycmF5VW5zaGlmdCA9IF90aGlzJHByb3BzMTIuYXJyYXlVbnNoaWZ0LFxuICAgICAgICAgICAgICBhc3luY0Vycm9ycyA9IF90aGlzJHByb3BzMTIuYXN5bmNFcnJvcnMsXG4gICAgICAgICAgICAgIGFzeW5jVmFsaWRhdGUgPSBfdGhpcyRwcm9wczEyLmFzeW5jVmFsaWRhdGUsXG4gICAgICAgICAgICAgIGFzeW5jVmFsaWRhdGluZyA9IF90aGlzJHByb3BzMTIuYXN5bmNWYWxpZGF0aW5nLFxuICAgICAgICAgICAgICBibHVyID0gX3RoaXMkcHJvcHMxMi5ibHVyLFxuICAgICAgICAgICAgICBjaGFuZ2UgPSBfdGhpcyRwcm9wczEyLmNoYW5nZSxcbiAgICAgICAgICAgICAgY2xlYXJTdWJtaXQgPSBfdGhpcyRwcm9wczEyLmNsZWFyU3VibWl0LFxuICAgICAgICAgICAgICBkZXN0cm95ID0gX3RoaXMkcHJvcHMxMi5kZXN0cm95LFxuICAgICAgICAgICAgICBkZXN0cm95T25Vbm1vdW50ID0gX3RoaXMkcHJvcHMxMi5kZXN0cm95T25Vbm1vdW50LFxuICAgICAgICAgICAgICBmb3JjZVVucmVnaXN0ZXJPblVubW91bnQgPSBfdGhpcyRwcm9wczEyLmZvcmNlVW5yZWdpc3Rlck9uVW5tb3VudCxcbiAgICAgICAgICAgICAgZGlydHkgPSBfdGhpcyRwcm9wczEyLmRpcnR5LFxuICAgICAgICAgICAgICBkaXNwYXRjaCA9IF90aGlzJHByb3BzMTIuZGlzcGF0Y2gsXG4gICAgICAgICAgICAgIGVuYWJsZVJlaW5pdGlhbGl6ZSA9IF90aGlzJHByb3BzMTIuZW5hYmxlUmVpbml0aWFsaXplLFxuICAgICAgICAgICAgICBlcnJvciA9IF90aGlzJHByb3BzMTIuZXJyb3IsXG4gICAgICAgICAgICAgIGZvY3VzID0gX3RoaXMkcHJvcHMxMi5mb2N1cyxcbiAgICAgICAgICAgICAgZm9ybSA9IF90aGlzJHByb3BzMTIuZm9ybSxcbiAgICAgICAgICAgICAgZ2V0Rm9ybVN0YXRlID0gX3RoaXMkcHJvcHMxMi5nZXRGb3JtU3RhdGUsXG4gICAgICAgICAgICAgIGltbXV0YWJsZVByb3BzID0gX3RoaXMkcHJvcHMxMi5pbW11dGFibGVQcm9wcyxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6ZSA9IF90aGlzJHByb3BzMTIuaW5pdGlhbGl6ZSxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6ZWQgPSBfdGhpcyRwcm9wczEyLmluaXRpYWxpemVkLFxuICAgICAgICAgICAgICBpbml0aWFsVmFsdWVzID0gX3RoaXMkcHJvcHMxMi5pbml0aWFsVmFsdWVzLFxuICAgICAgICAgICAgICBpbnZhbGlkID0gX3RoaXMkcHJvcHMxMi5pbnZhbGlkLFxuICAgICAgICAgICAgICBrZWVwRGlydHlPblJlaW5pdGlhbGl6ZSA9IF90aGlzJHByb3BzMTIua2VlcERpcnR5T25SZWluaXRpYWxpemUsXG4gICAgICAgICAgICAgIGtlZXBWYWx1ZXMgPSBfdGhpcyRwcm9wczEyLmtlZXBWYWx1ZXMsXG4gICAgICAgICAgICAgIHVwZGF0ZVVucmVnaXN0ZXJlZEZpZWxkcyA9IF90aGlzJHByb3BzMTIudXBkYXRlVW5yZWdpc3RlcmVkRmllbGRzLFxuICAgICAgICAgICAgICBwcmlzdGluZSA9IF90aGlzJHByb3BzMTIucHJpc3RpbmUsXG4gICAgICAgICAgICAgIHByb3BOYW1lc3BhY2UgPSBfdGhpcyRwcm9wczEyLnByb3BOYW1lc3BhY2UsXG4gICAgICAgICAgICAgIHJlZ2lzdGVyZWRGaWVsZHMgPSBfdGhpcyRwcm9wczEyLnJlZ2lzdGVyZWRGaWVsZHMsXG4gICAgICAgICAgICAgIHJlZ2lzdGVyRmllbGQgPSBfdGhpcyRwcm9wczEyLnJlZ2lzdGVyRmllbGQsXG4gICAgICAgICAgICAgIHJlc2V0ID0gX3RoaXMkcHJvcHMxMi5yZXNldCxcbiAgICAgICAgICAgICAgcmVzZXRTZWN0aW9uID0gX3RoaXMkcHJvcHMxMi5yZXNldFNlY3Rpb24sXG4gICAgICAgICAgICAgIHNldFN1Ym1pdEZhaWxlZCA9IF90aGlzJHByb3BzMTIuc2V0U3VibWl0RmFpbGVkLFxuICAgICAgICAgICAgICBzZXRTdWJtaXRTdWNjZWVkZWQgPSBfdGhpcyRwcm9wczEyLnNldFN1Ym1pdFN1Y2NlZWRlZCxcbiAgICAgICAgICAgICAgc2hvdWxkQXN5bmNWYWxpZGF0ZSA9IF90aGlzJHByb3BzMTIuc2hvdWxkQXN5bmNWYWxpZGF0ZSxcbiAgICAgICAgICAgICAgc2hvdWxkVmFsaWRhdGUgPSBfdGhpcyRwcm9wczEyLnNob3VsZFZhbGlkYXRlLFxuICAgICAgICAgICAgICBzaG91bGRFcnJvciA9IF90aGlzJHByb3BzMTIuc2hvdWxkRXJyb3IsXG4gICAgICAgICAgICAgIHNob3VsZFdhcm4gPSBfdGhpcyRwcm9wczEyLnNob3VsZFdhcm4sXG4gICAgICAgICAgICAgIHN0YXJ0QXN5bmNWYWxpZGF0aW9uID0gX3RoaXMkcHJvcHMxMi5zdGFydEFzeW5jVmFsaWRhdGlvbixcbiAgICAgICAgICAgICAgc3RhcnRTdWJtaXQgPSBfdGhpcyRwcm9wczEyLnN0YXJ0U3VibWl0LFxuICAgICAgICAgICAgICBzdG9wQXN5bmNWYWxpZGF0aW9uID0gX3RoaXMkcHJvcHMxMi5zdG9wQXN5bmNWYWxpZGF0aW9uLFxuICAgICAgICAgICAgICBzdG9wU3VibWl0ID0gX3RoaXMkcHJvcHMxMi5zdG9wU3VibWl0LFxuICAgICAgICAgICAgICBzdWJtaXR0aW5nID0gX3RoaXMkcHJvcHMxMi5zdWJtaXR0aW5nLFxuICAgICAgICAgICAgICBzdWJtaXRGYWlsZWQgPSBfdGhpcyRwcm9wczEyLnN1Ym1pdEZhaWxlZCxcbiAgICAgICAgICAgICAgc3VibWl0U3VjY2VlZGVkID0gX3RoaXMkcHJvcHMxMi5zdWJtaXRTdWNjZWVkZWQsXG4gICAgICAgICAgICAgIHRvdWNoID0gX3RoaXMkcHJvcHMxMi50b3VjaCxcbiAgICAgICAgICAgICAgdG91Y2hPbkJsdXIgPSBfdGhpcyRwcm9wczEyLnRvdWNoT25CbHVyLFxuICAgICAgICAgICAgICB0b3VjaE9uQ2hhbmdlID0gX3RoaXMkcHJvcHMxMi50b3VjaE9uQ2hhbmdlLFxuICAgICAgICAgICAgICBwZXJzaXN0ZW50U3VibWl0RXJyb3JzID0gX3RoaXMkcHJvcHMxMi5wZXJzaXN0ZW50U3VibWl0RXJyb3JzLFxuICAgICAgICAgICAgICBzeW5jRXJyb3JzID0gX3RoaXMkcHJvcHMxMi5zeW5jRXJyb3JzLFxuICAgICAgICAgICAgICBzeW5jV2FybmluZ3MgPSBfdGhpcyRwcm9wczEyLnN5bmNXYXJuaW5ncyxcbiAgICAgICAgICAgICAgdW5yZWdpc3RlckZpZWxkID0gX3RoaXMkcHJvcHMxMi51bnJlZ2lzdGVyRmllbGQsXG4gICAgICAgICAgICAgIHVudG91Y2ggPSBfdGhpcyRwcm9wczEyLnVudG91Y2gsXG4gICAgICAgICAgICAgIHVwZGF0ZVN5bmNFcnJvcnMgPSBfdGhpcyRwcm9wczEyLnVwZGF0ZVN5bmNFcnJvcnMsXG4gICAgICAgICAgICAgIHVwZGF0ZVN5bmNXYXJuaW5ncyA9IF90aGlzJHByb3BzMTIudXBkYXRlU3luY1dhcm5pbmdzLFxuICAgICAgICAgICAgICB2YWxpZCA9IF90aGlzJHByb3BzMTIudmFsaWQsXG4gICAgICAgICAgICAgIHZhbGlkRXhjZXB0U3VibWl0ID0gX3RoaXMkcHJvcHMxMi52YWxpZEV4Y2VwdFN1Ym1pdCxcbiAgICAgICAgICAgICAgdmFsdWVzID0gX3RoaXMkcHJvcHMxMi52YWx1ZXMsXG4gICAgICAgICAgICAgIHdhcm5pbmcgPSBfdGhpcyRwcm9wczEyLndhcm5pbmcsXG4gICAgICAgICAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdGhpcyRwcm9wczEyLCBbXCJhbnlUb3VjaGVkXCIsIFwiYXJyYXlcIiwgXCJhcnJheUluc2VydFwiLCBcImFycmF5TW92ZVwiLCBcImFycmF5UG9wXCIsIFwiYXJyYXlQdXNoXCIsIFwiYXJyYXlSZW1vdmVcIiwgXCJhcnJheVJlbW92ZUFsbFwiLCBcImFycmF5U2hpZnRcIiwgXCJhcnJheVNwbGljZVwiLCBcImFycmF5U3dhcFwiLCBcImFycmF5VW5zaGlmdFwiLCBcImFzeW5jRXJyb3JzXCIsIFwiYXN5bmNWYWxpZGF0ZVwiLCBcImFzeW5jVmFsaWRhdGluZ1wiLCBcImJsdXJcIiwgXCJjaGFuZ2VcIiwgXCJjbGVhclN1Ym1pdFwiLCBcImRlc3Ryb3lcIiwgXCJkZXN0cm95T25Vbm1vdW50XCIsIFwiZm9yY2VVbnJlZ2lzdGVyT25Vbm1vdW50XCIsIFwiZGlydHlcIiwgXCJkaXNwYXRjaFwiLCBcImVuYWJsZVJlaW5pdGlhbGl6ZVwiLCBcImVycm9yXCIsIFwiZm9jdXNcIiwgXCJmb3JtXCIsIFwiZ2V0Rm9ybVN0YXRlXCIsIFwiaW1tdXRhYmxlUHJvcHNcIiwgXCJpbml0aWFsaXplXCIsIFwiaW5pdGlhbGl6ZWRcIiwgXCJpbml0aWFsVmFsdWVzXCIsIFwiaW52YWxpZFwiLCBcImtlZXBEaXJ0eU9uUmVpbml0aWFsaXplXCIsIFwia2VlcFZhbHVlc1wiLCBcInVwZGF0ZVVucmVnaXN0ZXJlZEZpZWxkc1wiLCBcInByaXN0aW5lXCIsIFwicHJvcE5hbWVzcGFjZVwiLCBcInJlZ2lzdGVyZWRGaWVsZHNcIiwgXCJyZWdpc3RlckZpZWxkXCIsIFwicmVzZXRcIiwgXCJyZXNldFNlY3Rpb25cIiwgXCJzZXRTdWJtaXRGYWlsZWRcIiwgXCJzZXRTdWJtaXRTdWNjZWVkZWRcIiwgXCJzaG91bGRBc3luY1ZhbGlkYXRlXCIsIFwic2hvdWxkVmFsaWRhdGVcIiwgXCJzaG91bGRFcnJvclwiLCBcInNob3VsZFdhcm5cIiwgXCJzdGFydEFzeW5jVmFsaWRhdGlvblwiLCBcInN0YXJ0U3VibWl0XCIsIFwic3RvcEFzeW5jVmFsaWRhdGlvblwiLCBcInN0b3BTdWJtaXRcIiwgXCJzdWJtaXR0aW5nXCIsIFwic3VibWl0RmFpbGVkXCIsIFwic3VibWl0U3VjY2VlZGVkXCIsIFwidG91Y2hcIiwgXCJ0b3VjaE9uQmx1clwiLCBcInRvdWNoT25DaGFuZ2VcIiwgXCJwZXJzaXN0ZW50U3VibWl0RXJyb3JzXCIsIFwic3luY0Vycm9yc1wiLCBcInN5bmNXYXJuaW5nc1wiLCBcInVucmVnaXN0ZXJGaWVsZFwiLCBcInVudG91Y2hcIiwgXCJ1cGRhdGVTeW5jRXJyb3JzXCIsIFwidXBkYXRlU3luY1dhcm5pbmdzXCIsIFwidmFsaWRcIiwgXCJ2YWxpZEV4Y2VwdFN1Ym1pdFwiLCBcInZhbHVlc1wiLCBcIndhcm5pbmdcIl0pO1xuICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuXG4gICAgICAgICAgdmFyIHJlZHV4Rm9ybVByb3BzID0gX2V4dGVuZHMoe1xuICAgICAgICAgICAgYXJyYXk6IGFycmF5LFxuICAgICAgICAgICAgYW55VG91Y2hlZDogYW55VG91Y2hlZCxcbiAgICAgICAgICAgIGFzeW5jVmFsaWRhdGU6IHRoaXMuYXN5bmNWYWxpZGF0ZSxcbiAgICAgICAgICAgIGFzeW5jVmFsaWRhdGluZzogYXN5bmNWYWxpZGF0aW5nXG4gICAgICAgICAgfSwgYmluZEFjdGlvbkNyZWF0b3JzKHtcbiAgICAgICAgICAgIGJsdXI6IGJsdXIsXG4gICAgICAgICAgICBjaGFuZ2U6IGNoYW5nZVxuICAgICAgICAgIH0sIGRpc3BhdGNoKSwge1xuICAgICAgICAgICAgY2xlYXJTdWJtaXQ6IGNsZWFyU3VibWl0LFxuICAgICAgICAgICAgZGVzdHJveTogZGVzdHJveSxcbiAgICAgICAgICAgIGRpcnR5OiBkaXJ0eSxcbiAgICAgICAgICAgIGRpc3BhdGNoOiBkaXNwYXRjaCxcbiAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgIGZvcm06IGZvcm0sXG4gICAgICAgICAgICBoYW5kbGVTdWJtaXQ6IHRoaXMuc3VibWl0LFxuICAgICAgICAgICAgaW5pdGlhbGl6ZTogaW5pdGlhbGl6ZSxcbiAgICAgICAgICAgIGluaXRpYWxpemVkOiBpbml0aWFsaXplZCxcbiAgICAgICAgICAgIGluaXRpYWxWYWx1ZXM6IGluaXRpYWxWYWx1ZXMsXG4gICAgICAgICAgICBpbnZhbGlkOiBpbnZhbGlkLFxuICAgICAgICAgICAgcHJpc3RpbmU6IHByaXN0aW5lLFxuICAgICAgICAgICAgcmVzZXQ6IHJlc2V0LFxuICAgICAgICAgICAgcmVzZXRTZWN0aW9uOiByZXNldFNlY3Rpb24sXG4gICAgICAgICAgICBzdWJtaXR0aW5nOiBzdWJtaXR0aW5nLFxuICAgICAgICAgICAgc3VibWl0RmFpbGVkOiBzdWJtaXRGYWlsZWQsXG4gICAgICAgICAgICBzdWJtaXRTdWNjZWVkZWQ6IHN1Ym1pdFN1Y2NlZWRlZCxcbiAgICAgICAgICAgIHRvdWNoOiB0b3VjaCxcbiAgICAgICAgICAgIHVudG91Y2g6IHVudG91Y2gsXG4gICAgICAgICAgICB2YWxpZDogdmFsaWQsXG4gICAgICAgICAgICB3YXJuaW5nOiB3YXJuaW5nXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgcHJvcHNUb1Bhc3MgPSBfZXh0ZW5kcyh7fSwgcHJvcE5hbWVzcGFjZSA/IChfcmVmID0ge30sIF9yZWZbcHJvcE5hbWVzcGFjZV0gPSByZWR1eEZvcm1Qcm9wcywgX3JlZikgOiByZWR1eEZvcm1Qcm9wcywgcmVzdCk7XG5cbiAgICAgICAgICBpZiAoaXNDbGFzc0NvbXBvbmVudChXcmFwcGVkQ29tcG9uZW50KSkge1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgcHJvcHNUb1Bhc3MucmVmID0gdGhpcy53cmFwcGVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfcmVkdXhGb3JtID0gX2V4dGVuZHMoe30sIHRoaXMucHJvcHMsIHtcbiAgICAgICAgICAgIGdldEZvcm1TdGF0ZTogZnVuY3Rpb24gZ2V0Rm9ybVN0YXRlKHN0YXRlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRJbihfdGhpczMucHJvcHMuZ2V0Rm9ybVN0YXRlKHN0YXRlKSwgX3RoaXMzLnByb3BzLmZvcm0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFzeW5jVmFsaWRhdGU6IHRoaXMuYXN5bmNWYWxpZGF0ZSxcbiAgICAgICAgICAgIGdldFZhbHVlczogdGhpcy5nZXRWYWx1ZXMsXG4gICAgICAgICAgICBzZWN0aW9uUHJlZml4OiB1bmRlZmluZWQsXG4gICAgICAgICAgICByZWdpc3RlcjogdGhpcy5yZWdpc3RlcixcbiAgICAgICAgICAgIHVucmVnaXN0ZXI6IHRoaXMudW5yZWdpc3RlcixcbiAgICAgICAgICAgIHJlZ2lzdGVySW5uZXJPblN1Ym1pdDogZnVuY3Rpb24gcmVnaXN0ZXJJbm5lck9uU3VibWl0KGlubmVyT25TdWJtaXQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5pbm5lck9uU3VibWl0ID0gaW5uZXJPblN1Ym1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFJlZHV4Rm9ybUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgICAgIHZhbHVlOiBfcmVkdXhGb3JtLFxuICAgICAgICAgICAgY2hpbGRyZW46IGNyZWF0ZUVsZW1lbnQoV3JhcHBlZENvbXBvbmVudCwgcHJvcHNUb1Bhc3MpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIEZvcm07XG4gICAgICB9KFJlYWN0LkNvbXBvbmVudCk7XG5cbiAgICAgIEZvcm0uZGlzcGxheU5hbWUgPSBcIkZvcm0oXCIgKyBnZXREaXNwbGF5TmFtZShXcmFwcGVkQ29tcG9uZW50KSArIFwiKVwiO1xuICAgICAgRm9ybS5XcmFwcGVkQ29tcG9uZW50ID0gV3JhcHBlZENvbXBvbmVudDtcbiAgICAgIEZvcm0ucHJvcFR5cGVzID0ge1xuICAgICAgICBkZXN0cm95T25Vbm1vdW50OiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgZm9yY2VVbnJlZ2lzdGVyT25Vbm1vdW50OiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgZm9ybTogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgICAgICBpbW11dGFibGVQcm9wczogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLnN0cmluZyksXG4gICAgICAgIGluaXRpYWxWYWx1ZXM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5hcnJheSwgUHJvcFR5cGVzLm9iamVjdF0pLFxuICAgICAgICBnZXRGb3JtU3RhdGU6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBvblN1Ym1pdEZhaWw6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBvblN1Ym1pdFN1Y2Nlc3M6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBwcm9wTmFtZXNwYWNlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICB2YWxpZGF0ZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIHdhcm46IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICB0b3VjaE9uQmx1cjogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIHRvdWNoT25DaGFuZ2U6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICB0cmlnZ2VyU3VibWl0OiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgcGVyc2lzdGVudFN1Ym1pdEVycm9yczogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIHJlZ2lzdGVyZWRGaWVsZHM6IFByb3BUeXBlcy5hbnlcbiAgICAgIH07XG4gICAgICB2YXIgY29ubmVjdG9yID0gY29ubmVjdChmdW5jdGlvbiAoc3RhdGUsIHByb3BzKSB7XG4gICAgICAgIHZhciBmb3JtID0gcHJvcHMuZm9ybSxcbiAgICAgICAgICAgIGdldEZvcm1TdGF0ZSA9IHByb3BzLmdldEZvcm1TdGF0ZSxcbiAgICAgICAgICAgIGluaXRpYWxWYWx1ZXMgPSBwcm9wcy5pbml0aWFsVmFsdWVzLFxuICAgICAgICAgICAgZW5hYmxlUmVpbml0aWFsaXplID0gcHJvcHMuZW5hYmxlUmVpbml0aWFsaXplLFxuICAgICAgICAgICAga2VlcERpcnR5T25SZWluaXRpYWxpemUgPSBwcm9wcy5rZWVwRGlydHlPblJlaW5pdGlhbGl6ZTtcbiAgICAgICAgdmFyIGZvcm1TdGF0ZSA9IGdldEluKGdldEZvcm1TdGF0ZShzdGF0ZSkgfHwgZW1wdHksIGZvcm0pIHx8IGVtcHR5O1xuICAgICAgICB2YXIgc3RhdGVJbml0aWFsID0gZ2V0SW4oZm9ybVN0YXRlLCAnaW5pdGlhbCcpO1xuICAgICAgICB2YXIgaW5pdGlhbGl6ZWQgPSAhIXN0YXRlSW5pdGlhbDtcbiAgICAgICAgdmFyIHNob3VsZFVwZGF0ZUluaXRpYWxWYWx1ZXMgPSBlbmFibGVSZWluaXRpYWxpemUgJiYgaW5pdGlhbGl6ZWQgJiYgIWRlZXBFcXVhbChpbml0aWFsVmFsdWVzLCBzdGF0ZUluaXRpYWwpO1xuICAgICAgICB2YXIgc2hvdWxkUmVzZXRWYWx1ZXMgPSBzaG91bGRVcGRhdGVJbml0aWFsVmFsdWVzICYmICFrZWVwRGlydHlPblJlaW5pdGlhbGl6ZTtcbiAgICAgICAgdmFyIGluaXRpYWwgPSBpbml0aWFsVmFsdWVzIHx8IHN0YXRlSW5pdGlhbCB8fCBlbXB0eTtcblxuICAgICAgICBpZiAoIXNob3VsZFVwZGF0ZUluaXRpYWxWYWx1ZXMpIHtcbiAgICAgICAgICBpbml0aWFsID0gc3RhdGVJbml0aWFsIHx8IGVtcHR5O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhbHVlcyA9IGdldEluKGZvcm1TdGF0ZSwgJ3ZhbHVlcycpIHx8IGluaXRpYWw7XG5cbiAgICAgICAgaWYgKHNob3VsZFJlc2V0VmFsdWVzKSB7XG4gICAgICAgICAgdmFsdWVzID0gaW5pdGlhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcmlzdGluZSA9IHNob3VsZFJlc2V0VmFsdWVzIHx8IGRlZXBFcXVhbChpbml0aWFsLCB2YWx1ZXMpO1xuICAgICAgICB2YXIgYXN5bmNFcnJvcnMgPSBnZXRJbihmb3JtU3RhdGUsICdhc3luY0Vycm9ycycpO1xuICAgICAgICB2YXIgc3luY0Vycm9ycyA9IGdldEluKGZvcm1TdGF0ZSwgJ3N5bmNFcnJvcnMnKSB8fCBwbGFpbi5lbXB0eTtcbiAgICAgICAgdmFyIHN5bmNXYXJuaW5ncyA9IGdldEluKGZvcm1TdGF0ZSwgJ3N5bmNXYXJuaW5ncycpIHx8IHBsYWluLmVtcHR5O1xuICAgICAgICB2YXIgcmVnaXN0ZXJlZEZpZWxkcyA9IGdldEluKGZvcm1TdGF0ZSwgJ3JlZ2lzdGVyZWRGaWVsZHMnKTtcbiAgICAgICAgdmFyIHZhbGlkID0gaXNWYWxpZChmb3JtLCBnZXRGb3JtU3RhdGUsIGZhbHNlKShzdGF0ZSk7XG4gICAgICAgIHZhciB2YWxpZEV4Y2VwdFN1Ym1pdCA9IGlzVmFsaWQoZm9ybSwgZ2V0Rm9ybVN0YXRlLCB0cnVlKShzdGF0ZSk7XG4gICAgICAgIHZhciBhbnlUb3VjaGVkID0gISFnZXRJbihmb3JtU3RhdGUsICdhbnlUb3VjaGVkJyk7XG4gICAgICAgIHZhciBzdWJtaXR0aW5nID0gISFnZXRJbihmb3JtU3RhdGUsICdzdWJtaXR0aW5nJyk7XG4gICAgICAgIHZhciBzdWJtaXRGYWlsZWQgPSAhIWdldEluKGZvcm1TdGF0ZSwgJ3N1Ym1pdEZhaWxlZCcpO1xuICAgICAgICB2YXIgc3VibWl0U3VjY2VlZGVkID0gISFnZXRJbihmb3JtU3RhdGUsICdzdWJtaXRTdWNjZWVkZWQnKTtcbiAgICAgICAgdmFyIGVycm9yID0gZ2V0SW4oZm9ybVN0YXRlLCAnZXJyb3InKTtcbiAgICAgICAgdmFyIHdhcm5pbmcgPSBnZXRJbihmb3JtU3RhdGUsICd3YXJuaW5nJyk7XG4gICAgICAgIHZhciB0cmlnZ2VyU3VibWl0ID0gZ2V0SW4oZm9ybVN0YXRlLCAndHJpZ2dlclN1Ym1pdCcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFueVRvdWNoZWQ6IGFueVRvdWNoZWQsXG4gICAgICAgICAgYXN5bmNFcnJvcnM6IGFzeW5jRXJyb3JzLFxuICAgICAgICAgIGFzeW5jVmFsaWRhdGluZzogZ2V0SW4oZm9ybVN0YXRlLCAnYXN5bmNWYWxpZGF0aW5nJykgfHwgZmFsc2UsXG4gICAgICAgICAgZGlydHk6ICFwcmlzdGluZSxcbiAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgaW5pdGlhbGl6ZWQ6IGluaXRpYWxpemVkLFxuICAgICAgICAgIGludmFsaWQ6ICF2YWxpZCxcbiAgICAgICAgICBwcmlzdGluZTogcHJpc3RpbmUsXG4gICAgICAgICAgcmVnaXN0ZXJlZEZpZWxkczogcmVnaXN0ZXJlZEZpZWxkcyxcbiAgICAgICAgICBzdWJtaXR0aW5nOiBzdWJtaXR0aW5nLFxuICAgICAgICAgIHN1Ym1pdEZhaWxlZDogc3VibWl0RmFpbGVkLFxuICAgICAgICAgIHN1Ym1pdFN1Y2NlZWRlZDogc3VibWl0U3VjY2VlZGVkLFxuICAgICAgICAgIHN5bmNFcnJvcnM6IHN5bmNFcnJvcnMsXG4gICAgICAgICAgc3luY1dhcm5pbmdzOiBzeW5jV2FybmluZ3MsXG4gICAgICAgICAgdHJpZ2dlclN1Ym1pdDogdHJpZ2dlclN1Ym1pdCxcbiAgICAgICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICAgICAgICB2YWxpZDogdmFsaWQsXG4gICAgICAgICAgdmFsaWRFeGNlcHRTdWJtaXQ6IHZhbGlkRXhjZXB0U3VibWl0LFxuICAgICAgICAgIHdhcm5pbmc6IHdhcm5pbmdcbiAgICAgICAgfTtcbiAgICAgIH0sIGZ1bmN0aW9uIChkaXNwYXRjaCwgaW5pdGlhbFByb3BzKSB7XG4gICAgICAgIHZhciBiaW5kRm9ybSA9IGZ1bmN0aW9uIGJpbmRGb3JtKGFjdGlvbkNyZWF0b3IpIHtcbiAgICAgICAgICByZXR1cm4gYWN0aW9uQ3JlYXRvci5iaW5kKG51bGwsIGluaXRpYWxQcm9wcy5mb3JtKTtcbiAgICAgICAgfTsgLy8gQmluZCB0aGUgZmlyc3QgcGFyYW1ldGVyIG9uIGBwcm9wcy5mb3JtYFxuXG5cbiAgICAgICAgdmFyIGJvdW5kRm9ybUFDcyA9IF9tYXBWYWx1ZXMoZm9ybUFjdGlvbnMsIGJpbmRGb3JtKTtcblxuICAgICAgICB2YXIgYm91bmRBcnJheUFDcyA9IF9tYXBWYWx1ZXMoYXJyYXlBY3Rpb25zLCBiaW5kRm9ybSk7XG5cbiAgICAgICAgdmFyIGJvdW5kQmx1ciA9IGZ1bmN0aW9uIGJvdW5kQmx1cihmaWVsZCwgdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gYmx1cihpbml0aWFsUHJvcHMuZm9ybSwgZmllbGQsIHZhbHVlLCAhIWluaXRpYWxQcm9wcy50b3VjaE9uQmx1cik7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGJvdW5kQ2hhbmdlID0gZnVuY3Rpb24gYm91bmRDaGFuZ2UoZmllbGQsIHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGNoYW5nZShpbml0aWFsUHJvcHMuZm9ybSwgZmllbGQsIHZhbHVlLCAhIWluaXRpYWxQcm9wcy50b3VjaE9uQ2hhbmdlLCAhIWluaXRpYWxQcm9wcy5wZXJzaXN0ZW50U3VibWl0RXJyb3JzKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYm91bmRGb2N1cyA9IGJpbmRGb3JtKGZvY3VzKTsgLy8gV3JhcCBhY3Rpb24gY3JlYXRvcnMgd2l0aCBgZGlzcGF0Y2hgXG5cbiAgICAgICAgdmFyIGNvbm5lY3RlZEZvcm1BQ3MgPSBiaW5kQWN0aW9uQ3JlYXRvcnMoYm91bmRGb3JtQUNzLCBkaXNwYXRjaCk7XG4gICAgICAgIHZhciBjb25uZWN0ZWRBcnJheUFDcyA9IHtcbiAgICAgICAgICBpbnNlcnQ6IGJpbmRBY3Rpb25DcmVhdG9ycyhib3VuZEFycmF5QUNzLmFycmF5SW5zZXJ0LCBkaXNwYXRjaCksXG4gICAgICAgICAgbW92ZTogYmluZEFjdGlvbkNyZWF0b3JzKGJvdW5kQXJyYXlBQ3MuYXJyYXlNb3ZlLCBkaXNwYXRjaCksXG4gICAgICAgICAgcG9wOiBiaW5kQWN0aW9uQ3JlYXRvcnMoYm91bmRBcnJheUFDcy5hcnJheVBvcCwgZGlzcGF0Y2gpLFxuICAgICAgICAgIHB1c2g6IGJpbmRBY3Rpb25DcmVhdG9ycyhib3VuZEFycmF5QUNzLmFycmF5UHVzaCwgZGlzcGF0Y2gpLFxuICAgICAgICAgIHJlbW92ZTogYmluZEFjdGlvbkNyZWF0b3JzKGJvdW5kQXJyYXlBQ3MuYXJyYXlSZW1vdmUsIGRpc3BhdGNoKSxcbiAgICAgICAgICByZW1vdmVBbGw6IGJpbmRBY3Rpb25DcmVhdG9ycyhib3VuZEFycmF5QUNzLmFycmF5UmVtb3ZlQWxsLCBkaXNwYXRjaCksXG4gICAgICAgICAgc2hpZnQ6IGJpbmRBY3Rpb25DcmVhdG9ycyhib3VuZEFycmF5QUNzLmFycmF5U2hpZnQsIGRpc3BhdGNoKSxcbiAgICAgICAgICBzcGxpY2U6IGJpbmRBY3Rpb25DcmVhdG9ycyhib3VuZEFycmF5QUNzLmFycmF5U3BsaWNlLCBkaXNwYXRjaCksXG4gICAgICAgICAgc3dhcDogYmluZEFjdGlvbkNyZWF0b3JzKGJvdW5kQXJyYXlBQ3MuYXJyYXlTd2FwLCBkaXNwYXRjaCksXG4gICAgICAgICAgdW5zaGlmdDogYmluZEFjdGlvbkNyZWF0b3JzKGJvdW5kQXJyYXlBQ3MuYXJyYXlVbnNoaWZ0LCBkaXNwYXRjaClcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgY29tcHV0ZWRBY3Rpb25zID0gX2V4dGVuZHMoe30sIGNvbm5lY3RlZEZvcm1BQ3MsIGJvdW5kQXJyYXlBQ3MsIHtcbiAgICAgICAgICBibHVyOiBib3VuZEJsdXIsXG4gICAgICAgICAgY2hhbmdlOiBib3VuZENoYW5nZSxcbiAgICAgICAgICBhcnJheTogY29ubmVjdGVkQXJyYXlBQ3MsXG4gICAgICAgICAgZm9jdXM6IGJvdW5kRm9jdXMsXG4gICAgICAgICAgZGlzcGF0Y2g6IGRpc3BhdGNoXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbXB1dGVkQWN0aW9ucztcbiAgICAgICAgfTtcbiAgICAgIH0sIHVuZGVmaW5lZCwge1xuICAgICAgICBmb3J3YXJkUmVmOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHZhciBDb25uZWN0ZWRGb3JtID0gaG9pc3RTdGF0aWNzKGNvbm5lY3RvcihGb3JtKSwgV3JhcHBlZENvbXBvbmVudCk7XG4gICAgICBDb25uZWN0ZWRGb3JtLmRlZmF1bHRQcm9wcyA9IGNvbmZpZzsgLy8gYnVpbGQgb3V0ZXIgY29tcG9uZW50IHRvIGV4cG9zZSBpbnN0YW5jZSBhcGlcblxuICAgICAgdmFyIFJlZHV4Rm9ybSA9XG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudDIpIHtcbiAgICAgICAgX2luaGVyaXRzTG9vc2UoUmVkdXhGb3JtLCBfUmVhY3QkQ29tcG9uZW50Mik7XG5cbiAgICAgICAgZnVuY3Rpb24gUmVkdXhGb3JtKCkge1xuICAgICAgICAgIHZhciBfdGhpczQ7XG5cbiAgICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGhpczQgPSBfUmVhY3QkQ29tcG9uZW50Mi5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQyLCBbdGhpc10uY29uY2F0KGFyZ3MpKSB8fCB0aGlzO1xuICAgICAgICAgIF90aGlzNC5yZWYgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgICByZXR1cm4gX3RoaXM0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9wcm90bzIgPSBSZWR1eEZvcm0ucHJvdG90eXBlO1xuXG4gICAgICAgIF9wcm90bzIuc3VibWl0ID0gZnVuY3Rpb24gc3VibWl0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJlZi5jdXJyZW50ICYmIHRoaXMucmVmLmN1cnJlbnQuc3VibWl0KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgX3Byb3RvMi5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICAgIGlmICh0aGlzLnJlZikge1xuICAgICAgICAgICAgdGhpcy5yZWYuY3VycmVudC5yZXNldCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBfcHJvdG8yLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgICB2YXIgX3RoaXMkcHJvcHMxMyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgIGluaXRpYWxWYWx1ZXMgPSBfdGhpcyRwcm9wczEzLmluaXRpYWxWYWx1ZXMsXG4gICAgICAgICAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdGhpcyRwcm9wczEzLCBbXCJpbml0aWFsVmFsdWVzXCJdKTtcblxuICAgICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KENvbm5lY3RlZEZvcm0sIF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgICAgICAgICByZWY6IHRoaXMucmVmLFxuICAgICAgICAgICAgLy8gY29udmVydCBpbml0aWFsVmFsdWVzIGlmIG5lZWQgdG9cbiAgICAgICAgICAgIGluaXRpYWxWYWx1ZXM6IGZyb21KUyhpbml0aWFsVmFsdWVzKVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcblxuICAgICAgICBfY3JlYXRlQ2xhc3MoUmVkdXhGb3JtLCBbe1xuICAgICAgICAgIGtleTogXCJ2YWxpZFwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuICEhKHRoaXMucmVmLmN1cnJlbnQgJiYgdGhpcy5yZWYuY3VycmVudC5pc1ZhbGlkKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJpbnZhbGlkXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMudmFsaWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInByaXN0aW5lXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gISEodGhpcy5yZWYuY3VycmVudCAmJiB0aGlzLnJlZi5jdXJyZW50LmlzUHJpc3RpbmUoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImRpcnR5XCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMucHJpc3RpbmU7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInZhbHVlc1wiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmLmN1cnJlbnQgPyB0aGlzLnJlZi5jdXJyZW50LmdldFZhbHVlcygpIDogZW1wdHk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImZpZWxkTGlzdFwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgLy8gbWFpbmx5IHByb3ZpZGVkIGZvciB0ZXN0aW5nXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWYuY3VycmVudCA/IHRoaXMucmVmLmN1cnJlbnQuZ2V0RmllbGRMaXN0KCkgOiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwid3JhcHBlZEluc3RhbmNlXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAvLyBmb3IgdGVzdGluZ1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmLmN1cnJlbnQgJiYgdGhpcy5yZWYuY3VycmVudC53cmFwcGVkLmN1cnJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XSk7XG5cbiAgICAgICAgcmV0dXJuIFJlZHV4Rm9ybTtcbiAgICAgIH0oUmVhY3QuQ29tcG9uZW50KTtcblxuICAgICAgcG9seWZpbGwoUmVkdXhGb3JtKTtcbiAgICAgIHZhciBXaXRoQ29udGV4dCA9IGhvaXN0U3RhdGljcyh3aXRoUmVkdXhGb3JtKFJlZHV4Rm9ybSksIFdyYXBwZWRDb21wb25lbnQpO1xuICAgICAgV2l0aENvbnRleHQuZGVmYXVsdFByb3BzID0gY29uZmlnO1xuICAgICAgcmV0dXJuIFdpdGhDb250ZXh0O1xuICAgIH07XG4gIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVSZWR1eEZvcm07IiwiaW1wb3J0IGNyZWF0ZVJlZHV4Rm9ybSBmcm9tICcuL2NyZWF0ZVJlZHV4Rm9ybSc7XG5pbXBvcnQgcGxhaW4gZnJvbSAnLi9zdHJ1Y3R1cmUvcGxhaW4nO1xuZXhwb3J0IGRlZmF1bHQgY3JlYXRlUmVkdXhGb3JtKHBsYWluKTsiLCJpbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZVwiO1xuaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2V4dGVuZHNcIjtcblxudmFyIHByb2Nlc3NQcm9wcyA9IGZ1bmN0aW9uIHByb2Nlc3NQcm9wcyh0eXBlLCBwcm9wcywgX3ZhbHVlLCBkZWVwRXF1YWwpIHtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG5cbiAgaWYgKHR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICBjaGVja2VkOiAhIXZhbHVlXG4gICAgfSk7XG4gIH1cblxuICBpZiAodHlwZSA9PT0gJ3JhZGlvJykge1xuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgIGNoZWNrZWQ6IGRlZXBFcXVhbCh2YWx1ZSwgX3ZhbHVlKSxcbiAgICAgIHZhbHVlOiBfdmFsdWVcbiAgICB9KTtcbiAgfVxuXG4gIGlmICh0eXBlID09PSAnc2VsZWN0LW11bHRpcGxlJykge1xuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSB8fCBbXVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHR5cGUgPT09ICdmaWxlJykge1xuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSB8fCB1bmRlZmluZWRcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBwcm9wcztcbn07XG5cbnZhciBjcmVhdGVGaWVsZFByb3BzID0gZnVuY3Rpb24gY3JlYXRlRmllbGRQcm9wcyhfcmVmLCBuYW1lLCBfcmVmMikge1xuICB2YXIgZ2V0SW4gPSBfcmVmLmdldEluLFxuICAgICAgdG9KUyA9IF9yZWYudG9KUyxcbiAgICAgIGRlZXBFcXVhbCA9IF9yZWYuZGVlcEVxdWFsO1xuXG4gIHZhciBhc3luY0Vycm9yID0gX3JlZjIuYXN5bmNFcnJvcixcbiAgICAgIGFzeW5jVmFsaWRhdGluZyA9IF9yZWYyLmFzeW5jVmFsaWRhdGluZyxcbiAgICAgIG9uQmx1ciA9IF9yZWYyLm9uQmx1cixcbiAgICAgIG9uQ2hhbmdlID0gX3JlZjIub25DaGFuZ2UsXG4gICAgICBvbkRyb3AgPSBfcmVmMi5vbkRyb3AsXG4gICAgICBvbkRyYWdTdGFydCA9IF9yZWYyLm9uRHJhZ1N0YXJ0LFxuICAgICAgZGlydHkgPSBfcmVmMi5kaXJ0eSxcbiAgICAgIGRpc3BhdGNoID0gX3JlZjIuZGlzcGF0Y2gsXG4gICAgICBvbkZvY3VzID0gX3JlZjIub25Gb2N1cyxcbiAgICAgIGZvcm0gPSBfcmVmMi5mb3JtLFxuICAgICAgZm9ybWF0ID0gX3JlZjIuZm9ybWF0LFxuICAgICAgaW5pdGlhbCA9IF9yZWYyLmluaXRpYWwsXG4gICAgICBwYXJzZSA9IF9yZWYyLnBhcnNlLFxuICAgICAgcHJpc3RpbmUgPSBfcmVmMi5wcmlzdGluZSxcbiAgICAgIHByb3BzID0gX3JlZjIucHJvcHMsXG4gICAgICBzdGF0ZSA9IF9yZWYyLnN0YXRlLFxuICAgICAgc3VibWl0RXJyb3IgPSBfcmVmMi5zdWJtaXRFcnJvcixcbiAgICAgIHN1Ym1pdEZhaWxlZCA9IF9yZWYyLnN1Ym1pdEZhaWxlZCxcbiAgICAgIHN1Ym1pdHRpbmcgPSBfcmVmMi5zdWJtaXR0aW5nLFxuICAgICAgc3luY0Vycm9yID0gX3JlZjIuc3luY0Vycm9yLFxuICAgICAgc3luY1dhcm5pbmcgPSBfcmVmMi5zeW5jV2FybmluZyxcbiAgICAgIHZhbGlkYXRlID0gX3JlZjIudmFsaWRhdGUsXG4gICAgICB2YWx1ZSA9IF9yZWYyLnZhbHVlLFxuICAgICAgX3ZhbHVlID0gX3JlZjIuX3ZhbHVlLFxuICAgICAgd2FybiA9IF9yZWYyLndhcm4sXG4gICAgICBjdXN0b20gPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmMiwgW1wiYXN5bmNFcnJvclwiLCBcImFzeW5jVmFsaWRhdGluZ1wiLCBcIm9uQmx1clwiLCBcIm9uQ2hhbmdlXCIsIFwib25Ecm9wXCIsIFwib25EcmFnU3RhcnRcIiwgXCJkaXJ0eVwiLCBcImRpc3BhdGNoXCIsIFwib25Gb2N1c1wiLCBcImZvcm1cIiwgXCJmb3JtYXRcIiwgXCJpbml0aWFsXCIsIFwicGFyc2VcIiwgXCJwcmlzdGluZVwiLCBcInByb3BzXCIsIFwic3RhdGVcIiwgXCJzdWJtaXRFcnJvclwiLCBcInN1Ym1pdEZhaWxlZFwiLCBcInN1Ym1pdHRpbmdcIiwgXCJzeW5jRXJyb3JcIiwgXCJzeW5jV2FybmluZ1wiLCBcInZhbGlkYXRlXCIsIFwidmFsdWVcIiwgXCJfdmFsdWVcIiwgXCJ3YXJuXCJdKTtcblxuICB2YXIgZXJyb3IgPSBzeW5jRXJyb3IgfHwgYXN5bmNFcnJvciB8fCBzdWJtaXRFcnJvcjtcbiAgdmFyIHdhcm5pbmcgPSBzeW5jV2FybmluZztcblxuICB2YXIgZm9ybWF0RmllbGRWYWx1ZSA9IGZ1bmN0aW9uIGZvcm1hdEZpZWxkVmFsdWUodmFsdWUsIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdEZvcm1hdHRlZFZhbHVlID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG4gICAgcmV0dXJuIGZvcm1hdCA/IGZvcm1hdCh2YWx1ZSwgbmFtZSkgOiBkZWZhdWx0Rm9ybWF0dGVkVmFsdWU7XG4gIH07XG5cbiAgdmFyIGZvcm1hdHRlZEZpZWxkVmFsdWUgPSBmb3JtYXRGaWVsZFZhbHVlKHZhbHVlLCBmb3JtYXQpO1xuICByZXR1cm4ge1xuICAgIGlucHV0OiBwcm9jZXNzUHJvcHMoY3VzdG9tLnR5cGUsIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBvbkJsdXI6IG9uQmx1cixcbiAgICAgIG9uQ2hhbmdlOiBvbkNoYW5nZSxcbiAgICAgIG9uRHJhZ1N0YXJ0OiBvbkRyYWdTdGFydCxcbiAgICAgIG9uRHJvcDogb25Ecm9wLFxuICAgICAgb25Gb2N1czogb25Gb2N1cyxcbiAgICAgIHZhbHVlOiBmb3JtYXR0ZWRGaWVsZFZhbHVlXG4gICAgfSwgX3ZhbHVlLCBkZWVwRXF1YWwpLFxuICAgIG1ldGE6IF9leHRlbmRzKHt9LCB0b0pTKHN0YXRlKSwge1xuICAgICAgYWN0aXZlOiAhIShzdGF0ZSAmJiBnZXRJbihzdGF0ZSwgJ2FjdGl2ZScpKSxcbiAgICAgIGFzeW5jVmFsaWRhdGluZzogYXN5bmNWYWxpZGF0aW5nLFxuICAgICAgYXV0b2ZpbGxlZDogISEoc3RhdGUgJiYgZ2V0SW4oc3RhdGUsICdhdXRvZmlsbGVkJykpLFxuICAgICAgZGlydHk6IGRpcnR5LFxuICAgICAgZGlzcGF0Y2g6IGRpc3BhdGNoLFxuICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgZm9ybTogZm9ybSxcbiAgICAgIGluaXRpYWw6IGluaXRpYWwsXG4gICAgICB3YXJuaW5nOiB3YXJuaW5nLFxuICAgICAgaW52YWxpZDogISFlcnJvcixcbiAgICAgIHByaXN0aW5lOiBwcmlzdGluZSxcbiAgICAgIHN1Ym1pdHRpbmc6ICEhc3VibWl0dGluZyxcbiAgICAgIHN1Ym1pdEZhaWxlZDogISFzdWJtaXRGYWlsZWQsXG4gICAgICB0b3VjaGVkOiAhIShzdGF0ZSAmJiBnZXRJbihzdGF0ZSwgJ3RvdWNoZWQnKSksXG4gICAgICB2YWxpZDogIWVycm9yLFxuICAgICAgdmlzaXRlZDogISEoc3RhdGUgJiYgZ2V0SW4oc3RhdGUsICd2aXNpdGVkJykpXG4gICAgfSksXG4gICAgY3VzdG9tOiBfZXh0ZW5kcyh7fSwgY3VzdG9tLCBwcm9wcylcbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUZpZWxkUHJvcHM7IiwiaW1wb3J0IGlzRXZlbnQgZnJvbSAnLi9pc0V2ZW50JztcblxudmFyIGdldFNlbGVjdGVkVmFsdWVzID0gZnVuY3Rpb24gZ2V0U2VsZWN0ZWRWYWx1ZXMob3B0aW9ucykge1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgb3B0aW9ucy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBvcHRpb24gPSBvcHRpb25zW2luZGV4XTtcblxuICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCkge1xuICAgICAgICByZXN1bHQucHVzaChvcHRpb24udmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZShldmVudCwgaXNSZWFjdE5hdGl2ZSkge1xuICBpZiAoaXNFdmVudChldmVudCkpIHtcbiAgICBpZiAoIWlzUmVhY3ROYXRpdmUgJiYgZXZlbnQubmF0aXZlRXZlbnQgJiYgZXZlbnQubmF0aXZlRXZlbnQudGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZlbnQubmF0aXZlRXZlbnQudGV4dDtcbiAgICB9XG5cbiAgICBpZiAoaXNSZWFjdE5hdGl2ZSAmJiBldmVudC5uYXRpdmVFdmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZlbnQubmF0aXZlRXZlbnQudGV4dDtcbiAgICB9XG5cbiAgICB2YXIgZGV0eXBlZEV2ZW50ID0gZXZlbnQ7XG4gICAgdmFyIF9kZXR5cGVkRXZlbnQkdGFyZ2V0ID0gZGV0eXBlZEV2ZW50LnRhcmdldCxcbiAgICAgICAgdHlwZSA9IF9kZXR5cGVkRXZlbnQkdGFyZ2V0LnR5cGUsXG4gICAgICAgIHZhbHVlID0gX2RldHlwZWRFdmVudCR0YXJnZXQudmFsdWUsXG4gICAgICAgIGNoZWNrZWQgPSBfZGV0eXBlZEV2ZW50JHRhcmdldC5jaGVja2VkLFxuICAgICAgICBmaWxlcyA9IF9kZXR5cGVkRXZlbnQkdGFyZ2V0LmZpbGVzLFxuICAgICAgICBkYXRhVHJhbnNmZXIgPSBkZXR5cGVkRXZlbnQuZGF0YVRyYW5zZmVyO1xuXG4gICAgaWYgKHR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICAgIHJldHVybiAhIWNoZWNrZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdmaWxlJykge1xuICAgICAgcmV0dXJuIGZpbGVzIHx8IGRhdGFUcmFuc2ZlciAmJiBkYXRhVHJhbnNmZXIuZmlsZXM7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdzZWxlY3QtbXVsdGlwbGUnKSB7XG4gICAgICByZXR1cm4gZ2V0U2VsZWN0ZWRWYWx1ZXMoZXZlbnQudGFyZ2V0Lm9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBldmVudDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGdldFZhbHVlOyIsInZhciBpc1JlYWN0TmF0aXZlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lm5hdmlnYXRvciAmJiB3aW5kb3cubmF2aWdhdG9yLnByb2R1Y3QgJiYgd2luZG93Lm5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnO1xuZXhwb3J0IGRlZmF1bHQgaXNSZWFjdE5hdGl2ZTsiLCJpbXBvcnQgZ2V0VmFsdWUgZnJvbSAnLi9nZXRWYWx1ZSc7XG5pbXBvcnQgaXNSZWFjdE5hdGl2ZSBmcm9tICcuLi9pc1JlYWN0TmF0aXZlJztcblxudmFyIG9uQ2hhbmdlVmFsdWUgPSBmdW5jdGlvbiBvbkNoYW5nZVZhbHVlKGV2ZW50LCBfcmVmKSB7XG4gIHZhciBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgcGFyc2UgPSBfcmVmLnBhcnNlLFxuICAgICAgbm9ybWFsaXplID0gX3JlZi5ub3JtYWxpemU7XG4gIC8vIHJlYWQgdmFsdWUgZnJvbSBpbnB1dFxuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShldmVudCwgaXNSZWFjdE5hdGl2ZSk7IC8vIHBhcnNlIHZhbHVlIGlmIHdlIGhhdmUgYSBwYXJzZXJcblxuICBpZiAocGFyc2UpIHtcbiAgICB2YWx1ZSA9IHBhcnNlKHZhbHVlLCBuYW1lKTtcbiAgfSAvLyBub3JtYWxpemUgdmFsdWVcblxuXG4gIGlmIChub3JtYWxpemUpIHtcbiAgICB2YWx1ZSA9IG5vcm1hbGl6ZShuYW1lLCB2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBvbkNoYW5nZVZhbHVlOyIsImV4cG9ydCB2YXIgZGF0YUtleSA9ICd0ZXh0JzsiLCJpbXBvcnQgeyBpc1ZhbGlkRWxlbWVudFR5cGUgfSBmcm9tICdyZWFjdC1pcyc7XG5cbnZhciB2YWxpZGF0ZUNvbXBvbmVudFByb3AgPSBmdW5jdGlvbiB2YWxpZGF0ZUNvbXBvbmVudFByb3AocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkIHByb3AgYCcgKyBwcm9wTmFtZSArICdgIHN1cHBsaWVkIHRvJyArICcgYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJyk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHZhbGlkYXRlQ29tcG9uZW50UHJvcDsiLCJpbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZVwiO1xuaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2V4dGVuZHNcIjtcbmltcG9ydCBfaW5oZXJpdHNMb29zZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c0xvb3NlXCI7XG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCBjcmVhdGVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IGNvbm5lY3QgfSBmcm9tICdyZWFjdC1yZWR1eCc7XG5pbXBvcnQgY3JlYXRlRmllbGRQcm9wcyBmcm9tICcuL2NyZWF0ZUZpZWxkUHJvcHMnO1xuaW1wb3J0IG9uQ2hhbmdlVmFsdWUgZnJvbSAnLi9ldmVudHMvb25DaGFuZ2VWYWx1ZSc7XG5pbXBvcnQgeyBkYXRhS2V5IH0gZnJvbSAnLi91dGlsL2V2ZW50Q29uc3RzJztcbmltcG9ydCBwbGFpbiBmcm9tICcuL3N0cnVjdHVyZS9wbGFpbic7XG5pbXBvcnQgaXNSZWFjdE5hdGl2ZSBmcm9tICcuL2lzUmVhY3ROYXRpdmUnO1xuaW1wb3J0IHZhbGlkYXRlQ29tcG9uZW50UHJvcCBmcm9tICcuL3V0aWwvdmFsaWRhdGVDb21wb25lbnRQcm9wJztcbmltcG9ydCBpc0V2ZW50IGZyb20gJy4vZXZlbnRzL2lzRXZlbnQnO1xudmFyIHByb3BzVG9Ob3RVcGRhdGVGb3IgPSBbJ19yZWR1eEZvcm0nXTtcblxudmFyIGlzT2JqZWN0ID0gZnVuY3Rpb24gaXNPYmplY3QoZW50aXR5KSB7XG4gIHJldHVybiBlbnRpdHkgJiYgdHlwZW9mIGVudGl0eSA9PT0gJ29iamVjdCc7XG59O1xuXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzRnVuY3Rpb24oZW50aXR5KSB7XG4gIHJldHVybiBlbnRpdHkgJiYgdHlwZW9mIGVudGl0eSA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cbnZhciBldmVudFByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gZXZlbnRQcmV2ZW50RGVmYXVsdChldmVudCkge1xuICBpZiAoaXNPYmplY3QoZXZlbnQpICYmIGlzRnVuY3Rpb24oZXZlbnQucHJldmVudERlZmF1bHQpKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxufTtcblxudmFyIGV2ZW50RGF0YVRyYW5zZmVyR2V0RGF0YSA9IGZ1bmN0aW9uIGV2ZW50RGF0YVRyYW5zZmVyR2V0RGF0YShldmVudCwga2V5KSB7XG4gIGlmIChpc09iamVjdChldmVudCkgJiYgaXNPYmplY3QoZXZlbnQuZGF0YVRyYW5zZmVyKSAmJiBpc0Z1bmN0aW9uKGV2ZW50LmRhdGFUcmFuc2Zlci5nZXREYXRhKSkge1xuICAgIHJldHVybiBldmVudC5kYXRhVHJhbnNmZXIuZ2V0RGF0YShrZXkpO1xuICB9XG59O1xuXG52YXIgZXZlbnREYXRhVHJhbnNmZXJTZXREYXRhID0gZnVuY3Rpb24gZXZlbnREYXRhVHJhbnNmZXJTZXREYXRhKGV2ZW50LCBrZXksIHZhbHVlKSB7XG4gIGlmIChpc09iamVjdChldmVudCkgJiYgaXNPYmplY3QoZXZlbnQuZGF0YVRyYW5zZmVyKSAmJiBpc0Z1bmN0aW9uKGV2ZW50LmRhdGFUcmFuc2Zlci5zZXREYXRhKSkge1xuICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5zZXREYXRhKGtleSwgdmFsdWUpO1xuICB9XG59O1xuXG52YXIgY3JlYXRlQ29ubmVjdGVkRmllbGQgPSBmdW5jdGlvbiBjcmVhdGVDb25uZWN0ZWRGaWVsZChzdHJ1Y3R1cmUpIHtcbiAgdmFyIGRlZXBFcXVhbCA9IHN0cnVjdHVyZS5kZWVwRXF1YWwsXG4gICAgICBnZXRJbiA9IHN0cnVjdHVyZS5nZXRJbjtcblxuICB2YXIgZ2V0U3luY0Vycm9yID0gZnVuY3Rpb24gZ2V0U3luY0Vycm9yKHN5bmNFcnJvcnMsIG5hbWUpIHtcbiAgICB2YXIgZXJyb3IgPSBwbGFpbi5nZXRJbihzeW5jRXJyb3JzLCBuYW1lKTsgLy8gQmVjYXVzZSB0aGUgZXJyb3IgZm9yIHRoaXMgZmllbGQgbWlnaHQgbm90IGJlIGF0IGEgbGV2ZWwgaW4gdGhlIGVycm9yIHN0cnVjdHVyZSB3aGVyZVxuICAgIC8vIGl0IGNhbiBiZSBzZXQgZGlyZWN0bHksIGl0IG1pZ2h0IG5lZWQgdG8gYmUgdW53cmFwcGVkIGZyb20gdGhlIF9lcnJvciBwcm9wZXJ0eVxuXG4gICAgcmV0dXJuIGVycm9yICYmIGVycm9yLl9lcnJvciA/IGVycm9yLl9lcnJvciA6IGVycm9yO1xuICB9O1xuXG4gIHZhciBnZXRTeW5jV2FybmluZyA9IGZ1bmN0aW9uIGdldFN5bmNXYXJuaW5nKHN5bmNXYXJuaW5ncywgbmFtZSkge1xuICAgIHZhciB3YXJuaW5nID0gZ2V0SW4oc3luY1dhcm5pbmdzLCBuYW1lKTsgLy8gQmVjYXVzZSB0aGUgd2FybmluZyBmb3IgdGhpcyBmaWVsZCBtaWdodCBub3QgYmUgYXQgYSBsZXZlbCBpbiB0aGUgd2FybmluZyBzdHJ1Y3R1cmUgd2hlcmVcbiAgICAvLyBpdCBjYW4gYmUgc2V0IGRpcmVjdGx5LCBpdCBtaWdodCBuZWVkIHRvIGJlIHVud3JhcHBlZCBmcm9tIHRoZSBfd2FybmluZyBwcm9wZXJ0eVxuXG4gICAgcmV0dXJuIHdhcm5pbmcgJiYgd2FybmluZy5fd2FybmluZyA/IHdhcm5pbmcuX3dhcm5pbmcgOiB3YXJuaW5nO1xuICB9O1xuXG4gIHZhciBDb25uZWN0ZWRGaWVsZCA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHNMb29zZShDb25uZWN0ZWRGaWVsZCwgX0NvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBDb25uZWN0ZWRGaWVsZCgpIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIF90aGlzID0gX0NvbXBvbmVudC5jYWxsLmFwcGx5KF9Db21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpIHx8IHRoaXM7XG4gICAgICBfdGhpcy5yZWYgPSBSZWFjdC5jcmVhdGVSZWYoKTtcblxuICAgICAgX3RoaXMuaXNQcmlzdGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnByb3BzLnByaXN0aW5lO1xuICAgICAgfTtcblxuICAgICAgX3RoaXMuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5wcm9wcy52YWx1ZTtcbiAgICAgIH07XG5cbiAgICAgIF90aGlzLmhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIG5hbWUgPSBfdGhpcyRwcm9wcy5uYW1lLFxuICAgICAgICAgICAgZGlzcGF0Y2ggPSBfdGhpcyRwcm9wcy5kaXNwYXRjaCxcbiAgICAgICAgICAgIHBhcnNlID0gX3RoaXMkcHJvcHMucGFyc2UsXG4gICAgICAgICAgICBub3JtYWxpemUgPSBfdGhpcyRwcm9wcy5ub3JtYWxpemUsXG4gICAgICAgICAgICBvbkNoYW5nZSA9IF90aGlzJHByb3BzLm9uQ2hhbmdlLFxuICAgICAgICAgICAgX3JlZHV4Rm9ybSA9IF90aGlzJHByb3BzLl9yZWR1eEZvcm0sXG4gICAgICAgICAgICBwcmV2aW91c1ZhbHVlID0gX3RoaXMkcHJvcHMudmFsdWU7XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IG9uQ2hhbmdlVmFsdWUoZXZlbnQsIHtcbiAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgIHBhcnNlOiBwYXJzZSxcbiAgICAgICAgICBub3JtYWxpemU6IG5vcm1hbGl6ZVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAob25DaGFuZ2UpIHtcbiAgICAgICAgICAvLyBDYW4ndCBzZWVtIHRvIGZpbmQgYSB3YXkgdG8gZXh0ZW5kIEV2ZW50IGluIFJlYWN0IE5hdGl2ZSxcbiAgICAgICAgICAvLyB0aHVzIEkgc2ltcGx5IGF2b2lkIGFkZGluZyBwcmV2ZW50RGVmYXVsdCgpIGluIGEgUk4gZW52aXJvbm1lbnRcbiAgICAgICAgICAvLyB0byBwcmV2ZW50IHRoZSBmb2xsb3dpbmcgZXJyb3I6XG4gICAgICAgICAgLy8gYE9uZSBvZiB0aGUgc291cmNlcyBmb3IgYXNzaWduIGhhcyBhbiBlbnVtZXJhYmxlIGtleSBvbiB0aGUgcHJvdG90eXBlIGNoYWluYFxuICAgICAgICAgIC8vIFJlZmVyZW5jZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9pc3N1ZXMvNTUwN1xuICAgICAgICAgIGlmICghaXNSZWFjdE5hdGl2ZSAmJiBpc0V2ZW50KGV2ZW50KSkge1xuICAgICAgICAgICAgb25DaGFuZ2UoX2V4dGVuZHMoe30sIGV2ZW50LCB7XG4gICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnRQcmV2ZW50RGVmYXVsdChldmVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLCBuZXdWYWx1ZSwgcHJldmlvdXNWYWx1ZSwgbmFtZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlZmF1bHRQcmV2ZW50ZWQgPSBvbkNoYW5nZShldmVudCwgbmV3VmFsdWUsIHByZXZpb3VzVmFsdWUsIG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgIC8vIGRpc3BhdGNoIGNoYW5nZSBhY3Rpb25cbiAgICAgICAgICBkaXNwYXRjaChfcmVkdXhGb3JtLmNoYW5nZShuYW1lLCBuZXdWYWx1ZSkpOyAvLyBjYWxsIHBvc3QtY2hhbmdlIGNhbGxiYWNrXG5cbiAgICAgICAgICBpZiAoX3JlZHV4Rm9ybS5hc3luY1ZhbGlkYXRlKSB7XG4gICAgICAgICAgICBfcmVkdXhGb3JtLmFzeW5jVmFsaWRhdGUobmFtZSwgbmV3VmFsdWUsICdjaGFuZ2UnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIF90aGlzLmhhbmRsZUZvY3VzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyRwcm9wczIgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIG5hbWUgPSBfdGhpcyRwcm9wczIubmFtZSxcbiAgICAgICAgICAgIGRpc3BhdGNoID0gX3RoaXMkcHJvcHMyLmRpc3BhdGNoLFxuICAgICAgICAgICAgb25Gb2N1cyA9IF90aGlzJHByb3BzMi5vbkZvY3VzLFxuICAgICAgICAgICAgX3JlZHV4Rm9ybSA9IF90aGlzJHByb3BzMi5fcmVkdXhGb3JtO1xuICAgICAgICB2YXIgZGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChvbkZvY3VzKSB7XG4gICAgICAgICAgaWYgKCFpc1JlYWN0TmF0aXZlKSB7XG4gICAgICAgICAgICBvbkZvY3VzKF9leHRlbmRzKHt9LCBldmVudCwge1xuICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gcHJldmVudERlZmF1bHQoKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50UHJldmVudERlZmF1bHQoZXZlbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSwgbmFtZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlZmF1bHRQcmV2ZW50ZWQgPSBvbkZvY3VzKGV2ZW50LCBuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICBkaXNwYXRjaChfcmVkdXhGb3JtLmZvY3VzKG5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgX3RoaXMuaGFuZGxlQmx1ciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgX3RoaXMkcHJvcHMzID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgICBuYW1lID0gX3RoaXMkcHJvcHMzLm5hbWUsXG4gICAgICAgICAgICBkaXNwYXRjaCA9IF90aGlzJHByb3BzMy5kaXNwYXRjaCxcbiAgICAgICAgICAgIHBhcnNlID0gX3RoaXMkcHJvcHMzLnBhcnNlLFxuICAgICAgICAgICAgbm9ybWFsaXplID0gX3RoaXMkcHJvcHMzLm5vcm1hbGl6ZSxcbiAgICAgICAgICAgIG9uQmx1ciA9IF90aGlzJHByb3BzMy5vbkJsdXIsXG4gICAgICAgICAgICBfcmVkdXhGb3JtID0gX3RoaXMkcHJvcHMzLl9yZWR1eEZvcm0sXG4gICAgICAgICAgICBfdmFsdWUgPSBfdGhpcyRwcm9wczMuX3ZhbHVlLFxuICAgICAgICAgICAgcHJldmlvdXNWYWx1ZSA9IF90aGlzJHByb3BzMy52YWx1ZTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gb25DaGFuZ2VWYWx1ZShldmVudCwge1xuICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgcGFyc2U6IHBhcnNlLFxuICAgICAgICAgIG5vcm1hbGl6ZTogbm9ybWFsaXplXG4gICAgICAgIH0pOyAvLyBmb3IgY2hlY2tib3ggYW5kIHJhZGlvLCBpZiB0aGUgdmFsdWUgcHJvcGVydHkgb2YgY2hlY2tib3ggb3IgcmFkaW8gZXF1YWxzXG4gICAgICAgIC8vIHRoZSB2YWx1ZSBwYXNzZWQgYnkgYmx1ciBldmVudCwgdGhlbiBmaXJlIGJsdXIgYWN0aW9uIHdpdGggcHJldmlvdXNWYWx1ZS5cblxuICAgICAgICBpZiAobmV3VmFsdWUgPT09IF92YWx1ZSAmJiBfdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5ld1ZhbHVlID0gcHJldmlvdXNWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKG9uQmx1cikge1xuICAgICAgICAgIGlmICghaXNSZWFjdE5hdGl2ZSkge1xuICAgICAgICAgICAgb25CbHVyKF9leHRlbmRzKHt9LCBldmVudCwge1xuICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gcHJldmVudERlZmF1bHQoKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50UHJldmVudERlZmF1bHQoZXZlbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSwgbmV3VmFsdWUsIHByZXZpb3VzVmFsdWUsIG5hbWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWZhdWx0UHJldmVudGVkID0gb25CbHVyKGV2ZW50LCBuZXdWYWx1ZSwgcHJldmlvdXNWYWx1ZSwgbmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgLy8gZGlzcGF0Y2ggYmx1ciBhY3Rpb25cbiAgICAgICAgICBkaXNwYXRjaChfcmVkdXhGb3JtLmJsdXIobmFtZSwgbmV3VmFsdWUpKTsgLy8gY2FsbCBwb3N0LWJsdXIgY2FsbGJhY2tcblxuICAgICAgICAgIGlmIChfcmVkdXhGb3JtLmFzeW5jVmFsaWRhdGUpIHtcbiAgICAgICAgICAgIF9yZWR1eEZvcm0uYXN5bmNWYWxpZGF0ZShuYW1lLCBuZXdWYWx1ZSwgJ2JsdXInKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIF90aGlzLmhhbmRsZURyYWdTdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgX3RoaXMkcHJvcHM0ID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgICBuYW1lID0gX3RoaXMkcHJvcHM0Lm5hbWUsXG4gICAgICAgICAgICBvbkRyYWdTdGFydCA9IF90aGlzJHByb3BzNC5vbkRyYWdTdGFydCxcbiAgICAgICAgICAgIHZhbHVlID0gX3RoaXMkcHJvcHM0LnZhbHVlO1xuICAgICAgICBldmVudERhdGFUcmFuc2ZlclNldERhdGEoZXZlbnQsIGRhdGFLZXksIHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlKTtcblxuICAgICAgICBpZiAob25EcmFnU3RhcnQpIHtcbiAgICAgICAgICBvbkRyYWdTdGFydChldmVudCwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIF90aGlzLmhhbmRsZURyb3AgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzJHByb3BzNSA9IF90aGlzLnByb3BzLFxuICAgICAgICAgICAgbmFtZSA9IF90aGlzJHByb3BzNS5uYW1lLFxuICAgICAgICAgICAgZGlzcGF0Y2ggPSBfdGhpcyRwcm9wczUuZGlzcGF0Y2gsXG4gICAgICAgICAgICBvbkRyb3AgPSBfdGhpcyRwcm9wczUub25Ecm9wLFxuICAgICAgICAgICAgX3JlZHV4Rm9ybSA9IF90aGlzJHByb3BzNS5fcmVkdXhGb3JtLFxuICAgICAgICAgICAgcHJldmlvdXNWYWx1ZSA9IF90aGlzJHByb3BzNS52YWx1ZTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gZXZlbnREYXRhVHJhbnNmZXJHZXREYXRhKGV2ZW50LCBkYXRhS2V5KTtcbiAgICAgICAgdmFyIGRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAob25Ecm9wKSB7XG4gICAgICAgICAgb25Ecm9wKF9leHRlbmRzKHt9LCBldmVudCwge1xuICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICAgICAgICBkZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50UHJldmVudERlZmF1bHQoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCBuZXdWYWx1ZSwgcHJldmlvdXNWYWx1ZSwgbmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAvLyBkaXNwYXRjaCBjaGFuZ2UgYWN0aW9uXG4gICAgICAgICAgZGlzcGF0Y2goX3JlZHV4Rm9ybS5jaGFuZ2UobmFtZSwgbmV3VmFsdWUpKTtcbiAgICAgICAgICBldmVudFByZXZlbnREZWZhdWx0KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8gPSBDb25uZWN0ZWRGaWVsZC5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24gc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBuZXh0UHJvcHNLZXlzID0gT2JqZWN0LmtleXMobmV4dFByb3BzKTtcbiAgICAgIHZhciB0aGlzUHJvcHNLZXlzID0gT2JqZWN0LmtleXModGhpcy5wcm9wcyk7IC8vIGlmIHdlIGhhdmUgY2hpbGRyZW4sIHdlIE1VU1QgdXBkYXRlIGluIFJlYWN0IDE2XG4gICAgICAvLyBodHRwczovL3R3aXR0ZXIuY29tL2VyaWtyYXMvc3RhdHVzLzkxNTg2NjU0NDU1ODc4ODYwOFxuXG4gICAgICByZXR1cm4gISEodGhpcy5wcm9wcy5jaGlsZHJlbiB8fCBuZXh0UHJvcHMuY2hpbGRyZW4gfHwgbmV4dFByb3BzS2V5cy5sZW5ndGggIT09IHRoaXNQcm9wc0tleXMubGVuZ3RoIHx8IG5leHRQcm9wc0tleXMuc29tZShmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICBpZiAofihuZXh0UHJvcHMuaW1tdXRhYmxlUHJvcHMgfHwgW10pLmluZGV4T2YocHJvcCkpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLnByb3BzW3Byb3BdICE9PSBuZXh0UHJvcHNbcHJvcF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gIX5wcm9wc1RvTm90VXBkYXRlRm9yLmluZGV4T2YocHJvcCkgJiYgIWRlZXBFcXVhbChfdGhpczIucHJvcHNbcHJvcF0sIG5leHRQcm9wc1twcm9wXSk7XG4gICAgICB9KSk7XG4gICAgfTtcblxuICAgIF9wcm90by5nZXRSZW5kZXJlZENvbXBvbmVudCA9IGZ1bmN0aW9uIGdldFJlbmRlcmVkQ29tcG9uZW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVmLmN1cnJlbnQ7XG4gICAgfTtcblxuICAgIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHM2ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBjb21wb25lbnQgPSBfdGhpcyRwcm9wczYuY29tcG9uZW50LFxuICAgICAgICAgIGZvcndhcmRSZWYgPSBfdGhpcyRwcm9wczYuZm9yd2FyZFJlZixcbiAgICAgICAgICBuYW1lID0gX3RoaXMkcHJvcHM2Lm5hbWUsXG4gICAgICAgICAgX3JlZHV4Rm9ybSA9IF90aGlzJHByb3BzNi5fcmVkdXhGb3JtLFxuICAgICAgICAgIG5vcm1hbGl6ZSA9IF90aGlzJHByb3BzNi5ub3JtYWxpemUsXG4gICAgICAgICAgb25CbHVyID0gX3RoaXMkcHJvcHM2Lm9uQmx1cixcbiAgICAgICAgICBvbkNoYW5nZSA9IF90aGlzJHByb3BzNi5vbkNoYW5nZSxcbiAgICAgICAgICBvbkZvY3VzID0gX3RoaXMkcHJvcHM2Lm9uRm9jdXMsXG4gICAgICAgICAgb25EcmFnU3RhcnQgPSBfdGhpcyRwcm9wczYub25EcmFnU3RhcnQsXG4gICAgICAgICAgb25Ecm9wID0gX3RoaXMkcHJvcHM2Lm9uRHJvcCxcbiAgICAgICAgICBpbW11dGFibGVQcm9wcyA9IF90aGlzJHByb3BzNi5pbW11dGFibGVQcm9wcyxcbiAgICAgICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3RoaXMkcHJvcHM2LCBbXCJjb21wb25lbnRcIiwgXCJmb3J3YXJkUmVmXCIsIFwibmFtZVwiLCBcIl9yZWR1eEZvcm1cIiwgXCJub3JtYWxpemVcIiwgXCJvbkJsdXJcIiwgXCJvbkNoYW5nZVwiLCBcIm9uRm9jdXNcIiwgXCJvbkRyYWdTdGFydFwiLCBcIm9uRHJvcFwiLCBcImltbXV0YWJsZVByb3BzXCJdKTtcblxuICAgICAgdmFyIF9jcmVhdGVGaWVsZFByb3BzID0gY3JlYXRlRmllbGRQcm9wcyhzdHJ1Y3R1cmUsIG5hbWUsIF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgICAgIGZvcm06IF9yZWR1eEZvcm0uZm9ybSxcbiAgICAgICAgb25CbHVyOiB0aGlzLmhhbmRsZUJsdXIsXG4gICAgICAgIG9uQ2hhbmdlOiB0aGlzLmhhbmRsZUNoYW5nZSxcbiAgICAgICAgb25Ecm9wOiB0aGlzLmhhbmRsZURyb3AsXG4gICAgICAgIG9uRHJhZ1N0YXJ0OiB0aGlzLmhhbmRsZURyYWdTdGFydCxcbiAgICAgICAgb25Gb2N1czogdGhpcy5oYW5kbGVGb2N1c1xuICAgICAgfSkpLFxuICAgICAgICAgIGN1c3RvbSA9IF9jcmVhdGVGaWVsZFByb3BzLmN1c3RvbSxcbiAgICAgICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9jcmVhdGVGaWVsZFByb3BzLCBbXCJjdXN0b21cIl0pO1xuXG4gICAgICBpZiAoZm9yd2FyZFJlZikge1xuICAgICAgICBjdXN0b20ucmVmID0gdGhpcy5yZWY7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgY29tcG9uZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgaW5wdXQgPSBwcm9wcy5pbnB1dCxcbiAgICAgICAgICAgIG1ldGEgPSBwcm9wcy5tZXRhOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgIC8vIGZsYXR0ZW4gaW5wdXQgaW50byBvdGhlciBwcm9wc1xuXG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KGNvbXBvbmVudCwgX2V4dGVuZHMoe30sIGlucHV0LCBjdXN0b20pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KGNvbXBvbmVudCwgX2V4dGVuZHMoe30sIHByb3BzLCBjdXN0b20pKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIENvbm5lY3RlZEZpZWxkO1xuICB9KENvbXBvbmVudCk7XG5cbiAgQ29ubmVjdGVkRmllbGQucHJvcFR5cGVzID0ge1xuICAgIGNvbXBvbmVudDogdmFsaWRhdGVDb21wb25lbnRQcm9wLFxuICAgIHByb3BzOiBQcm9wVHlwZXMub2JqZWN0XG4gIH07XG4gIHZhciBjb25uZWN0b3IgPSBjb25uZWN0KGZ1bmN0aW9uIChzdGF0ZSwgb3duUHJvcHMpIHtcbiAgICB2YXIgbmFtZSA9IG93blByb3BzLm5hbWUsXG4gICAgICAgIF9vd25Qcm9wcyRfcmVkdXhGb3JtID0gb3duUHJvcHMuX3JlZHV4Rm9ybSxcbiAgICAgICAgaW5pdGlhbFZhbHVlcyA9IF9vd25Qcm9wcyRfcmVkdXhGb3JtLmluaXRpYWxWYWx1ZXMsXG4gICAgICAgIGdldEZvcm1TdGF0ZSA9IF9vd25Qcm9wcyRfcmVkdXhGb3JtLmdldEZvcm1TdGF0ZTtcbiAgICB2YXIgZm9ybVN0YXRlID0gZ2V0Rm9ybVN0YXRlKHN0YXRlKTtcbiAgICB2YXIgaW5pdGlhbFN0YXRlID0gZ2V0SW4oZm9ybVN0YXRlLCBcImluaXRpYWwuXCIgKyBuYW1lKTtcbiAgICB2YXIgaW5pdGlhbCA9IGluaXRpYWxTdGF0ZSAhPT0gdW5kZWZpbmVkID8gaW5pdGlhbFN0YXRlIDogaW5pdGlhbFZhbHVlcyAmJiBnZXRJbihpbml0aWFsVmFsdWVzLCBuYW1lKTtcbiAgICB2YXIgdmFsdWUgPSBnZXRJbihmb3JtU3RhdGUsIFwidmFsdWVzLlwiICsgbmFtZSk7XG4gICAgdmFyIHN1Ym1pdHRpbmcgPSBnZXRJbihmb3JtU3RhdGUsICdzdWJtaXR0aW5nJyk7XG4gICAgdmFyIHN5bmNFcnJvciA9IGdldFN5bmNFcnJvcihnZXRJbihmb3JtU3RhdGUsICdzeW5jRXJyb3JzJyksIG5hbWUpO1xuICAgIHZhciBzeW5jV2FybmluZyA9IGdldFN5bmNXYXJuaW5nKGdldEluKGZvcm1TdGF0ZSwgJ3N5bmNXYXJuaW5ncycpLCBuYW1lKTtcbiAgICB2YXIgcHJpc3RpbmUgPSBkZWVwRXF1YWwodmFsdWUsIGluaXRpYWwpO1xuICAgIHJldHVybiB7XG4gICAgICBhc3luY0Vycm9yOiBnZXRJbihmb3JtU3RhdGUsIFwiYXN5bmNFcnJvcnMuXCIgKyBuYW1lKSxcbiAgICAgIGFzeW5jVmFsaWRhdGluZzogZ2V0SW4oZm9ybVN0YXRlLCAnYXN5bmNWYWxpZGF0aW5nJykgPT09IG5hbWUsXG4gICAgICBkaXJ0eTogIXByaXN0aW5lLFxuICAgICAgcHJpc3RpbmU6IHByaXN0aW5lLFxuICAgICAgc3RhdGU6IGdldEluKGZvcm1TdGF0ZSwgXCJmaWVsZHMuXCIgKyBuYW1lKSxcbiAgICAgIHN1Ym1pdEVycm9yOiBnZXRJbihmb3JtU3RhdGUsIFwic3VibWl0RXJyb3JzLlwiICsgbmFtZSksXG4gICAgICBzdWJtaXRGYWlsZWQ6IGdldEluKGZvcm1TdGF0ZSwgJ3N1Ym1pdEZhaWxlZCcpLFxuICAgICAgc3VibWl0dGluZzogc3VibWl0dGluZyxcbiAgICAgIHN5bmNFcnJvcjogc3luY0Vycm9yLFxuICAgICAgc3luY1dhcm5pbmc6IHN5bmNXYXJuaW5nLFxuICAgICAgaW5pdGlhbDogaW5pdGlhbCxcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIF92YWx1ZTogb3duUHJvcHMudmFsdWUgLy8gc2F2ZSB2YWx1ZSBwYXNzZWQgaW4gKGZvciByYWRpb3MpXG5cbiAgICB9O1xuICB9LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwge1xuICAgIGZvcndhcmRSZWY6IHRydWVcbiAgfSk7XG4gIHJldHVybiBjb25uZWN0b3IoQ29ubmVjdGVkRmllbGQpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlQ29ubmVjdGVkRmllbGQ7IiwiaW1wb3J0IF9pc0VxdWFsV2l0aCBmcm9tIFwibG9kYXNoL2lzRXF1YWxXaXRoXCI7XG5cbnZhciBjdXN0b21pemVyID0gZnVuY3Rpb24gY3VzdG9taXplcihvYmplY3RWYWx1ZSwgb3RoZXJWYWx1ZSwgaW5kZXhPcmtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spIHtcbiAgLy8gaHR0cHM6Ly9sb2Rhc2guY29tL2RvY3MvNC4xNy40I2lzRXF1YWxXaXRoXG4gIGlmIChzdGFjaykge1xuICAgIC8vIFNoYWxsb3cgY29tcGFyZXNcbiAgICAvLyBGb3IgMXN0IGxldmVsLCBzdGFjayA9PT0gdW5kZWZpbmVkLlxuICAgIC8vICAgLT4gRG8gbm90aGluZyAoYW5kIGltcGxpY2l0bHkgcmV0dXJuIHVuZGVmaW5lZCBzbyB0aGF0IGl0IGdvZXMgdG8gY29tcGFyZSAybmQgbGV2ZWwpXG4gICAgLy8gRm9yIDJuZCBsZXZlbCBhbmQgdXAsIHN0YWNrICE9PSB1bmRlZmluZWQuXG4gICAgLy8gICAtPiBDb21wYXJlIGJ5ID09PSBvcGVyYXRvclxuICAgIHJldHVybiBvYmplY3RWYWx1ZSA9PT0gb3RoZXJWYWx1ZTtcbiAgfVxufTtcblxudmFyIHNoYWxsb3dDb21wYXJlID0gZnVuY3Rpb24gc2hhbGxvd0NvbXBhcmUoaW5zdGFuY2UsIG5leHRQcm9wcywgbmV4dFN0YXRlKSB7XG4gIHZhciBwcm9wc0VxdWFsID0gX2lzRXF1YWxXaXRoKGluc3RhbmNlLnByb3BzLCBuZXh0UHJvcHMsIGN1c3RvbWl6ZXIpO1xuXG4gIHZhciBzdGF0ZUVxdWFsID0gX2lzRXF1YWxXaXRoKGluc3RhbmNlLnN0YXRlLCBuZXh0U3RhdGUsIGN1c3RvbWl6ZXIpO1xuXG4gIHJldHVybiAhcHJvcHNFcXVhbCB8fCAhc3RhdGVFcXVhbDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHNoYWxsb3dDb21wYXJlOyIsInZhciBmb3JtYXROYW1lID0gZnVuY3Rpb24gZm9ybWF0TmFtZShfcmVmLCBuYW1lKSB7XG4gIHZhciBzZWN0aW9uUHJlZml4ID0gX3JlZi5fcmVkdXhGb3JtLnNlY3Rpb25QcmVmaXg7XG4gIHJldHVybiBzZWN0aW9uUHJlZml4ID8gc2VjdGlvblByZWZpeCArIFwiLlwiICsgbmFtZSA6IG5hbWU7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmb3JtYXROYW1lOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9leHRlbmRzXCI7XG5pbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCI7XG5pbXBvcnQgX2luaGVyaXRzTG9vc2UgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNMb29zZVwiO1xuaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCwgY3JlYXRlRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHBvbHlmaWxsIH0gZnJvbSAncmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcbmltcG9ydCBjcmVhdGVDb25uZWN0ZWRGaWVsZCBmcm9tICcuL0Nvbm5lY3RlZEZpZWxkJztcbmltcG9ydCBzaGFsbG93Q29tcGFyZSBmcm9tICcuL3V0aWwvc2hhbGxvd0NvbXBhcmUnO1xuaW1wb3J0IHByZWZpeE5hbWUgZnJvbSAnLi91dGlsL3ByZWZpeE5hbWUnO1xuaW1wb3J0IHBsYWluIGZyb20gJy4vc3RydWN0dXJlL3BsYWluJztcbmltcG9ydCB7IHdpdGhSZWR1eEZvcm0gfSBmcm9tICcuL1JlZHV4Rm9ybUNvbnRleHQnO1xuaW1wb3J0IHZhbGlkYXRlQ29tcG9uZW50UHJvcCBmcm9tICcuL3V0aWwvdmFsaWRhdGVDb21wb25lbnRQcm9wJztcblxudmFyIGNyZWF0ZUZpZWxkID0gZnVuY3Rpb24gY3JlYXRlRmllbGQoc3RydWN0dXJlKSB7XG4gIHZhciBDb25uZWN0ZWRGaWVsZCA9IGNyZWF0ZUNvbm5lY3RlZEZpZWxkKHN0cnVjdHVyZSk7XG4gIHZhciBzZXRJbiA9IHN0cnVjdHVyZS5zZXRJbjtcblxuICB2YXIgRmllbGQgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzTG9vc2UoRmllbGQsIF9Db21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gRmllbGQocHJvcHMpIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgX3RoaXMgPSBfQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG4gICAgICBfdGhpcy5yZWYgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgIF90aGlzLnJlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuXG4gICAgICBfdGhpcy5ub3JtYWxpemUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZSA9IF90aGlzLnByb3BzLm5vcm1hbGl6ZTtcblxuICAgICAgICBpZiAoIW5vcm1hbGl6ZSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcmV2aW91c1ZhbHVlcyA9IF90aGlzLnByb3BzLl9yZWR1eEZvcm0uZ2V0VmFsdWVzKCk7XG5cbiAgICAgICAgdmFyIHByZXZpb3VzVmFsdWUgPSBfdGhpcy52YWx1ZTtcbiAgICAgICAgdmFyIG5leHRWYWx1ZXMgPSBzZXRJbihwcmV2aW91c1ZhbHVlcywgbmFtZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplKHZhbHVlLCBwcmV2aW91c1ZhbHVlLCBuZXh0VmFsdWVzLCBwcmV2aW91c1ZhbHVlcywgbmFtZSk7XG4gICAgICB9O1xuXG4gICAgICBpZiAoIXByb3BzLl9yZWR1eEZvcm0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWVsZCBtdXN0IGJlIGluc2lkZSBhIGNvbXBvbmVudCBkZWNvcmF0ZWQgd2l0aCByZWR1eEZvcm0oKScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgdmFyIF9wcm90byA9IEZpZWxkLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMucHJvcHMuX3JlZHV4Rm9ybS5yZWdpc3Rlcih0aGlzLm5hbWUsICdGaWVsZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5wcm9wcy52YWxpZGF0ZTtcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5wcm9wcy53YXJuO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF9wcm90by5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbiBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUpIHtcbiAgICAgIHJldHVybiBzaGFsbG93Q29tcGFyZSh0aGlzLCBuZXh0UHJvcHMsIG5leHRTdGF0ZSk7XG4gICAgfTtcblxuICAgIF9wcm90by5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgIHZhciBvbGROYW1lID0gcHJlZml4TmFtZSh0aGlzLnByb3BzLCB0aGlzLnByb3BzLm5hbWUpO1xuICAgICAgdmFyIG5ld05hbWUgPSBwcmVmaXhOYW1lKG5leHRQcm9wcywgbmV4dFByb3BzLm5hbWUpO1xuXG4gICAgICBpZiAob2xkTmFtZSAhPT0gbmV3TmFtZSB8fCAvLyB1c2UgZGVlcEVxdWFsIGhlcmUgYmVjYXVzZSB0aGV5IGNvdWxkIGJlIGEgZnVuY3Rpb24gb3IgYW4gYXJyYXkgb2YgZnVuY3Rpb25zXG4gICAgICAhcGxhaW4uZGVlcEVxdWFsKHRoaXMucHJvcHMudmFsaWRhdGUsIG5leHRQcm9wcy52YWxpZGF0ZSkgfHwgIXBsYWluLmRlZXBFcXVhbCh0aGlzLnByb3BzLndhcm4sIG5leHRQcm9wcy53YXJuKSkge1xuICAgICAgICAvLyB1bnJlZ2lzdGVyIG9sZCBuYW1lXG4gICAgICAgIHRoaXMucHJvcHMuX3JlZHV4Rm9ybS51bnJlZ2lzdGVyKG9sZE5hbWUpOyAvLyByZWdpc3RlciBuZXcgbmFtZVxuXG5cbiAgICAgICAgdGhpcy5wcm9wcy5fcmVkdXhGb3JtLnJlZ2lzdGVyKG5ld05hbWUsICdGaWVsZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gbmV4dFByb3BzLnZhbGlkYXRlO1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG5leHRQcm9wcy53YXJuO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICB0aGlzLnByb3BzLl9yZWR1eEZvcm0udW5yZWdpc3Rlcih0aGlzLm5hbWUpO1xuICAgIH07XG5cbiAgICBfcHJvdG8uZ2V0UmVuZGVyZWRDb21wb25lbnQgPSBmdW5jdGlvbiBnZXRSZW5kZXJlZENvbXBvbmVudCgpIHtcbiAgICAgIGludmFyaWFudCh0aGlzLnByb3BzLmZvcndhcmRSZWYsICdJZiB5b3Ugd2FudCB0byBhY2Nlc3MgZ2V0UmVuZGVyZWRDb21wb25lbnQoKSwgJyArICd5b3UgbXVzdCBzcGVjaWZ5IGEgZm9yd2FyZFJlZiBwcm9wIHRvIEZpZWxkJyk7XG4gICAgICByZXR1cm4gdGhpcy5yZWYuY3VycmVudCA/IHRoaXMucmVmLmN1cnJlbnQuZ2V0UmVuZGVyZWRDb21wb25lbnQoKSA6IHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KENvbm5lY3RlZEZpZWxkLCBfZXh0ZW5kcyh7fSwgdGhpcy5wcm9wcywge1xuICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIG5vcm1hbGl6ZTogdGhpcy5ub3JtYWxpemUsXG4gICAgICAgIHJlZjogdGhpcy5yZWZcbiAgICAgIH0pKTtcbiAgICB9O1xuXG4gICAgX2NyZWF0ZUNsYXNzKEZpZWxkLCBbe1xuICAgICAga2V5OiBcIm5hbWVcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gcHJlZml4TmFtZSh0aGlzLnByb3BzLCB0aGlzLnByb3BzLm5hbWUpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkaXJ0eVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5wcmlzdGluZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicHJpc3RpbmVcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gISEodGhpcy5yZWYuY3VycmVudCAmJiB0aGlzLnJlZi5jdXJyZW50LmlzUHJpc3RpbmUoKSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInZhbHVlXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmLmN1cnJlbnQgJiYgdGhpcy5yZWYuY3VycmVudC5nZXRWYWx1ZSgpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBGaWVsZDtcbiAgfShDb21wb25lbnQpO1xuXG4gIEZpZWxkLnByb3BUeXBlcyA9IHtcbiAgICBuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgY29tcG9uZW50OiB2YWxpZGF0ZUNvbXBvbmVudFByb3AsXG4gICAgZm9ybWF0OiBQcm9wVHlwZXMuZnVuYyxcbiAgICBub3JtYWxpemU6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uQmx1cjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uRm9jdXM6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uRHJhZ1N0YXJ0OiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkRyb3A6IFByb3BUeXBlcy5mdW5jLFxuICAgIHBhcnNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBwcm9wczogUHJvcFR5cGVzLm9iamVjdCxcbiAgICB2YWxpZGF0ZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5mdW5jKV0pLFxuICAgIHdhcm46IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuZnVuYyldKSxcbiAgICBmb3J3YXJkUmVmOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBpbW11dGFibGVQcm9wczogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLnN0cmluZyksXG4gICAgX3JlZHV4Rm9ybTogUHJvcFR5cGVzLm9iamVjdFxuICB9O1xuICBwb2x5ZmlsbChGaWVsZCk7XG4gIHJldHVybiB3aXRoUmVkdXhGb3JtKEZpZWxkKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUZpZWxkOyIsImltcG9ydCBjcmVhdGVGaWVsZCBmcm9tICcuL2NyZWF0ZUZpZWxkJztcbmltcG9ydCBwbGFpbiBmcm9tICcuL3N0cnVjdHVyZS9wbGFpbic7XG5leHBvcnQgZGVmYXVsdCBjcmVhdGVGaWVsZChwbGFpbik7IiwiLyoqIEBsaWNlbnNlIE1hdGVyaWFsLVVJIHYzLjguM1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5pbXBvcnQgKiBhcyBjb2xvcnMgZnJvbSAnLi9jb2xvcnMnO1xuZXhwb3J0IHsgY29sb3JzIH07XG5leHBvcnQgeyBjcmVhdGVHZW5lcmF0ZUNsYXNzTmFtZSwgY3JlYXRlTXVpVGhlbWUsIGNyZWF0ZVN0eWxlcywganNzUHJlc2V0LCBNdWlUaGVtZVByb3ZpZGVyLCB3aXRoU3R5bGVzLCB3aXRoVGhlbWUgfSBmcm9tICcuL3N0eWxlcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEFwcEJhciB9IGZyb20gJy4vQXBwQmFyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQXZhdGFyIH0gZnJvbSAnLi9BdmF0YXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBCYWNrZHJvcCB9IGZyb20gJy4vQmFja2Ryb3AnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBCYWRnZSB9IGZyb20gJy4vQmFkZ2UnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBCb3R0b21OYXZpZ2F0aW9uIH0gZnJvbSAnLi9Cb3R0b21OYXZpZ2F0aW9uJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQm90dG9tTmF2aWdhdGlvbkFjdGlvbiB9IGZyb20gJy4vQm90dG9tTmF2aWdhdGlvbkFjdGlvbic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEJ1dHRvbiB9IGZyb20gJy4vQnV0dG9uJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQnV0dG9uQmFzZSB9IGZyb20gJy4vQnV0dG9uQmFzZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENhcmQgfSBmcm9tICcuL0NhcmQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDYXJkQWN0aW9uQXJlYSB9IGZyb20gJy4vQ2FyZEFjdGlvbkFyZWEnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDYXJkQWN0aW9ucyB9IGZyb20gJy4vQ2FyZEFjdGlvbnMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDYXJkQ29udGVudCB9IGZyb20gJy4vQ2FyZENvbnRlbnQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDYXJkSGVhZGVyIH0gZnJvbSAnLi9DYXJkSGVhZGVyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ2FyZE1lZGlhIH0gZnJvbSAnLi9DYXJkTWVkaWEnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDaGVja2JveCB9IGZyb20gJy4vQ2hlY2tib3gnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDaGlwIH0gZnJvbSAnLi9DaGlwJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ2lyY3VsYXJQcm9ncmVzcyB9IGZyb20gJy4vQ2lyY3VsYXJQcm9ncmVzcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENsaWNrQXdheUxpc3RlbmVyIH0gZnJvbSAnLi9DbGlja0F3YXlMaXN0ZW5lcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENvbGxhcHNlIH0gZnJvbSAnLi9Db2xsYXBzZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENzc0Jhc2VsaW5lIH0gZnJvbSAnLi9Dc3NCYXNlbGluZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIERpYWxvZyB9IGZyb20gJy4vRGlhbG9nJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRGlhbG9nQWN0aW9ucyB9IGZyb20gJy4vRGlhbG9nQWN0aW9ucyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIERpYWxvZ0NvbnRlbnQgfSBmcm9tICcuL0RpYWxvZ0NvbnRlbnQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBEaWFsb2dDb250ZW50VGV4dCB9IGZyb20gJy4vRGlhbG9nQ29udGVudFRleHQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBEaWFsb2dUaXRsZSB9IGZyb20gJy4vRGlhbG9nVGl0bGUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBEaXZpZGVyIH0gZnJvbSAnLi9EaXZpZGVyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRHJhd2VyIH0gZnJvbSAnLi9EcmF3ZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBFeHBhbnNpb25QYW5lbCB9IGZyb20gJy4vRXhwYW5zaW9uUGFuZWwnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBFeHBhbnNpb25QYW5lbEFjdGlvbnMgfSBmcm9tICcuL0V4cGFuc2lvblBhbmVsQWN0aW9ucyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEV4cGFuc2lvblBhbmVsRGV0YWlscyB9IGZyb20gJy4vRXhwYW5zaW9uUGFuZWxEZXRhaWxzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRXhwYW5zaW9uUGFuZWxTdW1tYXJ5IH0gZnJvbSAnLi9FeHBhbnNpb25QYW5lbFN1bW1hcnknO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBGYWIgfSBmcm9tICcuL0ZhYic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEZhZGUgfSBmcm9tICcuL0ZhZGUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBGaWxsZWRJbnB1dCB9IGZyb20gJy4vRmlsbGVkSW5wdXQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBGb3JtQ29udHJvbCB9IGZyb20gJy4vRm9ybUNvbnRyb2wnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBGb3JtQ29udHJvbExhYmVsIH0gZnJvbSAnLi9Gb3JtQ29udHJvbExhYmVsJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRm9ybUdyb3VwIH0gZnJvbSAnLi9Gb3JtR3JvdXAnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBGb3JtSGVscGVyVGV4dCB9IGZyb20gJy4vRm9ybUhlbHBlclRleHQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBGb3JtTGFiZWwgfSBmcm9tICcuL0Zvcm1MYWJlbCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEdyaWQgfSBmcm9tICcuL0dyaWQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBHcmlkTGlzdCB9IGZyb20gJy4vR3JpZExpc3QnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBHcmlkTGlzdFRpbGUgfSBmcm9tICcuL0dyaWRMaXN0VGlsZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEdyaWRMaXN0VGlsZUJhciB9IGZyb20gJy4vR3JpZExpc3RUaWxlQmFyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgR3JvdyB9IGZyb20gJy4vR3Jvdyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEhpZGRlbiB9IGZyb20gJy4vSGlkZGVuJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgSWNvbiB9IGZyb20gJy4vSWNvbic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEljb25CdXR0b24gfSBmcm9tICcuL0ljb25CdXR0b24nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBJbnB1dCB9IGZyb20gJy4vSW5wdXQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBJbnB1dEFkb3JubWVudCB9IGZyb20gJy4vSW5wdXRBZG9ybm1lbnQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBJbnB1dEJhc2UgfSBmcm9tICcuL0lucHV0QmFzZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIElucHV0TGFiZWwgfSBmcm9tICcuL0lucHV0TGFiZWwnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBMaW5lYXJQcm9ncmVzcyB9IGZyb20gJy4vTGluZWFyUHJvZ3Jlc3MnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBMaW5rIH0gZnJvbSAnLi9MaW5rJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTGlzdCB9IGZyb20gJy4vTGlzdCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIExpc3RJdGVtIH0gZnJvbSAnLi9MaXN0SXRlbSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIExpc3RJdGVtQXZhdGFyIH0gZnJvbSAnLi9MaXN0SXRlbUF2YXRhcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIExpc3RJdGVtSWNvbiB9IGZyb20gJy4vTGlzdEl0ZW1JY29uJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTGlzdEl0ZW1TZWNvbmRhcnlBY3Rpb24gfSBmcm9tICcuL0xpc3RJdGVtU2Vjb25kYXJ5QWN0aW9uJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTGlzdEl0ZW1UZXh0IH0gZnJvbSAnLi9MaXN0SXRlbVRleHQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBMaXN0U3ViaGVhZGVyIH0gZnJvbSAnLi9MaXN0U3ViaGVhZGVyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTWVudSB9IGZyb20gJy4vTWVudSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE1lbnVJdGVtIH0gZnJvbSAnLi9NZW51SXRlbSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE1lbnVMaXN0IH0gZnJvbSAnLi9NZW51TGlzdCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE1vYmlsZVN0ZXBwZXIgfSBmcm9tICcuL01vYmlsZVN0ZXBwZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNb2RhbCwgTW9kYWxNYW5hZ2VyIH0gZnJvbSAnLi9Nb2RhbCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE5hdGl2ZVNlbGVjdCB9IGZyb20gJy4vTmF0aXZlU2VsZWN0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTm9Tc3IgfSBmcm9tICcuL05vU3NyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgT3V0bGluZWRJbnB1dCB9IGZyb20gJy4vT3V0bGluZWRJbnB1dCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFBhcGVyIH0gZnJvbSAnLi9QYXBlcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFBvcG92ZXIgfSBmcm9tICcuL1BvcG92ZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQb3BwZXIgfSBmcm9tICcuL1BvcHBlcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFBvcnRhbCB9IGZyb20gJy4vUG9ydGFsJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUmFkaW8gfSBmcm9tICcuL1JhZGlvJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUmFkaW9Hcm91cCB9IGZyb20gJy4vUmFkaW9Hcm91cCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFJvb3RSZWYgfSBmcm9tICcuL1Jvb3RSZWYnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTZWxlY3QgfSBmcm9tICcuL1NlbGVjdCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNsaWRlIH0gZnJvbSAnLi9TbGlkZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNuYWNrYmFyIH0gZnJvbSAnLi9TbmFja2Jhcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNuYWNrYmFyQ29udGVudCB9IGZyb20gJy4vU25hY2tiYXJDb250ZW50JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU3RlcCB9IGZyb20gJy4vU3RlcCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFN0ZXBCdXR0b24gfSBmcm9tICcuL1N0ZXBCdXR0b24nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTdGVwQ29ubmVjdG9yIH0gZnJvbSAnLi9TdGVwQ29ubmVjdG9yJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU3RlcENvbnRlbnQgfSBmcm9tICcuL1N0ZXBDb250ZW50JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU3RlcEljb24gfSBmcm9tICcuL1N0ZXBJY29uJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU3RlcExhYmVsIH0gZnJvbSAnLi9TdGVwTGFiZWwnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTdGVwcGVyIH0gZnJvbSAnLi9TdGVwcGVyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU3ZnSWNvbiB9IGZyb20gJy4vU3ZnSWNvbic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFN3aXBlYWJsZURyYXdlciB9IGZyb20gJy4vU3dpcGVhYmxlRHJhd2VyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU3dpdGNoIH0gZnJvbSAnLi9Td2l0Y2gnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUYWIgfSBmcm9tICcuL1RhYic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRhYmxlIH0gZnJvbSAnLi9UYWJsZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRhYmxlQm9keSB9IGZyb20gJy4vVGFibGVCb2R5JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGFibGVDZWxsIH0gZnJvbSAnLi9UYWJsZUNlbGwnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUYWJsZUZvb3RlciB9IGZyb20gJy4vVGFibGVGb290ZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUYWJsZUhlYWQgfSBmcm9tICcuL1RhYmxlSGVhZCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRhYmxlUGFnaW5hdGlvbiB9IGZyb20gJy4vVGFibGVQYWdpbmF0aW9uJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGFibGVSb3cgfSBmcm9tICcuL1RhYmxlUm93JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGFibGVTb3J0TGFiZWwgfSBmcm9tICcuL1RhYmxlU29ydExhYmVsJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGFicyB9IGZyb20gJy4vVGFicyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRleHRGaWVsZCB9IGZyb20gJy4vVGV4dEZpZWxkJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVG9vbGJhciB9IGZyb20gJy4vVG9vbGJhcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRvb2x0aXAgfSBmcm9tICcuL1Rvb2x0aXAnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUeXBvZ3JhcGh5IH0gZnJvbSAnLi9UeXBvZ3JhcGh5JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgd2l0aE1vYmlsZURpYWxvZyB9IGZyb20gJy4vd2l0aE1vYmlsZURpYWxvZyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHdpdGhXaWR0aCB9IGZyb20gJy4vd2l0aFdpZHRoJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgWm9vbSB9IGZyb20gJy4vWm9vbSc7XG4iLCJpbXBvcnQgeyBUZXh0RmllbGQgfSBmcm9tIFwiQG1hdGVyaWFsLXVpL2NvcmVcIjtcclxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgKGZpZWxkOiBhbnkpID0+IChcclxuICAgIDxUZXh0RmllbGQgey4uLmZpZWxkLmlucHV0fSBsYWJlbD17ZmllbGQubGFiZWx9IHJlcXVpcmVkPXtmaWVsZC5yZXF1aXJlZH0gZGlzYWJsZWQ9e2ZpZWxkLmRpc2FibGVkfS8+XHJcbik7XHJcbiIsImltcG9ydCB7IFNlbGVjdCwgRm9ybUNvbnRyb2wsIElucHV0TGFiZWwgfSBmcm9tIFwiQG1hdGVyaWFsLXVpL2NvcmVcIjtcclxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgKGZpZWxkOiBhbnkpID0+IChcclxuICAgIDxGb3JtQ29udHJvbCBzdHlsZT17e21pbldpZHRoOiAxMjB9fT5cclxuICAgICAgICA8SW5wdXRMYWJlbD57ZmllbGQubGFiZWx9PC9JbnB1dExhYmVsPlxyXG4gICAgICAgIDxTZWxlY3Qgey4uLmZpZWxkLmlucHV0fSByZXF1aXJlZD17ZmllbGQucmVxdWlyZWR9IGRpc2FibGVkPXtmaWVsZC5kaXNhYmxlZH0+XHJcbiAgICAgICAgICAgIHtmaWVsZC5jaGlsZHJlbn1cclxuICAgICAgICA8L1NlbGVjdD5cclxuICAgIDwvRm9ybUNvbnRyb2w+XHJcbik7XHJcbiIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgU2VsZWN0LCBGb3JtQ29udHJvbCwgSW5wdXRMYWJlbCwgTWVudUl0ZW0gfSBmcm9tICdAbWF0ZXJpYWwtdWkvY29yZSc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW1vdGVTZWxlY3QgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8YW55LCBhbnk+e1xyXG5cclxuICAgIHJlbmRlcmVkOiBib29sZWFuOyBcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcyl7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7fTtcclxuICAgICAgICB0aGlzLnJlbmRlcmVkID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50RGlkTW91bnQoKXtcclxuICAgICAgICBjb25zb2xlLmxvZyhcInJlbW90ZSBzZWxlY3RcIik7XHJcbiAgICAgICAgY29uc29sZS5sb2codGhpcy5wcm9wcyk7XHJcbiAgICAgICAgdGhpcy5wcm9wcy5tZXRhLmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgdHlwZTogXCJMT0FESU5HXCIsXHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMucHJvcHMuaW5wdXQubmFtZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCk9PntcclxuICAgICAgICAgICAgdmFyIHNlbGVjdCA9IFtcclxuICAgICAgICAgICAgICAgIDxNZW51SXRlbSB2YWx1ZT17MTB9PlJlbW90ZSBUZW48L01lbnVJdGVtPixcclxuICAgICAgICAgICAgICAgIDxNZW51SXRlbSB2YWx1ZT17MjB9PlJlbW90ZSBUd2VudHk8L01lbnVJdGVtPixcclxuICAgICAgICAgICAgICAgIDxNZW51SXRlbSB2YWx1ZT17MzB9PlJlbW90ZSBUaGlydHk8L01lbnVJdGVtPiBcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtzZWxlY3Q6IHNlbGVjdH0pOyAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICB9LCAxMCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCl7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPEZvcm1Db250cm9sIHN0eWxlPXt7bWluV2lkdGg6IDEyMH19PlxyXG4gICAgICAgICAgICAgICAgPElucHV0TGFiZWw+e3RoaXMucHJvcHMubGFiZWx9PC9JbnB1dExhYmVsPlxyXG4gICAgICAgICAgICAgICAgPFNlbGVjdCB7Li4udGhpcy5wcm9wcy5pbnB1dH0gcmVxdWlyZWQ9e3RoaXMucHJvcHMucmVxdWlyZWR9IGRpc2FibGVkPXt0aGlzLnByb3BzLmRpc2FibGVkfT5cclxuICAgICAgICAgICAgICAgICAgICB7dGhpcy5zdGF0ZS5zZWxlY3R9XHJcbiAgICAgICAgICAgICAgICA8L1NlbGVjdD5cclxuICAgICAgICAgICAgPC9Gb3JtQ29udHJvbD5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBGaWVsZCwgcmVkdXhGb3JtLCBGb3JtUHJvcHMsIEZvcm1FcnJvcnMsIEluamVjdGVkRm9ybVByb3BzIH0gZnJvbSAncmVkdXgtZm9ybSc7XHJcbmltcG9ydCBUZXh0RmllbGQgZnJvbSAnLi9mb3JtL2NvbnRyb2wvVGV4dEZpZWxkJztcclxuaW1wb3J0IHsgY29ubmVjdCB9IGZyb20gJ3JlYWN0LXJlZHV4JztcclxuaW1wb3J0IHsgR3JpZCwgTWVudUl0ZW0gfSBmcm9tICdAbWF0ZXJpYWwtdWkvY29yZSc7XHJcbmltcG9ydCBTZWxlY3QgZnJvbSAnLi9mb3JtL2NvbnRyb2wvU2VsZWN0JztcclxuaW1wb3J0IFJlbW90ZVNlbGVjdCBmcm9tICcuL2Zvcm0vY29udHJvbC9SZW1vdGVTZWxlY3QnO1xyXG5cclxuLyoqXHJcbiAqIFNpbXBsZSBGb3JtIENvbXBvbmVudCBcclxuICovXHJcbkAoY29ubmVjdCggXHJcbiAgICAvLyBtYXAgc3RhdGUgdG8gcHJvcHNcclxuICAgIGZ1bmN0aW9uKHN0YXRlOiBhbnkpe1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHN0YXRlKTtcclxuICAgICAgICByZXR1cm4ge3NpbXBsZTogc3RhdGUgJiYgc3RhdGUuZm9ybSAmJiBzdGF0ZS5mb3JtLnNpbXBsZSAmJiBzdGF0ZS5mb3JtLnNpbXBsZS52YWx1ZXMgPyBzdGF0ZS5mb3JtLnNpbXBsZS52YWx1ZXMgOiB7fSB9O1xyXG4gICAgfSAsXHJcbiAgICAvLyBtYXAgZGlzcGF0Y2ggdG8gcHJvcHNcclxuICAgIGZ1bmN0aW9uKGRpc3BhdGNoKXtcclxuICAgICAgICByZXR1cm4ge307XHJcbiAgICB9ICAgIFxyXG4pIGFzIGFueSlcclxuQChyZWR1eEZvcm0oe2Zvcm0gOiAnc2ltcGxlJ30pIGFzIGFueSlcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2ltcGxlRm9ybUNvbXBvbmVudCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxJbmplY3RlZEZvcm1Qcm9wcyB8IGFueSAsIGFueSA+e1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByb3BzOiBhbnkpe1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gcHJvcHM7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCl7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGZvcm0+XHJcbiAgICAgICAgICAgICAgICA8R3JpZCBjb250YWluZXI+XHJcbiAgICAgICAgICAgICAgICAgICAgPEdyaWQgaXRlbT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPEZpZWxkIG5hbWU9XCJzaW1wbGVUZXh0RmllbGQxXCIgbGFiZWw9XCJTaW1wbGUgVGV4dCBGaWVsZCAxXCIgY29tcG9uZW50PXtUZXh0RmllbGR9Lz5cclxuICAgICAgICAgICAgICAgICAgICA8L0dyaWQ+XHJcbiAgICAgICAgICAgICAgICA8L0dyaWQ+XHJcbiAgICAgICAgICAgICAgICA8R3JpZCBjb250YWluZXI+XHJcbiAgICAgICAgICAgICAgICAgICAgPEdyaWQgaXRlbT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPEZpZWxkIG5hbWU9XCJzaW1wbGVTZWxlY3RGaWVsZFwiIGxhYmVsPVwiU2ltcGxlIFNlbGVjdFwiIGNvbXBvbmVudD17U2VsZWN0fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxNZW51SXRlbSB2YWx1ZT17MTB9PlRlbjwvTWVudUl0ZW0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8TWVudUl0ZW0gdmFsdWU9ezIwfT5Ud2VudHk8L01lbnVJdGVtPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPE1lbnVJdGVtIHZhbHVlPXszMH0+VGhpcnR5PC9NZW51SXRlbT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9GaWVsZD5cclxuICAgICAgICAgICAgICAgICAgICA8L0dyaWQ+XHJcbiAgICAgICAgICAgICAgICA8L0dyaWQ+XHJcbiAgICAgICAgICAgICAgICA8R3JpZCBjb250YWluZXI+XHJcbiAgICAgICAgICAgICAgICAgICAgPEdyaWQgaXRlbT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPEZpZWxkIG5hbWU9XCJyZW1vdGVTZWxlY3RGaWVsZFwiIGxhYmVsPVwiUmVtb3RlIFNlbGVjdFwiIGNvbXBvbmVudD17UmVtb3RlU2VsZWN0fS8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9HcmlkPlxyXG4gICAgICAgICAgICAgICAgPC9HcmlkPlxyXG4gICAgICAgICAgICA8L2Zvcm0+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcblxyXG4iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0ICogYXMgUmVhY3RET00gZnJvbSBcInJlYWN0LWRvbVwiO1xyXG5pbXBvcnQgeyBjb21iaW5lUmVkdWNlcnMsIGNyZWF0ZVN0b3JlIH0gZnJvbSBcInJlZHV4XCI7XHJcbmltcG9ydCB7IHJlZHVjZXIgfSBmcm9tICdyZWR1eC1mb3JtJztcclxuaW1wb3J0IFNpbXBsZUZvcm1Db21wb25lbnQgZnJvbSBcIi4vU2ltcGxlRm9ybUNvbXBvbmVudFwiO1xyXG5pbXBvcnQgeyBQcm92aWRlciwgY29ubmVjdCB9IGZyb20gXCJyZWFjdC1yZWR1eFwiO1xyXG5cclxuY29uc3Qgcm9vdFJlZHVjZXIgPSBjb21iaW5lUmVkdWNlcnMoe1xyXG4gICAgZm9ybTogcmVkdWNlci5wbHVnaW4oe1xyXG4gICAgICAgIGxvYWRpbmc6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgIHN3aXRjaChhY3Rpb24udHlwZSl7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiTE9BRElOR1wiOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghYWN0aW9uLm5hbWUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RhdGUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uc3RhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRpbmc6IHRydWVcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcbn0pO1xyXG5cclxuY29uc3Qgc3RvcmUgPSBjcmVhdGVTdG9yZShyb290UmVkdWNlciwge30pO1xyXG5cclxuQChjb25uZWN0KCBcclxuICAgIC8vIG1hcCBzdGF0ZSB0byBwcm9wc1xyXG4gICAgZnVuY3Rpb24oc3RhdGU6IGFueSl7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coc3RhdGUpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNpbXBsZTogc3RhdGUgJiYgc3RhdGUuZm9ybSAmJiBzdGF0ZS5mb3JtLnNpbXBsZSAmJiBzdGF0ZS5mb3JtLnNpbXBsZS52YWx1ZXMgPyBzdGF0ZS5mb3JtLnNpbXBsZS52YWx1ZXMgOiB7fSxcclxuICAgICAgICAgICAgZm9ybTogc3RhdGUgJiYgc3RhdGUuZm9ybSAmJiBzdGF0ZS5mb3JtLnNpbXBsZSA/IHN0YXRlLmZvcm0uc2ltcGxlIDoge31cclxuICAgICAgICB9O1xyXG4gICAgfSAsXHJcbiAgICAvLyBtYXAgZGlzcGF0Y2ggdG8gcHJvcHNcclxuICAgIGZ1bmN0aW9uKGRpc3BhdGNoKXtcclxuICAgICAgICByZXR1cm4ge307XHJcbiAgICB9ICAgIFxyXG4pIGFzIGFueSlcclxuY2xhc3MgQXBwIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PGFueSwgYW55PntcclxuICAgIFxyXG4gICAgY29uc3RydWN0b3IocHJvcHMpe1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gcHJvcHM7XHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpe1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJywgbmV4dFByb3BzKTsgICAgICAgIFxyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcigpe1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICA8aDE+SGVsbG8gV29ybGQ8L2gxPlxyXG4gICAgICAgICAgICAgICAgICAgIDxTaW1wbGVGb3JtQ29tcG9uZW50Lz5cclxuICAgICAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICAgICAge3RoaXMucHJvcHMuc2ltcGxlLnNpbXBsZVRleHRGaWVsZDF9XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICAgICAge3RoaXMucHJvcHMuc2ltcGxlLnNpbXBsZVNlbGVjdEZpZWxkfVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIHt0aGlzLnByb3BzLnNpbXBsZS5yZW1vdGVTZWxlY3RGaWVsZH1cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICBcclxuICAgICAgICApXHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5SZWFjdERPTS5yZW5kZXIoXHJcbiAgICA8UHJvdmlkZXIgc3RvcmU9e3N0b3JlfT5cclxuICAgICAgICA8QXBwIC8+XHJcbiAgICA8L1Byb3ZpZGVyPiwgXHJcbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhcHAnKSk7XHJcblxyXG4gICAgXHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///455\n')}});